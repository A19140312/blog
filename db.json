{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/404.html","path":"404.html","modified":1,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/alipay.jpg","path":"images/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.png","path":"images/avatar.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/clipboard.min.js","path":"js/src/clipboard.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/clipboard-use.js","path":"js/src/clipboard-use.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1562857980721},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1562857980722},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1562857980721},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1562857980723},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1562857980723},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1562857980723},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1562857980723},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1562857980724},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1562857980723},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1562857980724},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1562857980724},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1562857980726},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1562857980727},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1562857980725},{"_id":"themes/next/_config.yml","hash":"ea179d84a25648a765b2b04914dee14c310cfceb","modified":1584371002899},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1562857980749},{"_id":"source/_drafts/Java-AQS.md","hash":"db5bc0956e920ef7883c55fe0a911005635bbe35","modified":1583496071871},{"_id":"source/_drafts/Redis.md","hash":"b7c466dce97ff94f7efcb60de711a291306982c7","modified":1562857980633},{"_id":"source/_drafts/MyBatis-01.md","hash":"0b86f1a1affa5ba8f0b4cc59d4a4434657104c2d","modified":1579685490355},{"_id":"source/authors/index.md","hash":"9072a029c7c9cb7050b7e98498752ab5b4f896e9","modified":1562857980692},{"_id":"source/_posts/.DS_Store","hash":"e45f8534a7331200a89cc56abe40cf0dbeb550cb","modified":1579707782084},{"_id":"source/_posts/C++-01.md","hash":"36c756700cb0d8dd5307e0445e7df60f95c9ddea","modified":1564580500987},{"_id":"source/categories/index.md","hash":"aee2c5e57dc28322f727617488ec89ca13299877","modified":1562857980692},{"_id":"source/tags/index.md","hash":"924a602ccdf829c5c1fd0faced2eb9b0f656d9d8","modified":1562857980693},{"_id":"source/_posts/Design-Pattern-Decorator.md","hash":"94e09ac296b27eb69c0fc27a4666eb71e3522336","modified":1579685490355},{"_id":"source/_posts/C++-02.md","hash":"fd628fd111b89ba5e4009f6791320e73c519db91","modified":1564580500987},{"_id":"source/_posts/Design-Pattern-Proxy.md","hash":"fd5c31672c021c55102a109282c6d929fb816579","modified":1584087421523},{"_id":"source/_posts/Design-Pattern-Observer.md","hash":"c8bceaa0798b948365c8bc0aaf77a5ca3432c372","modified":1579685490355},{"_id":"source/_posts/Design-Pattern-Singleton.md","hash":"a6bb7f59a37d49fafc2c2b54de8211098608edb8","modified":1583498671776},{"_id":"source/_posts/Design-Pattern-Strategy.md","hash":"8e4740dbee6fce9b65017280515c4177182041fb","modified":1579685490365},{"_id":"source/_posts/GIt-Ignore.md","hash":"749c54729a3595fb46bb94aad3d5db6e2f3bc417","modified":1564580500988},{"_id":"source/_posts/Guava.md","hash":"3b3294314bd3e52c6e37bb47e33a0b28a29064e3","modified":1579685490365},{"_id":"source/_posts/Github-Pages-Blog.md","hash":"5ee6fa536db3f9c25602f58ec76a22f4a8f378c8","modified":1564580500989},{"_id":"source/_posts/Idea-Activation.md","hash":"84437eea343f3b0a89e7c69347b7ff2eb383f8b1","modified":1579685490365},{"_id":"source/_posts/JVM1.md","hash":"19fc14394c50c1f101ac17415db16915c793dc5c","modified":1564580500989},{"_id":"source/_posts/JVM-Fundamentals.md","hash":"087b756726bb8e9ca5574367d0653ac93dbfd291","modified":1584257376731},{"_id":"source/_posts/JVM2.md","hash":"1b6c4052d779947f9f654e9bbc683cb00aed4477","modified":1564580500989},{"_id":"source/_posts/JVM3.md","hash":"d5d5687cc2b0681915c70735cf5903e67d344f66","modified":1564580500990},{"_id":"source/_posts/Java-Cas.md","hash":"def524d4897e6b96538b6c9ea2a87d898ad636f7","modified":1583131578558},{"_id":"source/_posts/Java-HashMap.md","hash":"21ce13903db90d94217c68a4a4aabe819bddc318","modified":1584087421539},{"_id":"source/_posts/Java-Spring.md","hash":"3b5c25abe932002a3b457f7fd9d8767e04688ad6","modified":1584087866531},{"_id":"source/_posts/Java-MemoryModel.md","hash":"805fd4eba68bdee7962d5583b161c3004a4515c1","modified":1582959612225},{"_id":"source/_posts/Java-SpringAOP.md","hash":"377833a0510433343b63e9b8ef85bd46736611b9","modified":1584087421541},{"_id":"source/_posts/Java-Synchronized.md","hash":"99fe4dd13ddf6d270f8cbfcfb12cb234b0f86c8e","modified":1583498671776},{"_id":"source/_posts/Java-Volatile.md","hash":"8574dbfaabc21c1e5235f791bc3cf782c1d0be4e","modified":1584195613326},{"_id":"source/_posts/Java-ThreadPool.md","hash":"e1661a20e61e3307ddd3e4336e994060a9bcd2fe","modified":1583499174595},{"_id":"source/_posts/Kafka-Background.md","hash":"5bdcdb250f731ac7c1387a0399326533c76b6999","modified":1564580500990},{"_id":"source/_posts/Kafka-Producer.md","hash":"9d099a8d9b0f857c0b19f35ca7cea66d4d5d4fc3","modified":1565015725650},{"_id":"source/_posts/Mysql-LSN.md","hash":"27b4c1aa1fd770b70aa413b8a7fa9806ee375437","modified":1567220639987},{"_id":"source/_posts/Mysql-RedoAndUndo.md","hash":"ca165ad83fdf547473224d96f3bba60addfd6cbd","modified":1567220639994},{"_id":"source/_posts/Kafka-Install.md","hash":"20a9e0697c1680827d4660932c16b40848846b00","modified":1564672215715},{"_id":"source/_posts/Mysql01.md","hash":"edb7db5495a8c4bc64633ed8da2d0c8dfd879304","modified":1567220639999},{"_id":"source/_posts/Mysql-storage.md","hash":"576ea02a03930f706759dd360a039f964e33b126","modified":1569421788413},{"_id":"source/_posts/Mysql03.md","hash":"6802745780979b82a1b1ad6393596b54565af5bc","modified":1569421788414},{"_id":"source/_posts/Mysql02.md","hash":"9b042ae630ef258cb4da6bd29150ada0f1914a22","modified":1567220640000},{"_id":"source/_posts/Project-Module.md","hash":"01f4ad68cbb9b0e3c8e6cf27c67aaaf30396de6f","modified":1564580500998},{"_id":"source/_posts/Redis-adlist.md","hash":"3614e9eacd3a93c0ecb76c598d063e686622f56c","modified":1564580500998},{"_id":"source/_posts/Redis-sds.md","hash":"ca08090dab47ba81c6860b27a2d15e0fe5dbe5e5","modified":1564580500999},{"_id":"source/_posts/Thailand-Raiders.md","hash":"7550aad1ea561765a04b5c1190295470c5749814","modified":1567255023601},{"_id":"source/_posts/Tree.md","hash":"038f00fd976426d91237277e44562319c670fc76","modified":1583496071889},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1562857980722},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1562857980722},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1562857980722},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1562857980722},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1562857980727},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1562857980727},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1562857980727},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1562857980728},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1562857980727},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1562857980728},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1562857980729},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1562857980729},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1562857980729},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1562857980729},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1562857980730},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1562857980729},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1562857980730},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1562857980730},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1562857980730},{"_id":"themes/next/languages/zh-Hans.yml","hash":"c4c9569e44d28fb37c2dad564922eee1d80dc0a2","modified":1562857980730},{"_id":"themes/next/layout/_layout.swig","hash":"0a817b96ab4c85961a247dad37ae9fb992e23438","modified":1564580501000},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1562857980748},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1562857980748},{"_id":"themes/next/layout/author.swig","hash":"564a7e148729701e48e1ae84f5176e38adf42204","modified":1562857980748},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1562857980748},{"_id":"themes/next/layout/page.swig","hash":"8c9280e56c45298e829b7b1418e621772eab78a7","modified":1562857980749},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1562857980749},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1562857980749},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1562857980750},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1562857980749},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1562857980751},{"_id":"themes/next/source/404.html","hash":"b5e6533bfe368e8ac136dde99b162c6b35ce9dc1","modified":1562857980753},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1562857980815},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1562857980816},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1562857980816},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562857980778},{"_id":"source/_posts/Github-Pages-Blog/blog-icon.png","hash":"b4198f97a457236f7c5677680634cbbff15bc837","modified":1562857980635},{"_id":"source/_posts/Github-Pages-Blog/categories.png","hash":"9d225500581c6625ccb43c90446ea702e2ad3d27","modified":1562857980636},{"_id":"source/_posts/Github-Pages-Blog/change-theme.png","hash":"80d61b4a4f7cba6f53e903cff176b394f9b7bdfa","modified":1562857980636},{"_id":"source/_posts/Github-Pages-Blog/create-project.png","hash":"8111130d13191b07f4de818e818120f8f4941c65","modified":1562857980641},{"_id":"source/_posts/Github-Pages-Blog/tags.png","hash":"ebae8e66598ef4ab1354a3f8b21f27ec29ef667f","modified":1562857980652},{"_id":"source/_posts/Github-Pages-Blog/deploy-position.png","hash":"710e477d8ff93bdd654228e4edfaeb8419fc32cb","modified":1562857980643},{"_id":"source/_posts/JVM-Fundamentals/10.1.png","hash":"2e6feb2f23fea72f3b6f962dba95ac69f4d115eb","modified":1579685490370},{"_id":"source/_posts/JVM-Fundamentals/2.png","hash":"d8677cc2e8145f814b6c01a1361f0467a121533f","modified":1579685490377},{"_id":"source/_posts/JVM-Fundamentals/10.png","hash":"d50899739e0a5462b0d261ff536f2ecb79245e2b","modified":1579685490376},{"_id":"source/_posts/Interview.md","hash":"9bb92639b00a91c5b6d5bb37c427f220b6e2e55c","modified":1585584053083},{"_id":"source/_posts/JVM-Fundamentals/6.jpeg","hash":"f33f7de3813ba348306b91a72920779f61da7408","modified":1579685490436},{"_id":"source/_posts/JVM-Fundamentals/8.png","hash":"79043e897182920cd1119ed7bc20b70ff60b728f","modified":1579685490440},{"_id":"source/_posts/JVM-Fundamentals/9.png","hash":"1232709e64ddce6192ad728d20e0f675fe0a836c","modified":1579685490444},{"_id":"source/_posts/JVM-Fundamentals/9.3.png","hash":"0bc44888ca9f426b4691502da75720b5158eb0de","modified":1579685490443},{"_id":"source/_posts/Interview/2.png","hash":"d8677cc2e8145f814b6c01a1361f0467a121533f","modified":1584087421528},{"_id":"source/_posts/Interview/6.jpeg","hash":"f33f7de3813ba348306b91a72920779f61da7408","modified":1579685490436},{"_id":"source/_posts/Interview/concurrentHashMap1.7.jpg","hash":"80910cb197a19b87dd05147b4e2c74946f31949f","modified":1584277050092},{"_id":"source/_posts/Interview/applicationContext.jpg","hash":"0d5a20772df5029f2b3d803d11dc3a72e4af8647","modified":1584264734773},{"_id":"source/_posts/Interview/hash2.jpg","hash":"b5897cefd817f4e9335f1fd0037f1f86adb1aadb","modified":1585546624869},{"_id":"source/_posts/Interview/hash.jpg","hash":"68bd9c9fbf57edb31c13e9b0944dd310e16ae40e","modified":1585546515502},{"_id":"source/_posts/Interview/osi.jpeg","hash":"cd9bdee073c32baf41b9cac689f5cb6ce73baada","modified":1584087421535},{"_id":"source/_posts/Interview/mybatisCache.jpg","hash":"ca907926257b64b30f6893142cec4edbcf4bba39","modified":1584274267370},{"_id":"source/_posts/Interview/redo-buffer.png","hash":"a9958302114fdc34e5b637c2cf97391f1652ab6f","modified":1565507650506},{"_id":"source/_posts/Interview/sort.png","hash":"95de4711a8acc403d8017ae6b342a91f080bd81b","modified":1584285472073},{"_id":"source/_posts/Interview/01.jpg","hash":"6940c7d3a605cab6ce504633598b00c653b749ba","modified":1584087421525},{"_id":"source/_posts/Java-AQS/CLH.jpg","hash":"ad8bf5246117c3c67aa62907109c3333ab98503b","modified":1583496071872},{"_id":"source/_posts/Java-MemoryModel/1.png","hash":"103001ab6ba408ed78a758c4742e291d8f1cfc0b","modified":1579685490445},{"_id":"source/_posts/Java-MemoryModel/4.jpeg","hash":"1bf210c52912b5d322a619e497efe53e5d785475","modified":1579685490447},{"_id":"source/_posts/Java-MemoryModel/3.png","hash":"dda9882341372a9affada457a13ac0b142100633","modified":1579685490446},{"_id":"source/_posts/Java-MemoryModel/2.png","hash":"ca7d3c4203c0378145f35a2df79586bc0fe9ce73","modified":1579685490446},{"_id":"source/_posts/Java-MemoryModel/5.jpeg","hash":"fb6cca8c5a2a75c74025111a0f50a86ba564fff2","modified":1579685490447},{"_id":"source/_posts/Java-MemoryModel/8.png","hash":"89307c4ca8191df70399cefee140246484072a5c","modified":1579685490451},{"_id":"source/_posts/Java-Synchronized/8.png","hash":"39e3d3066cb10dd21f6a9ca73f639d61fffaa3de","modified":1583496071888},{"_id":"source/_posts/Java-Synchronized/9.png","hash":"a5d4bc6269934d46d52deb22b8ac42c3266c01a3","modified":1583496071888},{"_id":"source/_posts/Kafka-Background/3.jpg","hash":"a4c2e32670e49c09a2d377caff93c8aaa1d70b09","modified":1562857980660},{"_id":"source/_posts/Kafka-Background/5.jpeg","hash":"2b65edd6da76ce3d4a5e9952e443a42cc26b33b2","modified":1562857980663},{"_id":"source/_posts/Kafka-Producer/producer.png","hash":"42ee01fe607e1749fa1cd1abc69cd2641456f353","modified":1565014684740},{"_id":"source/_posts/Mysql-RedoAndUndo/redo-buffer.png","hash":"a9958302114fdc34e5b637c2cf97391f1652ab6f","modified":1566025934643},{"_id":"source/_posts/Mysql-RedoAndUndo/undo-Segment.png","hash":"457de2d3b2642a5f6e77eccae8551cec0d6a7a06","modified":1567220639996},{"_id":"source/_posts/Mysql-storage/640.png","hash":"6ac75230f47c0f20723ff8173a692c333791a6e6","modified":1567220639998},{"_id":"source/_posts/Mysql02/2.png","hash":"442f662987cf8f60dc485f28b0204af01e00eae3","modified":1564580500997},{"_id":"source/_posts/Mysql02/1.png","hash":"82b40a9930154e28645f49e88edf3cd83e66dba9","modified":1564580500994},{"_id":"source/_posts/Mysql02/Insert-Buffer.svg","hash":"4d80ff4d45b4d7130339f98ccd9b48c284e12b56","modified":1566025934646},{"_id":"source/_posts/Mysql02/index-update.png","hash":"3ead441d30ab2d87942c80255e996af2ecbcb453","modified":1567220640001},{"_id":"source/_posts/Mysql02/insert-buffer.png","hash":"1e3ab488168d2be4ea0155824d7c7a685d2d5ace","modified":1567220640002},{"_id":"source/_posts/Mysql02/innodb-buffer-pool-list.jpg","hash":"40c9f806063efd636600239d43fdb5744ba2fceb","modified":1565012490843},{"_id":"source/_posts/Mysql02/read.svg","hash":"daad246215b8d9be25ec717ae8b57c30db73b1bf","modified":1566025934654},{"_id":"source/_posts/Mysql02/redo-buffer.png","hash":"a9958302114fdc34e5b637c2cf97391f1652ab6f","modified":1565507650506},{"_id":"source/_posts/Mysql02/write.svg","hash":"ef9bf0d961d620f5d26b5dc5961aa5133d30516b","modified":1566025934659},{"_id":"source/_posts/Mysql02/write.png","hash":"e86f979693cd53c9dc663f3d838d038f5ace0365","modified":1566025934658},{"_id":"source/_posts/Mysql02/IO.png","hash":"bb293525c02678266360c565b887ba239a88dfcd","modified":1566025934645},{"_id":"source/_posts/Project-Module/12.png","hash":"0c0eac591fb404c7b4bf7652807cb36468b41f50","modified":1562857980671},{"_id":"source/_posts/Project-Module/19.png","hash":"3e5db4c7a07dc0e56bd19f93ff9d6fb0002f1802","modified":1562857980672},{"_id":"source/_posts/Project-Module/17.png","hash":"78271020841f963b565f5bbadbd0fd5e4053f79e","modified":1562857980671},{"_id":"source/_posts/Project-Module/24.png","hash":"9bf2ce87e94232e26d6793509c69b2a15368646f","modified":1562857980674},{"_id":"source/_posts/Project-Module/32.png","hash":"b04d5ce74316668a7034f5c6a25cea90b0825289","modified":1562857980678},{"_id":"source/_posts/Project-Module/30.2.png","hash":"4a74cb3845660e82405f5a58d6707d8952c3536a","modified":1562857980678},{"_id":"source/_posts/Project-Module/6.png","hash":"12c3edf7adc454d9d40b4cf1e06f13cd5d8ac1e7","modified":1562857980680},{"_id":"source/_posts/Project-Module/7.png","hash":"42eb5628fe0a2771a62be81dcab1912d28293cdd","modified":1562857980681},{"_id":"source/_posts/Project-Module/8.png","hash":"408186cdf11cf8fd9e44b01ddb300ce89853e874","modified":1562857980681},{"_id":"source/_posts/Redis-sds/sdshdr.png","hash":"a0297688ecc572e7a8a01e6c3d67055a34270da1","modified":1562857980692},{"_id":"source/_posts/Thailand-Raiders/10.jpeg","hash":"6d3cbf62e3ae76e9f1c0b7d83131c2285f153012","modified":1563457979789},{"_id":"source/_posts/Thailand-Raiders/5.png","hash":"fa26beabe60a86da1e11fb49f9243e3872b495bc","modified":1563457979824},{"_id":"source/_posts/Tree/BBT2.png","hash":"23e5828814c8e662bd0aed71dfcf9bebb35038a8","modified":1583496072451},{"_id":"source/_posts/Tree/BBT1.png","hash":"645a1fe9ba706a0159bfacd5cb9bf6cd525abefb","modified":1583496072452},{"_id":"source/_posts/Tree/BBT3.png","hash":"3bbb36e99daa5c6cac40a2f7fb5c57227e4c9181","modified":1583496072450},{"_id":"source/_posts/Tree/BBT4.png","hash":"e0d5a6066060e3f56c9b2a646b41f9ad267a2bf7","modified":1583496072450},{"_id":"source/_posts/Tree/BST_delete1.png","hash":"7a4ead2cfe4785e8a85fb667c046933ba06c3904","modified":1583496072449},{"_id":"source/_posts/Tree/BST_delete2.png","hash":"460deb38ed00f83ceb4e05ce05808e7b66f0dda3","modified":1583496072448},{"_id":"source/_posts/Tree/BST_insert.png","hash":"b5c6e16d88546efe42b1f8b04cc678c573d20364","modified":1583496072447},{"_id":"source/_posts/Tree/BST_linked.png","hash":"fa4948a5bcee882a13b10b8c2daf51ac6ca24d85","modified":1583496072447},{"_id":"source/_posts/Tree/Red02.jpeg","hash":"7e985de520d6eb2e3e9b6f1a230b53a75fc4ad76","modified":1584087421543},{"_id":"source/_posts/Tree/Red03.jpeg","hash":"ea2676a248e591bb413d2bc1b27905501cb2d09c","modified":1584087421544},{"_id":"source/_posts/Tree/Red06.jpeg","hash":"28da71d12754d62d82c90c32a2b48e8be2d2378a","modified":1584087421545},{"_id":"source/_posts/Tree/Red07.jpeg","hash":"b20d7b2c168b08c6c072e808131d18ce80bc3ad8","modified":1584087421546},{"_id":"source/_posts/Tree/Red08.jpeg","hash":"2bfbbdd2838fdc1cef1c6bc6769041ab0472b002","modified":1584087421546},{"_id":"source/_posts/Tree/Red10.jpg","hash":"99d1342d710861539ddfcc68d4d6d17ab826e891","modified":1584087421547},{"_id":"source/_posts/Tree/Red09.jpeg","hash":"0ef39a229dcc10a7fa51d5c82ca31d8e74f095a1","modified":1584087421547},{"_id":"source/_posts/Tree/Red11.jpg","hash":"18a2b1b978c5c29a5fbd0eff4b260baba663c496","modified":1584087421547},{"_id":"source/_posts/Tree/Red13.jpg","hash":"dce17244ad2e9da8c7f046382527b97e68f84cd3","modified":1584087421548},{"_id":"source/_posts/Tree/Red12.jpg","hash":"215b348c9df9ced1a7962760cb48b665562f47d0","modified":1584087421547},{"_id":"source/_posts/Tree/Red14.jpg","hash":"a65fab574a893e6244985c68f89201f886a3ed15","modified":1584087421548},{"_id":"source/_posts/Tree/Red15.jpg","hash":"3d8554bbecd7677ef88340fa343cfbecd8a745b4","modified":1584087421548},{"_id":"source/_posts/Tree/Red17.jpg","hash":"ddfdc744c7769715bbfdbf18285c4a9ecc2ff1c3","modified":1584087421549},{"_id":"source/_posts/Tree/Red16.jpg","hash":"666ff16a2a0393c8b4461877a3af284286043188","modified":1584087421549},{"_id":"source/_posts/Tree/Req18.jpg","hash":"6b7e663982a31773e9de6243a365b0bf3305216b","modified":1584087421550},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1562857980730},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1562857980730},{"_id":"themes/next/layout/_partials/footer.swig","hash":"b035a2d2b7ad281b3a6df0c759fcafe6b0113177","modified":1579685490459},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1562857980733},{"_id":"themes/next/layout/_partials/head.swig","hash":"52a1985c4ee199d3a1b2bdee46b437c64e619224","modified":1579685490459},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1562857980734},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1562857980734},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1562857980735},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1562857980735},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1562857980732},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1562857980731},{"_id":"themes/next/layout/_macro/post-end-tag.swig","hash":"51118e29759de4dce54b348eb8197cd0044aa45c","modified":1562857980732},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1562857980732},{"_id":"themes/next/layout/_macro/my-copyright.swig","hash":"72c1224cd566eea28a33e93f85e4ad3cb67270b1","modified":1564580501001},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1562857980733},{"_id":"themes/next/layout/_macro/post.swig","hash":"61efd7b2d9b6386bc267a22e15cbcb66a13f802e","modified":1579685490459},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1562857980738},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1562857980733},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1562857980739},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1562857980745},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1562857980746},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1562857980746},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1562857980741},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1562857980746},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1562857980751},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1562857980751},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1562857980751},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1562857980752},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1562857980752},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1562857980752},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1562857980752},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1562857980752},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1562857980753},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1562857980746},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1562857980746},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1562857980778},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1562857980746},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1562857980779},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1562857980780},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1562857980780},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1562857980780},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1562857980779},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1562857980781},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1562857980781},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1562857980781},{"_id":"themes/next/source/images/alipay.jpg","hash":"499aab03d01ae8b1e2f2eb593bdcd6e989188b9e","modified":1562857980779},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1562857980781},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1562857980781},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1562857980782},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1562857980782},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1562857980782},{"_id":"themes/next/source/images/favicon.ico","hash":"85da2faa392c9c975434e11a311e70fc6e8ca55e","modified":1562857980782},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1562857980782},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1562857980783},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1562857980782},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1562857980782},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1562857980783},{"_id":"themes/next/source/images/wechatpay.jpg","hash":"a6529134a0531dda88058747a8f41f4aab5e9abe","modified":1562857980783},{"_id":"source/_posts/JVM-Fundamentals/10.2.png","hash":"3ab3812234c032043b50a4883d2f676cba8ac6c3","modified":1579685490371},{"_id":"source/_posts/Interview/01.jpeg","hash":"f8d112cde57747db5b03afff0bcb3f0d6b06d2a4","modified":1584087421524},{"_id":"source/_posts/Interview/doublewrite.png","hash":"f42d0c74d3eb68e0c960d90c40523918f34c5e12","modified":1566025934647},{"_id":"source/_posts/Interview/kafka.png","hash":"f970b02b874a9e4a4ae888ee84153951b6e82153","modified":1562857980658},{"_id":"source/_posts/Interview/load.png","hash":"88d61d1e91fc0d95ae5609e914a59b5413296d35","modified":1585583403085},{"_id":"source/_posts/Interview/slidingWindow  .png","hash":"3ec3a3d1fa0ca6a91e3861531aaecf5ef3a3beb6","modified":1584087421536},{"_id":"source/_posts/Java-MemoryModel/7.png","hash":"5a07bf12e21e7c1fbb108ceb19fd37012130fdba","modified":1579685490451},{"_id":"source/_posts/Java-Synchronized/10.png","hash":"ff70b07c7053278691b7046c3c84938a1fbb4b40","modified":1583496071875},{"_id":"source/_posts/Java-Synchronized/3.png","hash":"05836569654ee69b5f60f8be2f25b8c09d92d259","modified":1583496071878},{"_id":"source/_posts/Java-Synchronized/4.png","hash":"ed0a0397d8c7a03b68bb8cf69eb4ca2c3ad488ef","modified":1583496071880},{"_id":"source/_posts/Java-Synchronized/5.png","hash":"27da5796ae36b88f6ec7d3a62d61e6460b63e524","modified":1583496071881},{"_id":"source/_posts/Kafka-Background/1.png","hash":"f970b02b874a9e4a4ae888ee84153951b6e82153","modified":1562857980658},{"_id":"source/_posts/Kafka-Producer/cert_override.png","hash":"c91783236434fcdc194b90089a5b1b9c1768344b","modified":1565014459203},{"_id":"source/_posts/Mysql02/doublewrite.png","hash":"f42d0c74d3eb68e0c960d90c40523918f34c5e12","modified":1566025934647},{"_id":"source/_posts/Mysql02/read.png","hash":"a8de8ff1931593ce04cd3c588dd4c29319b77546","modified":1566025934653},{"_id":"source/_posts/Mysql02/three-list2.png","hash":"59d11716ab165d813482de8b436db0b60eb6604f","modified":1566025934658},{"_id":"source/_posts/Project-Module/10.png","hash":"5db18541d543dd31c8345d1fc67cef3c0a41f755","modified":1562857980669},{"_id":"source/_posts/Project-Module/11.png","hash":"9b094ebe0fbdfd04aa207b9ce540c69a5c0c3f45","modified":1562857980670},{"_id":"source/_posts/Project-Module/3.png","hash":"be6b1ece28049a1871b51a8c184e2e1952ae6da2","modified":1562857980675},{"_id":"source/_posts/Project-Module/5.png","hash":"77180f160369fde5065dd5b6139c5e506c60671b","modified":1562857980680},{"_id":"source/_posts/Redis-adlist/list.png","hash":"8c42024153090d4e8dc85dd26313b98ae394a2fc","modified":1562857980691},{"_id":"source/_posts/Thailand-Raiders/1.png","hash":"6df75200d332aff25a8a580f74be792f9ebadebc","modified":1563457979788},{"_id":"source/_posts/Thailand-Raiders/WechatIMG40.png","hash":"433cf7251a4e330ab70046a7ddce2dc7a83fba84","modified":1567254838764},{"_id":"source/_posts/Thailand-Raiders/WechatIMG39.png","hash":"9add9f7543f1a03febc8430bf4053a11ed9e6101","modified":1567254838867},{"_id":"source/_posts/Tree/Red01.jpg","hash":"28ed0c72d6c948c96b26d798c3e553f4615dafb5","modified":1584087421543},{"_id":"source/_posts/Tree/Red05.jpeg","hash":"88d6405053440f26ecdd076fb4f89e1b02f571c6","modified":1584087421545},{"_id":"source/_posts/Tree/Red04.jpeg","hash":"a59d5e8d3c903037dd6a8e3d1bbbbc90a2f2e385","modified":1584087421544},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562857980741},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562857980741},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562857980778},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564672944238},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562857980772},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562857980772},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562857980773},{"_id":"themes/next/source/images/avatar.png","hash":"2fc664b73fb0dc51c0025d6d605f70440f3712c1","modified":1562857980780},{"_id":"source/_posts/Github-Pages-Blog/comment-delete.png","hash":"e8e8f4226ffb96387f1e15a45df8e28d6fe219f2","modified":1562857980638},{"_id":"source/_posts/Github-Pages-Blog/github-pages.png","hash":"cb19bd12e2c73729f622bb439c7ca2bfc6fa1706","modified":1562857980645},{"_id":"source/_posts/Github-Pages-Blog/setting.png","hash":"d78c0cf7a9a0d795e350eff8c0ab9ef0262cc01d","modified":1562857980652},{"_id":"source/_posts/Github-Pages-Blog/valine.png","hash":"b35df8378b9559765b74f7d6bb9909a1372d115e","modified":1562857980655},{"_id":"source/_posts/JVM-Fundamentals/10.3.png","hash":"2b9dd8c64009d4fa6bd050839c7f1bc47f85e2e7","modified":1579685490372},{"_id":"source/_posts/JVM-Fundamentals/3.png","hash":"48192e32212baa9ac9e96c70812a2013fe7a3069","modified":1579685490378},{"_id":"source/_posts/JVM-Fundamentals/4.png","hash":"d1a7333498973d07ce8596a06c81e7753e98e9d1","modified":1579685490380},{"_id":"source/_posts/JVM-Fundamentals/9.1.png","hash":"5752a00ddb6259673a364e3acc21d6912d45ec2b","modified":1579685490441},{"_id":"source/_posts/JVM-Fundamentals/9.2.png","hash":"6e99288d2d233d02d5aaa42386817290a8c776de","modified":1579685490442},{"_id":"source/_posts/Interview/3.png","hash":"48192e32212baa9ac9e96c70812a2013fe7a3069","modified":1584087421530},{"_id":"source/_posts/Interview/4.png","hash":"d1a7333498973d07ce8596a06c81e7753e98e9d1","modified":1584087421531},{"_id":"source/_posts/Interview/Handshake.png","hash":"6145e0e669156819486e5d9405838910a4727443","modified":1584087421535},{"_id":"source/_posts/Interview/innodb-Architecture.png","hash":"f99f6d2e919632903493f158c7573cb81238dba0","modified":1566025934650},{"_id":"source/_posts/Java-Synchronized/1.png","hash":"07765c8f808a56bdf73702874c3c0d34ddba4211","modified":1583496071874},{"_id":"source/_posts/Java-Synchronized/2.png","hash":"1f43754626c98781d0ed07cde400724f40333cf4","modified":1583496071877},{"_id":"source/_posts/Mysql01/01.jpg","hash":"6d800a31280148d6e6b796003941c74e14805fea","modified":1564580500993},{"_id":"source/_posts/Mysql02/innodb-Architecture.png","hash":"f99f6d2e919632903493f158c7573cb81238dba0","modified":1566025934650},{"_id":"source/_posts/Mysql02/three-list.png","hash":"b5cdd07f60a3fa569e61b7c6078f860f5e1441e6","modified":1566025934656},{"_id":"source/_posts/Project-Module/1.png","hash":"0d13a4094fe66b80ad104b87698f7d95c422acf0","modified":1562857980668},{"_id":"source/_posts/Project-Module/2.png","hash":"23d9f5a8c391d42f884d2921d3ae263f17510a41","modified":1562857980674},{"_id":"source/_posts/Project-Module/30.1.png","hash":"8d2eb3439248383787e3593bf7fd1693efe90ea9","modified":1562857980677},{"_id":"source/_posts/Project-Module/4.png","hash":"10d542aa156ac37480249b2be21cd83ee6902804","modified":1562857980679},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1562857980735},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1562857980735},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1562857980734},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1562857980734},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1562857980737},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1562857980736},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1562857980736},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1562857980737},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1562857980737},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1562857980739},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1562857980740},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1562857980741},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1562857980742},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1562857980742},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1562857980742},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1562857980742},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1562857980743},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1562857980743},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1562857980742},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1562857980743},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1562857980743},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"a4bc24330c24a51012bd4d3e876008afb0a0b83f","modified":1579685490460},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1562857980743},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1562857980743},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1562857980743},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1562857980744},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1562857980744},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1562857980744},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1562857980744},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1562857980745},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1562857980745},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1562857980745},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1562857980745},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1562857980745},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1562857980747},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1562857980747},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1562857980748},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1562857980747},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1562857980778},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1562857980778},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1565012483780},{"_id":"themes/next/source/css/_variables/base.styl","hash":"f3e52c47c5eb6a0aec6b1e6cb1be0bca807c35ac","modified":1579685490461},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1562857980772},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1562857980772},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1562857980772},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"1777d9550bb55fdb8ef82265225de15ba345ff8a","modified":1579685490460},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1562857980784},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1562857980784},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1562857980784},{"_id":"themes/next/source/js/src/clipboard.min.js","hash":"765eed9192ea1956416508e97868f65507cc7d35","modified":1564580501003},{"_id":"themes/next/source/js/src/clipboard-use.js","hash":"f5dfecd9bf13b9d1483bf663a367c7c080aac9cc","modified":1564580501002},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1562857980784},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1562857980784},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1562857980784},{"_id":"themes/next/source/js/src/motion.js","hash":"6a96c556378d10ec3250850be7ba4a5b55f5b5d7","modified":1562857980785},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1562857980785},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1562857980785},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1562857980791},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1562857980785},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1562857980792},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1562857980786},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1562857980789},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1562857980803},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1562857980803},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1562857980804},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1562857980804},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1562857980804},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1562857980804},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1562857980804},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1562857980795},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1562857980805},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1562857980795},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1562857980796},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1562857980805},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1562857980805},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1562857980795},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1562857980797},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1562857980797},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1562857980797},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1562857980797},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1562857980797},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1562857980809},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1562857980809},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1562857980805},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1562857980806},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1562857980809},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1562857980806},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1562857980806},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1562857980806},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1562857980806},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1562857980807},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1562857980807},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1562857980807},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1562857980808},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1562857980808},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1562857980808},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1562857980809},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1562857980808},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1562857980813},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1562857980813},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1562857980815},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1562857980815},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1562857980815},{"_id":"source/_posts/Github-Pages-Blog/create-repository.png","hash":"9bdbb8073bb7b6f37f42577ef8843d09028cd026","modified":1562857980642},{"_id":"source/_posts/JVM-Fundamentals/5.png","hash":"a321a88703c8d967b4e204a5ce56cbb8d7cb7d00","modified":1579685490435},{"_id":"source/_posts/JVM-Fundamentals/7.png","hash":"622b295c636943020706f03789423ce34629f8fc","modified":1579685490439},{"_id":"source/_posts/Interview/5.png","hash":"a321a88703c8d967b4e204a5ce56cbb8d7cb7d00","modified":1584087421533},{"_id":"source/_posts/Interview/io.png","hash":"59002cfa2c0c7651a8bd890c596cf8fb4f2f08af","modified":1584537122426},{"_id":"source/_posts/Interview/wave.png","hash":"a58ac6cefa465384147a4a57d2e3db4f37e33a0e","modified":1584087421538},{"_id":"source/_posts/Java-MemoryModel/6.png","hash":"db48a4b53910fb28788ed7e3114001d379e5a165","modified":1579685490449},{"_id":"source/_posts/Kafka-Background/2.png","hash":"ab3ac1493d4e8a787578f5ad348c1164e137fa03","modified":1562857980660},{"_id":"source/_posts/Kafka-Background/4.jpg","hash":"2f17548f83ba5831e21fca29aaed2dc64ef1a4db","modified":1562857980662},{"_id":"source/_posts/MyBatis-01/1.png","hash":"793797fc5114bdb4ae634a652ade3cb7a90b7413","modified":1579685490454},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1562857980803},{"_id":"source/_posts/Design-Pattern-Observer/2.png","hash":"72a6fba3e46327e3632a09810b24215f763850b4","modified":1579685490364},{"_id":"source/_posts/Github-Pages-Blog/copy-url.png","hash":"fb7edbabddfe278a5fc1db57a90a99f690daafe5","modified":1562857980640},{"_id":"source/_posts/JVM-Fundamentals/1.png","hash":"1392017bcb5b3941e30919d0b3f71a4eff053635","modified":1579685490369},{"_id":"source/_posts/Interview/1.png","hash":"1392017bcb5b3941e30919d0b3f71a4eff053635","modified":1584087421528},{"_id":"source/_posts/Interview/bean.png","hash":"3ead8b25dab88b265902775bfc6eabbf6379a8cc","modified":1584793636061},{"_id":"source/_posts/Java-Synchronized/7.png","hash":"7e7d700f0500ae56ae98885113579fecc845c4d9","modified":1583496071887},{"_id":"source/_posts/Mysql-LSN/LOG.png","hash":"9a8feb8bfefe2de7a8401f1afebeb88577807ac6","modified":1567220639993},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1562857980747},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"6109209e94d4d06513ce194a11e05a5640927e41","modified":1562857980771},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1562857980771},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1562857980747},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1562857980771},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1562857980771},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1562857980771},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1562857980771},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1562857980753},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"f05d6881daddfba936f7936fb7ea8b8debe07c01","modified":1562857980754},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1562857980771},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1562857980754},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1562857980754},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1562857980754},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1562857980760},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1562857980774},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1562857980773},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1562857980767},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1562857980774},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1562857980774},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1562857980773},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1562857980775},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1562857980775},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1562857980777},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1562857980776},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1562857980777},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1562857980777},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1562857980777},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1562857980777},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1562857980775},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1562857980773},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1562857980776},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1562857980776},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1562857980776},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1562857980776},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1562857980785},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1562857980789},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1562857980787},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1562857980788},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1562857980792},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1562857980792},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1562857980793},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1562857980792},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1562857980792},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1562857980793},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1562857980795},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1562857980795},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1562857980794},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1562857980796},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1562857980796},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1562857980798},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1562857980798},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1562857980813},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1562857980813},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1562857980798},{"_id":"source/_posts/JVM-Fundamentals/10.4.png","hash":"f03b6b525df73dec6871493ec77ee52d90091f5c","modified":1579685490375},{"_id":"source/_posts/Interview/head.png","hash":"c8859977608a9b6a44112b222f63d5d43b6a48b9","modified":1584543079832},{"_id":"source/_posts/Java-Synchronized/6.png","hash":"d1b91fb46ceab7190534a29419a48ba0d3b6fb92","modified":1583496071885},{"_id":"source/_posts/Kafka-Background/6.png","hash":"95bb5f40b31f98bec90ca4eb43fa1fcb6a6d2b1d","modified":1562857980666},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1562857980788},{"_id":"source/_posts/C++-02/1.png","hash":"36cb35aebf9aff9ea22a85ce733502814cd96341","modified":1563457979786},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1562857980814},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1562857980802},{"_id":"source/_posts/Design-Pattern-Observer/1.png","hash":"d3bddadb077b53b79235a90930fed4a902a531d1","modified":1579685490361},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1562857980802},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-13-11-50-782_com.xingin.xhs.png","hash":"94400f10315c8e5d2717b26181f21ec5fa89dadb","modified":1567228877979},{"_id":"source/_posts/Thailand-Raiders/tianjin-airport.png","hash":"24a3881c4494b484a15cfaa065221d05241d9ebc","modified":1563457979863},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1562857980754},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1562857980758},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1562857980757},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1562857980757},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1562857980755},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1562857980756},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1562857980755},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1562857980755},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1562857980756},{"_id":"themes/next/source/css/_common/components/post/my-post-copyright.styl","hash":"1a510f995e665b28d85ba4d169b824276c40e4f3","modified":1562857980760},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1562857980761},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1562857980762},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1562857980761},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1562857980763},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1562857980762},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1562857980763},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1562857980763},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1562857980763},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1562857980764},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1562857980764},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1562857980764},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1562857980765},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1562857980764},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1562857980764},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1562857980758},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1562857980759},{"_id":"themes/next/source/css/_common/components/pages/authors.styl","hash":"ebbd43658f5a054d934c9ca5abdf801449ca6559","modified":1562857980759},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"646467b94ae4a78eebabb2d8635a2ac12665fa4e","modified":1562857980759},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1562857980759},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1562857980759},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"8f40a758fe6dff1f45268f2dc875b4336e551335","modified":1562857980766},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1562857980766},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1562857980766},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"90d78b7270739eaab5b054226b684631a319011a","modified":1562857980765},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1562857980766},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1562857980766},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1562857980766},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1562857980767},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1562857980767},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1562857980767},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1584370377772},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1562857980767},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1562857980768},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1562857980767},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1562857980768},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1562857980768},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1562857980769},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1562857980768},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1562857980768},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1562857980769},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1562857980768},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1562857980769},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1562857980769},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1562857980770},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1562857980770},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1562857980770},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1562857980770},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1562857980769},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1562857980770},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1562857980770},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1562857980775},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1562857980775},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1562857980786},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1562857980776},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1562857980786},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1562857980787},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1562857980793},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1562857980793},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1562857980787},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1562857980793},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1562857980793},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1562857980794},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1562857980794},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1562857980787},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1562857980800},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1562857980799},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1562857980801},{"_id":"source/_posts/Interview/redis-shujujiegou.png","hash":"02e0352ee8a35b481041b8a488406485713452a7","modified":1584794839265},{"_id":"source/_posts/Project-Module/9.png","hash":"b7a7304228d094b97030b6a3851d60c0cd40db8c","modified":1562857980684},{"_id":"source/_posts/JVM-Fundamentals/5.2.png","hash":"cd01362a01a14fd353ed6a826e1bac3f54d77d1a","modified":1579685490392},{"_id":"source/_posts/JVM-Fundamentals/5.3.png","hash":"b27f822676d7ac896430eaa736de883769823e5b","modified":1579685490399},{"_id":"source/_posts/JVM-Fundamentals/5.1.png","hash":"36099be072bd8a223781d30adb33c258a6811c85","modified":1579685490385},{"_id":"source/_posts/JVM-Fundamentals/5.5.png","hash":"2159f9eb991464b3a5bd06d20d998987e92dce98","modified":1579685490409},{"_id":"source/_posts/JVM-Fundamentals/5.6.png","hash":"61a7f63fdd4b896cdb0495f1197ed2f4b179ad83","modified":1579685490414},{"_id":"source/_posts/JVM-Fundamentals/5.7.png","hash":"72ecaa12e56f9163104a099213d3129ebadf2432","modified":1579685490419},{"_id":"source/_posts/JVM-Fundamentals/5.9.png","hash":"f628779197aff2f4cab54d5cd463ea3a29e10a5f","modified":1579685490432},{"_id":"source/_posts/JVM-Fundamentals/5.4.png","hash":"2c5a7205bdd818a683eb4218dfa51626c294309c","modified":1579685490404},{"_id":"source/_posts/Interview/threadPoll.png","hash":"0bbf087a38348f5c3a2fc167e5d2583157dbc265","modified":1584867778153},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1562857980791},{"_id":"source/_posts/JVM-Fundamentals/5.8.png","hash":"bba6d111d8fec8792d926b7e5a0dedaaf8e5a393","modified":1579685490426},{"_id":"source/_posts/Thailand-Raiders/Tiffany.png","hash":"e2b3b598e4f2f77aa72c6d888de5b7c28d971dd9","modified":1563457979859},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1562857980812},{"_id":"source/_posts/Github-Pages-Blog/select-theme.png","hash":"2f05fcf89dee3dbaf7042198d28ab27c567b6a0d","modified":1562857980650},{"_id":"source/_posts/Interview/sqllock.gif","hash":"9d5b717b51f3d2556e88f6ac7a2ec5d6b9e3de13","modified":1584287735610},{"_id":"source/_posts/Thailand-Raiders/455.jpeg","hash":"f62028d3c728e26a58ee9a081b5a470ab114d82b","modified":1565622956564},{"_id":"source/_posts/Thailand-Raiders/8.png","hash":"05f3c25bcbdad89508a1740b34464f33ea8132ce","modified":1563457979850},{"_id":"source/_posts/Thailand-Raiders/9.png","hash":"565b668726c06a9abab0bd490da907f2b3ed6e98","modified":1563457979855},{"_id":"source/_posts/Thailand-Raiders/WechatIMG38.jpeg","hash":"b9d274ae9388be4436f54708acb8ae92a303b60a","modified":1567254839131},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1562857980801},{"_id":"source/_posts/Thailand-Raiders/455-3.jpeg","hash":"604b935a2bcd0dc10de6a3303e741a72b572dc40","modified":1565622956557},{"_id":"source/_posts/Thailand-Raiders/455-2.jpeg","hash":"c6bfeb6633daa1a6250c18f91f9369626959e157","modified":1565622956549},{"_id":"source/_posts/Thailand-Raiders/6.png","hash":"3f10dab38908d094d0b909422bc19d0a17340057","modified":1563457979836},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-13-12-27-105_com.xingin.xhs.png","hash":"8cff18582c7a30d6195fbcc5d7c55267eb7453ae","modified":1567229061576},{"_id":"source/_posts/Thailand-Raiders/7.png","hash":"3fc9d1546cac372d29ff9b8b7d15391355ca4b7f","modified":1563457979844},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-13-11-56-133_com.xingin.xhs.png","hash":"e6eff5392fa75f21454b10b8d5952f92e083da2d","modified":1567228904571},{"_id":"source/_posts/Thailand-Raiders/11.png","hash":"7d4c9b3713ea0e79a64cb03a47c4b300ba2e4b70","modified":1563457979793},{"_id":"source/_posts/Thailand-Raiders/4.png","hash":"1fb34d3299621f60fb2dbf4288d8c36e6ac5e77f","modified":1563457979823},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-14-25-04-833_com.xingin.xhs.png","hash":"2238216e08587f3b15762c9dd3e82051358a5e51","modified":1567234118511},{"_id":"source/_posts/Thailand-Raiders/3.png","hash":"371d12b9c4257b27c643c35e22ded6217d31d2f5","modified":1563457979806},{"_id":"source/_posts/Thailand-Raiders/2.png","hash":"d6619479a7b598851ad99a36ef764acbad9aa01a","modified":1563457979797},{"_id":"source/_posts/Interview/springmvc.png","hash":"2340f33bb4d22746f78bc3163e7af4e869997ae9","modified":1584861015131},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-14-05-58-003_com.xingin.xhs.png","hash":"56e1172a88c0bfd9c4c52e333611fc6595ab8c7a","modified":1567234094895},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-12-05-18-389_com.xingin.xhs.png","hash":"f928b7f7e08fbb020de4fb3c4cf528f8d856b8e3","modified":1567224662579},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-12-05-30-499_com.xingin.xhs.png","hash":"7cafaa78693a7c0b2626f1ee2210b3b57ab2ed1b","modified":1567224678772},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-11-46-03-072_com.xingin.xhs.png","hash":"9e417ba24b91a347b8cbb606f8c728e2557d2a82","modified":1567223852026},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-12-05-20-912_com.xingin.xhs.png","hash":"2ac2f81bc4349ec9568cb5747b88893642922a67","modified":1567224633028},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-12-05-25-297_com.xingin.xhs.png","hash":"5c7ab3a4fb6d52e1ac7a7b25ac67c5f2e3e8ae0d","modified":1567224607667},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-12-05-23-188_com.xingin.xhs.png","hash":"2c4b2f791d89c9f9fdfc9f41c1d2e59c44be9703","modified":1567224620248},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-11-46-00-652_com.xingin.xhs.png","hash":"e8f3537c76dc753e795914ac8ffbe4e515b5304f","modified":1567223778750},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-12-05-14-972_com.xingin.xhs.png","hash":"a252f74aae9f5fc9bafc8086362434d537b30de9","modified":1567224646701},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-11-45-57-687_com.xingin.xhs.png","hash":"c38ed53378b5d8b29299a543b9615d289e2679a6","modified":1567223801385},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-11-45-53-237_com.xingin.xhs.png","hash":"724228f9d5e8d6ad4dbc4c27ad75b316650834d7","modified":1567223816906},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-11-46-08-364_com.xingin.xhs.png","hash":"98baf6d8c995e9f2a9e366730c584219e32a3911","modified":1567223882938}],"Category":[{"name":"JAVA","_id":"ck8fb4a890004k2o5isqmeoli"},{"name":"redis","_id":"ck8fb4a8i000ak2o5vo9v85as"},{"name":"MyBatis","_id":"ck8fb4a8o000fk2o53d9l6iy3"},{"name":"C++","_id":"ck8fb4a8r000kk2o56bivgkch"},{"name":"设计模式","_id":"ck8fb4a9i000wk2o5hmlpa2ls"},{"name":"GUAVA","_id":"ck8fb4abn001uk2o58u8uxel0"},{"name":"blog","_id":"ck8fb4ac60022k2o5apqquflw"},{"name":"Idea","_id":"ck8fb4acr002ak2o5gm4pxzdg"},{"name":"JVM","_id":"ck8fb4ada002jk2o50pdewtqz"},{"name":"项目搭建","_id":"ck8fb4ae40038k2o5nk6rvvab"},{"name":"Kafka","_id":"ck8fb4ae7003lk2o5ix733zs0"},{"name":"Mysql","_id":"ck8fb4aeb003uk2o5ns49o7iw"},{"name":"旅游","_id":"ck8fb4ak1006yk2o5p43zplnx"},{"name":"数据结构","_id":"ck8fb4ak40070k2o5mhhb8qxh"}],"Data":[],"Page":[{"title":"authors","type":"authors","comments":0,"_content":"","source":"authors/index.md","raw":"---\ntitle: authors\ntype: \"authors\"\ncomments: false\n---","date":"2020-01-22T09:36:15.543Z","updated":"2019-07-11T15:13:00.692Z","path":"authors/index.html","layout":"page","_id":"ck8fb4a830001k2o543h53nl9","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ntype: \"tags\"\ncomments: false\n---","date":"2020-01-22T09:36:15.553Z","updated":"2019-07-11T15:13:00.693Z","path":"tags/index.html","layout":"page","_id":"ck8fb4a890003k2o5mdh63s47","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ntype: \"categories\"\ncomments: false\n---\n","date":"2020-01-22T09:36:15.553Z","updated":"2019-07-11T15:13:00.692Z","path":"categories/index.html","layout":"page","_id":"ck8fb4a8f0007k2o57gjlccok","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"JAVA-AQS","date":"2019-10-23T06:41:04.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"# AQS\nAQS是AbstractQueuedSynchronizer的简称。AQS提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，如下图所示。\n![](Java-AQS/CLH.jpg)\nstate: AQS维护了一个volatile long类型的state,state = 0 表示无线程占用，state > 0 表示有线程占用\n当state > 0 有线程占用时，队列中其他线程自旋等待。//设置当前线程占有资源\n\n","source":"_drafts/Java-AQS.md","raw":"---\ntitle: JAVA-AQS\ndate: 2019-10-23 14:41:04\ntags:\n    - JAVA\n    - 并发\n    - 学习笔记\ncategories: JAVA\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n# AQS\nAQS是AbstractQueuedSynchronizer的简称。AQS提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，如下图所示。\n![](Java-AQS/CLH.jpg)\nstate: AQS维护了一个volatile long类型的state,state = 0 表示无线程占用，state > 0 表示有线程占用\n当state > 0 有线程占用时，队列中其他线程自旋等待。//设置当前线程占有资源\n\n","slug":"Java-AQS","published":0,"updated":"2020-03-06T12:01:11.871Z","layout":"post","photos":[],"link":"","_id":"ck8fb4a7y0000k2o5uyka3ixq","content":"<h1 id=\"AQS\"><a href=\"#AQS\" class=\"headerlink\" title=\"AQS\"></a>AQS</h1><p>AQS是AbstractQueuedSynchronizer的简称。AQS提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，如下图所示。<br><img src=\"/JAVA/Java-AQS/CLH.jpg\" alt=\"\"><br>state: AQS维护了一个volatile long类型的state,state = 0 表示无线程占用，state &gt; 0 表示有线程占用<br>当state &gt; 0 有线程占用时，队列中其他线程自旋等待。//设置当前线程占有资源</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"AQS\"><a href=\"#AQS\" class=\"headerlink\" title=\"AQS\"></a>AQS</h1><p>AQS是AbstractQueuedSynchronizer的简称。AQS提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，如下图所示。<br><img src=\"/JAVA/Java-AQS/CLH.jpg\" alt=\"\"><br>state: AQS维护了一个volatile long类型的state,state = 0 表示无线程占用，state &gt; 0 表示有线程占用<br>当state &gt; 0 有线程占用时，队列中其他线程自旋等待。//设置当前线程占有资源</p>\n"},{"title":"redis常见面试题","date":"2019-03-13T14:33:04.000Z","copyright":true,"comments":0,"_content":"#### 什么是redis?\n```bash\nRedis 是一个基于内存的高性能key-value数据库。\n```\n\n#### Redis支持哪几种数据结构\n``` bash\nString（字符串）: set key value\nHash（哈希）: hmset name  key1 value1 key2 value2\nList（列表）：lpush  name  value\nSet（集合）：sadd  name  value\nzset(sorted set：有序集合)： zadd  name score value\n```\n#### Redis为什么这么快？redis采用多线程会有哪些问题？\n```bash\nRedis效率高的主要原因有下面几个：\n\n    （1）基于内存操作，速度非常快\n    （2）采用单线程，避免了上下文的切换导致消耗CPU\n    （3）采用单线程，不用去考虑各种加锁释放锁的问题\n    （4）使用IO多路复用模型，非阻塞IO\n```\n#### 什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？\n```bash\nRedis 提供了两种持久化方式:RDB（默认） 和AOF \nRDB:当前内存中的数据集快照写入磁盘,恢复时是将快照文件直接读到内存里。\nAOF:将Redis执行的每次写命令记录到单独的日志文件中,当Redis重启时再次执行AOF文件中的命令来恢复数据。\n```\n#### 一个字符串类型的值能存储最大容量是多少？\n```bash\n512M\n```\n#### Redis集群方案什么情况下会导致整个集群不可用？\n```bash\n有A，B，C三个节点的集群,在没有<复制模型>的情况下.\n如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。\n```\n#### Redis哈希槽的概念？\n```bash\nRedis集群没有使用一致性hash,而是引入了哈希槽的概念.\nRedis集群有 16384 个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽.\n集群的每个节点负责一部分hash槽。\n```\n#### Redis集群的主从复制模型？\n```bash\n为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，\n所以集群使用了主从复制模型,每个节点都会有N-1个复制品.\n```\n#### Redis事务相关的命令有哪几个？\n```bash\ndiscard命令-取消事务,发起执行事务块里的所有命令.\nexec命令-执行所有事务块内的命令.\nmulti命令-标记一个事务块的开始.\nwatch命令-监视一个（或多个）key，如果在执行事务之前这些key被其他命令所改动，事务将被打断.\nunwatch命令-取消watch命令对所有key的监视.\n```\n\n#### redis的过期策略\n```bash\nredis采用的是定期删除+惰性删除策略。\n\n定期删除：redis默认每个100ms检查，是否有过期的key（随机抽取key进行检查）,有过期key则删除。\n因此，如果只采用定期删除策略，会导致很多key到时间没有删除。\n\n惰性删除：在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。\n```\n#### 为什么不用定时删除策略?\n```bash\n定时删除,用一个定时器来负责监视key,过期则自动删除。\n虽然内存及时释放，但是十分消耗CPU资源。\n在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.\n```\n","source":"_drafts/Redis.md","raw":"---\ntitle: redis常见面试题\ndate: 2019-03-13 22:33:04\ntags:\n    - redis\n    - 面试总结\ncategories: redis\ncopyright: true\ncomments: false\n---\n#### 什么是redis?\n```bash\nRedis 是一个基于内存的高性能key-value数据库。\n```\n\n#### Redis支持哪几种数据结构\n``` bash\nString（字符串）: set key value\nHash（哈希）: hmset name  key1 value1 key2 value2\nList（列表）：lpush  name  value\nSet（集合）：sadd  name  value\nzset(sorted set：有序集合)： zadd  name score value\n```\n#### Redis为什么这么快？redis采用多线程会有哪些问题？\n```bash\nRedis效率高的主要原因有下面几个：\n\n    （1）基于内存操作，速度非常快\n    （2）采用单线程，避免了上下文的切换导致消耗CPU\n    （3）采用单线程，不用去考虑各种加锁释放锁的问题\n    （4）使用IO多路复用模型，非阻塞IO\n```\n#### 什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？\n```bash\nRedis 提供了两种持久化方式:RDB（默认） 和AOF \nRDB:当前内存中的数据集快照写入磁盘,恢复时是将快照文件直接读到内存里。\nAOF:将Redis执行的每次写命令记录到单独的日志文件中,当Redis重启时再次执行AOF文件中的命令来恢复数据。\n```\n#### 一个字符串类型的值能存储最大容量是多少？\n```bash\n512M\n```\n#### Redis集群方案什么情况下会导致整个集群不可用？\n```bash\n有A，B，C三个节点的集群,在没有<复制模型>的情况下.\n如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。\n```\n#### Redis哈希槽的概念？\n```bash\nRedis集群没有使用一致性hash,而是引入了哈希槽的概念.\nRedis集群有 16384 个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽.\n集群的每个节点负责一部分hash槽。\n```\n#### Redis集群的主从复制模型？\n```bash\n为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，\n所以集群使用了主从复制模型,每个节点都会有N-1个复制品.\n```\n#### Redis事务相关的命令有哪几个？\n```bash\ndiscard命令-取消事务,发起执行事务块里的所有命令.\nexec命令-执行所有事务块内的命令.\nmulti命令-标记一个事务块的开始.\nwatch命令-监视一个（或多个）key，如果在执行事务之前这些key被其他命令所改动，事务将被打断.\nunwatch命令-取消watch命令对所有key的监视.\n```\n\n#### redis的过期策略\n```bash\nredis采用的是定期删除+惰性删除策略。\n\n定期删除：redis默认每个100ms检查，是否有过期的key（随机抽取key进行检查）,有过期key则删除。\n因此，如果只采用定期删除策略，会导致很多key到时间没有删除。\n\n惰性删除：在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。\n```\n#### 为什么不用定时删除策略?\n```bash\n定时删除,用一个定时器来负责监视key,过期则自动删除。\n虽然内存及时释放，但是十分消耗CPU资源。\n在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.\n```\n","slug":"Redis","published":0,"updated":"2019-07-11T15:13:00.633Z","layout":"post","photos":[],"link":"","_id":"ck8fb4a860002k2o5csx56k4q","content":"<h4 id=\"什么是redis\"><a href=\"#什么是redis\" class=\"headerlink\" title=\"什么是redis?\"></a>什么是redis?</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Redis 是一个基于内存的高性能key-value数据库。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Redis支持哪几种数据结构\"><a href=\"#Redis支持哪几种数据结构\" class=\"headerlink\" title=\"Redis支持哪几种数据结构\"></a>Redis支持哪几种数据结构</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String（字符串）: <span class=\"built_in\">set</span> key value</span><br><span class=\"line\">Hash（哈希）: hmset name  key1 value1 key2 value2</span><br><span class=\"line\">List（列表）：lpush  name  value</span><br><span class=\"line\">Set（集合）：sadd  name  value</span><br><span class=\"line\">zset(sorted <span class=\"built_in\">set</span>：有序集合)： zadd  name score value</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Redis为什么这么快？redis采用多线程会有哪些问题？\"><a href=\"#Redis为什么这么快？redis采用多线程会有哪些问题？\" class=\"headerlink\" title=\"Redis为什么这么快？redis采用多线程会有哪些问题？\"></a>Redis为什么这么快？redis采用多线程会有哪些问题？</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Redis效率高的主要原因有下面几个：</span><br><span class=\"line\"></span><br><span class=\"line\">    （1）基于内存操作，速度非常快</span><br><span class=\"line\">    （2）采用单线程，避免了上下文的切换导致消耗CPU</span><br><span class=\"line\">    （3）采用单线程，不用去考虑各种加锁释放锁的问题</span><br><span class=\"line\">    （4）使用IO多路复用模型，非阻塞IO</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？\"><a href=\"#什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？\" class=\"headerlink\" title=\"什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？\"></a>什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Redis 提供了两种持久化方式:RDB（默认） 和AOF </span><br><span class=\"line\">RDB:当前内存中的数据集快照写入磁盘,恢复时是将快照文件直接读到内存里。</span><br><span class=\"line\">AOF:将Redis执行的每次写命令记录到单独的日志文件中,当Redis重启时再次执行AOF文件中的命令来恢复数据。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"一个字符串类型的值能存储最大容量是多少？\"><a href=\"#一个字符串类型的值能存储最大容量是多少？\" class=\"headerlink\" title=\"一个字符串类型的值能存储最大容量是多少？\"></a>一个字符串类型的值能存储最大容量是多少？</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">512M</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Redis集群方案什么情况下会导致整个集群不可用？\"><a href=\"#Redis集群方案什么情况下会导致整个集群不可用？\" class=\"headerlink\" title=\"Redis集群方案什么情况下会导致整个集群不可用？\"></a>Redis集群方案什么情况下会导致整个集群不可用？</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有A，B，C三个节点的集群,在没有&lt;复制模型&gt;的情况下.</span><br><span class=\"line\">如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Redis哈希槽的概念？\"><a href=\"#Redis哈希槽的概念？\" class=\"headerlink\" title=\"Redis哈希槽的概念？\"></a>Redis哈希槽的概念？</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Redis集群没有使用一致性<span class=\"built_in\">hash</span>,而是引入了哈希槽的概念.</span><br><span class=\"line\">Redis集群有 16384 个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽.</span><br><span class=\"line\">集群的每个节点负责一部分<span class=\"built_in\">hash</span>槽。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Redis集群的主从复制模型？\"><a href=\"#Redis集群的主从复制模型？\" class=\"headerlink\" title=\"Redis集群的主从复制模型？\"></a>Redis集群的主从复制模型？</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，</span><br><span class=\"line\">所以集群使用了主从复制模型,每个节点都会有N-1个复制品.</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Redis事务相关的命令有哪几个？\"><a href=\"#Redis事务相关的命令有哪几个？\" class=\"headerlink\" title=\"Redis事务相关的命令有哪几个？\"></a>Redis事务相关的命令有哪几个？</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">discard命令-取消事务,发起执行事务块里的所有命令.</span><br><span class=\"line\"><span class=\"built_in\">exec</span>命令-执行所有事务块内的命令.</span><br><span class=\"line\">multi命令-标记一个事务块的开始.</span><br><span class=\"line\">watch命令-监视一个（或多个）key，如果在执行事务之前这些key被其他命令所改动，事务将被打断.</span><br><span class=\"line\">unwatch命令-取消watch命令对所有key的监视.</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"redis的过期策略\"><a href=\"#redis的过期策略\" class=\"headerlink\" title=\"redis的过期策略\"></a>redis的过期策略</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis采用的是定期删除+惰性删除策略。</span><br><span class=\"line\"></span><br><span class=\"line\">定期删除：redis默认每个100ms检查，是否有过期的key（随机抽取key进行检查）,有过期key则删除。</span><br><span class=\"line\">因此，如果只采用定期删除策略，会导致很多key到时间没有删除。</span><br><span class=\"line\"></span><br><span class=\"line\">惰性删除：在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"为什么不用定时删除策略\"><a href=\"#为什么不用定时删除策略\" class=\"headerlink\" title=\"为什么不用定时删除策略?\"></a>为什么不用定时删除策略?</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定时删除,用一个定时器来负责监视key,过期则自动删除。</span><br><span class=\"line\">虽然内存及时释放，但是十分消耗CPU资源。</span><br><span class=\"line\">在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么是redis\"><a href=\"#什么是redis\" class=\"headerlink\" title=\"什么是redis?\"></a>什么是redis?</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Redis 是一个基于内存的高性能key-value数据库。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Redis支持哪几种数据结构\"><a href=\"#Redis支持哪几种数据结构\" class=\"headerlink\" title=\"Redis支持哪几种数据结构\"></a>Redis支持哪几种数据结构</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String（字符串）: <span class=\"built_in\">set</span> key value</span><br><span class=\"line\">Hash（哈希）: hmset name  key1 value1 key2 value2</span><br><span class=\"line\">List（列表）：lpush  name  value</span><br><span class=\"line\">Set（集合）：sadd  name  value</span><br><span class=\"line\">zset(sorted <span class=\"built_in\">set</span>：有序集合)： zadd  name score value</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Redis为什么这么快？redis采用多线程会有哪些问题？\"><a href=\"#Redis为什么这么快？redis采用多线程会有哪些问题？\" class=\"headerlink\" title=\"Redis为什么这么快？redis采用多线程会有哪些问题？\"></a>Redis为什么这么快？redis采用多线程会有哪些问题？</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Redis效率高的主要原因有下面几个：</span><br><span class=\"line\"></span><br><span class=\"line\">    （1）基于内存操作，速度非常快</span><br><span class=\"line\">    （2）采用单线程，避免了上下文的切换导致消耗CPU</span><br><span class=\"line\">    （3）采用单线程，不用去考虑各种加锁释放锁的问题</span><br><span class=\"line\">    （4）使用IO多路复用模型，非阻塞IO</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？\"><a href=\"#什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？\" class=\"headerlink\" title=\"什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？\"></a>什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Redis 提供了两种持久化方式:RDB（默认） 和AOF </span><br><span class=\"line\">RDB:当前内存中的数据集快照写入磁盘,恢复时是将快照文件直接读到内存里。</span><br><span class=\"line\">AOF:将Redis执行的每次写命令记录到单独的日志文件中,当Redis重启时再次执行AOF文件中的命令来恢复数据。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"一个字符串类型的值能存储最大容量是多少？\"><a href=\"#一个字符串类型的值能存储最大容量是多少？\" class=\"headerlink\" title=\"一个字符串类型的值能存储最大容量是多少？\"></a>一个字符串类型的值能存储最大容量是多少？</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">512M</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Redis集群方案什么情况下会导致整个集群不可用？\"><a href=\"#Redis集群方案什么情况下会导致整个集群不可用？\" class=\"headerlink\" title=\"Redis集群方案什么情况下会导致整个集群不可用？\"></a>Redis集群方案什么情况下会导致整个集群不可用？</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有A，B，C三个节点的集群,在没有&lt;复制模型&gt;的情况下.</span><br><span class=\"line\">如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Redis哈希槽的概念？\"><a href=\"#Redis哈希槽的概念？\" class=\"headerlink\" title=\"Redis哈希槽的概念？\"></a>Redis哈希槽的概念？</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Redis集群没有使用一致性<span class=\"built_in\">hash</span>,而是引入了哈希槽的概念.</span><br><span class=\"line\">Redis集群有 16384 个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽.</span><br><span class=\"line\">集群的每个节点负责一部分<span class=\"built_in\">hash</span>槽。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Redis集群的主从复制模型？\"><a href=\"#Redis集群的主从复制模型？\" class=\"headerlink\" title=\"Redis集群的主从复制模型？\"></a>Redis集群的主从复制模型？</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，</span><br><span class=\"line\">所以集群使用了主从复制模型,每个节点都会有N-1个复制品.</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Redis事务相关的命令有哪几个？\"><a href=\"#Redis事务相关的命令有哪几个？\" class=\"headerlink\" title=\"Redis事务相关的命令有哪几个？\"></a>Redis事务相关的命令有哪几个？</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">discard命令-取消事务,发起执行事务块里的所有命令.</span><br><span class=\"line\"><span class=\"built_in\">exec</span>命令-执行所有事务块内的命令.</span><br><span class=\"line\">multi命令-标记一个事务块的开始.</span><br><span class=\"line\">watch命令-监视一个（或多个）key，如果在执行事务之前这些key被其他命令所改动，事务将被打断.</span><br><span class=\"line\">unwatch命令-取消watch命令对所有key的监视.</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"redis的过期策略\"><a href=\"#redis的过期策略\" class=\"headerlink\" title=\"redis的过期策略\"></a>redis的过期策略</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis采用的是定期删除+惰性删除策略。</span><br><span class=\"line\"></span><br><span class=\"line\">定期删除：redis默认每个100ms检查，是否有过期的key（随机抽取key进行检查）,有过期key则删除。</span><br><span class=\"line\">因此，如果只采用定期删除策略，会导致很多key到时间没有删除。</span><br><span class=\"line\"></span><br><span class=\"line\">惰性删除：在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"为什么不用定时删除策略\"><a href=\"#为什么不用定时删除策略\" class=\"headerlink\" title=\"为什么不用定时删除策略?\"></a>为什么不用定时删除策略?</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定时删除,用一个定时器来负责监视key,过期则自动删除。</span><br><span class=\"line\">虽然内存及时释放，但是十分消耗CPU资源。</span><br><span class=\"line\">在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.</span><br></pre></td></tr></table></figure>\n\n"},{"title":"《MyBatis技术内幕》学习笔记-MyBatis整体架构","date":"2019-11-15T08:51:04.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"# 整体架构\nMyBatis 整体架构分为3层，分别是 基础支持层、核心处理层、接口层。\n![mysql体系结构图](../_posts/MyBatis-01/1.png)\n\n## 基础支持层\n1. 反射模块:\n    * 对JAVA原生反射进行了良好的封装。\n2. 类型转换模块：\n    * 为了简化配置文件，提供了别名机制。\n3. 日志模块：\n    * 能够集成多种日志框架。\n4. 资源加载模块\n    * 对类加载器进行封装，确定类加载器的使用顺序，并可加载类文件及其他资源文件。\n5. 解析器模块\n    * 对XPath进行封装，用于解析mybatis-config.xml以及映射配置文件。\n    * 为处理动态SQL语句中的占位符提供支持。\n6. 数据源模块\n    * 自身提供了数据源实现，也支持第三方数据源集成接口。\n7. 事务管理模块\n    * 对数据库事物进行了抽象，并提供了相应的事务接口及简单实现。\n8. 缓存模块\n    * 提供了一级缓存和二级缓存\n9. Binding模块\n    * 讲用户自定义的Mapper接口与映射配置文件关联。\n","source":"_drafts/MyBatis-01.md","raw":"---\ntitle: 《MyBatis技术内幕》学习笔记-MyBatis整体架构\ndate: 2019-11-15 16:51:04\ntags:\n    - MyBatis\n    - 框架\n    - 学习笔记\ncategories: MyBatis\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n# 整体架构\nMyBatis 整体架构分为3层，分别是 基础支持层、核心处理层、接口层。\n![mysql体系结构图](../_posts/MyBatis-01/1.png)\n\n## 基础支持层\n1. 反射模块:\n    * 对JAVA原生反射进行了良好的封装。\n2. 类型转换模块：\n    * 为了简化配置文件，提供了别名机制。\n3. 日志模块：\n    * 能够集成多种日志框架。\n4. 资源加载模块\n    * 对类加载器进行封装，确定类加载器的使用顺序，并可加载类文件及其他资源文件。\n5. 解析器模块\n    * 对XPath进行封装，用于解析mybatis-config.xml以及映射配置文件。\n    * 为处理动态SQL语句中的占位符提供支持。\n6. 数据源模块\n    * 自身提供了数据源实现，也支持第三方数据源集成接口。\n7. 事务管理模块\n    * 对数据库事物进行了抽象，并提供了相应的事务接口及简单实现。\n8. 缓存模块\n    * 提供了一级缓存和二级缓存\n9. Binding模块\n    * 讲用户自定义的Mapper接口与映射配置文件关联。\n","slug":"MyBatis-01","published":0,"updated":"2020-01-22T09:31:30.355Z","layout":"post","photos":[],"link":"","_id":"ck8fb4a8b0006k2o53jxnri0h","content":"<h1 id=\"整体架构\"><a href=\"#整体架构\" class=\"headerlink\" title=\"整体架构\"></a>整体架构</h1><p>MyBatis 整体架构分为3层，分别是 基础支持层、核心处理层、接口层。<br><img src=\"/MyBatis/MyBatis-01/../_posts/MyBatis-01/1.png\" alt=\"mysql体系结构图\"></p>\n<h2 id=\"基础支持层\"><a href=\"#基础支持层\" class=\"headerlink\" title=\"基础支持层\"></a>基础支持层</h2><ol>\n<li>反射模块:<ul>\n<li>对JAVA原生反射进行了良好的封装。</li>\n</ul>\n</li>\n<li>类型转换模块：<ul>\n<li>为了简化配置文件，提供了别名机制。</li>\n</ul>\n</li>\n<li>日志模块：<ul>\n<li>能够集成多种日志框架。</li>\n</ul>\n</li>\n<li>资源加载模块<ul>\n<li>对类加载器进行封装，确定类加载器的使用顺序，并可加载类文件及其他资源文件。</li>\n</ul>\n</li>\n<li>解析器模块<ul>\n<li>对XPath进行封装，用于解析mybatis-config.xml以及映射配置文件。</li>\n<li>为处理动态SQL语句中的占位符提供支持。</li>\n</ul>\n</li>\n<li>数据源模块<ul>\n<li>自身提供了数据源实现，也支持第三方数据源集成接口。</li>\n</ul>\n</li>\n<li>事务管理模块<ul>\n<li>对数据库事物进行了抽象，并提供了相应的事务接口及简单实现。</li>\n</ul>\n</li>\n<li>缓存模块<ul>\n<li>提供了一级缓存和二级缓存</li>\n</ul>\n</li>\n<li>Binding模块<ul>\n<li>讲用户自定义的Mapper接口与映射配置文件关联。</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"整体架构\"><a href=\"#整体架构\" class=\"headerlink\" title=\"整体架构\"></a>整体架构</h1><p>MyBatis 整体架构分为3层，分别是 基础支持层、核心处理层、接口层。<br><img src=\"/MyBatis/MyBatis-01/../_posts/MyBatis-01/1.png\" alt=\"mysql体系结构图\"></p>\n<h2 id=\"基础支持层\"><a href=\"#基础支持层\" class=\"headerlink\" title=\"基础支持层\"></a>基础支持层</h2><ol>\n<li>反射模块:<ul>\n<li>对JAVA原生反射进行了良好的封装。</li>\n</ul>\n</li>\n<li>类型转换模块：<ul>\n<li>为了简化配置文件，提供了别名机制。</li>\n</ul>\n</li>\n<li>日志模块：<ul>\n<li>能够集成多种日志框架。</li>\n</ul>\n</li>\n<li>资源加载模块<ul>\n<li>对类加载器进行封装，确定类加载器的使用顺序，并可加载类文件及其他资源文件。</li>\n</ul>\n</li>\n<li>解析器模块<ul>\n<li>对XPath进行封装，用于解析mybatis-config.xml以及映射配置文件。</li>\n<li>为处理动态SQL语句中的占位符提供支持。</li>\n</ul>\n</li>\n<li>数据源模块<ul>\n<li>自身提供了数据源实现，也支持第三方数据源集成接口。</li>\n</ul>\n</li>\n<li>事务管理模块<ul>\n<li>对数据库事物进行了抽象，并提供了相应的事务接口及简单实现。</li>\n</ul>\n</li>\n<li>缓存模块<ul>\n<li>提供了一级缓存和二级缓存</li>\n</ul>\n</li>\n<li>Binding模块<ul>\n<li>讲用户自定义的Mapper接口与映射配置文件关联。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"C++强制类型转换","date":"2019-07-09T12:17:00.000Z","author":"zyh","copyright":true,"comments":1,"_content":"## C语言类型转换\nc语言类型转换有如下两种(旧式转型)\n```C++\n(T)expression  //将 expression 转型为T\nT(expression)  //将 expression 转型为T\n```\n## C++新式类型转换\nC++类型转换有如下四种\n```C++\nconst_cast<T>(expression)\ndynamic_cast<T>(expression)\nreinterpret_cast<T>(expression)\nstatic_cast<T>(expression)\n```\n<!-- more -->\n### const_cast\n一般用于移除对象的const与volatile。如下图所示，b可以修改a的值。但是注意，编译器会进行优化，将数字常量1替代a常量。所以`cout << a << endl;`输出为1。\n```C++\n#include <iostream>\nusing namespace std;\nint main(int argc, char *argv[]) {\n\tconst int a = 1;\n\tint* b = const_cast<int*> (&a);\n\t*b = 2;\n\tcout << a << \" \" << *(&a) << \" \" << *b << endl;\n}\n// 输出：1 2 2\n```\n### dynamic_cast\ndynamic_cast 主要作用是将指向**派生类对象**的**基类指针或引用**，安全的转换为指向**派生类对象**的**派生类指针或引用**，并使用转换后的指针调用派生类独有的函数(非虚函数)。如果转换指针转换失败，则将返回空指针；如果转换引用失败，则将会抛出一个名为std::bad_cast的异常。\n在如下3种情况中转换可以成功\n- expression的类型与待转换类型相同。则转换必定成功。\n- expression的类型为待转换类型的公有派生类。(指针向上转换)\n- expression的类型为待转换类型的公有基类时，必须满足以下两个要求，才会转换成功，否则转换失败。(指针向下转换)\n   - 当expression为指向派生类的指针或引用派生类对象的基类引用。\n   - 基类中必须包含虚函数，也就是必须具备多态性。\n\n假设有如下两个类\n```C++\n#include <string>\n#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n\tBase() {}\n\tBase(string s) : str(s) {}\n\tvirtual void Print() {cout << str << endl;}\nprivate:\n\tstring str;\n};\n\nclass Derived : public Base {\npublic:\n\tDerived() {}\n\tDerived(string s, int i) : Base(s), ival(i) {}\n\tvoid Print() {\n\t\tBase::Print();\n\t\tcout << ival << endl;\n\t}\n\tvoid PrintIval() {\n\t\tcout << ival << endl;\n\t}\nprivate:\n\tint ival;\n};\n```\nexample:\n```C++\nint main(int argc, char *argv[])\n{\n\t//基类指针指向派生类对象，基类中包含虚函数，符合向下转换规则。\n\tBase* b = new Derived(\"test\", 1);\n\t//使用基类指针无法调用派生类独有的函数，编译无法通过\n\tb->PrintIval();\n\t//类型转换至派生类指针就可以调用到派生类独有的函数\n\tDerived* d = dynamic_cast<Derived*> (b);\n\td->PrintIval();\n\treturn 0;\n}\n```\n### reinterpret_cast\nreinterpret_cast 主要的作用为允许任意**长度相同**的对象之间进行转换，而转换的安全性，则全部由程序员所保证，它只关注对象之间长度是否相同，长度不相同则无法通过编译。注意，**reinterpret_cast无法去掉源对象的const、volatile属性**。\n```C++\nint main(int argc, char *argv[])\n{\n\tchar a = 1;\n\t//将a的指针转化为长整型数\n\tlong b = reinterpret_cast<long>(&a);\n\t//将空指针转化为长整型数\n\tlong d = reinterpret_cast<long>(NULL);\n\t//编译报错 int 4字节，而指针8字节\n\tint e = reinterpret_cast<int>(&a);\n\treturn 0;\n}\n```\n需注意在32位机器上，指针为4字节，而在64位机器上，指针为8字节。\n\n### static_cast\nstatic_cast 类似C语言强制类型转换，它可以完成如下一些转换\n- 编译器隐式执行的类型转换，如int与float、double与char、enum与int之间的转换等。(精度大->精度小使用位截断处理)\n- 将任意类型表达式转换为void类型，或从void*指针中找回其中的值。\n- 基类与派生类指针或引用类型之间的转换，注意，由派生类转换至基类时(向上转换)是安全的，由基类至派生类转换时(向下转换)是非安全的。\nexample(使用上述代码定义的类):\n```C++\nint main(int argc, char *argv[])\n{\n\tchar a = 'a';\n\t//将 char -> int\n\tint i = static_cast<int>(a);\n\t\n\tBase* b = new Base(\"123\");\n\t//将 Base 转换为 void*\n\tvoid* v = static_cast<void*>(b);\n\t//将 *void 转换为 Base\n\tb = static_cast<Base*>(v);\n\t\n\tDerived* d = new Derived(\"123\", 123);\n\t//向上转换 将Derived* 转换为 Base*\n\tBase* bb = static_cast<Base*>(d);\n\t//向下转换 将Base* 转换为 Derived*\n\tDerived* dd = static_cast<Derived*>(b);\n\t//未定义的行为!非常危险!父类对象并不包含该函数，编译不会报错!\n\tdd->PrintIval();\n}\n```\n一下内容取自effective C++\n>如果可以，尽量避免转型，特别是在注重效率的代码中避免 dynamic_cast。如果有个设计需要转型的动作，试着发展无需转型的替代设计。\n>如果转型是必要的，试着将它隐藏至某个函数背后，客户随后可以调用该函数，而不需将转型放进他们的代码内。\n>宁可使用C++-style(新式转型)，不要使用旧式转型。前者很容易辨识出来，而且有其不同的职责。","source":"_posts/C++-01.md","raw":"---\ntitle: C++强制类型转换\ndate: 2019-07-09 20:17:00\ntags:\n    - C++\ncategories: C++\nauthor: zyh\ncopyright: true\ncomments: true\n---\n## C语言类型转换\nc语言类型转换有如下两种(旧式转型)\n```C++\n(T)expression  //将 expression 转型为T\nT(expression)  //将 expression 转型为T\n```\n## C++新式类型转换\nC++类型转换有如下四种\n```C++\nconst_cast<T>(expression)\ndynamic_cast<T>(expression)\nreinterpret_cast<T>(expression)\nstatic_cast<T>(expression)\n```\n<!-- more -->\n### const_cast\n一般用于移除对象的const与volatile。如下图所示，b可以修改a的值。但是注意，编译器会进行优化，将数字常量1替代a常量。所以`cout << a << endl;`输出为1。\n```C++\n#include <iostream>\nusing namespace std;\nint main(int argc, char *argv[]) {\n\tconst int a = 1;\n\tint* b = const_cast<int*> (&a);\n\t*b = 2;\n\tcout << a << \" \" << *(&a) << \" \" << *b << endl;\n}\n// 输出：1 2 2\n```\n### dynamic_cast\ndynamic_cast 主要作用是将指向**派生类对象**的**基类指针或引用**，安全的转换为指向**派生类对象**的**派生类指针或引用**，并使用转换后的指针调用派生类独有的函数(非虚函数)。如果转换指针转换失败，则将返回空指针；如果转换引用失败，则将会抛出一个名为std::bad_cast的异常。\n在如下3种情况中转换可以成功\n- expression的类型与待转换类型相同。则转换必定成功。\n- expression的类型为待转换类型的公有派生类。(指针向上转换)\n- expression的类型为待转换类型的公有基类时，必须满足以下两个要求，才会转换成功，否则转换失败。(指针向下转换)\n   - 当expression为指向派生类的指针或引用派生类对象的基类引用。\n   - 基类中必须包含虚函数，也就是必须具备多态性。\n\n假设有如下两个类\n```C++\n#include <string>\n#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n\tBase() {}\n\tBase(string s) : str(s) {}\n\tvirtual void Print() {cout << str << endl;}\nprivate:\n\tstring str;\n};\n\nclass Derived : public Base {\npublic:\n\tDerived() {}\n\tDerived(string s, int i) : Base(s), ival(i) {}\n\tvoid Print() {\n\t\tBase::Print();\n\t\tcout << ival << endl;\n\t}\n\tvoid PrintIval() {\n\t\tcout << ival << endl;\n\t}\nprivate:\n\tint ival;\n};\n```\nexample:\n```C++\nint main(int argc, char *argv[])\n{\n\t//基类指针指向派生类对象，基类中包含虚函数，符合向下转换规则。\n\tBase* b = new Derived(\"test\", 1);\n\t//使用基类指针无法调用派生类独有的函数，编译无法通过\n\tb->PrintIval();\n\t//类型转换至派生类指针就可以调用到派生类独有的函数\n\tDerived* d = dynamic_cast<Derived*> (b);\n\td->PrintIval();\n\treturn 0;\n}\n```\n### reinterpret_cast\nreinterpret_cast 主要的作用为允许任意**长度相同**的对象之间进行转换，而转换的安全性，则全部由程序员所保证，它只关注对象之间长度是否相同，长度不相同则无法通过编译。注意，**reinterpret_cast无法去掉源对象的const、volatile属性**。\n```C++\nint main(int argc, char *argv[])\n{\n\tchar a = 1;\n\t//将a的指针转化为长整型数\n\tlong b = reinterpret_cast<long>(&a);\n\t//将空指针转化为长整型数\n\tlong d = reinterpret_cast<long>(NULL);\n\t//编译报错 int 4字节，而指针8字节\n\tint e = reinterpret_cast<int>(&a);\n\treturn 0;\n}\n```\n需注意在32位机器上，指针为4字节，而在64位机器上，指针为8字节。\n\n### static_cast\nstatic_cast 类似C语言强制类型转换，它可以完成如下一些转换\n- 编译器隐式执行的类型转换，如int与float、double与char、enum与int之间的转换等。(精度大->精度小使用位截断处理)\n- 将任意类型表达式转换为void类型，或从void*指针中找回其中的值。\n- 基类与派生类指针或引用类型之间的转换，注意，由派生类转换至基类时(向上转换)是安全的，由基类至派生类转换时(向下转换)是非安全的。\nexample(使用上述代码定义的类):\n```C++\nint main(int argc, char *argv[])\n{\n\tchar a = 'a';\n\t//将 char -> int\n\tint i = static_cast<int>(a);\n\t\n\tBase* b = new Base(\"123\");\n\t//将 Base 转换为 void*\n\tvoid* v = static_cast<void*>(b);\n\t//将 *void 转换为 Base\n\tb = static_cast<Base*>(v);\n\t\n\tDerived* d = new Derived(\"123\", 123);\n\t//向上转换 将Derived* 转换为 Base*\n\tBase* bb = static_cast<Base*>(d);\n\t//向下转换 将Base* 转换为 Derived*\n\tDerived* dd = static_cast<Derived*>(b);\n\t//未定义的行为!非常危险!父类对象并不包含该函数，编译不会报错!\n\tdd->PrintIval();\n}\n```\n一下内容取自effective C++\n>如果可以，尽量避免转型，特别是在注重效率的代码中避免 dynamic_cast。如果有个设计需要转型的动作，试着发展无需转型的替代设计。\n>如果转型是必要的，试着将它隐藏至某个函数背后，客户随后可以调用该函数，而不需将转型放进他们的代码内。\n>宁可使用C++-style(新式转型)，不要使用旧式转型。前者很容易辨识出来，而且有其不同的职责。","slug":"C++-01","published":1,"updated":"2019-07-31T13:41:40.987Z","layout":"post","photos":[],"link":"","_id":"ck8fb4a8f0008k2o5tk37pyei","content":"<h2 id=\"C语言类型转换\"><a href=\"#C语言类型转换\" class=\"headerlink\" title=\"C语言类型转换\"></a>C语言类型转换</h2><p>c语言类型转换有如下两种(旧式转型)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(T)expression  <span class=\"comment\">//将 expression 转型为T</span></span><br><span class=\"line\">T(expression)  <span class=\"comment\">//将 expression 转型为T</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-新式类型转换\"><a href=\"#C-新式类型转换\" class=\"headerlink\" title=\"C++新式类型转换\"></a>C++新式类型转换</h2><p>C++类型转换有如下四种</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const_cast</span>&lt;T&gt;(expression)</span><br><span class=\"line\"><span class=\"keyword\">dynamic_cast</span>&lt;T&gt;(expression)</span><br><span class=\"line\"><span class=\"keyword\">reinterpret_cast</span>&lt;T&gt;(expression)</span><br><span class=\"line\"><span class=\"keyword\">static_cast</span>&lt;T&gt;(expression)</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n<h3 id=\"const-cast\"><a href=\"#const-cast\" class=\"headerlink\" title=\"const_cast\"></a>const_cast</h3><p>一般用于移除对象的const与volatile。如下图所示，b可以修改a的值。但是注意，编译器会进行优化，将数字常量1替代a常量。所以<code>cout &lt;&lt; a &lt;&lt; endl;</code>输出为1。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>* b = <span class=\"keyword\">const_cast</span>&lt;<span class=\"keyword\">int</span>*&gt; (&amp;a);</span><br><span class=\"line\">\t*b = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; *(&amp;a) &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; *b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出：1 2 2</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"dynamic-cast\"><a href=\"#dynamic-cast\" class=\"headerlink\" title=\"dynamic_cast\"></a>dynamic_cast</h3><p>dynamic_cast 主要作用是将指向<strong>派生类对象</strong>的<strong>基类指针或引用</strong>，安全的转换为指向<strong>派生类对象</strong>的<strong>派生类指针或引用</strong>，并使用转换后的指针调用派生类独有的函数(非虚函数)。如果转换指针转换失败，则将返回空指针；如果转换引用失败，则将会抛出一个名为std::bad_cast的异常。<br>在如下3种情况中转换可以成功</p>\n<ul>\n<li>expression的类型与待转换类型相同。则转换必定成功。</li>\n<li>expression的类型为待转换类型的公有派生类。(指针向上转换)</li>\n<li>expression的类型为待转换类型的公有基类时，必须满足以下两个要求，才会转换成功，否则转换失败。(指针向下转换)<ul>\n<li>当expression为指向派生类的指针或引用派生类对象的基类引用。</li>\n<li>基类中必须包含虚函数，也就是必须具备多态性。</li>\n</ul>\n</li>\n</ul>\n<p>假设有如下两个类</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tBase() &#123;&#125;</span><br><span class=\"line\">\tBase(<span class=\"built_in\">string</span> s) : str(s) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Print</span><span class=\"params\">()</span> </span>&#123;<span class=\"built_in\">cout</span> &lt;&lt; str &lt;&lt; <span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">string</span> str;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span> :</span> <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tDerived() &#123;&#125;</span><br><span class=\"line\">\tDerived(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> i) : Base(s), ival(i) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tBase::Print();</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; ival &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintIval</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; ival &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ival;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>example:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//基类指针指向派生类对象，基类中包含虚函数，符合向下转换规则。</span></span><br><span class=\"line\">\tBase* b = <span class=\"keyword\">new</span> Derived(<span class=\"string\">\"test\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//使用基类指针无法调用派生类独有的函数，编译无法通过</span></span><br><span class=\"line\">\tb-&gt;PrintIval();</span><br><span class=\"line\">\t<span class=\"comment\">//类型转换至派生类指针就可以调用到派生类独有的函数</span></span><br><span class=\"line\">\tDerived* d = <span class=\"keyword\">dynamic_cast</span>&lt;Derived*&gt; (b);</span><br><span class=\"line\">\td-&gt;PrintIval();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"reinterpret-cast\"><a href=\"#reinterpret-cast\" class=\"headerlink\" title=\"reinterpret_cast\"></a>reinterpret_cast</h3><p>reinterpret_cast 主要的作用为允许任意<strong>长度相同</strong>的对象之间进行转换，而转换的安全性，则全部由程序员所保证，它只关注对象之间长度是否相同，长度不相同则无法通过编译。注意，<strong>reinterpret_cast无法去掉源对象的const、volatile属性</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//将a的指针转化为长整型数</span></span><br><span class=\"line\">\t<span class=\"keyword\">long</span> b = <span class=\"keyword\">reinterpret_cast</span>&lt;<span class=\"keyword\">long</span>&gt;(&amp;a);</span><br><span class=\"line\">\t<span class=\"comment\">//将空指针转化为长整型数</span></span><br><span class=\"line\">\t<span class=\"keyword\">long</span> d = <span class=\"keyword\">reinterpret_cast</span>&lt;<span class=\"keyword\">long</span>&gt;(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//编译报错 int 4字节，而指针8字节</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> e = <span class=\"keyword\">reinterpret_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(&amp;a);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需注意在32位机器上，指针为4字节，而在64位机器上，指针为8字节。</p>\n<h3 id=\"static-cast\"><a href=\"#static-cast\" class=\"headerlink\" title=\"static_cast\"></a>static_cast</h3><p>static_cast 类似C语言强制类型转换，它可以完成如下一些转换</p>\n<ul>\n<li>编译器隐式执行的类型转换，如int与float、double与char、enum与int之间的转换等。(精度大-&gt;精度小使用位截断处理)</li>\n<li>将任意类型表达式转换为void类型，或从void*指针中找回其中的值。</li>\n<li>基类与派生类指针或引用类型之间的转换，注意，由派生类转换至基类时(向上转换)是安全的，由基类至派生类转换时(向下转换)是非安全的。<br>example(使用上述代码定义的类):<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> a = <span class=\"string\">'a'</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//将 char -&gt; int</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(a);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tBase* b = <span class=\"keyword\">new</span> Base(<span class=\"string\">\"123\"</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//将 Base 转换为 void*</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* v = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">void</span>*&gt;(b);</span><br><span class=\"line\">\t<span class=\"comment\">//将 *void 转换为 Base</span></span><br><span class=\"line\">\tb = <span class=\"keyword\">static_cast</span>&lt;Base*&gt;(v);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tDerived* d = <span class=\"keyword\">new</span> Derived(<span class=\"string\">\"123\"</span>, <span class=\"number\">123</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//向上转换 将Derived* 转换为 Base*</span></span><br><span class=\"line\">\tBase* bb = <span class=\"keyword\">static_cast</span>&lt;Base*&gt;(d);</span><br><span class=\"line\">\t<span class=\"comment\">//向下转换 将Base* 转换为 Derived*</span></span><br><span class=\"line\">\tDerived* dd = <span class=\"keyword\">static_cast</span>&lt;Derived*&gt;(b);</span><br><span class=\"line\">\t<span class=\"comment\">//未定义的行为!非常危险!父类对象并不包含该函数，编译不会报错!</span></span><br><span class=\"line\">\tdd-&gt;PrintIval();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>一下内容取自effective C++</p>\n<blockquote>\n<p>如果可以，尽量避免转型，特别是在注重效率的代码中避免 dynamic_cast。如果有个设计需要转型的动作，试着发展无需转型的替代设计。<br>如果转型是必要的，试着将它隐藏至某个函数背后，客户随后可以调用该函数，而不需将转型放进他们的代码内。<br>宁可使用C++-style(新式转型)，不要使用旧式转型。前者很容易辨识出来，而且有其不同的职责。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"C语言类型转换\"><a href=\"#C语言类型转换\" class=\"headerlink\" title=\"C语言类型转换\"></a>C语言类型转换</h2><p>c语言类型转换有如下两种(旧式转型)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(T)expression  <span class=\"comment\">//将 expression 转型为T</span></span><br><span class=\"line\">T(expression)  <span class=\"comment\">//将 expression 转型为T</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-新式类型转换\"><a href=\"#C-新式类型转换\" class=\"headerlink\" title=\"C++新式类型转换\"></a>C++新式类型转换</h2><p>C++类型转换有如下四种</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const_cast</span>&lt;T&gt;(expression)</span><br><span class=\"line\"><span class=\"keyword\">dynamic_cast</span>&lt;T&gt;(expression)</span><br><span class=\"line\"><span class=\"keyword\">reinterpret_cast</span>&lt;T&gt;(expression)</span><br><span class=\"line\"><span class=\"keyword\">static_cast</span>&lt;T&gt;(expression)</span><br></pre></td></tr></table></figure>","more":"<h3 id=\"const-cast\"><a href=\"#const-cast\" class=\"headerlink\" title=\"const_cast\"></a>const_cast</h3><p>一般用于移除对象的const与volatile。如下图所示，b可以修改a的值。但是注意，编译器会进行优化，将数字常量1替代a常量。所以<code>cout &lt;&lt; a &lt;&lt; endl;</code>输出为1。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>* b = <span class=\"keyword\">const_cast</span>&lt;<span class=\"keyword\">int</span>*&gt; (&amp;a);</span><br><span class=\"line\">\t*b = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; a &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; *(&amp;a) &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; *b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出：1 2 2</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"dynamic-cast\"><a href=\"#dynamic-cast\" class=\"headerlink\" title=\"dynamic_cast\"></a>dynamic_cast</h3><p>dynamic_cast 主要作用是将指向<strong>派生类对象</strong>的<strong>基类指针或引用</strong>，安全的转换为指向<strong>派生类对象</strong>的<strong>派生类指针或引用</strong>，并使用转换后的指针调用派生类独有的函数(非虚函数)。如果转换指针转换失败，则将返回空指针；如果转换引用失败，则将会抛出一个名为std::bad_cast的异常。<br>在如下3种情况中转换可以成功</p>\n<ul>\n<li>expression的类型与待转换类型相同。则转换必定成功。</li>\n<li>expression的类型为待转换类型的公有派生类。(指针向上转换)</li>\n<li>expression的类型为待转换类型的公有基类时，必须满足以下两个要求，才会转换成功，否则转换失败。(指针向下转换)<ul>\n<li>当expression为指向派生类的指针或引用派生类对象的基类引用。</li>\n<li>基类中必须包含虚函数，也就是必须具备多态性。</li>\n</ul>\n</li>\n</ul>\n<p>假设有如下两个类</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tBase() &#123;&#125;</span><br><span class=\"line\">\tBase(<span class=\"built_in\">string</span> s) : str(s) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Print</span><span class=\"params\">()</span> </span>&#123;<span class=\"built_in\">cout</span> &lt;&lt; str &lt;&lt; <span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">string</span> str;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derived</span> :</span> <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tDerived() &#123;&#125;</span><br><span class=\"line\">\tDerived(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> i) : Base(s), ival(i) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tBase::Print();</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; ival &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintIval</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; ival &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ival;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>example:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//基类指针指向派生类对象，基类中包含虚函数，符合向下转换规则。</span></span><br><span class=\"line\">\tBase* b = <span class=\"keyword\">new</span> Derived(<span class=\"string\">\"test\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//使用基类指针无法调用派生类独有的函数，编译无法通过</span></span><br><span class=\"line\">\tb-&gt;PrintIval();</span><br><span class=\"line\">\t<span class=\"comment\">//类型转换至派生类指针就可以调用到派生类独有的函数</span></span><br><span class=\"line\">\tDerived* d = <span class=\"keyword\">dynamic_cast</span>&lt;Derived*&gt; (b);</span><br><span class=\"line\">\td-&gt;PrintIval();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"reinterpret-cast\"><a href=\"#reinterpret-cast\" class=\"headerlink\" title=\"reinterpret_cast\"></a>reinterpret_cast</h3><p>reinterpret_cast 主要的作用为允许任意<strong>长度相同</strong>的对象之间进行转换，而转换的安全性，则全部由程序员所保证，它只关注对象之间长度是否相同，长度不相同则无法通过编译。注意，<strong>reinterpret_cast无法去掉源对象的const、volatile属性</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//将a的指针转化为长整型数</span></span><br><span class=\"line\">\t<span class=\"keyword\">long</span> b = <span class=\"keyword\">reinterpret_cast</span>&lt;<span class=\"keyword\">long</span>&gt;(&amp;a);</span><br><span class=\"line\">\t<span class=\"comment\">//将空指针转化为长整型数</span></span><br><span class=\"line\">\t<span class=\"keyword\">long</span> d = <span class=\"keyword\">reinterpret_cast</span>&lt;<span class=\"keyword\">long</span>&gt;(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//编译报错 int 4字节，而指针8字节</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> e = <span class=\"keyword\">reinterpret_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(&amp;a);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需注意在32位机器上，指针为4字节，而在64位机器上，指针为8字节。</p>\n<h3 id=\"static-cast\"><a href=\"#static-cast\" class=\"headerlink\" title=\"static_cast\"></a>static_cast</h3><p>static_cast 类似C语言强制类型转换，它可以完成如下一些转换</p>\n<ul>\n<li>编译器隐式执行的类型转换，如int与float、double与char、enum与int之间的转换等。(精度大-&gt;精度小使用位截断处理)</li>\n<li>将任意类型表达式转换为void类型，或从void*指针中找回其中的值。</li>\n<li>基类与派生类指针或引用类型之间的转换，注意，由派生类转换至基类时(向上转换)是安全的，由基类至派生类转换时(向下转换)是非安全的。<br>example(使用上述代码定义的类):<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> a = <span class=\"string\">'a'</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//将 char -&gt; int</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(a);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tBase* b = <span class=\"keyword\">new</span> Base(<span class=\"string\">\"123\"</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//将 Base 转换为 void*</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* v = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">void</span>*&gt;(b);</span><br><span class=\"line\">\t<span class=\"comment\">//将 *void 转换为 Base</span></span><br><span class=\"line\">\tb = <span class=\"keyword\">static_cast</span>&lt;Base*&gt;(v);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tDerived* d = <span class=\"keyword\">new</span> Derived(<span class=\"string\">\"123\"</span>, <span class=\"number\">123</span>);</span><br><span class=\"line\">\t<span class=\"comment\">//向上转换 将Derived* 转换为 Base*</span></span><br><span class=\"line\">\tBase* bb = <span class=\"keyword\">static_cast</span>&lt;Base*&gt;(d);</span><br><span class=\"line\">\t<span class=\"comment\">//向下转换 将Base* 转换为 Derived*</span></span><br><span class=\"line\">\tDerived* dd = <span class=\"keyword\">static_cast</span>&lt;Derived*&gt;(b);</span><br><span class=\"line\">\t<span class=\"comment\">//未定义的行为!非常危险!父类对象并不包含该函数，编译不会报错!</span></span><br><span class=\"line\">\tdd-&gt;PrintIval();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>一下内容取自effective C++</p>\n<blockquote>\n<p>如果可以，尽量避免转型，特别是在注重效率的代码中避免 dynamic_cast。如果有个设计需要转型的动作，试着发展无需转型的替代设计。<br>如果转型是必要的，试着将它隐藏至某个函数背后，客户随后可以调用该函数，而不需将转型放进他们的代码内。<br>宁可使用C++-style(新式转型)，不要使用旧式转型。前者很容易辨识出来，而且有其不同的职责。</p>\n</blockquote>"},{"title":"C++右值引用","date":"2019-07-09T12:17:00.000Z","author":"zyh","copyright":true,"comments":1,"_content":"## 左值与右值的区分\n在C++中，所有的值均被分为左值与右值之一。左值是指表达式结束后依然存在的**持久化对象**，右值是指表达式结束时就不再存在的**临时对象**。所有的具名变量或者对象都是左值，而右值不具名。有一个很简单的方法区别左值与右值，**观察是否可以对表达式进行取地址，如果能，则为左值，否则为右值。**\n```C++\nint func() {return func;}\nint a = 1 + 2;\nint b = func();\nint c = a + b;\nint d = c;\n```\n<!-- more -->\n如上图所示，第2行的 a显然是左值，而(1 + 2)产生的临时变量值则为右值。同理第3行的b为左值，而func()的返回值同样是一个临时变量，为右值。第4行的c为左值，而(a+b)作为临时变量则为右值，而第5行中，d与c都为左值。套用上述的区别方法，a,b,c,d变量均可以进行取地址操作，而(1+2), func()返回值, (a+b)我们都无法取其地址。\n如书中记载，在C++11中，右值分为**纯右值**与**将亡值**。纯右值指的就是我们上述所描述的各类临时变量。而将亡值则是c++11新增的和右值引用相关的表达式，这样的表达式通常时将要移动的对象、T&&函数返回值、std::move()函数的返回值等，将亡值与纯右值均为右值，使用没有任何区别。\n## 左值引用与右值引用\n在C++11前引用已经非常常见了，就是给变量取了一个别名，如下所示。\n```C++\nint b = 1;\nint &a = b;\nint &c = 2;   //编译错误!\n```\n需注意，在定义左值引用的同时，我们不能将右值绑定至左值引用上，如上面第3行代码所示。\n而C++的右值引用同左值引用相似，则使用 && 来表示。\n```C++\nint func() {return 1;}\nint && a = 1;\nint && b = (1 + 2) * 3;\nint && c = func();\nint && d = a;    //编译错误!\n```\n同左值引用相同，在定义右值引用的同时，我们不能将左值绑定在右值引用上，如上面第5行所示。\n也就是说，右值引用只能绑定右值，左值引用只能绑定左值。\n若希望将一个左值绑定到右值引用，则可以使用**移动语义**`std::move()`将左值转换为右值，例如:\n```C++\nint a = 1;\nint &&b = std::move(a);  //编译通过\n```\n但是注意，**使用移动移动语义转移对象a后，a不可再次被使用**!\n除了普通引用，还有一类我们经常使用到的引用，**常量左值引用**。大家可以显而易见的发现，常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。但是在它的存活时期中，它只能是可读的。我们常在函数参数中使用到它，如下所示。\n```C++\nvoid func(const string &str) {\n\tcout << str << endl;\n}\n\nint main(int argc, char *argv[]) {\n\tstring s1(\"1234\");\n\tconst string s2(\"1234\");\n\tfunc(s1);                  //非常量左值\n\tfunc(s2);                  //常量左值\n\tfunc(string(\"1234\"));      //右值\n\treturn 0;\n}\n```\n在如上介绍中很容易可以得出一下结论(转载图片)：\n![表格1](C++-02/1.png)","source":"_posts/C++-02.md","raw":"---\ntitle: C++右值引用\ndate: 2019-07-09 20:17:00\ntags:\n    - C++\ncategories: C++\nauthor: zyh\ncopyright: true\ncomments: true\n---\n## 左值与右值的区分\n在C++中，所有的值均被分为左值与右值之一。左值是指表达式结束后依然存在的**持久化对象**，右值是指表达式结束时就不再存在的**临时对象**。所有的具名变量或者对象都是左值，而右值不具名。有一个很简单的方法区别左值与右值，**观察是否可以对表达式进行取地址，如果能，则为左值，否则为右值。**\n```C++\nint func() {return func;}\nint a = 1 + 2;\nint b = func();\nint c = a + b;\nint d = c;\n```\n<!-- more -->\n如上图所示，第2行的 a显然是左值，而(1 + 2)产生的临时变量值则为右值。同理第3行的b为左值，而func()的返回值同样是一个临时变量，为右值。第4行的c为左值，而(a+b)作为临时变量则为右值，而第5行中，d与c都为左值。套用上述的区别方法，a,b,c,d变量均可以进行取地址操作，而(1+2), func()返回值, (a+b)我们都无法取其地址。\n如书中记载，在C++11中，右值分为**纯右值**与**将亡值**。纯右值指的就是我们上述所描述的各类临时变量。而将亡值则是c++11新增的和右值引用相关的表达式，这样的表达式通常时将要移动的对象、T&&函数返回值、std::move()函数的返回值等，将亡值与纯右值均为右值，使用没有任何区别。\n## 左值引用与右值引用\n在C++11前引用已经非常常见了，就是给变量取了一个别名，如下所示。\n```C++\nint b = 1;\nint &a = b;\nint &c = 2;   //编译错误!\n```\n需注意，在定义左值引用的同时，我们不能将右值绑定至左值引用上，如上面第3行代码所示。\n而C++的右值引用同左值引用相似，则使用 && 来表示。\n```C++\nint func() {return 1;}\nint && a = 1;\nint && b = (1 + 2) * 3;\nint && c = func();\nint && d = a;    //编译错误!\n```\n同左值引用相同，在定义右值引用的同时，我们不能将左值绑定在右值引用上，如上面第5行所示。\n也就是说，右值引用只能绑定右值，左值引用只能绑定左值。\n若希望将一个左值绑定到右值引用，则可以使用**移动语义**`std::move()`将左值转换为右值，例如:\n```C++\nint a = 1;\nint &&b = std::move(a);  //编译通过\n```\n但是注意，**使用移动移动语义转移对象a后，a不可再次被使用**!\n除了普通引用，还有一类我们经常使用到的引用，**常量左值引用**。大家可以显而易见的发现，常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。但是在它的存活时期中，它只能是可读的。我们常在函数参数中使用到它，如下所示。\n```C++\nvoid func(const string &str) {\n\tcout << str << endl;\n}\n\nint main(int argc, char *argv[]) {\n\tstring s1(\"1234\");\n\tconst string s2(\"1234\");\n\tfunc(s1);                  //非常量左值\n\tfunc(s2);                  //常量左值\n\tfunc(string(\"1234\"));      //右值\n\treturn 0;\n}\n```\n在如上介绍中很容易可以得出一下结论(转载图片)：\n![表格1](C++-02/1.png)","slug":"C++-02","published":1,"updated":"2019-07-31T13:41:40.987Z","layout":"post","photos":[],"link":"","_id":"ck8fb4a8h0009k2o5i5mhy2f9","content":"<h2 id=\"左值与右值的区分\"><a href=\"#左值与右值的区分\" class=\"headerlink\" title=\"左值与右值的区分\"></a>左值与右值的区分</h2><p>在C++中，所有的值均被分为左值与右值之一。左值是指表达式结束后依然存在的<strong>持久化对象</strong>，右值是指表达式结束时就不再存在的<strong>临时对象</strong>。所有的具名变量或者对象都是左值，而右值不具名。有一个很简单的方法区别左值与右值，<strong>观察是否可以对表达式进行取地址，如果能，则为左值，否则为右值。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> func;&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">1</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = func();</span><br><span class=\"line\"><span class=\"keyword\">int</span> c = a + b;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d = c;</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n<p>如上图所示，第2行的 a显然是左值，而(1 + 2)产生的临时变量值则为右值。同理第3行的b为左值，而func()的返回值同样是一个临时变量，为右值。第4行的c为左值，而(a+b)作为临时变量则为右值，而第5行中，d与c都为左值。套用上述的区别方法，a,b,c,d变量均可以进行取地址操作，而(1+2), func()返回值, (a+b)我们都无法取其地址。<br>如书中记载，在C++11中，右值分为<strong>纯右值</strong>与<strong>将亡值</strong>。纯右值指的就是我们上述所描述的各类临时变量。而将亡值则是c++11新增的和右值引用相关的表达式，这样的表达式通常时将要移动的对象、T&amp;&amp;函数返回值、std::move()函数的返回值等，将亡值与纯右值均为右值，使用没有任何区别。</p>\n<h2 id=\"左值引用与右值引用\"><a href=\"#左值引用与右值引用\" class=\"headerlink\" title=\"左值引用与右值引用\"></a>左值引用与右值引用</h2><p>在C++11前引用已经非常常见了，就是给变量取了一个别名，如下所示。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;a = b;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;c = <span class=\"number\">2</span>;   <span class=\"comment\">//编译错误!</span></span><br></pre></td></tr></table></figure>\n\n<p>需注意，在定义左值引用的同时，我们不能将右值绑定至左值引用上，如上面第3行代码所示。<br>而C++的右值引用同左值引用相似，则使用 &amp;&amp; 来表示。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">1</span>;&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp; a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp; b = (<span class=\"number\">1</span> + <span class=\"number\">2</span>) * <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp; c = func();</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp; d = a;    <span class=\"comment\">//编译错误!</span></span><br></pre></td></tr></table></figure>\n\n<p>同左值引用相同，在定义右值引用的同时，我们不能将左值绑定在右值引用上，如上面第5行所示。<br>也就是说，右值引用只能绑定右值，左值引用只能绑定左值。<br>若希望将一个左值绑定到右值引用，则可以使用<strong>移动语义</strong><code>std::move()</code>将左值转换为右值，例如:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;b = <span class=\"built_in\">std</span>::move(a);  <span class=\"comment\">//编译通过</span></span><br></pre></td></tr></table></figure>\n\n<p>但是注意，<strong>使用移动移动语义转移对象a后，a不可再次被使用</strong>!<br>除了普通引用，还有一类我们经常使用到的引用，<strong>常量左值引用</strong>。大家可以显而易见的发现，常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。但是在它的存活时期中，它只能是可读的。我们常在函数参数中使用到它，如下所示。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;str)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; str &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">s1</span><span class=\"params\">(<span class=\"string\">\"1234\"</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> <span class=\"title\">s2</span><span class=\"params\">(<span class=\"string\">\"1234\"</span>)</span></span>;</span><br><span class=\"line\">\tfunc(s1);                  <span class=\"comment\">//非常量左值</span></span><br><span class=\"line\">\tfunc(s2);                  <span class=\"comment\">//常量左值</span></span><br><span class=\"line\">\tfunc(<span class=\"built_in\">string</span>(<span class=\"string\">\"1234\"</span>));      <span class=\"comment\">//右值</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在如上介绍中很容易可以得出一下结论(转载图片)：<br><img src=\"/C/C++-02/1.png\" alt=\"表格1\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"左值与右值的区分\"><a href=\"#左值与右值的区分\" class=\"headerlink\" title=\"左值与右值的区分\"></a>左值与右值的区分</h2><p>在C++中，所有的值均被分为左值与右值之一。左值是指表达式结束后依然存在的<strong>持久化对象</strong>，右值是指表达式结束时就不再存在的<strong>临时对象</strong>。所有的具名变量或者对象都是左值，而右值不具名。有一个很简单的方法区别左值与右值，<strong>观察是否可以对表达式进行取地址，如果能，则为左值，否则为右值。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> func;&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">1</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = func();</span><br><span class=\"line\"><span class=\"keyword\">int</span> c = a + b;</span><br><span class=\"line\"><span class=\"keyword\">int</span> d = c;</span><br></pre></td></tr></table></figure>","more":"<p>如上图所示，第2行的 a显然是左值，而(1 + 2)产生的临时变量值则为右值。同理第3行的b为左值，而func()的返回值同样是一个临时变量，为右值。第4行的c为左值，而(a+b)作为临时变量则为右值，而第5行中，d与c都为左值。套用上述的区别方法，a,b,c,d变量均可以进行取地址操作，而(1+2), func()返回值, (a+b)我们都无法取其地址。<br>如书中记载，在C++11中，右值分为<strong>纯右值</strong>与<strong>将亡值</strong>。纯右值指的就是我们上述所描述的各类临时变量。而将亡值则是c++11新增的和右值引用相关的表达式，这样的表达式通常时将要移动的对象、T&amp;&amp;函数返回值、std::move()函数的返回值等，将亡值与纯右值均为右值，使用没有任何区别。</p>\n<h2 id=\"左值引用与右值引用\"><a href=\"#左值引用与右值引用\" class=\"headerlink\" title=\"左值引用与右值引用\"></a>左值引用与右值引用</h2><p>在C++11前引用已经非常常见了，就是给变量取了一个别名，如下所示。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;a = b;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;c = <span class=\"number\">2</span>;   <span class=\"comment\">//编译错误!</span></span><br></pre></td></tr></table></figure>\n\n<p>需注意，在定义左值引用的同时，我们不能将右值绑定至左值引用上，如上面第3行代码所示。<br>而C++的右值引用同左值引用相似，则使用 &amp;&amp; 来表示。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">1</span>;&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp; a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp; b = (<span class=\"number\">1</span> + <span class=\"number\">2</span>) * <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp; c = func();</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp; d = a;    <span class=\"comment\">//编译错误!</span></span><br></pre></td></tr></table></figure>\n\n<p>同左值引用相同，在定义右值引用的同时，我们不能将左值绑定在右值引用上，如上面第5行所示。<br>也就是说，右值引用只能绑定右值，左值引用只能绑定左值。<br>若希望将一个左值绑定到右值引用，则可以使用<strong>移动语义</strong><code>std::move()</code>将左值转换为右值，例如:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;b = <span class=\"built_in\">std</span>::move(a);  <span class=\"comment\">//编译通过</span></span><br></pre></td></tr></table></figure>\n\n<p>但是注意，<strong>使用移动移动语义转移对象a后，a不可再次被使用</strong>!<br>除了普通引用，还有一类我们经常使用到的引用，<strong>常量左值引用</strong>。大家可以显而易见的发现，常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。但是在它的存活时期中，它只能是可读的。我们常在函数参数中使用到它，如下所示。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;str)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; str &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">s1</span><span class=\"params\">(<span class=\"string\">\"1234\"</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">string</span> <span class=\"title\">s2</span><span class=\"params\">(<span class=\"string\">\"1234\"</span>)</span></span>;</span><br><span class=\"line\">\tfunc(s1);                  <span class=\"comment\">//非常量左值</span></span><br><span class=\"line\">\tfunc(s2);                  <span class=\"comment\">//常量左值</span></span><br><span class=\"line\">\tfunc(<span class=\"built_in\">string</span>(<span class=\"string\">\"1234\"</span>));      <span class=\"comment\">//右值</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在如上介绍中很容易可以得出一下结论(转载图片)：<br><img src=\"/C/C++-02/1.png\" alt=\"表格1\"></p>"},{"title":"设计模式-装饰器模式","date":"2019-12-16T08:49:00.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"","source":"_posts/Design-Pattern-Decorator.md","raw":"---\ntitle: 设计模式-装饰器模式\ndate: 2019-12-16 16:49:00\ntags:\n    - 设计模式\ncategories: 设计模式\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n","slug":"Design-Pattern-Decorator","published":1,"updated":"2020-01-22T09:31:30.355Z","layout":"post","photos":[],"link":"","_id":"ck8fb4a8k000ck2o5l35k7e4n","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"设计模式-代理模式","date":"2020-03-10T15:15:04.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"# 什么是代理\n给某一个对象提供一个代理，并由代理对象控制对原对象的引用\n简单来说就是增强了一个对象的功能，比如：买火车票，app就是一个代理，他代理了火车站\n\n#java实现的代理的办法\n## 代理的名词\n* 代理对象：增强后的对象\n* 目标对象：被增强的对象\n\n## 静态代理\n### 继承\n代理对象继承目标对象，重写需要增强的方法\n缺点：会代理类过多，非常复杂\n\n以租房为例，我们一般用租房软件、找中介或者找房东。这里的中介就是代理者。\n```java\n// 目标对象\npublic class RentHose {\n\n\tpublic void rentHose() {\n\t\tSystem.out.println(\"租了一间房子。。。\");\n\t}\n}\n\n//代理对象\npublic class IntermediaryProxy extends RentHose{\n\t@Override\n\tpublic void rentHose() {\n\t\tSystem.out.println(\"交中介费..\");\n\t\tsuper.rentHose();\n\t\tSystem.out.println(\"中介负责维修管理..\");\n\t}\n}\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tRentHose rentHose = new IntermediaryProxy();\n\t\trentHose.rentHose();\n\t}\n}\n```\n\n### 聚合\n目标对象和代理对象实现同一个接口，代理对象当中要包含目标对象。\n缺点：也会产生类爆炸，只不过比继承少一点点\n\n```java\npublic interface IRentHose {\n\tpublic void rentHose();\n}\n\n// 目标对象\npublic class RentHose implements IRentHose{\n\n\t@Override\n\tpublic void rentHose() {\n\t\tSystem.out.println(\"租了一间房子。。。\");\n\t}\n}\n\n// 代理对象\npublic class IntermediaryProxy implements IRentHose{\n\n\tprivate IRentHose iRentHose;\n\n\tpublic IntermediaryProxy(IRentHose iRentHose) {\n\t\tthis.iRentHose = iRentHose;\n\t}\n\n\t@Override\n\tpublic void rentHose() {\n\t\tSystem.out.println(\"交中介费..\");\n\t\tiRentHose.rentHose();\n\t\tSystem.out.println(\"中介负责维修管理..\");\n\t}\n}\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tRentHose rentHose = new RentHose();\n\t\tIRentHose iRentHose = new IntermediaryProxy(rentHose);\n\t\tiRentHose.rentHose();\n\t}\n}\n```\n\n### 总结\n如果在不确定的情况下，尽量不要去使用静态代理。因为一旦你写代码，就会产生类，一旦产生类就爆炸。\n\n## 动态代理\n我们知道现在的中介不仅仅是有租房业务，同时还有卖房、家政、维修等得业务，只是我们就不能对每一个业务都增加一个代理，就要提供通用的代理方法，这就要通过动态代理来实现了。\n\n### JDK动态代理\n通过接口->反射得到字节码(.class)，然后把字节码转成Class对象（利用native方法）。\n\n```java\npublic class IntermediaryProxy implements InvocationHandler {\n\n\tprivate Object obj;\n\n\tpublic IntermediaryProxy(Object obj) {\n\t\tthis.obj = obj;\n\t}\n\n\t/**\n\t * 调用被代理的方法\n\t * @param proxy：代理对象\n\t * @param method：方法\n\t * @param args：参数\n\t * @return \n\t * @throws Throwable\n\t */\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\tSystem.out.println(\"交中介费\");\n\t\t//执行目标对象的方法\n\t\tObject result =  method.invoke(this.obj, args);\n\t\tSystem.out.println(\"中介负责维修管理\");\n\t\treturn  result;\n\t}\n}\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tRentHose rentHose = new RentHose();\n\t\t//定义一个handler\n\t\tInvocationHandler handler = new IntermediaryProxy(rentHose);\n\t\t// 获取对象的classLoader\n\t\tClassLoader classLoader = rentHose.getClass().getClassLoader();\n\t\t// JDK 动态代理产生代理类\n\t\tIRentHose proxy = (IRentHose) Proxy.newProxyInstance(classLoader,new Class[]{IRentHose.class},handler);\n\t\tproxy.rentHose();\n\t}\n}\n```\n\n### 自己模拟的动态代理\n步骤：\n    1. 通过目标对象反射和字符串拼接生成一个类文件\n    2. 然后调用第三方的编译技术,动态编译这个产生的类文件成class文件\n    3. 利用UrlclassLoader,把这个动态编译的类加载到jvm当中\n    4. 最后通过反射把这个类实例化。\n    ","source":"_posts/Design-Pattern-Proxy.md","raw":"---\ntitle: 设计模式-代理模式\ndate: 2020-03-10 23:15:04\ntags:\n    - 设计模式\ncategories: 设计模式\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n# 什么是代理\n给某一个对象提供一个代理，并由代理对象控制对原对象的引用\n简单来说就是增强了一个对象的功能，比如：买火车票，app就是一个代理，他代理了火车站\n\n#java实现的代理的办法\n## 代理的名词\n* 代理对象：增强后的对象\n* 目标对象：被增强的对象\n\n## 静态代理\n### 继承\n代理对象继承目标对象，重写需要增强的方法\n缺点：会代理类过多，非常复杂\n\n以租房为例，我们一般用租房软件、找中介或者找房东。这里的中介就是代理者。\n```java\n// 目标对象\npublic class RentHose {\n\n\tpublic void rentHose() {\n\t\tSystem.out.println(\"租了一间房子。。。\");\n\t}\n}\n\n//代理对象\npublic class IntermediaryProxy extends RentHose{\n\t@Override\n\tpublic void rentHose() {\n\t\tSystem.out.println(\"交中介费..\");\n\t\tsuper.rentHose();\n\t\tSystem.out.println(\"中介负责维修管理..\");\n\t}\n}\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tRentHose rentHose = new IntermediaryProxy();\n\t\trentHose.rentHose();\n\t}\n}\n```\n\n### 聚合\n目标对象和代理对象实现同一个接口，代理对象当中要包含目标对象。\n缺点：也会产生类爆炸，只不过比继承少一点点\n\n```java\npublic interface IRentHose {\n\tpublic void rentHose();\n}\n\n// 目标对象\npublic class RentHose implements IRentHose{\n\n\t@Override\n\tpublic void rentHose() {\n\t\tSystem.out.println(\"租了一间房子。。。\");\n\t}\n}\n\n// 代理对象\npublic class IntermediaryProxy implements IRentHose{\n\n\tprivate IRentHose iRentHose;\n\n\tpublic IntermediaryProxy(IRentHose iRentHose) {\n\t\tthis.iRentHose = iRentHose;\n\t}\n\n\t@Override\n\tpublic void rentHose() {\n\t\tSystem.out.println(\"交中介费..\");\n\t\tiRentHose.rentHose();\n\t\tSystem.out.println(\"中介负责维修管理..\");\n\t}\n}\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tRentHose rentHose = new RentHose();\n\t\tIRentHose iRentHose = new IntermediaryProxy(rentHose);\n\t\tiRentHose.rentHose();\n\t}\n}\n```\n\n### 总结\n如果在不确定的情况下，尽量不要去使用静态代理。因为一旦你写代码，就会产生类，一旦产生类就爆炸。\n\n## 动态代理\n我们知道现在的中介不仅仅是有租房业务，同时还有卖房、家政、维修等得业务，只是我们就不能对每一个业务都增加一个代理，就要提供通用的代理方法，这就要通过动态代理来实现了。\n\n### JDK动态代理\n通过接口->反射得到字节码(.class)，然后把字节码转成Class对象（利用native方法）。\n\n```java\npublic class IntermediaryProxy implements InvocationHandler {\n\n\tprivate Object obj;\n\n\tpublic IntermediaryProxy(Object obj) {\n\t\tthis.obj = obj;\n\t}\n\n\t/**\n\t * 调用被代理的方法\n\t * @param proxy：代理对象\n\t * @param method：方法\n\t * @param args：参数\n\t * @return \n\t * @throws Throwable\n\t */\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\tSystem.out.println(\"交中介费\");\n\t\t//执行目标对象的方法\n\t\tObject result =  method.invoke(this.obj, args);\n\t\tSystem.out.println(\"中介负责维修管理\");\n\t\treturn  result;\n\t}\n}\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tRentHose rentHose = new RentHose();\n\t\t//定义一个handler\n\t\tInvocationHandler handler = new IntermediaryProxy(rentHose);\n\t\t// 获取对象的classLoader\n\t\tClassLoader classLoader = rentHose.getClass().getClassLoader();\n\t\t// JDK 动态代理产生代理类\n\t\tIRentHose proxy = (IRentHose) Proxy.newProxyInstance(classLoader,new Class[]{IRentHose.class},handler);\n\t\tproxy.rentHose();\n\t}\n}\n```\n\n### 自己模拟的动态代理\n步骤：\n    1. 通过目标对象反射和字符串拼接生成一个类文件\n    2. 然后调用第三方的编译技术,动态编译这个产生的类文件成class文件\n    3. 利用UrlclassLoader,把这个动态编译的类加载到jvm当中\n    4. 最后通过反射把这个类实例化。\n    ","slug":"Design-Pattern-Proxy","published":1,"updated":"2020-03-13T08:17:01.523Z","layout":"post","photos":[],"link":"","_id":"ck8fb4a8m000dk2o5i6lsj1vz","content":"<h1 id=\"什么是代理\"><a href=\"#什么是代理\" class=\"headerlink\" title=\"什么是代理\"></a>什么是代理</h1><p>给某一个对象提供一个代理，并由代理对象控制对原对象的引用<br>简单来说就是增强了一个对象的功能，比如：买火车票，app就是一个代理，他代理了火车站</p>\n<p>#java实现的代理的办法</p>\n<h2 id=\"代理的名词\"><a href=\"#代理的名词\" class=\"headerlink\" title=\"代理的名词\"></a>代理的名词</h2><ul>\n<li>代理对象：增强后的对象</li>\n<li>目标对象：被增强的对象</li>\n</ul>\n<h2 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h2><h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>代理对象继承目标对象，重写需要增强的方法<br>缺点：会代理类过多，非常复杂</p>\n<p>以租房为例，我们一般用租房软件、找中介或者找房东。这里的中介就是代理者。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 目标对象</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RentHose</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rentHose</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"租了一间房子。。。\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//代理对象</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntermediaryProxy</span> <span class=\"keyword\">extends</span> <span class=\"title\">RentHose</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rentHose</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"交中介费..\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>.rentHose();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"中介负责维修管理..\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tRentHose rentHose = <span class=\"keyword\">new</span> IntermediaryProxy();</span><br><span class=\"line\">\t\trentHose.rentHose();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h3><p>目标对象和代理对象实现同一个接口，代理对象当中要包含目标对象。<br>缺点：也会产生类爆炸，只不过比继承少一点点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IRentHose</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rentHose</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 目标对象</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RentHose</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRentHose</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rentHose</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"租了一间房子。。。\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代理对象</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntermediaryProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRentHose</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> IRentHose iRentHose;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">IntermediaryProxy</span><span class=\"params\">(IRentHose iRentHose)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.iRentHose = iRentHose;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rentHose</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"交中介费..\"</span>);</span><br><span class=\"line\">\t\tiRentHose.rentHose();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"中介负责维修管理..\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tRentHose rentHose = <span class=\"keyword\">new</span> RentHose();</span><br><span class=\"line\">\t\tIRentHose iRentHose = <span class=\"keyword\">new</span> IntermediaryProxy(rentHose);</span><br><span class=\"line\">\t\tiRentHose.rentHose();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>如果在不确定的情况下，尽量不要去使用静态代理。因为一旦你写代码，就会产生类，一旦产生类就爆炸。</p>\n<h2 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h2><p>我们知道现在的中介不仅仅是有租房业务，同时还有卖房、家政、维修等得业务，只是我们就不能对每一个业务都增加一个代理，就要提供通用的代理方法，这就要通过动态代理来实现了。</p>\n<h3 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h3><p>通过接口-&gt;反射得到字节码(.class)，然后把字节码转成Class对象（利用native方法）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntermediaryProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Object obj;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">IntermediaryProxy</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.obj = obj;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 调用被代理的方法</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> proxy：代理对象</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> method：方法</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> args：参数</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> </span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@throws</span> Throwable</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"交中介费\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//执行目标对象的方法</span></span><br><span class=\"line\">\t\tObject result =  method.invoke(<span class=\"keyword\">this</span>.obj, args);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"中介负责维修管理\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>  result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tRentHose rentHose = <span class=\"keyword\">new</span> RentHose();</span><br><span class=\"line\">\t\t<span class=\"comment\">//定义一个handler</span></span><br><span class=\"line\">\t\tInvocationHandler handler = <span class=\"keyword\">new</span> IntermediaryProxy(rentHose);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 获取对象的classLoader</span></span><br><span class=\"line\">\t\tClassLoader classLoader = rentHose.getClass().getClassLoader();</span><br><span class=\"line\">\t\t<span class=\"comment\">// JDK 动态代理产生代理类</span></span><br><span class=\"line\">\t\tIRentHose proxy = (IRentHose) Proxy.newProxyInstance(classLoader,<span class=\"keyword\">new</span> Class[]&#123;IRentHose.class&#125;,handler);</span><br><span class=\"line\">\t\tproxy.rentHose();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自己模拟的动态代理\"><a href=\"#自己模拟的动态代理\" class=\"headerlink\" title=\"自己模拟的动态代理\"></a>自己模拟的动态代理</h3><p>步骤：<br>    1. 通过目标对象反射和字符串拼接生成一个类文件<br>    2. 然后调用第三方的编译技术,动态编译这个产生的类文件成class文件<br>    3. 利用UrlclassLoader,把这个动态编译的类加载到jvm当中<br>    4. 最后通过反射把这个类实例化。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是代理\"><a href=\"#什么是代理\" class=\"headerlink\" title=\"什么是代理\"></a>什么是代理</h1><p>给某一个对象提供一个代理，并由代理对象控制对原对象的引用<br>简单来说就是增强了一个对象的功能，比如：买火车票，app就是一个代理，他代理了火车站</p>\n<p>#java实现的代理的办法</p>\n<h2 id=\"代理的名词\"><a href=\"#代理的名词\" class=\"headerlink\" title=\"代理的名词\"></a>代理的名词</h2><ul>\n<li>代理对象：增强后的对象</li>\n<li>目标对象：被增强的对象</li>\n</ul>\n<h2 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h2><h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>代理对象继承目标对象，重写需要增强的方法<br>缺点：会代理类过多，非常复杂</p>\n<p>以租房为例，我们一般用租房软件、找中介或者找房东。这里的中介就是代理者。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 目标对象</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RentHose</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rentHose</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"租了一间房子。。。\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//代理对象</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntermediaryProxy</span> <span class=\"keyword\">extends</span> <span class=\"title\">RentHose</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rentHose</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"交中介费..\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>.rentHose();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"中介负责维修管理..\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tRentHose rentHose = <span class=\"keyword\">new</span> IntermediaryProxy();</span><br><span class=\"line\">\t\trentHose.rentHose();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h3><p>目标对象和代理对象实现同一个接口，代理对象当中要包含目标对象。<br>缺点：也会产生类爆炸，只不过比继承少一点点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IRentHose</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rentHose</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 目标对象</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RentHose</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRentHose</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rentHose</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"租了一间房子。。。\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代理对象</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntermediaryProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRentHose</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> IRentHose iRentHose;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">IntermediaryProxy</span><span class=\"params\">(IRentHose iRentHose)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.iRentHose = iRentHose;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rentHose</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"交中介费..\"</span>);</span><br><span class=\"line\">\t\tiRentHose.rentHose();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"中介负责维修管理..\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tRentHose rentHose = <span class=\"keyword\">new</span> RentHose();</span><br><span class=\"line\">\t\tIRentHose iRentHose = <span class=\"keyword\">new</span> IntermediaryProxy(rentHose);</span><br><span class=\"line\">\t\tiRentHose.rentHose();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>如果在不确定的情况下，尽量不要去使用静态代理。因为一旦你写代码，就会产生类，一旦产生类就爆炸。</p>\n<h2 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h2><p>我们知道现在的中介不仅仅是有租房业务，同时还有卖房、家政、维修等得业务，只是我们就不能对每一个业务都增加一个代理，就要提供通用的代理方法，这就要通过动态代理来实现了。</p>\n<h3 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h3><p>通过接口-&gt;反射得到字节码(.class)，然后把字节码转成Class对象（利用native方法）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntermediaryProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Object obj;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">IntermediaryProxy</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.obj = obj;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 调用被代理的方法</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> proxy：代理对象</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> method：方法</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> args：参数</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> </span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@throws</span> Throwable</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"交中介费\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//执行目标对象的方法</span></span><br><span class=\"line\">\t\tObject result =  method.invoke(<span class=\"keyword\">this</span>.obj, args);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"中介负责维修管理\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>  result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tRentHose rentHose = <span class=\"keyword\">new</span> RentHose();</span><br><span class=\"line\">\t\t<span class=\"comment\">//定义一个handler</span></span><br><span class=\"line\">\t\tInvocationHandler handler = <span class=\"keyword\">new</span> IntermediaryProxy(rentHose);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 获取对象的classLoader</span></span><br><span class=\"line\">\t\tClassLoader classLoader = rentHose.getClass().getClassLoader();</span><br><span class=\"line\">\t\t<span class=\"comment\">// JDK 动态代理产生代理类</span></span><br><span class=\"line\">\t\tIRentHose proxy = (IRentHose) Proxy.newProxyInstance(classLoader,<span class=\"keyword\">new</span> Class[]&#123;IRentHose.class&#125;,handler);</span><br><span class=\"line\">\t\tproxy.rentHose();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自己模拟的动态代理\"><a href=\"#自己模拟的动态代理\" class=\"headerlink\" title=\"自己模拟的动态代理\"></a>自己模拟的动态代理</h3><p>步骤：<br>    1. 通过目标对象反射和字符串拼接生成一个类文件<br>    2. 然后调用第三方的编译技术,动态编译这个产生的类文件成class文件<br>    3. 利用UrlclassLoader,把这个动态编译的类加载到jvm当中<br>    4. 最后通过反射把这个类实例化。</p>\n"},{"title":"设计模式-单例模式","date":"2020-02-29T09:37:00.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"## 单例模式\n多个线程操作不同实例对象。多个线程要操作同一对象，要保证对象的唯一性\n\n## 单例模式的特点\n1. 有一个实例化的过程（只有一次），产生实例化对象\n2. 提供返回实例对象的方法\n\n## 单例模式的分类\n\n### 饿汉式\n```java\npublic class HungrySingleton {\n\t//加载时就产生了实例对象\n\tprivate static HungrySingleton instance = new HungrySingleton();\n\n\tprivate HungrySingleton() {\n\t}\n\t//返回实例对象\n\tpublic static HungrySingleton getInstance() {\n\t\treturn instance;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tfor(int i = 0 ; i < 10 ; i ++){\n\t\t\tnew Thread(()->{\n\t\t\t\tHungrySingleton hungerySingleton = HungrySingleton.getInstance();\n\t\t\t\tSystem.out.println(hungerySingleton);\n\t\t\t}).start();\n\t\t}\n\t}\n}\n```\n\n* 线程安全性：在加载的时候已经被实例化，所以只有这一次，线程安全的。\n* 懒加载：没有延迟加载\n* 性能：长时间不使用，数据一直放在堆中影响性能\n\n\n### 懒汉式\n```java\npublic class LazySingleton {\n\tprivate static LazySingleton instance = null;\n\n\tprivate LazySingleton() {\n\t}\n\n\tpublic static LazySingleton getInstance() {\n\t\tif(instance == null){\n\t\t\tinstance = new LazySingleton();\n\t\t}\n\t\treturn instance;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tfor(int i = 0 ; i < 10 ; i ++){\n\t\t    new Thread(()-> System.out.println(LazySingleton.getInstance())).start();\n\t\t}\n\t}\n}\n```\n* 线程安全性：不能保证实例对象的唯一性\n* 懒加载：有延迟加载\n* 性能：使用时才进行加载，性能较好\n\n### 懒汉式+同步方法\n将懒汉式的get方法加上synchronized\n```java\n\tpublic synchronized static LazySingleton getInstance() {\n\t\tif(instance == null){\n\t\t\tinstance = new LazySingleton();\n\t\t}\n\t\treturn instance;\n\t}\n```\n* 线程安全性：synchronized保证线程安全\n* 懒加载：有延迟加载\n* 性能：多个线程调用该方法时 synchronized 会使线程阻塞，退化到了串行执行\n\n### Double-Check-Locking\n```java\npublic class DCLSingleton {\n\tprivate static DCLSingleton instance = null;\n\n\tprivate DCLSingleton() {\n\t}\n\n\tpublic static DCLSingleton getInstance() {\n\t\tif(instance == null){\n\t\t\tsynchronized (DCLSingleton.class){\n\t\t\t\tif(instance == null){\n\t\t\t\t\tinstance = new DCLSingleton();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n\tpublic static void main(String[] args) {\n\t\tfor(int i = 0 ; i < 10 ; i ++){\n\t\t\tnew Thread(()-> System.out.println(DCLSingleton.getInstance())).start();\n\t\t}\n\t}\n}\n```\n* 线程安全性：线程安全\n* 懒加载：有延迟加载\n* 性能：性能比较好\n* 缺点：会因为指令重排，引起空指针异常。\n\n### Volatile+Double-check\n添加volatile 避免空指针异常。\n```java\n\tprivate volatile static DCLSingleton instance = null;\n```\n\n### Holder\n声明类的时候，成员变量中不声明实例变量，而放到内部静态类中，\n```java\npublic class HolderSingleton {\n\tprivate HolderSingleton() {\n\t}\n\t//通过内部类实现懒加载，只有调用时才会进行实例化，静态类只能实例一次，保证线程安全\n\tprivate static class Holder{\n\t\tprivate static HolderSingleton instance=new HolderSingleton();\n\t}\n\tpublic static HolderSingleton getInstance(){\n\t\treturn Holder.instance;\n\t}\n}\n```\n\n### 枚举\n```java\npublic class EnumSingleton {\n\tprivate EnumSingleton() {\n\t}\n\t//延迟加载\n\tprivate enum EnumHolder{\n\t\tINSTANCE;\n\t\tprivate EnumSingleton instance=null;\n\n\t\tEnumHolder() {\n\t\t\tthis.instance = new EnumSingleton();\n\t\t}\n\t}\n\tpublic static EnumSingleton getInstance(){\n\t\treturn EnumHolder.INSTANCE.instance;\n\t}\n}\n```\n","source":"_posts/Design-Pattern-Singleton.md","raw":"---\ntitle: 设计模式-单例模式\ndate: 2020-02-29 17:37:00\ntags:\n    - 设计模式\ncategories: 设计模式\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n## 单例模式\n多个线程操作不同实例对象。多个线程要操作同一对象，要保证对象的唯一性\n\n## 单例模式的特点\n1. 有一个实例化的过程（只有一次），产生实例化对象\n2. 提供返回实例对象的方法\n\n## 单例模式的分类\n\n### 饿汉式\n```java\npublic class HungrySingleton {\n\t//加载时就产生了实例对象\n\tprivate static HungrySingleton instance = new HungrySingleton();\n\n\tprivate HungrySingleton() {\n\t}\n\t//返回实例对象\n\tpublic static HungrySingleton getInstance() {\n\t\treturn instance;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tfor(int i = 0 ; i < 10 ; i ++){\n\t\t\tnew Thread(()->{\n\t\t\t\tHungrySingleton hungerySingleton = HungrySingleton.getInstance();\n\t\t\t\tSystem.out.println(hungerySingleton);\n\t\t\t}).start();\n\t\t}\n\t}\n}\n```\n\n* 线程安全性：在加载的时候已经被实例化，所以只有这一次，线程安全的。\n* 懒加载：没有延迟加载\n* 性能：长时间不使用，数据一直放在堆中影响性能\n\n\n### 懒汉式\n```java\npublic class LazySingleton {\n\tprivate static LazySingleton instance = null;\n\n\tprivate LazySingleton() {\n\t}\n\n\tpublic static LazySingleton getInstance() {\n\t\tif(instance == null){\n\t\t\tinstance = new LazySingleton();\n\t\t}\n\t\treturn instance;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tfor(int i = 0 ; i < 10 ; i ++){\n\t\t    new Thread(()-> System.out.println(LazySingleton.getInstance())).start();\n\t\t}\n\t}\n}\n```\n* 线程安全性：不能保证实例对象的唯一性\n* 懒加载：有延迟加载\n* 性能：使用时才进行加载，性能较好\n\n### 懒汉式+同步方法\n将懒汉式的get方法加上synchronized\n```java\n\tpublic synchronized static LazySingleton getInstance() {\n\t\tif(instance == null){\n\t\t\tinstance = new LazySingleton();\n\t\t}\n\t\treturn instance;\n\t}\n```\n* 线程安全性：synchronized保证线程安全\n* 懒加载：有延迟加载\n* 性能：多个线程调用该方法时 synchronized 会使线程阻塞，退化到了串行执行\n\n### Double-Check-Locking\n```java\npublic class DCLSingleton {\n\tprivate static DCLSingleton instance = null;\n\n\tprivate DCLSingleton() {\n\t}\n\n\tpublic static DCLSingleton getInstance() {\n\t\tif(instance == null){\n\t\t\tsynchronized (DCLSingleton.class){\n\t\t\t\tif(instance == null){\n\t\t\t\t\tinstance = new DCLSingleton();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n\tpublic static void main(String[] args) {\n\t\tfor(int i = 0 ; i < 10 ; i ++){\n\t\t\tnew Thread(()-> System.out.println(DCLSingleton.getInstance())).start();\n\t\t}\n\t}\n}\n```\n* 线程安全性：线程安全\n* 懒加载：有延迟加载\n* 性能：性能比较好\n* 缺点：会因为指令重排，引起空指针异常。\n\n### Volatile+Double-check\n添加volatile 避免空指针异常。\n```java\n\tprivate volatile static DCLSingleton instance = null;\n```\n\n### Holder\n声明类的时候，成员变量中不声明实例变量，而放到内部静态类中，\n```java\npublic class HolderSingleton {\n\tprivate HolderSingleton() {\n\t}\n\t//通过内部类实现懒加载，只有调用时才会进行实例化，静态类只能实例一次，保证线程安全\n\tprivate static class Holder{\n\t\tprivate static HolderSingleton instance=new HolderSingleton();\n\t}\n\tpublic static HolderSingleton getInstance(){\n\t\treturn Holder.instance;\n\t}\n}\n```\n\n### 枚举\n```java\npublic class EnumSingleton {\n\tprivate EnumSingleton() {\n\t}\n\t//延迟加载\n\tprivate enum EnumHolder{\n\t\tINSTANCE;\n\t\tprivate EnumSingleton instance=null;\n\n\t\tEnumHolder() {\n\t\t\tthis.instance = new EnumSingleton();\n\t\t}\n\t}\n\tpublic static EnumSingleton getInstance(){\n\t\treturn EnumHolder.INSTANCE.instance;\n\t}\n}\n```\n","slug":"Design-Pattern-Singleton","published":1,"updated":"2020-03-06T12:44:31.776Z","layout":"post","photos":[],"link":"","_id":"ck8fb4a8o000hk2o5pvv4qvrr","content":"<h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><p>多个线程操作不同实例对象。多个线程要操作同一对象，要保证对象的唯一性</p>\n<h2 id=\"单例模式的特点\"><a href=\"#单例模式的特点\" class=\"headerlink\" title=\"单例模式的特点\"></a>单例模式的特点</h2><ol>\n<li>有一个实例化的过程（只有一次），产生实例化对象</li>\n<li>提供返回实例对象的方法</li>\n</ol>\n<h2 id=\"单例模式的分类\"><a href=\"#单例模式的分类\" class=\"headerlink\" title=\"单例模式的分类\"></a>单例模式的分类</h2><h3 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"饿汉式\"></a>饿汉式</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HungrySingleton</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//加载时就产生了实例对象</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> HungrySingleton instance = <span class=\"keyword\">new</span> HungrySingleton();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">HungrySingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//返回实例对象</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HungrySingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">10</span> ; i ++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">\t\t\t\tHungrySingleton hungerySingleton = HungrySingleton.getInstance();</span><br><span class=\"line\">\t\t\t\tSystem.out.println(hungerySingleton);</span><br><span class=\"line\">\t\t\t&#125;).start();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>线程安全性：在加载的时候已经被实例化，所以只有这一次，线程安全的。</li>\n<li>懒加载：没有延迟加载</li>\n<li>性能：长时间不使用，数据一直放在堆中影响性能</li>\n</ul>\n<h3 id=\"懒汉式\"><a href=\"#懒汉式\" class=\"headerlink\" title=\"懒汉式\"></a>懒汉式</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazySingleton</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">LazySingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\tinstance = <span class=\"keyword\">new</span> LazySingleton();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">10</span> ; i ++)&#123;</span><br><span class=\"line\">\t\t    <span class=\"keyword\">new</span> Thread(()-&gt; System.out.println(LazySingleton.getInstance())).start();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>线程安全性：不能保证实例对象的唯一性</li>\n<li>懒加载：有延迟加载</li>\n<li>性能：使用时才进行加载，性能较好</li>\n</ul>\n<h3 id=\"懒汉式-同步方法\"><a href=\"#懒汉式-同步方法\" class=\"headerlink\" title=\"懒汉式+同步方法\"></a>懒汉式+同步方法</h3><p>将懒汉式的get方法加上synchronized</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\tinstance = <span class=\"keyword\">new</span> LazySingleton();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>线程安全性：synchronized保证线程安全</li>\n<li>懒加载：有延迟加载</li>\n<li>性能：多个线程调用该方法时 synchronized 会使线程阻塞，退化到了串行执行</li>\n</ul>\n<h3 id=\"Double-Check-Locking\"><a href=\"#Double-Check-Locking\" class=\"headerlink\" title=\"Double-Check-Locking\"></a>Double-Check-Locking</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DCLSingleton</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> DCLSingleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">DCLSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> DCLSingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">synchronized</span> (DCLSingleton.class)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tinstance = <span class=\"keyword\">new</span> DCLSingleton();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">10</span> ; i ++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">new</span> Thread(()-&gt; System.out.println(DCLSingleton.getInstance())).start();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>线程安全性：线程安全</li>\n<li>懒加载：有延迟加载</li>\n<li>性能：性能比较好</li>\n<li>缺点：会因为指令重排，引起空指针异常。</li>\n</ul>\n<h3 id=\"Volatile-Double-check\"><a href=\"#Volatile-Double-check\" class=\"headerlink\" title=\"Volatile+Double-check\"></a>Volatile+Double-check</h3><p>添加volatile 避免空指针异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> DCLSingleton instance = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Holder\"><a href=\"#Holder\" class=\"headerlink\" title=\"Holder\"></a>Holder</h3><p>声明类的时候，成员变量中不声明实例变量，而放到内部静态类中，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HolderSingleton</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">HolderSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//通过内部类实现懒加载，只有调用时才会进行实例化，静态类只能实例一次，保证线程安全</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Holder</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> HolderSingleton instance=<span class=\"keyword\">new</span> HolderSingleton();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HolderSingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Holder.instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EnumSingleton</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">EnumSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//延迟加载</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">enum</span> EnumHolder&#123;</span><br><span class=\"line\">\t\tINSTANCE;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span> EnumSingleton instance=<span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tEnumHolder() &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.instance = <span class=\"keyword\">new</span> EnumSingleton();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> EnumSingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> EnumHolder.INSTANCE.instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><p>多个线程操作不同实例对象。多个线程要操作同一对象，要保证对象的唯一性</p>\n<h2 id=\"单例模式的特点\"><a href=\"#单例模式的特点\" class=\"headerlink\" title=\"单例模式的特点\"></a>单例模式的特点</h2><ol>\n<li>有一个实例化的过程（只有一次），产生实例化对象</li>\n<li>提供返回实例对象的方法</li>\n</ol>\n<h2 id=\"单例模式的分类\"><a href=\"#单例模式的分类\" class=\"headerlink\" title=\"单例模式的分类\"></a>单例模式的分类</h2><h3 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"饿汉式\"></a>饿汉式</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HungrySingleton</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//加载时就产生了实例对象</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> HungrySingleton instance = <span class=\"keyword\">new</span> HungrySingleton();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">HungrySingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//返回实例对象</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HungrySingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">10</span> ; i ++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">\t\t\t\tHungrySingleton hungerySingleton = HungrySingleton.getInstance();</span><br><span class=\"line\">\t\t\t\tSystem.out.println(hungerySingleton);</span><br><span class=\"line\">\t\t\t&#125;).start();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>线程安全性：在加载的时候已经被实例化，所以只有这一次，线程安全的。</li>\n<li>懒加载：没有延迟加载</li>\n<li>性能：长时间不使用，数据一直放在堆中影响性能</li>\n</ul>\n<h3 id=\"懒汉式\"><a href=\"#懒汉式\" class=\"headerlink\" title=\"懒汉式\"></a>懒汉式</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazySingleton</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">LazySingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\tinstance = <span class=\"keyword\">new</span> LazySingleton();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">10</span> ; i ++)&#123;</span><br><span class=\"line\">\t\t    <span class=\"keyword\">new</span> Thread(()-&gt; System.out.println(LazySingleton.getInstance())).start();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>线程安全性：不能保证实例对象的唯一性</li>\n<li>懒加载：有延迟加载</li>\n<li>性能：使用时才进行加载，性能较好</li>\n</ul>\n<h3 id=\"懒汉式-同步方法\"><a href=\"#懒汉式-同步方法\" class=\"headerlink\" title=\"懒汉式+同步方法\"></a>懒汉式+同步方法</h3><p>将懒汉式的get方法加上synchronized</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\tinstance = <span class=\"keyword\">new</span> LazySingleton();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>线程安全性：synchronized保证线程安全</li>\n<li>懒加载：有延迟加载</li>\n<li>性能：多个线程调用该方法时 synchronized 会使线程阻塞，退化到了串行执行</li>\n</ul>\n<h3 id=\"Double-Check-Locking\"><a href=\"#Double-Check-Locking\" class=\"headerlink\" title=\"Double-Check-Locking\"></a>Double-Check-Locking</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DCLSingleton</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> DCLSingleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">DCLSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> DCLSingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">synchronized</span> (DCLSingleton.class)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tinstance = <span class=\"keyword\">new</span> DCLSingleton();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">10</span> ; i ++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">new</span> Thread(()-&gt; System.out.println(DCLSingleton.getInstance())).start();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>线程安全性：线程安全</li>\n<li>懒加载：有延迟加载</li>\n<li>性能：性能比较好</li>\n<li>缺点：会因为指令重排，引起空指针异常。</li>\n</ul>\n<h3 id=\"Volatile-Double-check\"><a href=\"#Volatile-Double-check\" class=\"headerlink\" title=\"Volatile+Double-check\"></a>Volatile+Double-check</h3><p>添加volatile 避免空指针异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> DCLSingleton instance = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Holder\"><a href=\"#Holder\" class=\"headerlink\" title=\"Holder\"></a>Holder</h3><p>声明类的时候，成员变量中不声明实例变量，而放到内部静态类中，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HolderSingleton</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">HolderSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//通过内部类实现懒加载，只有调用时才会进行实例化，静态类只能实例一次，保证线程安全</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Holder</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> HolderSingleton instance=<span class=\"keyword\">new</span> HolderSingleton();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HolderSingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Holder.instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EnumSingleton</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">EnumSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//延迟加载</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">enum</span> EnumHolder&#123;</span><br><span class=\"line\">\t\tINSTANCE;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span> EnumSingleton instance=<span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tEnumHolder() &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.instance = <span class=\"keyword\">new</span> EnumSingleton();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> EnumSingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> EnumHolder.INSTANCE.instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"设计模式-观察者模式","date":"2019-12-13T11:39:04.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"## 认识观察者模式\n我们看看报纸和杂志的订阅是怎么回事:\n1. 报社的业务就是出版报纸。\n2. 向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。只要你是他们的订户，你就会一直收到新报纸。\n<!-- more -->\n3. 当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸来。\n4. 只要报社还在运营，就会一直有人(或单位)向他们订阅报 纸或取消订阅报纸。\n\n## 观察者模式\n出版者+订阅者=观察者模式\n出版者改称为“主题”(Subject)，订阅者改称为“观察者”(Observer)。\n观察者模式：定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。\n\n## 示例\n\n建立气象站：\n该气象站必须建立在WeatherData对象上，由WeatherData对象负责追踪目前的天气状况(温度、\n湿度、气压)。希望能建立一个应用，有三种布告板，分别显示目前的状况、气象统计及简单的预报。 \n当WeatherObject对象获得最新的测量数据时，三种布告板 必须实时更新。\n而且，这是一个可以扩展的气象站，Weather-O-Rama气象 站希望公布一组API，好让其他开发人员可以写出自己的气象布告板，并插入此应用中。\n![](Design-Pattern-Observer/1.png)\n\n```java\npublic interface Subject {\n    // 注册\n    public void registerObserver(Observer o);\n    // 移除\n    public void removeObserver(Observer o);\n    // 通知\n    public void notifyObservers();\n}\n```\n\n```java\npublic interface Observer {\n    public void update(float temp, float humidity, float pressure);\n}\n```\n\n```java\npublic interface DisplayElement {\n    // 显示布告板\n    public void display();\n}\n```\n\n```java\nimport java.util.ArrayList;\n\n\npublic class WeatherData implements Subject{\n    private ArrayList observers;\n    // 温度\n    private float temperature;\n    // 湿度\n    private float humidity;\n    // 气压\n    private float pressure;\n\n    public WeatherData() {\n        observers = new ArrayList();\n    }\n\n    @Override\n    public void registerObserver(Observer o) {\n        observers.add(o);\n    }\n\n    @Override\n    public void removeObserver(Observer o) {\n        int i = observers.indexOf(o);\n        if (i >= 0) {\n            observers.remove(i);\n        }\n    }\n\n    @Override\n    public void notifyObservers() {\n        for (int i = 0; i < observers.size(); i++) {\n            Observer observer = (Observer)observers.get(i);\n            observer.update(temperature, humidity, pressure);\n        }\n\n    }\n    // 当从气象站得到更新观测值时，我们通知观察者。\n    public void measurementsChanged() {\n        notifyObservers();\n    }\n\n    public void setMeasurements(float temperature, float humidity, float pressure) {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        measurementsChanged();\n    }\n\n    //其他方法省略\n}\n```\n布告板\n\n```java\n\npublic class CurrentConditionsDisplay implements Observer, DisplayElement{\n    private float temperature;\n\n    private float humidity;\n\n    private Subject weatherData;\n\n    public CurrentConditionsDisplay(Subject weatherData) {\n        this.weatherData = weatherData;\n        weatherData.registerObserver(this);\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Current conditions: \" + temperature + \"F degrees and \" + humidity + \"% humidity\");\n    }\n\n    @Override\n    public void update(float temp, float humidity, float pressure) {\n        this.temperature = temp;\n        this.humidity = humidity;\n        display();\n    }\n}\n```\n气象站测试类\n\n```java\npublic class WeatherStation {\n    public static void main(String[] args) {\n        WeatherData weatherData = new WeatherData();\n        CurrentConditionsDisplay currentDisplay = new CurrentConditionsDisplay(weatherData);\n//        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);\n//        ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData);\n        weatherData.setMeasurements(80, 65, 30.4f);\n        weatherData.setMeasurements(82, 70, 29.2f);\n        weatherData.setMeasurements(78, 90, 29.2f);\n    }\n}\n```\n\n运行结果\n\n```bash\nCurrent conditions: 80.0F degrees and 65.0% humidity\nCurrent conditions: 82.0F degrees and 70.0% humidity\nCurrent conditions: 78.0F degrees and 90.0% humidity\n```\n\n## JAVA内置的观察者模式\nJava API有内置的观察者模式。java.util包(package)内包含最基本的Observer接口与Observable类。\n![](Design-Pattern-Observer/2.png)\n\nObserver接口\n```java\npackage java.util;\n\npublic interface Observer {\n\n    void update(Observable o, Object arg);\n}\n\n```\n\nObservable类\n```java\n\npackage java.util;\n\npublic class Observable {\n    private boolean changed = false;// 数据更新标记\n    private Vector<Observer> obs; // 观察者列表\n\n    //构造函数\n    public Observable() {\n        obs = new Vector<>();\n    }\n    \n    //添加观察者\n    public synchronized void addObserver(Observer o) {\n        if (o == null)\n            throw new NullPointerException();\n        if (!obs.contains(o)) {\n            obs.addElement(o);\n        }\n    }\n\n    // 删除某一个观察者\n    public synchronized void deleteObserver(Observer o) {\n        obs.removeElement(o);\n    }\n\n    // 通知观察者\n    public void notifyObservers() {\n        notifyObservers(null);\n    }\n\n    // 如果changed = true 意味着数据被修改，通知每个观察者。\n    public void notifyObservers(Object arg) {\n        Object[] arrLocal;\n\n        synchronized (this) {\n            if (!changed)\n                return;\n            arrLocal = obs.toArray();\n            clearChanged();\n        }\n\n        for (int i = arrLocal.length-1; i>=0; i--)\n            ((Observer)arrLocal[i]).update(this, arg);\n    }\n\n    // 删除所有观察者\n    public synchronized void deleteObservers() {\n        obs.removeAllElements();\n    }\n\n    // 设置changed值\n    protected synchronized void setChanged() {\n        changed = true;\n    }\n\n    // 清除changed值\n    protected synchronized void clearChanged() {\n        changed = false;\n    }\n\n    // 获取changed值\n    public synchronized boolean hasChanged() {\n        return changed;\n    }\n\n    // 返回观察者个数\n    public synchronized int countObservers() {\n        return obs.size();\n    }\n}\n\n```\n\n```java\nimport java.util.Observable;\n\npublic class WeatherData extends Observable {\n    // 温度\n    private float temperature;\n    // 湿度\n    private float humidity;\n    // 气压\n    private float pressure;\n\n    public WeatherData() {\n    }\n\n    // 当从气象站得到更新观测值时，我们通知观察者。\n    public void measurementsChanged() {\n        setChanged();\n        notifyObservers();\n    }\n\n    public void setMeasurements(float temperature, float humidity, float pressure) {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        measurementsChanged();\n    }\n\n    //使用“拉”的做法\n    public float getTemperature() {\n        return temperature;\n    }\n\n    public float getHumidity() {\n        return humidity;\n    }\n\n    public float getPressure() {\n        return pressure;\n    }\n\n    //其他方法省略\n}\n```\n\n```java\nimport java.util.Observable;\nimport java.util.Observer;\n\npublic class CurrentConditionsDisplay implements Observer, DisplayElement{\n    private float temperature;\n\n    private float humidity;\n\n    Observable observable;\n\n    public CurrentConditionsDisplay(Observable observable) {\n        this.observable = observable;\n        observable.addObserver(this);\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Current conditions: \" + temperature + \"F degrees and \" + humidity + \"% humidity\");\n    }\n\n\n    @Override\n    public void update(Observable o, Object arg) {\n        if (o instanceof WeatherData) {\n            WeatherData weatherData = (WeatherData)o;\n            this.temperature = weatherData.getTemperature();\n            this.humidity = weatherData.getHumidity();\n            display();\n        }\n    }\n}\n```\n\n测试代码和测试结果同上\n\n### java.util.Observable的缺点\njava.util.Observable的实现 有许多问题，限制了它的使用和复用。\n* 观察者是一个“类”而不是一个“接 口”\n    * 你必须设计一个类继承它。如果某类想同时 具有Observable类和另一个超类的行为，就会陷入两难，毕竟Java不支持多重继承。\n* Observable将关键的方法保护起来\n    * setChanged()方法被保护起来了(被定义成 protected)。这意味着:除非你继承自Observable，否则你无法创建Observable实例并组合到你自己的对象中来。这个设计违反了第二个设计原 则:“多用组合，少用继承”。\n\n## 要点\n* 观察者模式定义了对象之间一对多的关系。\n* 主题(也就是可观察者)用一个共同的接口来更新观察者。\n* 观察者和可观察者之间用松耦合方式结合(loosecoupl- ing)，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。\n* 使用此模式时，你可从被观察者处推(push)或拉(pull)数据(然而，推的方式被认为更“正确”)。\n* 有多个观察者时，不可以依赖特定的通知次序。\n* Java有多种观察者模式的实现，包括了通用的java.util.Observable。\n* 要注意java.util.Observable实现上所带来的一些问题。\n* 如果有必要的话，可以实现自己的Observable。\n* Swing大量使用观察者模式，许多GUI框架也是如此。\n* 此模式也被应用在许多地方，例如:JavaBeans、RMI。\n\n\n","source":"_posts/Design-Pattern-Observer.md","raw":"---\ntitle: 设计模式-观察者模式\ndate: 2019-12-13 19:39:04\ntags:\n    - 设计模式\ncategories: 设计模式\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n## 认识观察者模式\n我们看看报纸和杂志的订阅是怎么回事:\n1. 报社的业务就是出版报纸。\n2. 向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。只要你是他们的订户，你就会一直收到新报纸。\n<!-- more -->\n3. 当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸来。\n4. 只要报社还在运营，就会一直有人(或单位)向他们订阅报 纸或取消订阅报纸。\n\n## 观察者模式\n出版者+订阅者=观察者模式\n出版者改称为“主题”(Subject)，订阅者改称为“观察者”(Observer)。\n观察者模式：定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。\n\n## 示例\n\n建立气象站：\n该气象站必须建立在WeatherData对象上，由WeatherData对象负责追踪目前的天气状况(温度、\n湿度、气压)。希望能建立一个应用，有三种布告板，分别显示目前的状况、气象统计及简单的预报。 \n当WeatherObject对象获得最新的测量数据时，三种布告板 必须实时更新。\n而且，这是一个可以扩展的气象站，Weather-O-Rama气象 站希望公布一组API，好让其他开发人员可以写出自己的气象布告板，并插入此应用中。\n![](Design-Pattern-Observer/1.png)\n\n```java\npublic interface Subject {\n    // 注册\n    public void registerObserver(Observer o);\n    // 移除\n    public void removeObserver(Observer o);\n    // 通知\n    public void notifyObservers();\n}\n```\n\n```java\npublic interface Observer {\n    public void update(float temp, float humidity, float pressure);\n}\n```\n\n```java\npublic interface DisplayElement {\n    // 显示布告板\n    public void display();\n}\n```\n\n```java\nimport java.util.ArrayList;\n\n\npublic class WeatherData implements Subject{\n    private ArrayList observers;\n    // 温度\n    private float temperature;\n    // 湿度\n    private float humidity;\n    // 气压\n    private float pressure;\n\n    public WeatherData() {\n        observers = new ArrayList();\n    }\n\n    @Override\n    public void registerObserver(Observer o) {\n        observers.add(o);\n    }\n\n    @Override\n    public void removeObserver(Observer o) {\n        int i = observers.indexOf(o);\n        if (i >= 0) {\n            observers.remove(i);\n        }\n    }\n\n    @Override\n    public void notifyObservers() {\n        for (int i = 0; i < observers.size(); i++) {\n            Observer observer = (Observer)observers.get(i);\n            observer.update(temperature, humidity, pressure);\n        }\n\n    }\n    // 当从气象站得到更新观测值时，我们通知观察者。\n    public void measurementsChanged() {\n        notifyObservers();\n    }\n\n    public void setMeasurements(float temperature, float humidity, float pressure) {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        measurementsChanged();\n    }\n\n    //其他方法省略\n}\n```\n布告板\n\n```java\n\npublic class CurrentConditionsDisplay implements Observer, DisplayElement{\n    private float temperature;\n\n    private float humidity;\n\n    private Subject weatherData;\n\n    public CurrentConditionsDisplay(Subject weatherData) {\n        this.weatherData = weatherData;\n        weatherData.registerObserver(this);\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Current conditions: \" + temperature + \"F degrees and \" + humidity + \"% humidity\");\n    }\n\n    @Override\n    public void update(float temp, float humidity, float pressure) {\n        this.temperature = temp;\n        this.humidity = humidity;\n        display();\n    }\n}\n```\n气象站测试类\n\n```java\npublic class WeatherStation {\n    public static void main(String[] args) {\n        WeatherData weatherData = new WeatherData();\n        CurrentConditionsDisplay currentDisplay = new CurrentConditionsDisplay(weatherData);\n//        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);\n//        ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData);\n        weatherData.setMeasurements(80, 65, 30.4f);\n        weatherData.setMeasurements(82, 70, 29.2f);\n        weatherData.setMeasurements(78, 90, 29.2f);\n    }\n}\n```\n\n运行结果\n\n```bash\nCurrent conditions: 80.0F degrees and 65.0% humidity\nCurrent conditions: 82.0F degrees and 70.0% humidity\nCurrent conditions: 78.0F degrees and 90.0% humidity\n```\n\n## JAVA内置的观察者模式\nJava API有内置的观察者模式。java.util包(package)内包含最基本的Observer接口与Observable类。\n![](Design-Pattern-Observer/2.png)\n\nObserver接口\n```java\npackage java.util;\n\npublic interface Observer {\n\n    void update(Observable o, Object arg);\n}\n\n```\n\nObservable类\n```java\n\npackage java.util;\n\npublic class Observable {\n    private boolean changed = false;// 数据更新标记\n    private Vector<Observer> obs; // 观察者列表\n\n    //构造函数\n    public Observable() {\n        obs = new Vector<>();\n    }\n    \n    //添加观察者\n    public synchronized void addObserver(Observer o) {\n        if (o == null)\n            throw new NullPointerException();\n        if (!obs.contains(o)) {\n            obs.addElement(o);\n        }\n    }\n\n    // 删除某一个观察者\n    public synchronized void deleteObserver(Observer o) {\n        obs.removeElement(o);\n    }\n\n    // 通知观察者\n    public void notifyObservers() {\n        notifyObservers(null);\n    }\n\n    // 如果changed = true 意味着数据被修改，通知每个观察者。\n    public void notifyObservers(Object arg) {\n        Object[] arrLocal;\n\n        synchronized (this) {\n            if (!changed)\n                return;\n            arrLocal = obs.toArray();\n            clearChanged();\n        }\n\n        for (int i = arrLocal.length-1; i>=0; i--)\n            ((Observer)arrLocal[i]).update(this, arg);\n    }\n\n    // 删除所有观察者\n    public synchronized void deleteObservers() {\n        obs.removeAllElements();\n    }\n\n    // 设置changed值\n    protected synchronized void setChanged() {\n        changed = true;\n    }\n\n    // 清除changed值\n    protected synchronized void clearChanged() {\n        changed = false;\n    }\n\n    // 获取changed值\n    public synchronized boolean hasChanged() {\n        return changed;\n    }\n\n    // 返回观察者个数\n    public synchronized int countObservers() {\n        return obs.size();\n    }\n}\n\n```\n\n```java\nimport java.util.Observable;\n\npublic class WeatherData extends Observable {\n    // 温度\n    private float temperature;\n    // 湿度\n    private float humidity;\n    // 气压\n    private float pressure;\n\n    public WeatherData() {\n    }\n\n    // 当从气象站得到更新观测值时，我们通知观察者。\n    public void measurementsChanged() {\n        setChanged();\n        notifyObservers();\n    }\n\n    public void setMeasurements(float temperature, float humidity, float pressure) {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        measurementsChanged();\n    }\n\n    //使用“拉”的做法\n    public float getTemperature() {\n        return temperature;\n    }\n\n    public float getHumidity() {\n        return humidity;\n    }\n\n    public float getPressure() {\n        return pressure;\n    }\n\n    //其他方法省略\n}\n```\n\n```java\nimport java.util.Observable;\nimport java.util.Observer;\n\npublic class CurrentConditionsDisplay implements Observer, DisplayElement{\n    private float temperature;\n\n    private float humidity;\n\n    Observable observable;\n\n    public CurrentConditionsDisplay(Observable observable) {\n        this.observable = observable;\n        observable.addObserver(this);\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Current conditions: \" + temperature + \"F degrees and \" + humidity + \"% humidity\");\n    }\n\n\n    @Override\n    public void update(Observable o, Object arg) {\n        if (o instanceof WeatherData) {\n            WeatherData weatherData = (WeatherData)o;\n            this.temperature = weatherData.getTemperature();\n            this.humidity = weatherData.getHumidity();\n            display();\n        }\n    }\n}\n```\n\n测试代码和测试结果同上\n\n### java.util.Observable的缺点\njava.util.Observable的实现 有许多问题，限制了它的使用和复用。\n* 观察者是一个“类”而不是一个“接 口”\n    * 你必须设计一个类继承它。如果某类想同时 具有Observable类和另一个超类的行为，就会陷入两难，毕竟Java不支持多重继承。\n* Observable将关键的方法保护起来\n    * setChanged()方法被保护起来了(被定义成 protected)。这意味着:除非你继承自Observable，否则你无法创建Observable实例并组合到你自己的对象中来。这个设计违反了第二个设计原 则:“多用组合，少用继承”。\n\n## 要点\n* 观察者模式定义了对象之间一对多的关系。\n* 主题(也就是可观察者)用一个共同的接口来更新观察者。\n* 观察者和可观察者之间用松耦合方式结合(loosecoupl- ing)，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。\n* 使用此模式时，你可从被观察者处推(push)或拉(pull)数据(然而，推的方式被认为更“正确”)。\n* 有多个观察者时，不可以依赖特定的通知次序。\n* Java有多种观察者模式的实现，包括了通用的java.util.Observable。\n* 要注意java.util.Observable实现上所带来的一些问题。\n* 如果有必要的话，可以实现自己的Observable。\n* Swing大量使用观察者模式，许多GUI框架也是如此。\n* 此模式也被应用在许多地方，例如:JavaBeans、RMI。\n\n\n","slug":"Design-Pattern-Observer","published":1,"updated":"2020-01-22T09:31:30.355Z","layout":"post","photos":[],"link":"","_id":"ck8fb4a8q000ik2o51yuoss7g","content":"<h2 id=\"认识观察者模式\"><a href=\"#认识观察者模式\" class=\"headerlink\" title=\"认识观察者模式\"></a>认识观察者模式</h2><p>我们看看报纸和杂志的订阅是怎么回事:</p>\n<ol>\n<li>报社的业务就是出版报纸。</li>\n<li>向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。只要你是他们的订户，你就会一直收到新报纸。<a id=\"more\"></a></li>\n<li>当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸来。</li>\n<li>只要报社还在运营，就会一直有人(或单位)向他们订阅报 纸或取消订阅报纸。</li>\n</ol>\n<h2 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h2><p>出版者+订阅者=观察者模式<br>出版者改称为“主题”(Subject)，订阅者改称为“观察者”(Observer)。<br>观察者模式：定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>建立气象站：<br>该气象站必须建立在WeatherData对象上，由WeatherData对象负责追踪目前的天气状况(温度、<br>湿度、气压)。希望能建立一个应用，有三种布告板，分别显示目前的状况、气象统计及简单的预报。<br>当WeatherObject对象获得最新的测量数据时，三种布告板 必须实时更新。<br>而且，这是一个可以扩展的气象站，Weather-O-Rama气象 站希望公布一组API，好让其他开发人员可以写出自己的气象布告板，并插入此应用中。<br><img src=\"/设计模式/Design-Pattern-Observer/1.png\" alt=\"\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注册</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerObserver</span><span class=\"params\">(Observer o)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 移除</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(Observer o)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 通知</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyObservers</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">float</span> temp, <span class=\"keyword\">float</span> humidity, <span class=\"keyword\">float</span> pressure)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DisplayElement</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 显示布告板</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeatherData</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ArrayList observers;</span><br><span class=\"line\">    <span class=\"comment\">// 温度</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> temperature;</span><br><span class=\"line\">    <span class=\"comment\">// 湿度</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> humidity;</span><br><span class=\"line\">    <span class=\"comment\">// 气压</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> pressure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeatherData</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        observers = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerObserver</span><span class=\"params\">(Observer o)</span> </span>&#123;</span><br><span class=\"line\">        observers.add(o);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(Observer o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = observers.indexOf(o);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            observers.remove(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyObservers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; observers.size(); i++) &#123;</span><br><span class=\"line\">            Observer observer = (Observer)observers.get(i);</span><br><span class=\"line\">            observer.update(temperature, humidity, pressure);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当从气象站得到更新观测值时，我们通知观察者。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">measurementsChanged</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        notifyObservers();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMeasurements</span><span class=\"params\">(<span class=\"keyword\">float</span> temperature, <span class=\"keyword\">float</span> humidity, <span class=\"keyword\">float</span> pressure)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.temperature = temperature;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.humidity = humidity;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.pressure = pressure;</span><br><span class=\"line\">        measurementsChanged();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//其他方法省略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>布告板</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CurrentConditionsDisplay</span> <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span>, <span class=\"title\">DisplayElement</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> temperature;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> humidity;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Subject weatherData;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CurrentConditionsDisplay</span><span class=\"params\">(Subject weatherData)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.weatherData = weatherData;</span><br><span class=\"line\">        weatherData.registerObserver(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Current conditions: \"</span> + temperature + <span class=\"string\">\"F degrees and \"</span> + humidity + <span class=\"string\">\"% humidity\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">float</span> temp, <span class=\"keyword\">float</span> humidity, <span class=\"keyword\">float</span> pressure)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.temperature = temp;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.humidity = humidity;</span><br><span class=\"line\">        display();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>气象站测试类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeatherStation</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        WeatherData weatherData = <span class=\"keyword\">new</span> WeatherData();</span><br><span class=\"line\">        CurrentConditionsDisplay currentDisplay = <span class=\"keyword\">new</span> CurrentConditionsDisplay(weatherData);</span><br><span class=\"line\"><span class=\"comment\">//        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);</span></span><br><span class=\"line\"><span class=\"comment\">//        ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData);</span></span><br><span class=\"line\">        weatherData.setMeasurements(<span class=\"number\">80</span>, <span class=\"number\">65</span>, <span class=\"number\">30.4f</span>);</span><br><span class=\"line\">        weatherData.setMeasurements(<span class=\"number\">82</span>, <span class=\"number\">70</span>, <span class=\"number\">29.2f</span>);</span><br><span class=\"line\">        weatherData.setMeasurements(<span class=\"number\">78</span>, <span class=\"number\">90</span>, <span class=\"number\">29.2f</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Current conditions: 80.0F degrees and 65.0% humidity</span><br><span class=\"line\">Current conditions: 82.0F degrees and 70.0% humidity</span><br><span class=\"line\">Current conditions: 78.0F degrees and 90.0% humidity</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"JAVA内置的观察者模式\"><a href=\"#JAVA内置的观察者模式\" class=\"headerlink\" title=\"JAVA内置的观察者模式\"></a>JAVA内置的观察者模式</h2><p>Java API有内置的观察者模式。java.util包(package)内包含最基本的Observer接口与Observable类。<br><img src=\"/设计模式/Design-Pattern-Observer/2.png\" alt=\"\"></p>\n<p>Observer接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.util;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(Observable o, Object arg)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Observable类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> java.util;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> changed = <span class=\"keyword\">false</span>;<span class=\"comment\">// 数据更新标记</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Vector&lt;Observer&gt; obs; <span class=\"comment\">// 观察者列表</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Observable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        obs = <span class=\"keyword\">new</span> Vector&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//添加观察者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">addObserver</span><span class=\"params\">(Observer o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!obs.contains(o)) &#123;</span><br><span class=\"line\">            obs.addElement(o);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除某一个观察者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteObserver</span><span class=\"params\">(Observer o)</span> </span>&#123;</span><br><span class=\"line\">        obs.removeElement(o);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通知观察者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyObservers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        notifyObservers(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果changed = true 意味着数据被修改，通知每个观察者。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyObservers</span><span class=\"params\">(Object arg)</span> </span>&#123;</span><br><span class=\"line\">        Object[] arrLocal;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!changed)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            arrLocal = obs.toArray();</span><br><span class=\"line\">            clearChanged();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = arrLocal.length-<span class=\"number\">1</span>; i&gt;=<span class=\"number\">0</span>; i--)</span><br><span class=\"line\">            ((Observer)arrLocal[i]).update(<span class=\"keyword\">this</span>, arg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除所有观察者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteObservers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        obs.removeAllElements();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置changed值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">setChanged</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        changed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 清除changed值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">clearChanged</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        changed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取changed值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasChanged</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> changed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回观察者个数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">int</span> <span class=\"title\">countObservers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obs.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Observable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeatherData</span> <span class=\"keyword\">extends</span> <span class=\"title\">Observable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 温度</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> temperature;</span><br><span class=\"line\">    <span class=\"comment\">// 湿度</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> humidity;</span><br><span class=\"line\">    <span class=\"comment\">// 气压</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> pressure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeatherData</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当从气象站得到更新观测值时，我们通知观察者。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">measurementsChanged</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        setChanged();</span><br><span class=\"line\">        notifyObservers();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMeasurements</span><span class=\"params\">(<span class=\"keyword\">float</span> temperature, <span class=\"keyword\">float</span> humidity, <span class=\"keyword\">float</span> pressure)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.temperature = temperature;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.humidity = humidity;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.pressure = pressure;</span><br><span class=\"line\">        measurementsChanged();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//使用“拉”的做法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">getTemperature</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> temperature;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">getHumidity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> humidity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">getPressure</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pressure;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//其他方法省略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Observable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Observer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CurrentConditionsDisplay</span> <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span>, <span class=\"title\">DisplayElement</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> temperature;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> humidity;</span><br><span class=\"line\"></span><br><span class=\"line\">    Observable observable;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CurrentConditionsDisplay</span><span class=\"params\">(Observable observable)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.observable = observable;</span><br><span class=\"line\">        observable.addObserver(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Current conditions: \"</span> + temperature + <span class=\"string\">\"F degrees and \"</span> + humidity + <span class=\"string\">\"% humidity\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(Observable o, Object arg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> WeatherData) &#123;</span><br><span class=\"line\">            WeatherData weatherData = (WeatherData)o;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.temperature = weatherData.getTemperature();</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.humidity = weatherData.getHumidity();</span><br><span class=\"line\">            display();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试代码和测试结果同上</p>\n<h3 id=\"java-util-Observable的缺点\"><a href=\"#java-util-Observable的缺点\" class=\"headerlink\" title=\"java.util.Observable的缺点\"></a>java.util.Observable的缺点</h3><p>java.util.Observable的实现 有许多问题，限制了它的使用和复用。</p>\n<ul>\n<li>观察者是一个“类”而不是一个“接 口”<ul>\n<li>你必须设计一个类继承它。如果某类想同时 具有Observable类和另一个超类的行为，就会陷入两难，毕竟Java不支持多重继承。</li>\n</ul>\n</li>\n<li>Observable将关键的方法保护起来<ul>\n<li>setChanged()方法被保护起来了(被定义成 protected)。这意味着:除非你继承自Observable，否则你无法创建Observable实例并组合到你自己的对象中来。这个设计违反了第二个设计原 则:“多用组合，少用继承”。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h2><ul>\n<li>观察者模式定义了对象之间一对多的关系。</li>\n<li>主题(也就是可观察者)用一个共同的接口来更新观察者。</li>\n<li>观察者和可观察者之间用松耦合方式结合(loosecoupl- ing)，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。</li>\n<li>使用此模式时，你可从被观察者处推(push)或拉(pull)数据(然而，推的方式被认为更“正确”)。</li>\n<li>有多个观察者时，不可以依赖特定的通知次序。</li>\n<li>Java有多种观察者模式的实现，包括了通用的java.util.Observable。</li>\n<li>要注意java.util.Observable实现上所带来的一些问题。</li>\n<li>如果有必要的话，可以实现自己的Observable。</li>\n<li>Swing大量使用观察者模式，许多GUI框架也是如此。</li>\n<li>此模式也被应用在许多地方，例如:JavaBeans、RMI。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"认识观察者模式\"><a href=\"#认识观察者模式\" class=\"headerlink\" title=\"认识观察者模式\"></a>认识观察者模式</h2><p>我们看看报纸和杂志的订阅是怎么回事:</p>\n<ol>\n<li>报社的业务就是出版报纸。</li>\n<li>向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。只要你是他们的订户，你就会一直收到新报纸。</li></ol>","more":"\n<li>当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸来。</li>\n<li>只要报社还在运营，就会一直有人(或单位)向他们订阅报 纸或取消订阅报纸。</li>\n\n<h2 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h2><p>出版者+订阅者=观察者模式<br>出版者改称为“主题”(Subject)，订阅者改称为“观察者”(Observer)。<br>观察者模式：定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>建立气象站：<br>该气象站必须建立在WeatherData对象上，由WeatherData对象负责追踪目前的天气状况(温度、<br>湿度、气压)。希望能建立一个应用，有三种布告板，分别显示目前的状况、气象统计及简单的预报。<br>当WeatherObject对象获得最新的测量数据时，三种布告板 必须实时更新。<br>而且，这是一个可以扩展的气象站，Weather-O-Rama气象 站希望公布一组API，好让其他开发人员可以写出自己的气象布告板，并插入此应用中。<br><img src=\"/设计模式/Design-Pattern-Observer/1.png\" alt=\"\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注册</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerObserver</span><span class=\"params\">(Observer o)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 移除</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(Observer o)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 通知</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyObservers</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">float</span> temp, <span class=\"keyword\">float</span> humidity, <span class=\"keyword\">float</span> pressure)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DisplayElement</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 显示布告板</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeatherData</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ArrayList observers;</span><br><span class=\"line\">    <span class=\"comment\">// 温度</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> temperature;</span><br><span class=\"line\">    <span class=\"comment\">// 湿度</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> humidity;</span><br><span class=\"line\">    <span class=\"comment\">// 气压</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> pressure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeatherData</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        observers = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerObserver</span><span class=\"params\">(Observer o)</span> </span>&#123;</span><br><span class=\"line\">        observers.add(o);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(Observer o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = observers.indexOf(o);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            observers.remove(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyObservers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; observers.size(); i++) &#123;</span><br><span class=\"line\">            Observer observer = (Observer)observers.get(i);</span><br><span class=\"line\">            observer.update(temperature, humidity, pressure);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当从气象站得到更新观测值时，我们通知观察者。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">measurementsChanged</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        notifyObservers();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMeasurements</span><span class=\"params\">(<span class=\"keyword\">float</span> temperature, <span class=\"keyword\">float</span> humidity, <span class=\"keyword\">float</span> pressure)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.temperature = temperature;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.humidity = humidity;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.pressure = pressure;</span><br><span class=\"line\">        measurementsChanged();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//其他方法省略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>布告板</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CurrentConditionsDisplay</span> <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span>, <span class=\"title\">DisplayElement</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> temperature;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> humidity;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Subject weatherData;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CurrentConditionsDisplay</span><span class=\"params\">(Subject weatherData)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.weatherData = weatherData;</span><br><span class=\"line\">        weatherData.registerObserver(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Current conditions: \"</span> + temperature + <span class=\"string\">\"F degrees and \"</span> + humidity + <span class=\"string\">\"% humidity\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">float</span> temp, <span class=\"keyword\">float</span> humidity, <span class=\"keyword\">float</span> pressure)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.temperature = temp;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.humidity = humidity;</span><br><span class=\"line\">        display();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>气象站测试类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeatherStation</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        WeatherData weatherData = <span class=\"keyword\">new</span> WeatherData();</span><br><span class=\"line\">        CurrentConditionsDisplay currentDisplay = <span class=\"keyword\">new</span> CurrentConditionsDisplay(weatherData);</span><br><span class=\"line\"><span class=\"comment\">//        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);</span></span><br><span class=\"line\"><span class=\"comment\">//        ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData);</span></span><br><span class=\"line\">        weatherData.setMeasurements(<span class=\"number\">80</span>, <span class=\"number\">65</span>, <span class=\"number\">30.4f</span>);</span><br><span class=\"line\">        weatherData.setMeasurements(<span class=\"number\">82</span>, <span class=\"number\">70</span>, <span class=\"number\">29.2f</span>);</span><br><span class=\"line\">        weatherData.setMeasurements(<span class=\"number\">78</span>, <span class=\"number\">90</span>, <span class=\"number\">29.2f</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Current conditions: 80.0F degrees and 65.0% humidity</span><br><span class=\"line\">Current conditions: 82.0F degrees and 70.0% humidity</span><br><span class=\"line\">Current conditions: 78.0F degrees and 90.0% humidity</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"JAVA内置的观察者模式\"><a href=\"#JAVA内置的观察者模式\" class=\"headerlink\" title=\"JAVA内置的观察者模式\"></a>JAVA内置的观察者模式</h2><p>Java API有内置的观察者模式。java.util包(package)内包含最基本的Observer接口与Observable类。<br><img src=\"/设计模式/Design-Pattern-Observer/2.png\" alt=\"\"></p>\n<p>Observer接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.util;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(Observable o, Object arg)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Observable类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> java.util;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> changed = <span class=\"keyword\">false</span>;<span class=\"comment\">// 数据更新标记</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Vector&lt;Observer&gt; obs; <span class=\"comment\">// 观察者列表</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//构造函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Observable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        obs = <span class=\"keyword\">new</span> Vector&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//添加观察者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">addObserver</span><span class=\"params\">(Observer o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!obs.contains(o)) &#123;</span><br><span class=\"line\">            obs.addElement(o);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除某一个观察者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteObserver</span><span class=\"params\">(Observer o)</span> </span>&#123;</span><br><span class=\"line\">        obs.removeElement(o);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通知观察者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyObservers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        notifyObservers(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果changed = true 意味着数据被修改，通知每个观察者。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyObservers</span><span class=\"params\">(Object arg)</span> </span>&#123;</span><br><span class=\"line\">        Object[] arrLocal;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!changed)</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            arrLocal = obs.toArray();</span><br><span class=\"line\">            clearChanged();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = arrLocal.length-<span class=\"number\">1</span>; i&gt;=<span class=\"number\">0</span>; i--)</span><br><span class=\"line\">            ((Observer)arrLocal[i]).update(<span class=\"keyword\">this</span>, arg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除所有观察者</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteObservers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        obs.removeAllElements();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置changed值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">setChanged</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        changed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 清除changed值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">clearChanged</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        changed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取changed值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasChanged</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> changed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回观察者个数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">int</span> <span class=\"title\">countObservers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obs.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Observable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeatherData</span> <span class=\"keyword\">extends</span> <span class=\"title\">Observable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 温度</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> temperature;</span><br><span class=\"line\">    <span class=\"comment\">// 湿度</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> humidity;</span><br><span class=\"line\">    <span class=\"comment\">// 气压</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> pressure;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeatherData</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当从气象站得到更新观测值时，我们通知观察者。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">measurementsChanged</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        setChanged();</span><br><span class=\"line\">        notifyObservers();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMeasurements</span><span class=\"params\">(<span class=\"keyword\">float</span> temperature, <span class=\"keyword\">float</span> humidity, <span class=\"keyword\">float</span> pressure)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.temperature = temperature;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.humidity = humidity;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.pressure = pressure;</span><br><span class=\"line\">        measurementsChanged();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//使用“拉”的做法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">getTemperature</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> temperature;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">getHumidity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> humidity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">getPressure</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pressure;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//其他方法省略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Observable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Observer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CurrentConditionsDisplay</span> <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span>, <span class=\"title\">DisplayElement</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> temperature;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> humidity;</span><br><span class=\"line\"></span><br><span class=\"line\">    Observable observable;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CurrentConditionsDisplay</span><span class=\"params\">(Observable observable)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.observable = observable;</span><br><span class=\"line\">        observable.addObserver(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Current conditions: \"</span> + temperature + <span class=\"string\">\"F degrees and \"</span> + humidity + <span class=\"string\">\"% humidity\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(Observable o, Object arg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> WeatherData) &#123;</span><br><span class=\"line\">            WeatherData weatherData = (WeatherData)o;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.temperature = weatherData.getTemperature();</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.humidity = weatherData.getHumidity();</span><br><span class=\"line\">            display();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试代码和测试结果同上</p>\n<h3 id=\"java-util-Observable的缺点\"><a href=\"#java-util-Observable的缺点\" class=\"headerlink\" title=\"java.util.Observable的缺点\"></a>java.util.Observable的缺点</h3><p>java.util.Observable的实现 有许多问题，限制了它的使用和复用。</p>\n<ul>\n<li>观察者是一个“类”而不是一个“接 口”<ul>\n<li>你必须设计一个类继承它。如果某类想同时 具有Observable类和另一个超类的行为，就会陷入两难，毕竟Java不支持多重继承。</li>\n</ul>\n</li>\n<li>Observable将关键的方法保护起来<ul>\n<li>setChanged()方法被保护起来了(被定义成 protected)。这意味着:除非你继承自Observable，否则你无法创建Observable实例并组合到你自己的对象中来。这个设计违反了第二个设计原 则:“多用组合，少用继承”。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h2><ul>\n<li>观察者模式定义了对象之间一对多的关系。</li>\n<li>主题(也就是可观察者)用一个共同的接口来更新观察者。</li>\n<li>观察者和可观察者之间用松耦合方式结合(loosecoupl- ing)，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。</li>\n<li>使用此模式时，你可从被观察者处推(push)或拉(pull)数据(然而，推的方式被认为更“正确”)。</li>\n<li>有多个观察者时，不可以依赖特定的通知次序。</li>\n<li>Java有多种观察者模式的实现，包括了通用的java.util.Observable。</li>\n<li>要注意java.util.Observable实现上所带来的一些问题。</li>\n<li>如果有必要的话，可以实现自己的Observable。</li>\n<li>Swing大量使用观察者模式，许多GUI框架也是如此。</li>\n<li>此模式也被应用在许多地方，例如:JavaBeans、RMI。</li>\n</ul>"},{"title":"设计模式-策略模式","date":"2019-12-13T04:00:04.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"## 什么是策略模式\n策略这个词应该怎么理解，打个比方说，我们出门的时候会选择不同的出行方式，比如骑自行车、坐公交、坐火车、坐飞机、坐火箭等等，这些出行方式，每一种都是一个策略。\n\n再比如我们去逛商场，商场现在正在搞活动，有打折的、有满减的、有返利的等等，其实不管商场如何进行促销，说到底都是一些算法，这些算法本身只是一种策略，并且这些算法是随时都可能互相替换的，比如针对同一件商品，今天打八折、明天满100减30，这些策略间是可以互换的。\n\n**策略模式（Strategy）**，定义了一组算法，将每个算法都封装起来，并且使它们之间可以互换。\n<!-- more -->\n## 示例\n\n### 模拟鸭子项目\n![](Design-Pattern-Strategy/1.png)\n```java\n\npublic abstract class Duck {\t\n    public void Quack() {\t\n        System.out.println(\"~~gaga~~\");\n    }\n    public abstract void display();\n    public void swim() {\t\n        System.out.println(\"~~im swim~~\");\n    }\n}\n\n```\nGreenHeadDuck继承Duck ：\n```java\n\npublic class GreenHeadDuck extends Duck {\t\n    @Override\t\n    public void display() {\t\n          System.out.println(\"**GreenHead**\");\n    }\n}\n```\n### 新需求\n\n添加会飞的鸭子\n\n```java\npublic abstract class Duck {\n        //...;\n\t public void Fly() {\t\n\t \tSystem.out.println(\"~~im fly~~\");\n\t }\n}\n```\n问题来了,这个Fly让所有子类都会飞了，这是不科学的。并非Duck所有的子类都会飞。在Duck超类中加上新的行为，会使得某些并不适合该行为的子类也具有该行为。\n这个导致，后面几十个鸭子不没有这个功能，不会飞，那么他们的都要去实现。工作量大，而且重复劳动。\n所以：超类挖的一个坑，每个子类都要来填，增加工作量，复杂度O(N^2)。不是好的设计方式\n\n### 用策略模式来解决新需求\n需要新的设计方式，应对项目的扩展性，降低复杂度：\n\n1）分析项目变化与不变部分，提取变化部分，然后把变化的部分抽象成接口+实现；\n\n2）鸭子哪些功能是会根据新需求变化的？叫声、飞行...\n\n![](Design-Pattern-Strategy/2.png)\n\n### 重新设计模拟鸭子项目\n\n```java\npublic abstract class Duck {\t\n    FlyBehavior mFlyBehavior;\n    QuackBehavior mQuackBehavior;\n    public Duck() { }\n    public void Fly() {\t\n        mFlyBehavior.fly();\n    }\n    public void Quack() {\t\n        mQuackBehavior.quack();\n    }\n    public abstract void display();\n}\n\n\npublic class GreenHeadDuck extends Duck {\n    public GreenHeadDuck() {\n        mFlyBehavior = new GoodFlyBehavior();\n        mQuackBehavior = new GaGaQuackBehavior();\n    }\n    @Override\n    public void display() {\n        System.out.println(\"I’m a real GreenHeadDuck\");\n    }\n}\n\n```\n## 总结\n1. 分析项目中变化部分与不变部分（方法论）——>这个方法论不仅是策略模式中才可以用的，用来分析项目中变法的何不变化的，变化的就可以怎么来抽取替换。而且变化的抽离出来的行为族，行为族之间是可以来相互替换的。\n\n2. 多用组合少用继承；用行为类组合，而不是行为的继承。更有弹性\n\n## 策略模式中的设计原则\n1. 开闭原则（Open-Closed Principle，缩写为OCP）\n    * 一个软件实体应当对扩展开放(例如对抽象层的扩展)，对修改关闭(例如对抽象层的修改)。即在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。\n    * 开闭原则的关键，在于抽象。策略模式，是开闭原则的一个极好的应用范例。\n\n2. 里氏替换原则（Liskov Substitution Principle，缩写为LSP）\n    * 里氏替换原则里一个软件实体如果使用的是**一个基类的话，那么一定适用于其子类，而且它根本不能察觉到基类对象和子类对象的区别。** 比如，假设有两个类，一个是Base类，一个是Derived类，并且Derived类是Base类的子类。那么一个方法如果可以接受一个基类对象b的话：method1(Base b)，那么它必然可以接受一个子类对象d，也即可以有method1(d)。反之，则不一定成立。\n    * 里氏替换原则讲的是基类与子类的关系。只有当这种关系存在时，里氏替换关系才存在，反之则不存在。\n    * 策略模式之所以可行的基础便是里氏替换原则：策略模式要求所有的策略对象都是可以互换的，因此它们都必须是一个抽象策略角色的子类。在客户端则仅知道抽象策略角色类型，虽然变量的真实类型可以是任何一个具体策略角色的实例。\n","source":"_posts/Design-Pattern-Strategy.md","raw":"---\ntitle: 设计模式-策略模式\ndate: 2019-12-13 12:00:04\ntags:\n    - 设计模式\ncategories: 设计模式\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n## 什么是策略模式\n策略这个词应该怎么理解，打个比方说，我们出门的时候会选择不同的出行方式，比如骑自行车、坐公交、坐火车、坐飞机、坐火箭等等，这些出行方式，每一种都是一个策略。\n\n再比如我们去逛商场，商场现在正在搞活动，有打折的、有满减的、有返利的等等，其实不管商场如何进行促销，说到底都是一些算法，这些算法本身只是一种策略，并且这些算法是随时都可能互相替换的，比如针对同一件商品，今天打八折、明天满100减30，这些策略间是可以互换的。\n\n**策略模式（Strategy）**，定义了一组算法，将每个算法都封装起来，并且使它们之间可以互换。\n<!-- more -->\n## 示例\n\n### 模拟鸭子项目\n![](Design-Pattern-Strategy/1.png)\n```java\n\npublic abstract class Duck {\t\n    public void Quack() {\t\n        System.out.println(\"~~gaga~~\");\n    }\n    public abstract void display();\n    public void swim() {\t\n        System.out.println(\"~~im swim~~\");\n    }\n}\n\n```\nGreenHeadDuck继承Duck ：\n```java\n\npublic class GreenHeadDuck extends Duck {\t\n    @Override\t\n    public void display() {\t\n          System.out.println(\"**GreenHead**\");\n    }\n}\n```\n### 新需求\n\n添加会飞的鸭子\n\n```java\npublic abstract class Duck {\n        //...;\n\t public void Fly() {\t\n\t \tSystem.out.println(\"~~im fly~~\");\n\t }\n}\n```\n问题来了,这个Fly让所有子类都会飞了，这是不科学的。并非Duck所有的子类都会飞。在Duck超类中加上新的行为，会使得某些并不适合该行为的子类也具有该行为。\n这个导致，后面几十个鸭子不没有这个功能，不会飞，那么他们的都要去实现。工作量大，而且重复劳动。\n所以：超类挖的一个坑，每个子类都要来填，增加工作量，复杂度O(N^2)。不是好的设计方式\n\n### 用策略模式来解决新需求\n需要新的设计方式，应对项目的扩展性，降低复杂度：\n\n1）分析项目变化与不变部分，提取变化部分，然后把变化的部分抽象成接口+实现；\n\n2）鸭子哪些功能是会根据新需求变化的？叫声、飞行...\n\n![](Design-Pattern-Strategy/2.png)\n\n### 重新设计模拟鸭子项目\n\n```java\npublic abstract class Duck {\t\n    FlyBehavior mFlyBehavior;\n    QuackBehavior mQuackBehavior;\n    public Duck() { }\n    public void Fly() {\t\n        mFlyBehavior.fly();\n    }\n    public void Quack() {\t\n        mQuackBehavior.quack();\n    }\n    public abstract void display();\n}\n\n\npublic class GreenHeadDuck extends Duck {\n    public GreenHeadDuck() {\n        mFlyBehavior = new GoodFlyBehavior();\n        mQuackBehavior = new GaGaQuackBehavior();\n    }\n    @Override\n    public void display() {\n        System.out.println(\"I’m a real GreenHeadDuck\");\n    }\n}\n\n```\n## 总结\n1. 分析项目中变化部分与不变部分（方法论）——>这个方法论不仅是策略模式中才可以用的，用来分析项目中变法的何不变化的，变化的就可以怎么来抽取替换。而且变化的抽离出来的行为族，行为族之间是可以来相互替换的。\n\n2. 多用组合少用继承；用行为类组合，而不是行为的继承。更有弹性\n\n## 策略模式中的设计原则\n1. 开闭原则（Open-Closed Principle，缩写为OCP）\n    * 一个软件实体应当对扩展开放(例如对抽象层的扩展)，对修改关闭(例如对抽象层的修改)。即在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。\n    * 开闭原则的关键，在于抽象。策略模式，是开闭原则的一个极好的应用范例。\n\n2. 里氏替换原则（Liskov Substitution Principle，缩写为LSP）\n    * 里氏替换原则里一个软件实体如果使用的是**一个基类的话，那么一定适用于其子类，而且它根本不能察觉到基类对象和子类对象的区别。** 比如，假设有两个类，一个是Base类，一个是Derived类，并且Derived类是Base类的子类。那么一个方法如果可以接受一个基类对象b的话：method1(Base b)，那么它必然可以接受一个子类对象d，也即可以有method1(d)。反之，则不一定成立。\n    * 里氏替换原则讲的是基类与子类的关系。只有当这种关系存在时，里氏替换关系才存在，反之则不存在。\n    * 策略模式之所以可行的基础便是里氏替换原则：策略模式要求所有的策略对象都是可以互换的，因此它们都必须是一个抽象策略角色的子类。在客户端则仅知道抽象策略角色类型，虽然变量的真实类型可以是任何一个具体策略角色的实例。\n","slug":"Design-Pattern-Strategy","published":1,"updated":"2020-01-22T09:31:30.365Z","layout":"post","photos":[],"link":"","_id":"ck8fb4a8r000mk2o5q3lvjr2d","content":"<h2 id=\"什么是策略模式\"><a href=\"#什么是策略模式\" class=\"headerlink\" title=\"什么是策略模式\"></a>什么是策略模式</h2><p>策略这个词应该怎么理解，打个比方说，我们出门的时候会选择不同的出行方式，比如骑自行车、坐公交、坐火车、坐飞机、坐火箭等等，这些出行方式，每一种都是一个策略。</p>\n<p>再比如我们去逛商场，商场现在正在搞活动，有打折的、有满减的、有返利的等等，其实不管商场如何进行促销，说到底都是一些算法，这些算法本身只是一种策略，并且这些算法是随时都可能互相替换的，比如针对同一件商品，今天打八折、明天满100减30，这些策略间是可以互换的。</p>\n<p><strong>策略模式（Strategy）</strong>，定义了一组算法，将每个算法都封装起来，并且使它们之间可以互换。</p>\n<a id=\"more\"></a>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><h3 id=\"模拟鸭子项目\"><a href=\"#模拟鸭子项目\" class=\"headerlink\" title=\"模拟鸭子项目\"></a>模拟鸭子项目</h3><p><img src=\"/设计模式/Design-Pattern-Strategy/1.png\" alt=\"\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Duck</span> </span>&#123;\t</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Quack</span><span class=\"params\">()</span> </span>&#123;\t</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"~~gaga~~\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">swim</span><span class=\"params\">()</span> </span>&#123;\t</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"~~im swim~~\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>GreenHeadDuck继承Duck ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreenHeadDuck</span> <span class=\"keyword\">extends</span> <span class=\"title\">Duck</span> </span>&#123;\t</span><br><span class=\"line\">    <span class=\"meta\">@Override</span>\t</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;\t</span><br><span class=\"line\">          System.out.println(<span class=\"string\">\"**GreenHead**\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"新需求\"><a href=\"#新需求\" class=\"headerlink\" title=\"新需求\"></a>新需求</h3><p>添加会飞的鸭子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Duck</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...;</span></span><br><span class=\"line\">\t <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Fly</span><span class=\"params\">()</span> </span>&#123;\t</span><br><span class=\"line\">\t \tSystem.out.println(<span class=\"string\">\"~~im fly~~\"</span>);</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>问题来了,这个Fly让所有子类都会飞了，这是不科学的。并非Duck所有的子类都会飞。在Duck超类中加上新的行为，会使得某些并不适合该行为的子类也具有该行为。<br>这个导致，后面几十个鸭子不没有这个功能，不会飞，那么他们的都要去实现。工作量大，而且重复劳动。<br>所以：超类挖的一个坑，每个子类都要来填，增加工作量，复杂度O(N^2)。不是好的设计方式</p>\n<h3 id=\"用策略模式来解决新需求\"><a href=\"#用策略模式来解决新需求\" class=\"headerlink\" title=\"用策略模式来解决新需求\"></a>用策略模式来解决新需求</h3><p>需要新的设计方式，应对项目的扩展性，降低复杂度：</p>\n<p>1）分析项目变化与不变部分，提取变化部分，然后把变化的部分抽象成接口+实现；</p>\n<p>2）鸭子哪些功能是会根据新需求变化的？叫声、飞行…</p>\n<p><img src=\"/设计模式/Design-Pattern-Strategy/2.png\" alt=\"\"></p>\n<h3 id=\"重新设计模拟鸭子项目\"><a href=\"#重新设计模拟鸭子项目\" class=\"headerlink\" title=\"重新设计模拟鸭子项目\"></a>重新设计模拟鸭子项目</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Duck</span> </span>&#123;\t</span><br><span class=\"line\">    FlyBehavior mFlyBehavior;</span><br><span class=\"line\">    QuackBehavior mQuackBehavior;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Duck</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Fly</span><span class=\"params\">()</span> </span>&#123;\t</span><br><span class=\"line\">        mFlyBehavior.fly();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Quack</span><span class=\"params\">()</span> </span>&#123;\t</span><br><span class=\"line\">        mQuackBehavior.quack();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreenHeadDuck</span> <span class=\"keyword\">extends</span> <span class=\"title\">Duck</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GreenHeadDuck</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        mFlyBehavior = <span class=\"keyword\">new</span> GoodFlyBehavior();</span><br><span class=\"line\">        mQuackBehavior = <span class=\"keyword\">new</span> GaGaQuackBehavior();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"I’m a real GreenHeadDuck\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li><p>分析项目中变化部分与不变部分（方法论）——&gt;这个方法论不仅是策略模式中才可以用的，用来分析项目中变法的何不变化的，变化的就可以怎么来抽取替换。而且变化的抽离出来的行为族，行为族之间是可以来相互替换的。</p>\n</li>\n<li><p>多用组合少用继承；用行为类组合，而不是行为的继承。更有弹性</p>\n</li>\n</ol>\n<h2 id=\"策略模式中的设计原则\"><a href=\"#策略模式中的设计原则\" class=\"headerlink\" title=\"策略模式中的设计原则\"></a>策略模式中的设计原则</h2><ol>\n<li><p>开闭原则（Open-Closed Principle，缩写为OCP）</p>\n<ul>\n<li>一个软件实体应当对扩展开放(例如对抽象层的扩展)，对修改关闭(例如对抽象层的修改)。即在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。</li>\n<li>开闭原则的关键，在于抽象。策略模式，是开闭原则的一个极好的应用范例。</li>\n</ul>\n</li>\n<li><p>里氏替换原则（Liskov Substitution Principle，缩写为LSP）</p>\n<ul>\n<li>里氏替换原则里一个软件实体如果使用的是<strong>一个基类的话，那么一定适用于其子类，而且它根本不能察觉到基类对象和子类对象的区别。</strong> 比如，假设有两个类，一个是Base类，一个是Derived类，并且Derived类是Base类的子类。那么一个方法如果可以接受一个基类对象b的话：method1(Base b)，那么它必然可以接受一个子类对象d，也即可以有method1(d)。反之，则不一定成立。</li>\n<li>里氏替换原则讲的是基类与子类的关系。只有当这种关系存在时，里氏替换关系才存在，反之则不存在。</li>\n<li>策略模式之所以可行的基础便是里氏替换原则：策略模式要求所有的策略对象都是可以互换的，因此它们都必须是一个抽象策略角色的子类。在客户端则仅知道抽象策略角色类型，虽然变量的真实类型可以是任何一个具体策略角色的实例。</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是策略模式\"><a href=\"#什么是策略模式\" class=\"headerlink\" title=\"什么是策略模式\"></a>什么是策略模式</h2><p>策略这个词应该怎么理解，打个比方说，我们出门的时候会选择不同的出行方式，比如骑自行车、坐公交、坐火车、坐飞机、坐火箭等等，这些出行方式，每一种都是一个策略。</p>\n<p>再比如我们去逛商场，商场现在正在搞活动，有打折的、有满减的、有返利的等等，其实不管商场如何进行促销，说到底都是一些算法，这些算法本身只是一种策略，并且这些算法是随时都可能互相替换的，比如针对同一件商品，今天打八折、明天满100减30，这些策略间是可以互换的。</p>\n<p><strong>策略模式（Strategy）</strong>，定义了一组算法，将每个算法都封装起来，并且使它们之间可以互换。</p>","more":"<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><h3 id=\"模拟鸭子项目\"><a href=\"#模拟鸭子项目\" class=\"headerlink\" title=\"模拟鸭子项目\"></a>模拟鸭子项目</h3><p><img src=\"/设计模式/Design-Pattern-Strategy/1.png\" alt=\"\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Duck</span> </span>&#123;\t</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Quack</span><span class=\"params\">()</span> </span>&#123;\t</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"~~gaga~~\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">swim</span><span class=\"params\">()</span> </span>&#123;\t</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"~~im swim~~\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>GreenHeadDuck继承Duck ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreenHeadDuck</span> <span class=\"keyword\">extends</span> <span class=\"title\">Duck</span> </span>&#123;\t</span><br><span class=\"line\">    <span class=\"meta\">@Override</span>\t</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;\t</span><br><span class=\"line\">          System.out.println(<span class=\"string\">\"**GreenHead**\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"新需求\"><a href=\"#新需求\" class=\"headerlink\" title=\"新需求\"></a>新需求</h3><p>添加会飞的鸭子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Duck</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...;</span></span><br><span class=\"line\">\t <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Fly</span><span class=\"params\">()</span> </span>&#123;\t</span><br><span class=\"line\">\t \tSystem.out.println(<span class=\"string\">\"~~im fly~~\"</span>);</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>问题来了,这个Fly让所有子类都会飞了，这是不科学的。并非Duck所有的子类都会飞。在Duck超类中加上新的行为，会使得某些并不适合该行为的子类也具有该行为。<br>这个导致，后面几十个鸭子不没有这个功能，不会飞，那么他们的都要去实现。工作量大，而且重复劳动。<br>所以：超类挖的一个坑，每个子类都要来填，增加工作量，复杂度O(N^2)。不是好的设计方式</p>\n<h3 id=\"用策略模式来解决新需求\"><a href=\"#用策略模式来解决新需求\" class=\"headerlink\" title=\"用策略模式来解决新需求\"></a>用策略模式来解决新需求</h3><p>需要新的设计方式，应对项目的扩展性，降低复杂度：</p>\n<p>1）分析项目变化与不变部分，提取变化部分，然后把变化的部分抽象成接口+实现；</p>\n<p>2）鸭子哪些功能是会根据新需求变化的？叫声、飞行…</p>\n<p><img src=\"/设计模式/Design-Pattern-Strategy/2.png\" alt=\"\"></p>\n<h3 id=\"重新设计模拟鸭子项目\"><a href=\"#重新设计模拟鸭子项目\" class=\"headerlink\" title=\"重新设计模拟鸭子项目\"></a>重新设计模拟鸭子项目</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Duck</span> </span>&#123;\t</span><br><span class=\"line\">    FlyBehavior mFlyBehavior;</span><br><span class=\"line\">    QuackBehavior mQuackBehavior;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Duck</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Fly</span><span class=\"params\">()</span> </span>&#123;\t</span><br><span class=\"line\">        mFlyBehavior.fly();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Quack</span><span class=\"params\">()</span> </span>&#123;\t</span><br><span class=\"line\">        mQuackBehavior.quack();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreenHeadDuck</span> <span class=\"keyword\">extends</span> <span class=\"title\">Duck</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GreenHeadDuck</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        mFlyBehavior = <span class=\"keyword\">new</span> GoodFlyBehavior();</span><br><span class=\"line\">        mQuackBehavior = <span class=\"keyword\">new</span> GaGaQuackBehavior();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"I’m a real GreenHeadDuck\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li><p>分析项目中变化部分与不变部分（方法论）——&gt;这个方法论不仅是策略模式中才可以用的，用来分析项目中变法的何不变化的，变化的就可以怎么来抽取替换。而且变化的抽离出来的行为族，行为族之间是可以来相互替换的。</p>\n</li>\n<li><p>多用组合少用继承；用行为类组合，而不是行为的继承。更有弹性</p>\n</li>\n</ol>\n<h2 id=\"策略模式中的设计原则\"><a href=\"#策略模式中的设计原则\" class=\"headerlink\" title=\"策略模式中的设计原则\"></a>策略模式中的设计原则</h2><ol>\n<li><p>开闭原则（Open-Closed Principle，缩写为OCP）</p>\n<ul>\n<li>一个软件实体应当对扩展开放(例如对抽象层的扩展)，对修改关闭(例如对抽象层的修改)。即在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。</li>\n<li>开闭原则的关键，在于抽象。策略模式，是开闭原则的一个极好的应用范例。</li>\n</ul>\n</li>\n<li><p>里氏替换原则（Liskov Substitution Principle，缩写为LSP）</p>\n<ul>\n<li>里氏替换原则里一个软件实体如果使用的是<strong>一个基类的话，那么一定适用于其子类，而且它根本不能察觉到基类对象和子类对象的区别。</strong> 比如，假设有两个类，一个是Base类，一个是Derived类，并且Derived类是Base类的子类。那么一个方法如果可以接受一个基类对象b的话：method1(Base b)，那么它必然可以接受一个子类对象d，也即可以有method1(d)。反之，则不一定成立。</li>\n<li>里氏替换原则讲的是基类与子类的关系。只有当这种关系存在时，里氏替换关系才存在，反之则不存在。</li>\n<li>策略模式之所以可行的基础便是里氏替换原则：策略模式要求所有的策略对象都是可以互换的，因此它们都必须是一个抽象策略角色的子类。在客户端则仅知道抽象策略角色类型，虽然变量的真实类型可以是任何一个具体策略角色的实例。</li>\n</ul>\n</li>\n</ol>"},{"title":"Guava-总结","date":"2019-10-24T02:55:04.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"### 项目相关信息\n官方首页：http://code.google.com/p/guava-libraries\n英文文档：http://www.ostools.net/apidocs/apidoc?api=guava\n中文文档：https://www.kancloud.cn/wizardforcel/java-opensource-doc/112616\n<!-- more -->\n### 博客\n* [Guava 学习笔记：Google Guava 类库简介](http://www.iocoder.cn/Guava/peida/intro/)\n* [Guava 学习笔记：Optional 优雅的使用null](http://www.iocoder.cn/Guava/peida/Optional/)\n* [Guava学习笔记：Preconditions优雅的检验参数](http://www.iocoder.cn/Guava/peida/Preconditions/)\n* [Guava学习笔记：复写的Object常用方法](http://www.iocoder.cn/Guava/peida/Object/)\n* [Guava学习笔记：Ordering犀利的比较器](https://www.cnblogs.com/peida/p/Guava_Ordering.html)\n* [Guava学习笔记：简化异常处理的Throwables类](http://www.iocoder.cn/Guava/peida/Throwables/)\n* [Guava学习笔记：Immutable(不可变)集合](http://www.iocoder.cn/Guava/peida/Immutable_Collections/)\n* [Guava学习笔记：Guava新增集合类型-Multiset](http://www.iocoder.cn/Guava/peida/Multiset/)\n* [Guava 学习笔记：Guava 新增集合类型 —— Multimap](http://www.iocoder.cn/Guava/peida/Multimap/)\n* [Guava学习笔记：Guava新增集合类型-Bimap](http://www.iocoder.cn/Guava/peida/Bimap/)\n* [Guava学习笔记：Guava新集合-Table等](http://www.iocoder.cn/Guava/peida/Table/)\n* [Guava学习笔记：Guava cache](http://www.iocoder.cn/Guava/peida/Cache/)\n* [Guava学习笔记：EventBus](http://www.iocoder.cn/Guava/peida/EventBus/)\n* [Guava学习笔记：Range](http://www.iocoder.cn/Guava/peida/Range/)\n","source":"_posts/Guava.md","raw":"---\ntitle: Guava-总结\ndate: 2019-10-24 10:55:04\ntags:\n    - JAVA\n    - GUAVA\ncategories: GUAVA\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n### 项目相关信息\n官方首页：http://code.google.com/p/guava-libraries\n英文文档：http://www.ostools.net/apidocs/apidoc?api=guava\n中文文档：https://www.kancloud.cn/wizardforcel/java-opensource-doc/112616\n<!-- more -->\n### 博客\n* [Guava 学习笔记：Google Guava 类库简介](http://www.iocoder.cn/Guava/peida/intro/)\n* [Guava 学习笔记：Optional 优雅的使用null](http://www.iocoder.cn/Guava/peida/Optional/)\n* [Guava学习笔记：Preconditions优雅的检验参数](http://www.iocoder.cn/Guava/peida/Preconditions/)\n* [Guava学习笔记：复写的Object常用方法](http://www.iocoder.cn/Guava/peida/Object/)\n* [Guava学习笔记：Ordering犀利的比较器](https://www.cnblogs.com/peida/p/Guava_Ordering.html)\n* [Guava学习笔记：简化异常处理的Throwables类](http://www.iocoder.cn/Guava/peida/Throwables/)\n* [Guava学习笔记：Immutable(不可变)集合](http://www.iocoder.cn/Guava/peida/Immutable_Collections/)\n* [Guava学习笔记：Guava新增集合类型-Multiset](http://www.iocoder.cn/Guava/peida/Multiset/)\n* [Guava 学习笔记：Guava 新增集合类型 —— Multimap](http://www.iocoder.cn/Guava/peida/Multimap/)\n* [Guava学习笔记：Guava新增集合类型-Bimap](http://www.iocoder.cn/Guava/peida/Bimap/)\n* [Guava学习笔记：Guava新集合-Table等](http://www.iocoder.cn/Guava/peida/Table/)\n* [Guava学习笔记：Guava cache](http://www.iocoder.cn/Guava/peida/Cache/)\n* [Guava学习笔记：EventBus](http://www.iocoder.cn/Guava/peida/EventBus/)\n* [Guava学习笔记：Range](http://www.iocoder.cn/Guava/peida/Range/)\n","slug":"Guava","published":1,"updated":"2020-01-22T09:31:30.365Z","layout":"post","photos":[],"link":"","_id":"ck8fb4a8t000ok2o5lm4sj09p","content":"<h3 id=\"项目相关信息\"><a href=\"#项目相关信息\" class=\"headerlink\" title=\"项目相关信息\"></a>项目相关信息</h3><p>官方首页：<a href=\"http://code.google.com/p/guava-libraries\" target=\"_blank\" rel=\"noopener\">http://code.google.com/p/guava-libraries</a><br>英文文档：<a href=\"http://www.ostools.net/apidocs/apidoc?api=guava\" target=\"_blank\" rel=\"noopener\">http://www.ostools.net/apidocs/apidoc?api=guava</a><br>中文文档：<a href=\"https://www.kancloud.cn/wizardforcel/java-opensource-doc/112616\" target=\"_blank\" rel=\"noopener\">https://www.kancloud.cn/wizardforcel/java-opensource-doc/112616</a></p>\n<a id=\"more\"></a>\n<h3 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h3><ul>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/intro/\" target=\"_blank\" rel=\"noopener\">Guava 学习笔记：Google Guava 类库简介</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Optional/\" target=\"_blank\" rel=\"noopener\">Guava 学习笔记：Optional 优雅的使用null</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Preconditions/\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：Preconditions优雅的检验参数</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Object/\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：复写的Object常用方法</a></li>\n<li><a href=\"https://www.cnblogs.com/peida/p/Guava_Ordering.html\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：Ordering犀利的比较器</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Throwables/\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：简化异常处理的Throwables类</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Immutable_Collections/\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：Immutable(不可变)集合</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Multiset/\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：Guava新增集合类型-Multiset</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Multimap/\" target=\"_blank\" rel=\"noopener\">Guava 学习笔记：Guava 新增集合类型 —— Multimap</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Bimap/\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：Guava新增集合类型-Bimap</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Table/\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：Guava新集合-Table等</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Cache/\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：Guava cache</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/EventBus/\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：EventBus</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Range/\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：Range</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"项目相关信息\"><a href=\"#项目相关信息\" class=\"headerlink\" title=\"项目相关信息\"></a>项目相关信息</h3><p>官方首页：<a href=\"http://code.google.com/p/guava-libraries\" target=\"_blank\" rel=\"noopener\">http://code.google.com/p/guava-libraries</a><br>英文文档：<a href=\"http://www.ostools.net/apidocs/apidoc?api=guava\" target=\"_blank\" rel=\"noopener\">http://www.ostools.net/apidocs/apidoc?api=guava</a><br>中文文档：<a href=\"https://www.kancloud.cn/wizardforcel/java-opensource-doc/112616\" target=\"_blank\" rel=\"noopener\">https://www.kancloud.cn/wizardforcel/java-opensource-doc/112616</a></p>","more":"<h3 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h3><ul>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/intro/\" target=\"_blank\" rel=\"noopener\">Guava 学习笔记：Google Guava 类库简介</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Optional/\" target=\"_blank\" rel=\"noopener\">Guava 学习笔记：Optional 优雅的使用null</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Preconditions/\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：Preconditions优雅的检验参数</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Object/\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：复写的Object常用方法</a></li>\n<li><a href=\"https://www.cnblogs.com/peida/p/Guava_Ordering.html\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：Ordering犀利的比较器</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Throwables/\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：简化异常处理的Throwables类</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Immutable_Collections/\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：Immutable(不可变)集合</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Multiset/\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：Guava新增集合类型-Multiset</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Multimap/\" target=\"_blank\" rel=\"noopener\">Guava 学习笔记：Guava 新增集合类型 —— Multimap</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Bimap/\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：Guava新增集合类型-Bimap</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Table/\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：Guava新集合-Table等</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Cache/\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：Guava cache</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/EventBus/\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：EventBus</a></li>\n<li><a href=\"http://www.iocoder.cn/Guava/peida/Range/\" target=\"_blank\" rel=\"noopener\">Guava学习笔记：Range</a></li>\n</ul>"},{"title":"Mac下利用Github Pages快速搭建免费博客","date":"2019-01-30T11:30:04.000Z","author":"Guyuqing","copyright":true,"comments":1,"_content":"本博客利用Hexo + Next + GitHubPages 搭建博客。\n\n## 准备工作\n\n### 安装node.js\n\n``` bash\n$ brew install node\n```\n\n### 安装 git\n\n``` bash\n$ brew install git\n```\n<!-- more -->\n\n### 安装yarn\n\n``` bash\n$ npm install yarn\n```\n\n如果安装失败用\n\n``` bash\n$ brew install yarn\n```\n\n### 安装hexo\n\n进入你的项目目录，举个例子我的目录是blog\n\n``` bash\n$ cd blog\n```\n\n然后用 yarn 安装 hexo\n\n``` bash\n$ yarn add hexo -S\n```\n\n如果安装失败用\n\n``` bash\n$ npm install hexo-cli -g\n$ npm install hexo-server --save\n```\n详细可见[官方文档](https://hexo.io/zh-cn/docs/)\n\n## 搭建本地博客\n\n### 项目初始化\n\n进入你的项目目录,初始化hexo\n\n``` bash\n$ cd blog\n$ hexo init\n```\n### 安装依赖\n\n``` bash\n$ yarn install\n```\n### 启动本地服务\n\n``` bash\n$ hexo server\n```\n在浏览器输入 `localhost:4000` 即可\n\n## 关联 GitHub\n### 创建项目\n\n![创建项目](Github-Pages-Blog/create-project.png)\n\n项目名称一定一定是 `[用户名].github.io`\n![创建项目](Github-Pages-Blog/create-repository.png)\n\n### 设置\n\n![设置](Github-Pages-Blog/setting.png)\n\n在设置中找到GitHub Pages ，分支选择master，点击choose a theme\n\n![设置github-pages](Github-Pages-Blog/github-pages.png)\n\n选择喜欢的主题，点击select theme即可\n![选择主题](Github-Pages-Blog/select-theme.png)\n\n到这里就可以访问你的主页啦  `https://[用户名].github.io/`,接下来复制你的项目链接\n\n![复制项目链接](Github-Pages-Blog/copy-url.png)\n\n到你的本地项目根目录找到 `_config.yml` 文件，粘贴到以下位置\n\n![hexo设置git](Github-Pages-Blog/deploy-position.png)\n\n### 站点配置\n站点配置包括修改博客名称，描述，作者等等，建议直接查看[官方教程](https://hexo.io/zh-cn/docs/configuration)\n\n### 关联\n\n安装 hexo-deployer-git 插件\n``` bash\n$ yarn add hexo-deployer-git -S\n```\n如果失败的话尝试下面的方法\n``` bash\n$ npm install --save hexo-deployer-git\n```\n在你的项目文件夹下运行 hexo d -g （生成本地文件并将本地文件推送到 GitHub ，和 git push 功能相同）,如果失败的话前面加sudo\n``` bash\n$  hexo d -g\n```\n这时访问你的github主页`https://[用户名].github.io/`就可以啦\n\n## NexT主题配置\nNexT 是一个高质量并且优雅的Hexo 主题。\n详细可见[官方文档](https://github.com/iissnan/hexo-theme-next/blob/master/README.cn.md)\n\n### 安装NexT主题\n在你的项目文件夹下，执行以下命令，安装NexT主题\n``` bash\n$ git clone https://github.com/iissnan/hexo-theme-next.git themes/next\n```\n更改项目根目录下`_config.yml` 文件，如下\n![更改主题](Github-Pages-Blog/change-theme.png)\n\n重新生成本地文件并推送到github\n``` bash\n$  hexo d -g\n```\n访问你的github主页`https://[用户名].github.io/`就可以看到啦\n\n### 主题配置\n\n`themes/next`文件夹下的`_config.yml`是主题的配置文件\nnext内置了4种主题方案，选择你喜欢的方案解开注释即可\n```yaml\n# ---------------------------------------------------------------\n# Scheme Settings\n# ---------------------------------------------------------------\n\n# Schemes\n#scheme: Muse\nscheme: Mist\n#scheme: Pisces\n#scheme: Gemini\n```\nMenu Settings是控制图中菜单的位置，根据需要解开注释即可\n```yaml\n# ---------------------------------------------------------------\n# Menu Settings\n# ---------------------------------------------------------------\nmenu:\n  home: / || home\n#  about: /about/ || user\n  tags: /tags/ || tags\n  categories: /categories/ || th\n#  archives: /archives/ || archive\n#  schedule: /schedule/ || calendar\n#  sitemap: /sitemap.xml || sitemap\n#  commonweal: /404.html || heartbeat\n```\n![更改菜单](Github-Pages-Blog/blog-icon.png)\n还有很多很多的配置请参考[官方教程](http://theme-next.iissnan.com/getting-started.html#install-next-theme),[主题个性配置教程](http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html),[主题美化](http://yearito.cn/posts/hexo-theme-beautify.html)\n\n修改之后，运行以下命令就可以再你的主页看到啦\n``` bash\n$  hexo clean\n$  hexo d -g\n```\n也可以在本地启动服务器，在浏览器输入 `localhost:4000` 观看效果\n``` bash\n$ hexo server\n```\n## 创建文章\n\n### 添加【标签】页面\n\n新建标签页面\n``` bash\n$ hexo new page tags\n```\n修改项目根目录下 source/tags 的 index.md 文件如下：\n``` markdown\ntitle: tags\ntype: \"tags\"\ncomments: false\n---\n```\n修改`themes/next`文件夹下的`_config.yml`主题配置文件，取消  `tags: /tags/ || tags` 这行注释\n新建测试文章\n``` bash\n$ hexo new 'test'\n```\n在测试文章的头部添加tags信息，如下：\n``` markdown\ntitle: 测试文章\ntags:\n  - Testing\n  - Another Tag\n---\n```\n启动本地服务，就可以看到标签菜单，点击可进入标签页，看到 如图所示 证明标签页面添加成功。\n![标签](Github-Pages-Blog/tags.png)\n\n### 添加【分类】页面\n新建标签页面\n``` bash\n$ hexo new page categories\n```\n修改项目根目录下 source/tags 的 index.md 文件如下：\n``` markdown\ntitle: categories\ntype: \"categories\"\ncomments: false\n---\n```\n修改`themes/next`文件夹下的`_config.yml`主题配置文件，取消  `categories: /categories/ || th` 这行注释\n在测试文章的头部添加categories信息，如下：\n``` markdown\ntitle: 测试文章\ntags:\n  - Testing\n  - Another Tag\n---\ncategories: Testing\n```\n启动本地服务，就可以看到标签菜单，点击可进入标签页，看到 如图所示 证明分类页面添加成功。\n![分类](Github-Pages-Blog/categories.png)\n\n### 给博客添加图片\n在项目目录下执行\n\n``` bash\n$ npm install hexo-asset-image --save\n```\n\n在用下面命令生成md文章时，会在_post目录下看到一个与文章同名的文件夹\n``` bash\n$ hexo new '文章名'\n```\n将想要上传的图片先放到文件夹下，然后在博客中使用markdown的格式引入图片：\n``` markdown\n ![文字](xxxx/图片名.jpg)\n```\n文章名和文件夹名字相同，所以不需要绝对路径，只要xxxx是文件夹的名字就可以了。\n\n### 添加Valine评论系统\n\n首先需要去注册一个[Leancloud](https://leancloud.cn/)账号,验证邮箱\n然后随便创建一个应用，按如图所示找到`appid`，`appkey`\n![评论](Github-Pages-Blog/valine.png)\n\n按下图修改`themes/next`文件夹下的`_config.yml`主题配置文件，重新启动服务器就可以啦\n``` yaml\n # Valine.\n # You can get your appid and appkey from https://leancloud.cn\n # more info please open https://valine.js.org\n valine:\n   enable: true\n   appid: your appid  # your leancloud application appid\n   appkey: your appkey # your leancloud application appkey\n   notify: false # mail notifier , https://github.com/xCss/Valine/wiki\n   verify: false # Verification code\n   placeholder: 描述  # comment box placeholder\n   avatar: monsterid # gravatar style\n   guest_info: nick,mail # custom comment header\n   pageSize: 10 # pagination size\n```\n如果要删除评论请到[Leancloud](https://leancloud.cn/)里删除哦\n![删除评论](Github-Pages-Blog/comment-delete.png)\n\n### hexo添加多作者\n在项目目录下执行\n\n``` bash\n$ npm install hexo-generator-author --save\n```\n\n在文章的头部添加author信息，如下：\n``` markdown\ntitle: 测试文章\ntags:\n  - Testing\n  - Another Tag\n---\nauthor: Alice\n```\n\n修改/layout/_macro/下的post.swig文件 +为新添加的行\n```swig\n         <div class=\"post-meta\">\n+          <span itemprop=\"about\" itemscope itemtype=\"https://schema.org/Thing\">\n+            <a href=\"/authors/{{ post.author }}\" itemprop=\"url\" rel=\"index\">\n+              <span itemprop=\"name\">{{ post.author }}</span>\n+            </a>\n+          </span>\n           <span class=\"post-time\">\n             <span class=\"post-meta-item-icon\">\n               <i class=\"fa fa-calendar-o\"></i>\n\n```\n在/layout下新创建author.swig文件\n```swig\n\n{% extends '_layout.swig' %}\n{% import '_macro/post-collapse.swig' as post_template %}\n{% import '_macro/sidebar.swig' as sidebar_template %}\n\n{% block title %} {{ __('title.author') }}: {{ page.author }} | {{ config.title }} {% endblock %}\n\n{% block content %}\n\n  <div class=\"post-block category\">\n\n    <div id=\"posts\" class=\"posts-collapse\">\n      <div class=\"collection-title\">\n\n        <{% if theme.seo %}h2{% else %}h1{% endif %}>{#\n        #}{{ page.author }}{#\n        #}<small>{{  __('title.author')  }}</small>\n        </{% if theme.seo %}h2{% else %}h1{% endif %}>\n      </div>\n\n      {% for post in page.posts %}\n        {{ post_template.render(post) }}\n      {% endfor %}\n    </div>\n\n  </div>\n\n  {% include '_partials/pagination.swig' %}\n\n{% endblock %}\n\n{% block sidebar %}\n  {{ sidebar_template.render(false) }}\n{% endblock %}\n\n```\n\n修改/layout下page.swig文件\n```swig\n\n     {{ __('title.category') + page_title_suffix }}\n   {% elif page.type === \"tags\" %}\n     {{ __('title.tag') + page_title_suffix }}\n+  {% elif page.type === \"authors\" %}\n+    {{ __('title.author') + page_title_suffix }}\n   {% else %}\n     {{ page.title + page_title_suffix }}\n   {% endif %}\n\n。。。。。。。\n           {{ list_categories() }}\n         </div>\n       </div>\n+    {% elif page.type === 'authors' %}\n+      <div class=\"author-all-page\">\n+        <div class=\"author-all-title\">\n+            {{ _p('counter.authors', site.authors.length) }}\n+        </div>\n+        <div class=\"author-all\">\n+          {{ list_authors() }}\n+        </div>\n+      </div>\n     {% else %}\n       {{ page.content }}\n     {% endif %}\n```\n修改{项目名称}/themes/next下zh-Hans.yml文件\n```yml\ntitle:\n  archive: 归档\n  category: 分类\n  tag: 标签\n  schedule: 日程表\n  author : 作者\n  \n。。。\n\ncounter:\n\n  authors:\n    zero: 暂无分类\n    one: 目前共计 1 个分类\n    other: \"目前共计 %d 个作者\"\n\n```\n\n在{项目名称}/themes/next/source/css/_common/components/pages/添加authors.styl，复制categories.styl内容将categorie改成author\n\n在同级文件pages.styl中添加@import \"authors\";\n\n修改之后，运行以下命令就可以再你的主页看到啦\n``` bash\n$  hexo clean\n$  hexo d -g\n```\n\n###博文压缩\n```bash\n$ npm install gulp -g\n$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save\n```\n在项目根目录下创建`gulpfile.js`并填入以下内容：\n```js\nvar gulp = require('gulp');\nvar minifycss = require('gulp-minify-css');\nvar uglify = require('gulp-uglify');\nvar htmlmin = require('gulp-htmlmin');\nvar htmlclean = require('gulp-htmlclean');\n// 压缩 public 目录 css\ngulp.task('minify-css', function() {\n    return gulp.src('./public/**/*.css')\n        .pipe(minifycss())\n        .pipe(gulp.dest('./public'));\n});\n// 压缩 public 目录 html\ngulp.task('minify-html', function() {\n  return gulp.src('./public/**/*.html')\n    .pipe(htmlclean())\n    .pipe(htmlmin({\n         removeComments: true,\n         minifyJS: true,\n         minifyCSS: true,\n         minifyURLs: true,\n    }))\n    .pipe(gulp.dest('./public'))\n});\n// 压缩 public/js 目录 js\ngulp.task('minify-js', function() {\n    return gulp.src('./public/**/*.js')\n        .pipe(uglify())\n        .pipe(gulp.dest('./public'));\n});\n// 执行 gulp 命令时执行的任务\ngulp.task('default', [\n    'minify-html','minify-css','minify-js'\n]);\n```\n\n生成博文是执行 hexo g && gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。","source":"_posts/Github-Pages-Blog.md","raw":"---\ntitle: Mac下利用Github Pages快速搭建免费博客\ndate: 2019-01-30 19:30:04\ntags:\n    - github\n    - hexo\n    - 教程\n    - blog\ncategories: blog\nauthor: Guyuqing\ncopyright: true\ncomments: true\n---\n本博客利用Hexo + Next + GitHubPages 搭建博客。\n\n## 准备工作\n\n### 安装node.js\n\n``` bash\n$ brew install node\n```\n\n### 安装 git\n\n``` bash\n$ brew install git\n```\n<!-- more -->\n\n### 安装yarn\n\n``` bash\n$ npm install yarn\n```\n\n如果安装失败用\n\n``` bash\n$ brew install yarn\n```\n\n### 安装hexo\n\n进入你的项目目录，举个例子我的目录是blog\n\n``` bash\n$ cd blog\n```\n\n然后用 yarn 安装 hexo\n\n``` bash\n$ yarn add hexo -S\n```\n\n如果安装失败用\n\n``` bash\n$ npm install hexo-cli -g\n$ npm install hexo-server --save\n```\n详细可见[官方文档](https://hexo.io/zh-cn/docs/)\n\n## 搭建本地博客\n\n### 项目初始化\n\n进入你的项目目录,初始化hexo\n\n``` bash\n$ cd blog\n$ hexo init\n```\n### 安装依赖\n\n``` bash\n$ yarn install\n```\n### 启动本地服务\n\n``` bash\n$ hexo server\n```\n在浏览器输入 `localhost:4000` 即可\n\n## 关联 GitHub\n### 创建项目\n\n![创建项目](Github-Pages-Blog/create-project.png)\n\n项目名称一定一定是 `[用户名].github.io`\n![创建项目](Github-Pages-Blog/create-repository.png)\n\n### 设置\n\n![设置](Github-Pages-Blog/setting.png)\n\n在设置中找到GitHub Pages ，分支选择master，点击choose a theme\n\n![设置github-pages](Github-Pages-Blog/github-pages.png)\n\n选择喜欢的主题，点击select theme即可\n![选择主题](Github-Pages-Blog/select-theme.png)\n\n到这里就可以访问你的主页啦  `https://[用户名].github.io/`,接下来复制你的项目链接\n\n![复制项目链接](Github-Pages-Blog/copy-url.png)\n\n到你的本地项目根目录找到 `_config.yml` 文件，粘贴到以下位置\n\n![hexo设置git](Github-Pages-Blog/deploy-position.png)\n\n### 站点配置\n站点配置包括修改博客名称，描述，作者等等，建议直接查看[官方教程](https://hexo.io/zh-cn/docs/configuration)\n\n### 关联\n\n安装 hexo-deployer-git 插件\n``` bash\n$ yarn add hexo-deployer-git -S\n```\n如果失败的话尝试下面的方法\n``` bash\n$ npm install --save hexo-deployer-git\n```\n在你的项目文件夹下运行 hexo d -g （生成本地文件并将本地文件推送到 GitHub ，和 git push 功能相同）,如果失败的话前面加sudo\n``` bash\n$  hexo d -g\n```\n这时访问你的github主页`https://[用户名].github.io/`就可以啦\n\n## NexT主题配置\nNexT 是一个高质量并且优雅的Hexo 主题。\n详细可见[官方文档](https://github.com/iissnan/hexo-theme-next/blob/master/README.cn.md)\n\n### 安装NexT主题\n在你的项目文件夹下，执行以下命令，安装NexT主题\n``` bash\n$ git clone https://github.com/iissnan/hexo-theme-next.git themes/next\n```\n更改项目根目录下`_config.yml` 文件，如下\n![更改主题](Github-Pages-Blog/change-theme.png)\n\n重新生成本地文件并推送到github\n``` bash\n$  hexo d -g\n```\n访问你的github主页`https://[用户名].github.io/`就可以看到啦\n\n### 主题配置\n\n`themes/next`文件夹下的`_config.yml`是主题的配置文件\nnext内置了4种主题方案，选择你喜欢的方案解开注释即可\n```yaml\n# ---------------------------------------------------------------\n# Scheme Settings\n# ---------------------------------------------------------------\n\n# Schemes\n#scheme: Muse\nscheme: Mist\n#scheme: Pisces\n#scheme: Gemini\n```\nMenu Settings是控制图中菜单的位置，根据需要解开注释即可\n```yaml\n# ---------------------------------------------------------------\n# Menu Settings\n# ---------------------------------------------------------------\nmenu:\n  home: / || home\n#  about: /about/ || user\n  tags: /tags/ || tags\n  categories: /categories/ || th\n#  archives: /archives/ || archive\n#  schedule: /schedule/ || calendar\n#  sitemap: /sitemap.xml || sitemap\n#  commonweal: /404.html || heartbeat\n```\n![更改菜单](Github-Pages-Blog/blog-icon.png)\n还有很多很多的配置请参考[官方教程](http://theme-next.iissnan.com/getting-started.html#install-next-theme),[主题个性配置教程](http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html),[主题美化](http://yearito.cn/posts/hexo-theme-beautify.html)\n\n修改之后，运行以下命令就可以再你的主页看到啦\n``` bash\n$  hexo clean\n$  hexo d -g\n```\n也可以在本地启动服务器，在浏览器输入 `localhost:4000` 观看效果\n``` bash\n$ hexo server\n```\n## 创建文章\n\n### 添加【标签】页面\n\n新建标签页面\n``` bash\n$ hexo new page tags\n```\n修改项目根目录下 source/tags 的 index.md 文件如下：\n``` markdown\ntitle: tags\ntype: \"tags\"\ncomments: false\n---\n```\n修改`themes/next`文件夹下的`_config.yml`主题配置文件，取消  `tags: /tags/ || tags` 这行注释\n新建测试文章\n``` bash\n$ hexo new 'test'\n```\n在测试文章的头部添加tags信息，如下：\n``` markdown\ntitle: 测试文章\ntags:\n  - Testing\n  - Another Tag\n---\n```\n启动本地服务，就可以看到标签菜单，点击可进入标签页，看到 如图所示 证明标签页面添加成功。\n![标签](Github-Pages-Blog/tags.png)\n\n### 添加【分类】页面\n新建标签页面\n``` bash\n$ hexo new page categories\n```\n修改项目根目录下 source/tags 的 index.md 文件如下：\n``` markdown\ntitle: categories\ntype: \"categories\"\ncomments: false\n---\n```\n修改`themes/next`文件夹下的`_config.yml`主题配置文件，取消  `categories: /categories/ || th` 这行注释\n在测试文章的头部添加categories信息，如下：\n``` markdown\ntitle: 测试文章\ntags:\n  - Testing\n  - Another Tag\n---\ncategories: Testing\n```\n启动本地服务，就可以看到标签菜单，点击可进入标签页，看到 如图所示 证明分类页面添加成功。\n![分类](Github-Pages-Blog/categories.png)\n\n### 给博客添加图片\n在项目目录下执行\n\n``` bash\n$ npm install hexo-asset-image --save\n```\n\n在用下面命令生成md文章时，会在_post目录下看到一个与文章同名的文件夹\n``` bash\n$ hexo new '文章名'\n```\n将想要上传的图片先放到文件夹下，然后在博客中使用markdown的格式引入图片：\n``` markdown\n ![文字](xxxx/图片名.jpg)\n```\n文章名和文件夹名字相同，所以不需要绝对路径，只要xxxx是文件夹的名字就可以了。\n\n### 添加Valine评论系统\n\n首先需要去注册一个[Leancloud](https://leancloud.cn/)账号,验证邮箱\n然后随便创建一个应用，按如图所示找到`appid`，`appkey`\n![评论](Github-Pages-Blog/valine.png)\n\n按下图修改`themes/next`文件夹下的`_config.yml`主题配置文件，重新启动服务器就可以啦\n``` yaml\n # Valine.\n # You can get your appid and appkey from https://leancloud.cn\n # more info please open https://valine.js.org\n valine:\n   enable: true\n   appid: your appid  # your leancloud application appid\n   appkey: your appkey # your leancloud application appkey\n   notify: false # mail notifier , https://github.com/xCss/Valine/wiki\n   verify: false # Verification code\n   placeholder: 描述  # comment box placeholder\n   avatar: monsterid # gravatar style\n   guest_info: nick,mail # custom comment header\n   pageSize: 10 # pagination size\n```\n如果要删除评论请到[Leancloud](https://leancloud.cn/)里删除哦\n![删除评论](Github-Pages-Blog/comment-delete.png)\n\n### hexo添加多作者\n在项目目录下执行\n\n``` bash\n$ npm install hexo-generator-author --save\n```\n\n在文章的头部添加author信息，如下：\n``` markdown\ntitle: 测试文章\ntags:\n  - Testing\n  - Another Tag\n---\nauthor: Alice\n```\n\n修改/layout/_macro/下的post.swig文件 +为新添加的行\n```swig\n         <div class=\"post-meta\">\n+          <span itemprop=\"about\" itemscope itemtype=\"https://schema.org/Thing\">\n+            <a href=\"/authors/{{ post.author }}\" itemprop=\"url\" rel=\"index\">\n+              <span itemprop=\"name\">{{ post.author }}</span>\n+            </a>\n+          </span>\n           <span class=\"post-time\">\n             <span class=\"post-meta-item-icon\">\n               <i class=\"fa fa-calendar-o\"></i>\n\n```\n在/layout下新创建author.swig文件\n```swig\n\n{% extends '_layout.swig' %}\n{% import '_macro/post-collapse.swig' as post_template %}\n{% import '_macro/sidebar.swig' as sidebar_template %}\n\n{% block title %} {{ __('title.author') }}: {{ page.author }} | {{ config.title }} {% endblock %}\n\n{% block content %}\n\n  <div class=\"post-block category\">\n\n    <div id=\"posts\" class=\"posts-collapse\">\n      <div class=\"collection-title\">\n\n        <{% if theme.seo %}h2{% else %}h1{% endif %}>{#\n        #}{{ page.author }}{#\n        #}<small>{{  __('title.author')  }}</small>\n        </{% if theme.seo %}h2{% else %}h1{% endif %}>\n      </div>\n\n      {% for post in page.posts %}\n        {{ post_template.render(post) }}\n      {% endfor %}\n    </div>\n\n  </div>\n\n  {% include '_partials/pagination.swig' %}\n\n{% endblock %}\n\n{% block sidebar %}\n  {{ sidebar_template.render(false) }}\n{% endblock %}\n\n```\n\n修改/layout下page.swig文件\n```swig\n\n     {{ __('title.category') + page_title_suffix }}\n   {% elif page.type === \"tags\" %}\n     {{ __('title.tag') + page_title_suffix }}\n+  {% elif page.type === \"authors\" %}\n+    {{ __('title.author') + page_title_suffix }}\n   {% else %}\n     {{ page.title + page_title_suffix }}\n   {% endif %}\n\n。。。。。。。\n           {{ list_categories() }}\n         </div>\n       </div>\n+    {% elif page.type === 'authors' %}\n+      <div class=\"author-all-page\">\n+        <div class=\"author-all-title\">\n+            {{ _p('counter.authors', site.authors.length) }}\n+        </div>\n+        <div class=\"author-all\">\n+          {{ list_authors() }}\n+        </div>\n+      </div>\n     {% else %}\n       {{ page.content }}\n     {% endif %}\n```\n修改{项目名称}/themes/next下zh-Hans.yml文件\n```yml\ntitle:\n  archive: 归档\n  category: 分类\n  tag: 标签\n  schedule: 日程表\n  author : 作者\n  \n。。。\n\ncounter:\n\n  authors:\n    zero: 暂无分类\n    one: 目前共计 1 个分类\n    other: \"目前共计 %d 个作者\"\n\n```\n\n在{项目名称}/themes/next/source/css/_common/components/pages/添加authors.styl，复制categories.styl内容将categorie改成author\n\n在同级文件pages.styl中添加@import \"authors\";\n\n修改之后，运行以下命令就可以再你的主页看到啦\n``` bash\n$  hexo clean\n$  hexo d -g\n```\n\n###博文压缩\n```bash\n$ npm install gulp -g\n$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save\n```\n在项目根目录下创建`gulpfile.js`并填入以下内容：\n```js\nvar gulp = require('gulp');\nvar minifycss = require('gulp-minify-css');\nvar uglify = require('gulp-uglify');\nvar htmlmin = require('gulp-htmlmin');\nvar htmlclean = require('gulp-htmlclean');\n// 压缩 public 目录 css\ngulp.task('minify-css', function() {\n    return gulp.src('./public/**/*.css')\n        .pipe(minifycss())\n        .pipe(gulp.dest('./public'));\n});\n// 压缩 public 目录 html\ngulp.task('minify-html', function() {\n  return gulp.src('./public/**/*.html')\n    .pipe(htmlclean())\n    .pipe(htmlmin({\n         removeComments: true,\n         minifyJS: true,\n         minifyCSS: true,\n         minifyURLs: true,\n    }))\n    .pipe(gulp.dest('./public'))\n});\n// 压缩 public/js 目录 js\ngulp.task('minify-js', function() {\n    return gulp.src('./public/**/*.js')\n        .pipe(uglify())\n        .pipe(gulp.dest('./public'));\n});\n// 执行 gulp 命令时执行的任务\ngulp.task('default', [\n    'minify-html','minify-css','minify-js'\n]);\n```\n\n生成博文是执行 hexo g && gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。","slug":"Github-Pages-Blog","published":1,"updated":"2019-07-31T13:41:40.989Z","layout":"post","photos":[],"link":"","_id":"ck8fb4a92000tk2o5p0gggblb","content":"<p>本博客利用Hexo + Next + GitHubPages 搭建博客。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"安装node-js\"><a href=\"#安装node-js\" class=\"headerlink\" title=\"安装node.js\"></a>安装node.js</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install node</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装-git\"><a href=\"#安装-git\" class=\"headerlink\" title=\"安装 git\"></a>安装 git</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install git</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<h3 id=\"安装yarn\"><a href=\"#安装yarn\" class=\"headerlink\" title=\"安装yarn\"></a>安装yarn</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install yarn</span><br></pre></td></tr></table></figure>\n\n<p>如果安装失败用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install yarn</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h3><p>进入你的项目目录，举个例子我的目录是blog</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> blog</span><br></pre></td></tr></table></figure>\n\n<p>然后用 yarn 安装 hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn add hexo -S</span><br></pre></td></tr></table></figure>\n\n<p>如果安装失败用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-cli -g</span><br><span class=\"line\">$ npm install hexo-server --save</span><br></pre></td></tr></table></figure>\n\n<p>详细可见<a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h2 id=\"搭建本地博客\"><a href=\"#搭建本地博客\" class=\"headerlink\" title=\"搭建本地博客\"></a>搭建本地博客</h2><h3 id=\"项目初始化\"><a href=\"#项目初始化\" class=\"headerlink\" title=\"项目初始化\"></a>项目初始化</h3><p>进入你的项目目录,初始化hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> blog</span><br><span class=\"line\">$ hexo init</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn install</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"启动本地服务\"><a href=\"#启动本地服务\" class=\"headerlink\" title=\"启动本地服务\"></a>启动本地服务</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>在浏览器输入 <code>localhost:4000</code> 即可</p>\n<h2 id=\"关联-GitHub\"><a href=\"#关联-GitHub\" class=\"headerlink\" title=\"关联 GitHub\"></a>关联 GitHub</h2><h3 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h3><p><img src=\"/blog/Github-Pages-Blog/create-project.png\" alt=\"创建项目\"></p>\n<p>项目名称一定一定是 <code>[用户名].github.io</code><br><img src=\"/blog/Github-Pages-Blog/create-repository.png\" alt=\"创建项目\"></p>\n<h3 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h3><p><img src=\"/blog/Github-Pages-Blog/setting.png\" alt=\"设置\"></p>\n<p>在设置中找到GitHub Pages ，分支选择master，点击choose a theme</p>\n<p><img src=\"/blog/Github-Pages-Blog/github-pages.png\" alt=\"设置github-pages\"></p>\n<p>选择喜欢的主题，点击select theme即可<br><img src=\"/blog/Github-Pages-Blog/select-theme.png\" alt=\"选择主题\"></p>\n<p>到这里就可以访问你的主页啦  <code>https://[用户名].github.io/</code>,接下来复制你的项目链接</p>\n<p><img src=\"/blog/Github-Pages-Blog/copy-url.png\" alt=\"复制项目链接\"></p>\n<p>到你的本地项目根目录找到 <code>_config.yml</code> 文件，粘贴到以下位置</p>\n<p><img src=\"/blog/Github-Pages-Blog/deploy-position.png\" alt=\"hexo设置git\"></p>\n<h3 id=\"站点配置\"><a href=\"#站点配置\" class=\"headerlink\" title=\"站点配置\"></a>站点配置</h3><p>站点配置包括修改博客名称，描述，作者等等，建议直接查看<a href=\"https://hexo.io/zh-cn/docs/configuration\" target=\"_blank\" rel=\"noopener\">官方教程</a></p>\n<h3 id=\"关联\"><a href=\"#关联\" class=\"headerlink\" title=\"关联\"></a>关联</h3><p>安装 hexo-deployer-git 插件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn add hexo-deployer-git -S</span><br></pre></td></tr></table></figure>\n\n<p>如果失败的话尝试下面的方法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>\n\n<p>在你的项目文件夹下运行 hexo d -g （生成本地文件并将本地文件推送到 GitHub ，和 git push 功能相同）,如果失败的话前面加sudo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$  hexo d -g</span><br></pre></td></tr></table></figure>\n\n<p>这时访问你的github主页<code>https://[用户名].github.io/</code>就可以啦</p>\n<h2 id=\"NexT主题配置\"><a href=\"#NexT主题配置\" class=\"headerlink\" title=\"NexT主题配置\"></a>NexT主题配置</h2><p>NexT 是一个高质量并且优雅的Hexo 主题。<br>详细可见<a href=\"https://github.com/iissnan/hexo-theme-next/blob/master/README.cn.md\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h3 id=\"安装NexT主题\"><a href=\"#安装NexT主题\" class=\"headerlink\" title=\"安装NexT主题\"></a>安装NexT主题</h3><p>在你的项目文件夹下，执行以下命令，安装NexT主题</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/iissnan/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>\n\n<p>更改项目根目录下<code>_config.yml</code> 文件，如下<br><img src=\"/blog/Github-Pages-Blog/change-theme.png\" alt=\"更改主题\"></p>\n<p>重新生成本地文件并推送到github</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$  hexo d -g</span><br></pre></td></tr></table></figure>\n\n<p>访问你的github主页<code>https://[用户名].github.io/</code>就可以看到啦</p>\n<h3 id=\"主题配置\"><a href=\"#主题配置\" class=\"headerlink\" title=\"主题配置\"></a>主题配置</h3><p><code>themes/next</code>文件夹下的<code>_config.yml</code>是主题的配置文件<br>next内置了4种主题方案，选择你喜欢的方案解开注释即可</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ---------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"># Scheme Settings</span></span><br><span class=\"line\"><span class=\"comment\"># ---------------------------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Schemes</span></span><br><span class=\"line\"><span class=\"comment\">#scheme: Muse</span></span><br><span class=\"line\"><span class=\"attr\">scheme:</span> <span class=\"string\">Mist</span></span><br><span class=\"line\"><span class=\"comment\">#scheme: Pisces</span></span><br><span class=\"line\"><span class=\"comment\">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>\n\n<p>Menu Settings是控制图中菜单的位置，根据需要解开注释即可</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ---------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"># Menu Settings</span></span><br><span class=\"line\"><span class=\"comment\"># ---------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\"><span class=\"attr\">  home:</span> <span class=\"string\">/</span> <span class=\"string\">||</span> <span class=\"string\">home</span></span><br><span class=\"line\"><span class=\"comment\">#  about: /about/ || user</span></span><br><span class=\"line\"><span class=\"attr\">  tags:</span> <span class=\"string\">/tags/</span> <span class=\"string\">||</span> <span class=\"string\">tags</span></span><br><span class=\"line\"><span class=\"attr\">  categories:</span> <span class=\"string\">/categories/</span> <span class=\"string\">||</span> <span class=\"string\">th</span></span><br><span class=\"line\"><span class=\"comment\">#  archives: /archives/ || archive</span></span><br><span class=\"line\"><span class=\"comment\">#  schedule: /schedule/ || calendar</span></span><br><span class=\"line\"><span class=\"comment\">#  sitemap: /sitemap.xml || sitemap</span></span><br><span class=\"line\"><span class=\"comment\">#  commonweal: /404.html || heartbeat</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/blog/Github-Pages-Blog/blog-icon.png\" alt=\"更改菜单\"><br>还有很多很多的配置请参考<a href=\"http://theme-next.iissnan.com/getting-started.html#install-next-theme\" target=\"_blank\" rel=\"noopener\">官方教程</a>,<a href=\"http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html\" target=\"_blank\" rel=\"noopener\">主题个性配置教程</a>,<a href=\"http://yearito.cn/posts/hexo-theme-beautify.html\" target=\"_blank\" rel=\"noopener\">主题美化</a></p>\n<p>修改之后，运行以下命令就可以再你的主页看到啦</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$  hexo clean</span><br><span class=\"line\">$  hexo d -g</span><br></pre></td></tr></table></figure>\n\n<p>也可以在本地启动服务器，在浏览器输入 <code>localhost:4000</code> 观看效果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建文章\"><a href=\"#创建文章\" class=\"headerlink\" title=\"创建文章\"></a>创建文章</h2><h3 id=\"添加【标签】页面\"><a href=\"#添加【标签】页面\" class=\"headerlink\" title=\"添加【标签】页面\"></a>添加【标签】页面</h3><p>新建标签页面</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page tags</span><br></pre></td></tr></table></figure>\n\n<p>修改项目根目录下 source/tags 的 index.md 文件如下：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: tags</span><br><span class=\"line\">type: \"tags\"</span><br><span class=\"line\">comments: false</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<p>修改<code>themes/next</code>文件夹下的<code>_config.yml</code>主题配置文件，取消  <code>tags: /tags/ || tags</code> 这行注释<br>新建测试文章</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">'test'</span></span><br></pre></td></tr></table></figure>\n\n<p>在测试文章的头部添加tags信息，如下：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 测试文章</span><br><span class=\"line\">tags:</span><br><span class=\"line\">  - Testing</span><br><span class=\"line\">  - Another Tag</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<p>启动本地服务，就可以看到标签菜单，点击可进入标签页，看到 如图所示 证明标签页面添加成功。<br><img src=\"/blog/Github-Pages-Blog/tags.png\" alt=\"标签\"></p>\n<h3 id=\"添加【分类】页面\"><a href=\"#添加【分类】页面\" class=\"headerlink\" title=\"添加【分类】页面\"></a>添加【分类】页面</h3><p>新建标签页面</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page categories</span><br></pre></td></tr></table></figure>\n\n<p>修改项目根目录下 source/tags 的 index.md 文件如下：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: categories</span><br><span class=\"line\">type: \"categories\"</span><br><span class=\"line\">comments: false</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<p>修改<code>themes/next</code>文件夹下的<code>_config.yml</code>主题配置文件，取消  <code>categories: /categories/ || th</code> 这行注释<br>在测试文章的头部添加categories信息，如下：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 测试文章</span><br><span class=\"line\">tags:</span><br><span class=\"line\">  - Testing</span><br><span class=\"line\">  - Another Tag</span><br><span class=\"line\">---</span><br><span class=\"line\">categories: Testing</span><br></pre></td></tr></table></figure>\n\n<p>启动本地服务，就可以看到标签菜单，点击可进入标签页，看到 如图所示 证明分类页面添加成功。<br><img src=\"/blog/Github-Pages-Blog/categories.png\" alt=\"分类\"></p>\n<h3 id=\"给博客添加图片\"><a href=\"#给博客添加图片\" class=\"headerlink\" title=\"给博客添加图片\"></a>给博客添加图片</h3><p>在项目目录下执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>\n\n<p>在用下面命令生成md文章时，会在_post目录下看到一个与文章同名的文件夹</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">'文章名'</span></span><br></pre></td></tr></table></figure>\n\n<p>将想要上传的图片先放到文件夹下，然后在博客中使用markdown的格式引入图片：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![<span class=\"string\">文字</span>](<span class=\"link\">xxxx/图片名.jpg</span>)</span><br></pre></td></tr></table></figure>\n\n<p>文章名和文件夹名字相同，所以不需要绝对路径，只要xxxx是文件夹的名字就可以了。</p>\n<h3 id=\"添加Valine评论系统\"><a href=\"#添加Valine评论系统\" class=\"headerlink\" title=\"添加Valine评论系统\"></a>添加Valine评论系统</h3><p>首先需要去注册一个<a href=\"https://leancloud.cn/\" target=\"_blank\" rel=\"noopener\">Leancloud</a>账号,验证邮箱<br>然后随便创建一个应用，按如图所示找到<code>appid</code>，<code>appkey</code><br><img src=\"/blog/Github-Pages-Blog/valine.png\" alt=\"评论\"></p>\n<p>按下图修改<code>themes/next</code>文件夹下的<code>_config.yml</code>主题配置文件，重新启动服务器就可以啦</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Valine.</span></span><br><span class=\"line\"><span class=\"comment\"># You can get your appid and appkey from https://leancloud.cn</span></span><br><span class=\"line\"><span class=\"comment\"># more info please open https://valine.js.org</span></span><br><span class=\"line\"><span class=\"attr\">valine:</span></span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  appid:</span> <span class=\"string\">your</span> <span class=\"string\">appid</span>  <span class=\"comment\"># your leancloud application appid</span></span><br><span class=\"line\"><span class=\"attr\">  appkey:</span> <span class=\"string\">your</span> <span class=\"string\">appkey</span> <span class=\"comment\"># your leancloud application appkey</span></span><br><span class=\"line\"><span class=\"attr\">  notify:</span> <span class=\"literal\">false</span> <span class=\"comment\"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class=\"line\"><span class=\"attr\">  verify:</span> <span class=\"literal\">false</span> <span class=\"comment\"># Verification code</span></span><br><span class=\"line\"><span class=\"attr\">  placeholder:</span> <span class=\"string\">描述</span>  <span class=\"comment\"># comment box placeholder</span></span><br><span class=\"line\"><span class=\"attr\">  avatar:</span> <span class=\"string\">monsterid</span> <span class=\"comment\"># gravatar style</span></span><br><span class=\"line\"><span class=\"attr\">  guest_info:</span> <span class=\"string\">nick,mail</span> <span class=\"comment\"># custom comment header</span></span><br><span class=\"line\"><span class=\"attr\">  pageSize:</span> <span class=\"number\">10</span> <span class=\"comment\"># pagination size</span></span><br></pre></td></tr></table></figure>\n\n<p>如果要删除评论请到<a href=\"https://leancloud.cn/\" target=\"_blank\" rel=\"noopener\">Leancloud</a>里删除哦<br><img src=\"/blog/Github-Pages-Blog/comment-delete.png\" alt=\"删除评论\"></p>\n<h3 id=\"hexo添加多作者\"><a href=\"#hexo添加多作者\" class=\"headerlink\" title=\"hexo添加多作者\"></a>hexo添加多作者</h3><p>在项目目录下执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-generator-author --save</span><br></pre></td></tr></table></figure>\n\n<p>在文章的头部添加author信息，如下：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 测试文章</span><br><span class=\"line\">tags:</span><br><span class=\"line\">  - Testing</span><br><span class=\"line\">  - Another Tag</span><br><span class=\"line\">---</span><br><span class=\"line\">author: Alice</span><br></pre></td></tr></table></figure>\n\n<p>修改/layout/_macro/下的post.swig文件 +为新添加的行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         &lt;div class=&quot;post-meta&quot;&gt;</span><br><span class=\"line\">+          &lt;span itemprop=&quot;about&quot; itemscope itemtype=&quot;https://schema.org/Thing&quot;&gt;</span><br><span class=\"line\">+            &lt;a href=&quot;/authors/&#123;&#123; post.author &#125;&#125;&quot; itemprop=&quot;url&quot; rel=&quot;index&quot;&gt;</span><br><span class=\"line\">+              &lt;span itemprop=&quot;name&quot;&gt;&#123;&#123; post.author &#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">+            &lt;/a&gt;</span><br><span class=\"line\">+          &lt;/span&gt;</span><br><span class=\"line\">           &lt;span class=&quot;post-time&quot;&gt;</span><br><span class=\"line\">             &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class=\"line\">               &lt;i class=&quot;fa fa-calendar-o&quot;&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在/layout下新创建author.swig文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#123;% extends &apos;_layout.swig&apos; %&#125;</span><br><span class=\"line\">&#123;% import &apos;_macro/post-collapse.swig&apos; as post_template %&#125;</span><br><span class=\"line\">&#123;% import &apos;_macro/sidebar.swig&apos; as sidebar_template %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% block title %&#125; &#123;&#123; __(&apos;title.author&apos;) &#125;&#125;: &#123;&#123; page.author &#125;&#125; | &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% block content %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;div class=&quot;post-block category&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;div id=&quot;posts&quot; class=&quot;posts-collapse&quot;&gt;</span><br><span class=\"line\">      &lt;div class=&quot;collection-title&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;&#123;% if theme.seo %&#125;h2&#123;% else %&#125;h1&#123;% endif %&#125;&gt;&#123;#</span><br><span class=\"line\">        #&#125;&#123;&#123; page.author &#125;&#125;&#123;#</span><br><span class=\"line\">        #&#125;&lt;small&gt;&#123;&#123;  __(&apos;title.author&apos;)  &#125;&#125;&lt;/small&gt;</span><br><span class=\"line\">        &lt;/&#123;% if theme.seo %&#125;h2&#123;% else %&#125;h1&#123;% endif %&#125;&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#123;% for post in page.posts %&#125;</span><br><span class=\"line\">        &#123;&#123; post_template.render(post) &#125;&#125;</span><br><span class=\"line\">      &#123;% endfor %&#125;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;% include &apos;_partials/pagination.swig&apos; %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% endblock %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% block sidebar %&#125;</span><br><span class=\"line\">  &#123;&#123; sidebar_template.render(false) &#125;&#125;</span><br><span class=\"line\">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改/layout下page.swig文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">     &#123;&#123; __(&apos;title.category&apos;) + page_title_suffix &#125;&#125;</span><br><span class=\"line\">   &#123;% elif page.type === &quot;tags&quot; %&#125;</span><br><span class=\"line\">     &#123;&#123; __(&apos;title.tag&apos;) + page_title_suffix &#125;&#125;</span><br><span class=\"line\">+  &#123;% elif page.type === &quot;authors&quot; %&#125;</span><br><span class=\"line\">+    &#123;&#123; __(&apos;title.author&apos;) + page_title_suffix &#125;&#125;</span><br><span class=\"line\">   &#123;% else %&#125;</span><br><span class=\"line\">     &#123;&#123; page.title + page_title_suffix &#125;&#125;</span><br><span class=\"line\">   &#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">。。。。。。。</span><br><span class=\"line\">           &#123;&#123; list_categories() &#125;&#125;</span><br><span class=\"line\">         &lt;/div&gt;</span><br><span class=\"line\">       &lt;/div&gt;</span><br><span class=\"line\">+    &#123;% elif page.type === &apos;authors&apos; %&#125;</span><br><span class=\"line\">+      &lt;div class=&quot;author-all-page&quot;&gt;</span><br><span class=\"line\">+        &lt;div class=&quot;author-all-title&quot;&gt;</span><br><span class=\"line\">+            &#123;&#123; _p(&apos;counter.authors&apos;, site.authors.length) &#125;&#125;</span><br><span class=\"line\">+        &lt;/div&gt;</span><br><span class=\"line\">+        &lt;div class=&quot;author-all&quot;&gt;</span><br><span class=\"line\">+          &#123;&#123; list_authors() &#125;&#125;</span><br><span class=\"line\">+        &lt;/div&gt;</span><br><span class=\"line\">+      &lt;/div&gt;</span><br><span class=\"line\">     &#123;% else %&#125;</span><br><span class=\"line\">       &#123;&#123; page.content &#125;&#125;</span><br><span class=\"line\">     &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改{项目名称}/themes/next下zh-Hans.yml文件</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">title:</span></span><br><span class=\"line\"><span class=\"attr\">  archive:</span> <span class=\"string\">归档</span></span><br><span class=\"line\"><span class=\"attr\">  category:</span> <span class=\"string\">分类</span></span><br><span class=\"line\"><span class=\"attr\">  tag:</span> <span class=\"string\">标签</span></span><br><span class=\"line\"><span class=\"attr\">  schedule:</span> <span class=\"string\">日程表</span></span><br><span class=\"line\">  <span class=\"string\">author</span> <span class=\"string\">:</span> <span class=\"string\">作者</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"string\">。。。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">counter:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">  authors:</span></span><br><span class=\"line\"><span class=\"attr\">    zero:</span> <span class=\"string\">暂无分类</span></span><br><span class=\"line\"><span class=\"attr\">    one:</span> <span class=\"string\">目前共计</span> <span class=\"number\">1</span> <span class=\"string\">个分类</span></span><br><span class=\"line\"><span class=\"attr\">    other:</span> <span class=\"string\">\"目前共计 %d 个作者\"</span></span><br></pre></td></tr></table></figure>\n\n<p>在{项目名称}/themes/next/source/css/_common/components/pages/添加authors.styl，复制categories.styl内容将categorie改成author</p>\n<p>在同级文件pages.styl中添加@import “authors”;</p>\n<p>修改之后，运行以下命令就可以再你的主页看到啦</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$  hexo clean</span><br><span class=\"line\">$  hexo d -g</span><br></pre></td></tr></table></figure>\n\n<p>###博文压缩</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install gulp -g</span><br><span class=\"line\">$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save</span><br></pre></td></tr></table></figure>\n\n<p>在项目根目录下创建<code>gulpfile.js</code>并填入以下内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> minifycss = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-minify-css'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> uglify = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-uglify'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> htmlmin = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-htmlmin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> htmlclean = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-htmlclean'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 压缩 public 目录 css</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'minify-css'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'./public/**/*.css'</span>)</span><br><span class=\"line\">        .pipe(minifycss())</span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">'./public'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 压缩 public 目录 html</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'minify-html'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'./public/**/*.html'</span>)</span><br><span class=\"line\">    .pipe(htmlclean())</span><br><span class=\"line\">    .pipe(htmlmin(&#123;</span><br><span class=\"line\">         removeComments: <span class=\"literal\">true</span>,</span><br><span class=\"line\">         minifyJS: <span class=\"literal\">true</span>,</span><br><span class=\"line\">         minifyCSS: <span class=\"literal\">true</span>,</span><br><span class=\"line\">         minifyURLs: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'./public'</span>))</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 压缩 public/js 目录 js</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'minify-js'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'./public/**/*.js'</span>)</span><br><span class=\"line\">        .pipe(uglify())</span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">'./public'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 执行 gulp 命令时执行的任务</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'default'</span>, [</span><br><span class=\"line\">    <span class=\"string\">'minify-html'</span>,<span class=\"string\">'minify-css'</span>,<span class=\"string\">'minify-js'</span></span><br><span class=\"line\">]);</span><br></pre></td></tr></table></figure>\n\n<p>生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。</p>\n","site":{"data":{}},"excerpt":"<p>本博客利用Hexo + Next + GitHubPages 搭建博客。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"安装node-js\"><a href=\"#安装node-js\" class=\"headerlink\" title=\"安装node.js\"></a>安装node.js</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install node</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装-git\"><a href=\"#安装-git\" class=\"headerlink\" title=\"安装 git\"></a>安装 git</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install git</span><br></pre></td></tr></table></figure>","more":"<h3 id=\"安装yarn\"><a href=\"#安装yarn\" class=\"headerlink\" title=\"安装yarn\"></a>安装yarn</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install yarn</span><br></pre></td></tr></table></figure>\n\n<p>如果安装失败用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install yarn</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h3><p>进入你的项目目录，举个例子我的目录是blog</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> blog</span><br></pre></td></tr></table></figure>\n\n<p>然后用 yarn 安装 hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn add hexo -S</span><br></pre></td></tr></table></figure>\n\n<p>如果安装失败用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-cli -g</span><br><span class=\"line\">$ npm install hexo-server --save</span><br></pre></td></tr></table></figure>\n\n<p>详细可见<a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h2 id=\"搭建本地博客\"><a href=\"#搭建本地博客\" class=\"headerlink\" title=\"搭建本地博客\"></a>搭建本地博客</h2><h3 id=\"项目初始化\"><a href=\"#项目初始化\" class=\"headerlink\" title=\"项目初始化\"></a>项目初始化</h3><p>进入你的项目目录,初始化hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> blog</span><br><span class=\"line\">$ hexo init</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn install</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"启动本地服务\"><a href=\"#启动本地服务\" class=\"headerlink\" title=\"启动本地服务\"></a>启动本地服务</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>在浏览器输入 <code>localhost:4000</code> 即可</p>\n<h2 id=\"关联-GitHub\"><a href=\"#关联-GitHub\" class=\"headerlink\" title=\"关联 GitHub\"></a>关联 GitHub</h2><h3 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h3><p><img src=\"/blog/Github-Pages-Blog/create-project.png\" alt=\"创建项目\"></p>\n<p>项目名称一定一定是 <code>[用户名].github.io</code><br><img src=\"/blog/Github-Pages-Blog/create-repository.png\" alt=\"创建项目\"></p>\n<h3 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h3><p><img src=\"/blog/Github-Pages-Blog/setting.png\" alt=\"设置\"></p>\n<p>在设置中找到GitHub Pages ，分支选择master，点击choose a theme</p>\n<p><img src=\"/blog/Github-Pages-Blog/github-pages.png\" alt=\"设置github-pages\"></p>\n<p>选择喜欢的主题，点击select theme即可<br><img src=\"/blog/Github-Pages-Blog/select-theme.png\" alt=\"选择主题\"></p>\n<p>到这里就可以访问你的主页啦  <code>https://[用户名].github.io/</code>,接下来复制你的项目链接</p>\n<p><img src=\"/blog/Github-Pages-Blog/copy-url.png\" alt=\"复制项目链接\"></p>\n<p>到你的本地项目根目录找到 <code>_config.yml</code> 文件，粘贴到以下位置</p>\n<p><img src=\"/blog/Github-Pages-Blog/deploy-position.png\" alt=\"hexo设置git\"></p>\n<h3 id=\"站点配置\"><a href=\"#站点配置\" class=\"headerlink\" title=\"站点配置\"></a>站点配置</h3><p>站点配置包括修改博客名称，描述，作者等等，建议直接查看<a href=\"https://hexo.io/zh-cn/docs/configuration\" target=\"_blank\" rel=\"noopener\">官方教程</a></p>\n<h3 id=\"关联\"><a href=\"#关联\" class=\"headerlink\" title=\"关联\"></a>关联</h3><p>安装 hexo-deployer-git 插件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yarn add hexo-deployer-git -S</span><br></pre></td></tr></table></figure>\n\n<p>如果失败的话尝试下面的方法</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>\n\n<p>在你的项目文件夹下运行 hexo d -g （生成本地文件并将本地文件推送到 GitHub ，和 git push 功能相同）,如果失败的话前面加sudo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$  hexo d -g</span><br></pre></td></tr></table></figure>\n\n<p>这时访问你的github主页<code>https://[用户名].github.io/</code>就可以啦</p>\n<h2 id=\"NexT主题配置\"><a href=\"#NexT主题配置\" class=\"headerlink\" title=\"NexT主题配置\"></a>NexT主题配置</h2><p>NexT 是一个高质量并且优雅的Hexo 主题。<br>详细可见<a href=\"https://github.com/iissnan/hexo-theme-next/blob/master/README.cn.md\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h3 id=\"安装NexT主题\"><a href=\"#安装NexT主题\" class=\"headerlink\" title=\"安装NexT主题\"></a>安装NexT主题</h3><p>在你的项目文件夹下，执行以下命令，安装NexT主题</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/iissnan/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>\n\n<p>更改项目根目录下<code>_config.yml</code> 文件，如下<br><img src=\"/blog/Github-Pages-Blog/change-theme.png\" alt=\"更改主题\"></p>\n<p>重新生成本地文件并推送到github</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$  hexo d -g</span><br></pre></td></tr></table></figure>\n\n<p>访问你的github主页<code>https://[用户名].github.io/</code>就可以看到啦</p>\n<h3 id=\"主题配置\"><a href=\"#主题配置\" class=\"headerlink\" title=\"主题配置\"></a>主题配置</h3><p><code>themes/next</code>文件夹下的<code>_config.yml</code>是主题的配置文件<br>next内置了4种主题方案，选择你喜欢的方案解开注释即可</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ---------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"># Scheme Settings</span></span><br><span class=\"line\"><span class=\"comment\"># ---------------------------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Schemes</span></span><br><span class=\"line\"><span class=\"comment\">#scheme: Muse</span></span><br><span class=\"line\"><span class=\"attr\">scheme:</span> <span class=\"string\">Mist</span></span><br><span class=\"line\"><span class=\"comment\">#scheme: Pisces</span></span><br><span class=\"line\"><span class=\"comment\">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>\n\n<p>Menu Settings是控制图中菜单的位置，根据需要解开注释即可</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ---------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"># Menu Settings</span></span><br><span class=\"line\"><span class=\"comment\"># ---------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\"><span class=\"attr\">  home:</span> <span class=\"string\">/</span> <span class=\"string\">||</span> <span class=\"string\">home</span></span><br><span class=\"line\"><span class=\"comment\">#  about: /about/ || user</span></span><br><span class=\"line\"><span class=\"attr\">  tags:</span> <span class=\"string\">/tags/</span> <span class=\"string\">||</span> <span class=\"string\">tags</span></span><br><span class=\"line\"><span class=\"attr\">  categories:</span> <span class=\"string\">/categories/</span> <span class=\"string\">||</span> <span class=\"string\">th</span></span><br><span class=\"line\"><span class=\"comment\">#  archives: /archives/ || archive</span></span><br><span class=\"line\"><span class=\"comment\">#  schedule: /schedule/ || calendar</span></span><br><span class=\"line\"><span class=\"comment\">#  sitemap: /sitemap.xml || sitemap</span></span><br><span class=\"line\"><span class=\"comment\">#  commonweal: /404.html || heartbeat</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/blog/Github-Pages-Blog/blog-icon.png\" alt=\"更改菜单\"><br>还有很多很多的配置请参考<a href=\"http://theme-next.iissnan.com/getting-started.html#install-next-theme\" target=\"_blank\" rel=\"noopener\">官方教程</a>,<a href=\"http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html\" target=\"_blank\" rel=\"noopener\">主题个性配置教程</a>,<a href=\"http://yearito.cn/posts/hexo-theme-beautify.html\" target=\"_blank\" rel=\"noopener\">主题美化</a></p>\n<p>修改之后，运行以下命令就可以再你的主页看到啦</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$  hexo clean</span><br><span class=\"line\">$  hexo d -g</span><br></pre></td></tr></table></figure>\n\n<p>也可以在本地启动服务器，在浏览器输入 <code>localhost:4000</code> 观看效果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建文章\"><a href=\"#创建文章\" class=\"headerlink\" title=\"创建文章\"></a>创建文章</h2><h3 id=\"添加【标签】页面\"><a href=\"#添加【标签】页面\" class=\"headerlink\" title=\"添加【标签】页面\"></a>添加【标签】页面</h3><p>新建标签页面</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page tags</span><br></pre></td></tr></table></figure>\n\n<p>修改项目根目录下 source/tags 的 index.md 文件如下：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: tags</span><br><span class=\"line\">type: \"tags\"</span><br><span class=\"line\">comments: false</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<p>修改<code>themes/next</code>文件夹下的<code>_config.yml</code>主题配置文件，取消  <code>tags: /tags/ || tags</code> 这行注释<br>新建测试文章</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">'test'</span></span><br></pre></td></tr></table></figure>\n\n<p>在测试文章的头部添加tags信息，如下：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 测试文章</span><br><span class=\"line\">tags:</span><br><span class=\"line\">  - Testing</span><br><span class=\"line\">  - Another Tag</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<p>启动本地服务，就可以看到标签菜单，点击可进入标签页，看到 如图所示 证明标签页面添加成功。<br><img src=\"/blog/Github-Pages-Blog/tags.png\" alt=\"标签\"></p>\n<h3 id=\"添加【分类】页面\"><a href=\"#添加【分类】页面\" class=\"headerlink\" title=\"添加【分类】页面\"></a>添加【分类】页面</h3><p>新建标签页面</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page categories</span><br></pre></td></tr></table></figure>\n\n<p>修改项目根目录下 source/tags 的 index.md 文件如下：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: categories</span><br><span class=\"line\">type: \"categories\"</span><br><span class=\"line\">comments: false</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<p>修改<code>themes/next</code>文件夹下的<code>_config.yml</code>主题配置文件，取消  <code>categories: /categories/ || th</code> 这行注释<br>在测试文章的头部添加categories信息，如下：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 测试文章</span><br><span class=\"line\">tags:</span><br><span class=\"line\">  - Testing</span><br><span class=\"line\">  - Another Tag</span><br><span class=\"line\">---</span><br><span class=\"line\">categories: Testing</span><br></pre></td></tr></table></figure>\n\n<p>启动本地服务，就可以看到标签菜单，点击可进入标签页，看到 如图所示 证明分类页面添加成功。<br><img src=\"/blog/Github-Pages-Blog/categories.png\" alt=\"分类\"></p>\n<h3 id=\"给博客添加图片\"><a href=\"#给博客添加图片\" class=\"headerlink\" title=\"给博客添加图片\"></a>给博客添加图片</h3><p>在项目目录下执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>\n\n<p>在用下面命令生成md文章时，会在_post目录下看到一个与文章同名的文件夹</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">'文章名'</span></span><br></pre></td></tr></table></figure>\n\n<p>将想要上传的图片先放到文件夹下，然后在博客中使用markdown的格式引入图片：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">![<span class=\"string\">文字</span>](<span class=\"link\">xxxx/图片名.jpg</span>)</span><br></pre></td></tr></table></figure>\n\n<p>文章名和文件夹名字相同，所以不需要绝对路径，只要xxxx是文件夹的名字就可以了。</p>\n<h3 id=\"添加Valine评论系统\"><a href=\"#添加Valine评论系统\" class=\"headerlink\" title=\"添加Valine评论系统\"></a>添加Valine评论系统</h3><p>首先需要去注册一个<a href=\"https://leancloud.cn/\" target=\"_blank\" rel=\"noopener\">Leancloud</a>账号,验证邮箱<br>然后随便创建一个应用，按如图所示找到<code>appid</code>，<code>appkey</code><br><img src=\"/blog/Github-Pages-Blog/valine.png\" alt=\"评论\"></p>\n<p>按下图修改<code>themes/next</code>文件夹下的<code>_config.yml</code>主题配置文件，重新启动服务器就可以啦</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Valine.</span></span><br><span class=\"line\"><span class=\"comment\"># You can get your appid and appkey from https://leancloud.cn</span></span><br><span class=\"line\"><span class=\"comment\"># more info please open https://valine.js.org</span></span><br><span class=\"line\"><span class=\"attr\">valine:</span></span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  appid:</span> <span class=\"string\">your</span> <span class=\"string\">appid</span>  <span class=\"comment\"># your leancloud application appid</span></span><br><span class=\"line\"><span class=\"attr\">  appkey:</span> <span class=\"string\">your</span> <span class=\"string\">appkey</span> <span class=\"comment\"># your leancloud application appkey</span></span><br><span class=\"line\"><span class=\"attr\">  notify:</span> <span class=\"literal\">false</span> <span class=\"comment\"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class=\"line\"><span class=\"attr\">  verify:</span> <span class=\"literal\">false</span> <span class=\"comment\"># Verification code</span></span><br><span class=\"line\"><span class=\"attr\">  placeholder:</span> <span class=\"string\">描述</span>  <span class=\"comment\"># comment box placeholder</span></span><br><span class=\"line\"><span class=\"attr\">  avatar:</span> <span class=\"string\">monsterid</span> <span class=\"comment\"># gravatar style</span></span><br><span class=\"line\"><span class=\"attr\">  guest_info:</span> <span class=\"string\">nick,mail</span> <span class=\"comment\"># custom comment header</span></span><br><span class=\"line\"><span class=\"attr\">  pageSize:</span> <span class=\"number\">10</span> <span class=\"comment\"># pagination size</span></span><br></pre></td></tr></table></figure>\n\n<p>如果要删除评论请到<a href=\"https://leancloud.cn/\" target=\"_blank\" rel=\"noopener\">Leancloud</a>里删除哦<br><img src=\"/blog/Github-Pages-Blog/comment-delete.png\" alt=\"删除评论\"></p>\n<h3 id=\"hexo添加多作者\"><a href=\"#hexo添加多作者\" class=\"headerlink\" title=\"hexo添加多作者\"></a>hexo添加多作者</h3><p>在项目目录下执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-generator-author --save</span><br></pre></td></tr></table></figure>\n\n<p>在文章的头部添加author信息，如下：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 测试文章</span><br><span class=\"line\">tags:</span><br><span class=\"line\">  - Testing</span><br><span class=\"line\">  - Another Tag</span><br><span class=\"line\">---</span><br><span class=\"line\">author: Alice</span><br></pre></td></tr></table></figure>\n\n<p>修改/layout/_macro/下的post.swig文件 +为新添加的行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         &lt;div class=&quot;post-meta&quot;&gt;</span><br><span class=\"line\">+          &lt;span itemprop=&quot;about&quot; itemscope itemtype=&quot;https://schema.org/Thing&quot;&gt;</span><br><span class=\"line\">+            &lt;a href=&quot;/authors/&#123;&#123; post.author &#125;&#125;&quot; itemprop=&quot;url&quot; rel=&quot;index&quot;&gt;</span><br><span class=\"line\">+              &lt;span itemprop=&quot;name&quot;&gt;&#123;&#123; post.author &#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">+            &lt;/a&gt;</span><br><span class=\"line\">+          &lt;/span&gt;</span><br><span class=\"line\">           &lt;span class=&quot;post-time&quot;&gt;</span><br><span class=\"line\">             &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class=\"line\">               &lt;i class=&quot;fa fa-calendar-o&quot;&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在/layout下新创建author.swig文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#123;% extends &apos;_layout.swig&apos; %&#125;</span><br><span class=\"line\">&#123;% import &apos;_macro/post-collapse.swig&apos; as post_template %&#125;</span><br><span class=\"line\">&#123;% import &apos;_macro/sidebar.swig&apos; as sidebar_template %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% block title %&#125; &#123;&#123; __(&apos;title.author&apos;) &#125;&#125;: &#123;&#123; page.author &#125;&#125; | &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% block content %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;div class=&quot;post-block category&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;div id=&quot;posts&quot; class=&quot;posts-collapse&quot;&gt;</span><br><span class=\"line\">      &lt;div class=&quot;collection-title&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;&#123;% if theme.seo %&#125;h2&#123;% else %&#125;h1&#123;% endif %&#125;&gt;&#123;#</span><br><span class=\"line\">        #&#125;&#123;&#123; page.author &#125;&#125;&#123;#</span><br><span class=\"line\">        #&#125;&lt;small&gt;&#123;&#123;  __(&apos;title.author&apos;)  &#125;&#125;&lt;/small&gt;</span><br><span class=\"line\">        &lt;/&#123;% if theme.seo %&#125;h2&#123;% else %&#125;h1&#123;% endif %&#125;&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#123;% for post in page.posts %&#125;</span><br><span class=\"line\">        &#123;&#123; post_template.render(post) &#125;&#125;</span><br><span class=\"line\">      &#123;% endfor %&#125;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;% include &apos;_partials/pagination.swig&apos; %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% endblock %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;% block sidebar %&#125;</span><br><span class=\"line\">  &#123;&#123; sidebar_template.render(false) &#125;&#125;</span><br><span class=\"line\">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改/layout下page.swig文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">     &#123;&#123; __(&apos;title.category&apos;) + page_title_suffix &#125;&#125;</span><br><span class=\"line\">   &#123;% elif page.type === &quot;tags&quot; %&#125;</span><br><span class=\"line\">     &#123;&#123; __(&apos;title.tag&apos;) + page_title_suffix &#125;&#125;</span><br><span class=\"line\">+  &#123;% elif page.type === &quot;authors&quot; %&#125;</span><br><span class=\"line\">+    &#123;&#123; __(&apos;title.author&apos;) + page_title_suffix &#125;&#125;</span><br><span class=\"line\">   &#123;% else %&#125;</span><br><span class=\"line\">     &#123;&#123; page.title + page_title_suffix &#125;&#125;</span><br><span class=\"line\">   &#123;% endif %&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">。。。。。。。</span><br><span class=\"line\">           &#123;&#123; list_categories() &#125;&#125;</span><br><span class=\"line\">         &lt;/div&gt;</span><br><span class=\"line\">       &lt;/div&gt;</span><br><span class=\"line\">+    &#123;% elif page.type === &apos;authors&apos; %&#125;</span><br><span class=\"line\">+      &lt;div class=&quot;author-all-page&quot;&gt;</span><br><span class=\"line\">+        &lt;div class=&quot;author-all-title&quot;&gt;</span><br><span class=\"line\">+            &#123;&#123; _p(&apos;counter.authors&apos;, site.authors.length) &#125;&#125;</span><br><span class=\"line\">+        &lt;/div&gt;</span><br><span class=\"line\">+        &lt;div class=&quot;author-all&quot;&gt;</span><br><span class=\"line\">+          &#123;&#123; list_authors() &#125;&#125;</span><br><span class=\"line\">+        &lt;/div&gt;</span><br><span class=\"line\">+      &lt;/div&gt;</span><br><span class=\"line\">     &#123;% else %&#125;</span><br><span class=\"line\">       &#123;&#123; page.content &#125;&#125;</span><br><span class=\"line\">     &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改{项目名称}/themes/next下zh-Hans.yml文件</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">title:</span></span><br><span class=\"line\"><span class=\"attr\">  archive:</span> <span class=\"string\">归档</span></span><br><span class=\"line\"><span class=\"attr\">  category:</span> <span class=\"string\">分类</span></span><br><span class=\"line\"><span class=\"attr\">  tag:</span> <span class=\"string\">标签</span></span><br><span class=\"line\"><span class=\"attr\">  schedule:</span> <span class=\"string\">日程表</span></span><br><span class=\"line\">  <span class=\"string\">author</span> <span class=\"string\">:</span> <span class=\"string\">作者</span></span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"string\">。。。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">counter:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">  authors:</span></span><br><span class=\"line\"><span class=\"attr\">    zero:</span> <span class=\"string\">暂无分类</span></span><br><span class=\"line\"><span class=\"attr\">    one:</span> <span class=\"string\">目前共计</span> <span class=\"number\">1</span> <span class=\"string\">个分类</span></span><br><span class=\"line\"><span class=\"attr\">    other:</span> <span class=\"string\">\"目前共计 %d 个作者\"</span></span><br></pre></td></tr></table></figure>\n\n<p>在{项目名称}/themes/next/source/css/_common/components/pages/添加authors.styl，复制categories.styl内容将categorie改成author</p>\n<p>在同级文件pages.styl中添加@import “authors”;</p>\n<p>修改之后，运行以下命令就可以再你的主页看到啦</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$  hexo clean</span><br><span class=\"line\">$  hexo d -g</span><br></pre></td></tr></table></figure>\n\n<p>###博文压缩</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install gulp -g</span><br><span class=\"line\">$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save</span><br></pre></td></tr></table></figure>\n\n<p>在项目根目录下创建<code>gulpfile.js</code>并填入以下内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> minifycss = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-minify-css'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> uglify = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-uglify'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> htmlmin = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-htmlmin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> htmlclean = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-htmlclean'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 压缩 public 目录 css</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'minify-css'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'./public/**/*.css'</span>)</span><br><span class=\"line\">        .pipe(minifycss())</span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">'./public'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 压缩 public 目录 html</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'minify-html'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'./public/**/*.html'</span>)</span><br><span class=\"line\">    .pipe(htmlclean())</span><br><span class=\"line\">    .pipe(htmlmin(&#123;</span><br><span class=\"line\">         removeComments: <span class=\"literal\">true</span>,</span><br><span class=\"line\">         minifyJS: <span class=\"literal\">true</span>,</span><br><span class=\"line\">         minifyCSS: <span class=\"literal\">true</span>,</span><br><span class=\"line\">         minifyURLs: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">'./public'</span>))</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 压缩 public/js 目录 js</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'minify-js'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">'./public/**/*.js'</span>)</span><br><span class=\"line\">        .pipe(uglify())</span><br><span class=\"line\">        .pipe(gulp.dest(<span class=\"string\">'./public'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 执行 gulp 命令时执行的任务</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'default'</span>, [</span><br><span class=\"line\">    <span class=\"string\">'minify-html'</span>,<span class=\"string\">'minify-css'</span>,<span class=\"string\">'minify-js'</span></span><br><span class=\"line\">]);</span><br></pre></td></tr></table></figure>\n\n<p>生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。</p>"},{"title":"Idea-Mac激活","date":"2020-01-19T03:22:00.000Z","author":"Guyuqing","copyright":true,"comments":1,"top":true,"_content":"\n1. 首先下载jar包：[百度网盘链接](https://pan.baidu.com/s/17k7rp63-XHho8oeHE0ROIA)  密码:**b8ye**  将其放到合适的文件夹\n2. 进入idea（首次进入可以选择免费30天，激活码失效后进入免费30分钟）如果没有项目随便建个项目，点击菜单栏 **Help -> Edit Custom VM Options** \n   * 注意：切记一定要通过 IDEA 来修改 .vmoptions 文件，不要手动直接去修改，现在 IDEA 针对反破解已经越来越严格\n3. 在末尾添加路径：**-javaagent:/Users/XXXX/XXXX/jetbrainsCrack.jar**\n    * 注意：补丁全路径中不要包含中文，否则，可能导致破解失败！\n4. `重启idea！！！一定要重启`\n5. 重启完成后，开始填入激活码，点击菜单栏 **Help -> Register:**\n\n```text\nA82DEE284F-eyJsaWNlbnNlSWQiOiJBODJERUUyODRGIiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJVbmxpbWl0ZWQgbGljZW5zZSB0aWxsIGVuZCBvZiB0aGUgY2VudHVyeS4iLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiODkwNzA3MC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-5epo90Xs7KIIBb8ckoxnB/AZQ8Ev7rFrNqwFhBAsQYsQyhvqf1FcYdmlecFWJBHSWZU9b41kvsN4bwAHT5PiznOTmfvGv1MuOzMO0VOXZlc+edepemgpt+t3GUHvfGtzWFYeKeyCk+CLA9BqUzHRTgl2uBoIMNqh5izlDmejIwUHLl39QOyzHiTYNehnVN7GW5+QUeimTr/koVUgK8xofu59Tv8rcdiwIXwTo71LcU2z2P+T3R81fwKkt34evy7kRch4NIQUQUno//Pl3V0rInm3B2oFq9YBygPUdBUbdH/KHROyohZRD8SaZJO6kUT0BNvtDPKF4mCT1saWM38jkw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==\n```\n\n```text\n3AGXEJXFK9-eyJsaWNlbnNlSWQiOiIzQUdYRUpYRks5IiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-WGTHs6XpDhr+uumvbwQPOdlxWnQwgnGaL4eRnlpGKApEEkJyYvNEuPWBSrQkPmVpim/8Sab6HV04Dw3IzkJT0yTc29sPEXBf69+7y6Jv718FaJu4MWfsAk/ZGtNIUOczUQ0iGKKnSSsfQ/3UoMv0q/yJcfvj+me5Zd/gfaisCCMUaGjB/lWIPpEPzblDtVJbRexB1MALrLCEoDv3ujcPAZ7xWb54DiZwjYhQvQ+CvpNNF2jeTku7lbm5v+BoDsdeRq7YBt9ANLUKPr2DahcaZ4gctpHZXhG96IyKx232jYq9jQrFDbQMtVr3E+GsCekMEWSD//dLT+HuZdc1sAIYrw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==\n```\n\n```text\nKNBB2QUUR1-eyJsaWNlbnNlSWQiOiJLTkJCMlFVVVIxIiwibGljZW5zZWVOYW1lIjoiZ2hib2tlIiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IiIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiQUMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRFBOIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBTIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRNIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkNMIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJTMCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSTSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJXUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSU1UiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiMTI3OTY4NzcvMCIsImdyYWNlUGVyaW9kRGF5cyI6NywiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-1iV7BA/baNqv0Q5yUnAphUmh66QhkDRX+qPL09ICuEicBqiPOBxmVLLCVUpkxhrNyfmOtat2LcHwcX/NHkYXdoW+6aS0S388xe1PV2oodiPBhFlEaOac42UQLgP4EidfGQSvKwC9tR1zL5b2CJPQKZ7iiHh/iKBQxP6OBMUP1T7j3Fe1rlxfYPc92HRZf6cO+C0+buJP5ERZkyIn5ZrVM4TEnWrRHbpL8SVNq4yqfc+NwoRzRSNC++81VDS3AXv9c91YeZJz6JXO7AokIk54wltr42FLNuKbozvB/HCxV9PA5vIiM+kZY1K0w5ytgxEYKqA87adA7R5xL/crpaMxHQ==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==\n```\n或者随便在网上找个激活码\n    \n6. 点击激活，可以看到激活日期到2089年\n\n","source":"_posts/Idea-Activation.md","raw":"---\ntitle: Idea-Mac激活\ndate: 2020-01-19 11:22:00\ntags:\n    - Idea\ncategories: Idea\nauthor: Guyuqing\ncopyright: true\ncomments: true\ntop: true\n---\n\n1. 首先下载jar包：[百度网盘链接](https://pan.baidu.com/s/17k7rp63-XHho8oeHE0ROIA)  密码:**b8ye**  将其放到合适的文件夹\n2. 进入idea（首次进入可以选择免费30天，激活码失效后进入免费30分钟）如果没有项目随便建个项目，点击菜单栏 **Help -> Edit Custom VM Options** \n   * 注意：切记一定要通过 IDEA 来修改 .vmoptions 文件，不要手动直接去修改，现在 IDEA 针对反破解已经越来越严格\n3. 在末尾添加路径：**-javaagent:/Users/XXXX/XXXX/jetbrainsCrack.jar**\n    * 注意：补丁全路径中不要包含中文，否则，可能导致破解失败！\n4. `重启idea！！！一定要重启`\n5. 重启完成后，开始填入激活码，点击菜单栏 **Help -> Register:**\n\n```text\nA82DEE284F-eyJsaWNlbnNlSWQiOiJBODJERUUyODRGIiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJVbmxpbWl0ZWQgbGljZW5zZSB0aWxsIGVuZCBvZiB0aGUgY2VudHVyeS4iLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiODkwNzA3MC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-5epo90Xs7KIIBb8ckoxnB/AZQ8Ev7rFrNqwFhBAsQYsQyhvqf1FcYdmlecFWJBHSWZU9b41kvsN4bwAHT5PiznOTmfvGv1MuOzMO0VOXZlc+edepemgpt+t3GUHvfGtzWFYeKeyCk+CLA9BqUzHRTgl2uBoIMNqh5izlDmejIwUHLl39QOyzHiTYNehnVN7GW5+QUeimTr/koVUgK8xofu59Tv8rcdiwIXwTo71LcU2z2P+T3R81fwKkt34evy7kRch4NIQUQUno//Pl3V0rInm3B2oFq9YBygPUdBUbdH/KHROyohZRD8SaZJO6kUT0BNvtDPKF4mCT1saWM38jkw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==\n```\n\n```text\n3AGXEJXFK9-eyJsaWNlbnNlSWQiOiIzQUdYRUpYRks5IiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-WGTHs6XpDhr+uumvbwQPOdlxWnQwgnGaL4eRnlpGKApEEkJyYvNEuPWBSrQkPmVpim/8Sab6HV04Dw3IzkJT0yTc29sPEXBf69+7y6Jv718FaJu4MWfsAk/ZGtNIUOczUQ0iGKKnSSsfQ/3UoMv0q/yJcfvj+me5Zd/gfaisCCMUaGjB/lWIPpEPzblDtVJbRexB1MALrLCEoDv3ujcPAZ7xWb54DiZwjYhQvQ+CvpNNF2jeTku7lbm5v+BoDsdeRq7YBt9ANLUKPr2DahcaZ4gctpHZXhG96IyKx232jYq9jQrFDbQMtVr3E+GsCekMEWSD//dLT+HuZdc1sAIYrw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==\n```\n\n```text\nKNBB2QUUR1-eyJsaWNlbnNlSWQiOiJLTkJCMlFVVVIxIiwibGljZW5zZWVOYW1lIjoiZ2hib2tlIiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IiIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiQUMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRFBOIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBTIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRNIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkNMIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJTMCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSTSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJXUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSU1UiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiMTI3OTY4NzcvMCIsImdyYWNlUGVyaW9kRGF5cyI6NywiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-1iV7BA/baNqv0Q5yUnAphUmh66QhkDRX+qPL09ICuEicBqiPOBxmVLLCVUpkxhrNyfmOtat2LcHwcX/NHkYXdoW+6aS0S388xe1PV2oodiPBhFlEaOac42UQLgP4EidfGQSvKwC9tR1zL5b2CJPQKZ7iiHh/iKBQxP6OBMUP1T7j3Fe1rlxfYPc92HRZf6cO+C0+buJP5ERZkyIn5ZrVM4TEnWrRHbpL8SVNq4yqfc+NwoRzRSNC++81VDS3AXv9c91YeZJz6JXO7AokIk54wltr42FLNuKbozvB/HCxV9PA5vIiM+kZY1K0w5ytgxEYKqA87adA7R5xL/crpaMxHQ==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==\n```\n或者随便在网上找个激活码\n    \n6. 点击激活，可以看到激活日期到2089年\n\n","slug":"Idea-Activation","published":1,"updated":"2020-01-22T09:31:30.365Z","layout":"post","photos":[],"link":"","_id":"ck8fb4a9a000vk2o55nnw227b","content":"<ol>\n<li>首先下载jar包：<a href=\"https://pan.baidu.com/s/17k7rp63-XHho8oeHE0ROIA\" target=\"_blank\" rel=\"noopener\">百度网盘链接</a>  密码:<strong>b8ye</strong>  将其放到合适的文件夹</li>\n<li>进入idea（首次进入可以选择免费30天，激活码失效后进入免费30分钟）如果没有项目随便建个项目，点击菜单栏 <strong>Help -&gt; Edit Custom VM Options</strong> <ul>\n<li>注意：切记一定要通过 IDEA 来修改 .vmoptions 文件，不要手动直接去修改，现在 IDEA 针对反破解已经越来越严格</li>\n</ul>\n</li>\n<li>在末尾添加路径：<strong>-javaagent:/Users/XXXX/XXXX/jetbrainsCrack.jar</strong><ul>\n<li>注意：补丁全路径中不要包含中文，否则，可能导致破解失败！</li>\n</ul>\n</li>\n<li><code>重启idea！！！一定要重启</code></li>\n<li>重启完成后，开始填入激活码，点击菜单栏 <strong>Help -&gt; Register:</strong></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A82DEE284F-eyJsaWNlbnNlSWQiOiJBODJERUUyODRGIiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJVbmxpbWl0ZWQgbGljZW5zZSB0aWxsIGVuZCBvZiB0aGUgY2VudHVyeS4iLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiODkwNzA3MC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-5epo90Xs7KIIBb8ckoxnB/AZQ8Ev7rFrNqwFhBAsQYsQyhvqf1FcYdmlecFWJBHSWZU9b41kvsN4bwAHT5PiznOTmfvGv1MuOzMO0VOXZlc+edepemgpt+t3GUHvfGtzWFYeKeyCk+CLA9BqUzHRTgl2uBoIMNqh5izlDmejIwUHLl39QOyzHiTYNehnVN7GW5+QUeimTr/koVUgK8xofu59Tv8rcdiwIXwTo71LcU2z2P+T3R81fwKkt34evy7kRch4NIQUQUno//Pl3V0rInm3B2oFq9YBygPUdBUbdH/KHROyohZRD8SaZJO6kUT0BNvtDPKF4mCT1saWM38jkw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3AGXEJXFK9-eyJsaWNlbnNlSWQiOiIzQUdYRUpYRks5IiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-WGTHs6XpDhr+uumvbwQPOdlxWnQwgnGaL4eRnlpGKApEEkJyYvNEuPWBSrQkPmVpim/8Sab6HV04Dw3IzkJT0yTc29sPEXBf69+7y6Jv718FaJu4MWfsAk/ZGtNIUOczUQ0iGKKnSSsfQ/3UoMv0q/yJcfvj+me5Zd/gfaisCCMUaGjB/lWIPpEPzblDtVJbRexB1MALrLCEoDv3ujcPAZ7xWb54DiZwjYhQvQ+CvpNNF2jeTku7lbm5v+BoDsdeRq7YBt9ANLUKPr2DahcaZ4gctpHZXhG96IyKx232jYq9jQrFDbQMtVr3E+GsCekMEWSD//dLT+HuZdc1sAIYrw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KNBB2QUUR1-eyJsaWNlbnNlSWQiOiJLTkJCMlFVVVIxIiwibGljZW5zZWVOYW1lIjoiZ2hib2tlIiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IiIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiQUMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRFBOIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBTIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRNIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkNMIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJTMCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSTSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJXUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSU1UiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiMTI3OTY4NzcvMCIsImdyYWNlUGVyaW9kRGF5cyI6NywiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-1iV7BA/baNqv0Q5yUnAphUmh66QhkDRX+qPL09ICuEicBqiPOBxmVLLCVUpkxhrNyfmOtat2LcHwcX/NHkYXdoW+6aS0S388xe1PV2oodiPBhFlEaOac42UQLgP4EidfGQSvKwC9tR1zL5b2CJPQKZ7iiHh/iKBQxP6OBMUP1T7j3Fe1rlxfYPc92HRZf6cO+C0+buJP5ERZkyIn5ZrVM4TEnWrRHbpL8SVNq4yqfc+NwoRzRSNC++81VDS3AXv9c91YeZJz6JXO7AokIk54wltr42FLNuKbozvB/HCxV9PA5vIiM+kZY1K0w5ytgxEYKqA87adA7R5xL/crpaMxHQ==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==</span><br></pre></td></tr></table></figure>\n\n<p>或者随便在网上找个激活码</p>\n<ol start=\"6\">\n<li>点击激活，可以看到激活日期到2089年</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>首先下载jar包：<a href=\"https://pan.baidu.com/s/17k7rp63-XHho8oeHE0ROIA\" target=\"_blank\" rel=\"noopener\">百度网盘链接</a>  密码:<strong>b8ye</strong>  将其放到合适的文件夹</li>\n<li>进入idea（首次进入可以选择免费30天，激活码失效后进入免费30分钟）如果没有项目随便建个项目，点击菜单栏 <strong>Help -&gt; Edit Custom VM Options</strong> <ul>\n<li>注意：切记一定要通过 IDEA 来修改 .vmoptions 文件，不要手动直接去修改，现在 IDEA 针对反破解已经越来越严格</li>\n</ul>\n</li>\n<li>在末尾添加路径：<strong>-javaagent:/Users/XXXX/XXXX/jetbrainsCrack.jar</strong><ul>\n<li>注意：补丁全路径中不要包含中文，否则，可能导致破解失败！</li>\n</ul>\n</li>\n<li><code>重启idea！！！一定要重启</code></li>\n<li>重启完成后，开始填入激活码，点击菜单栏 <strong>Help -&gt; Register:</strong></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A82DEE284F-eyJsaWNlbnNlSWQiOiJBODJERUUyODRGIiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJVbmxpbWl0ZWQgbGljZW5zZSB0aWxsIGVuZCBvZiB0aGUgY2VudHVyeS4iLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiODkwNzA3MC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-5epo90Xs7KIIBb8ckoxnB/AZQ8Ev7rFrNqwFhBAsQYsQyhvqf1FcYdmlecFWJBHSWZU9b41kvsN4bwAHT5PiznOTmfvGv1MuOzMO0VOXZlc+edepemgpt+t3GUHvfGtzWFYeKeyCk+CLA9BqUzHRTgl2uBoIMNqh5izlDmejIwUHLl39QOyzHiTYNehnVN7GW5+QUeimTr/koVUgK8xofu59Tv8rcdiwIXwTo71LcU2z2P+T3R81fwKkt34evy7kRch4NIQUQUno//Pl3V0rInm3B2oFq9YBygPUdBUbdH/KHROyohZRD8SaZJO6kUT0BNvtDPKF4mCT1saWM38jkw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3AGXEJXFK9-eyJsaWNlbnNlSWQiOiIzQUdYRUpYRks5IiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-WGTHs6XpDhr+uumvbwQPOdlxWnQwgnGaL4eRnlpGKApEEkJyYvNEuPWBSrQkPmVpim/8Sab6HV04Dw3IzkJT0yTc29sPEXBf69+7y6Jv718FaJu4MWfsAk/ZGtNIUOczUQ0iGKKnSSsfQ/3UoMv0q/yJcfvj+me5Zd/gfaisCCMUaGjB/lWIPpEPzblDtVJbRexB1MALrLCEoDv3ujcPAZ7xWb54DiZwjYhQvQ+CvpNNF2jeTku7lbm5v+BoDsdeRq7YBt9ANLUKPr2DahcaZ4gctpHZXhG96IyKx232jYq9jQrFDbQMtVr3E+GsCekMEWSD//dLT+HuZdc1sAIYrw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KNBB2QUUR1-eyJsaWNlbnNlSWQiOiJLTkJCMlFVVVIxIiwibGljZW5zZWVOYW1lIjoiZ2hib2tlIiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IiIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiQUMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRFBOIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBTIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRNIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkNMIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJTMCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSTSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJXUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSU1UiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiMTI3OTY4NzcvMCIsImdyYWNlUGVyaW9kRGF5cyI6NywiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-1iV7BA/baNqv0Q5yUnAphUmh66QhkDRX+qPL09ICuEicBqiPOBxmVLLCVUpkxhrNyfmOtat2LcHwcX/NHkYXdoW+6aS0S388xe1PV2oodiPBhFlEaOac42UQLgP4EidfGQSvKwC9tR1zL5b2CJPQKZ7iiHh/iKBQxP6OBMUP1T7j3Fe1rlxfYPc92HRZf6cO+C0+buJP5ERZkyIn5ZrVM4TEnWrRHbpL8SVNq4yqfc+NwoRzRSNC++81VDS3AXv9c91YeZJz6JXO7AokIk54wltr42FLNuKbozvB/HCxV9PA5vIiM+kZY1K0w5ytgxEYKqA87adA7R5xL/crpaMxHQ==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==</span><br></pre></td></tr></table></figure>\n\n<p>或者随便在网上找个激活码</p>\n<ol start=\"6\">\n<li>点击激活，可以看到激活日期到2089年</li>\n</ol>\n"},{"title":"《自己动手写JAVA虚拟机》学习笔记一【命令行工具】","date":"2019-02-11T09:23:04.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"最近正在看张秀宏著的《自己动手写Java虚拟机》，这本书适合初学者更深入的理解java虚拟机的含义，也可以简单学习go语言的基本使用。\n\n## 准备工作\n\n### 安装JDK\n从Oracle官网下载最新的JDK，双击运行即可。我使用的是1.8.0_161\n\n### 安装GO\n从[GO语言官网](https://golang.org/dl/)下载最新版本的GO安装文件，双击运行即可,我使用的是1.11.2。\n测试Go环境是否安装成功\n``` bash\n～$ go version\ngo version go1.11.2 darwin/amd64\n```\n<!-- more -->\n设置环境变量\n```bash\n#添加Go的运行环境路径\nexport PATH=$PATH:/usr/local/go/bin\n#添加Go工程的工作空间,可自行修改\nexport GOPATH=/home/XXX/XXX/jvmgo/go\n```\n执行以下命令，如果GOPATH与你设置的相同环境变量设置成功,\n```base\n～$ go env\n```\n## 实现JAVA命令\n\njava命令常用选项及其用途\n\n| 选项 | 用途 |\n| :------ | :------ | \n| -version | 输出版本信息，然后退出 | \n| -?/-help\t | 输出帮助信息，然后退出 |\n| -cp/-classpath | 指定用户类路径 |\n| -Dproperty=value | 设置Java系统属性 |\n| -Xms | 设置初始堆空间大小 |\n| -Xmx | 设置最大堆空间大小 |\n| -Xss | 设置线程栈空间大小 |\n\n### 编写命令行工具\n\n首先创建项目结构\n```base\n|-jvmgo\n    |-ch01\n```\n在ch01目录下创建cmd.go文件\n```go\npackage main\n\nimport \"flag\"\nimport \"fmt\"\nimport \"os\"\n\n\n//用法: java [-options] class [args...] (执行类)\n//或  java [-options] -jar jarfile [args...] (执行 jar 文件)\ntype Cmd struct {\n\thelpFlag bool\n\tversionFlag bool\n\tcpOption string\n\tclass string\n\targs []string\n}\n\n\n//把命令的用法打印到控制台\nfunc printUsage()  {\n\tfmt.Printf(\"Usage：%s [-options] class [args...]\\n\",os.Args[0])\n}\n\n//命令解析\nfunc parseCmd() *Cmd {\n\t\n\t//声明cmd为指向空的Cmd对象的指针\n\tcmd := &Cmd{}\n\n\t//定义flag参数\n\t//Usage是一个函数，默认输出所有定义了的命令行参数和帮助信息\n\tflag.Usage = printUsage\n\tflag.BoolVar(&cmd.helpFlag,\"help\",false,\"print help message\")\n\tflag.BoolVar(&cmd.helpFlag,\"?\",false,\"print help message\")\n\tflag.BoolVar(&cmd.versionFlag,\"version\",false,\"print version and exit\")\n\tflag.StringVar(&cmd.cpOption,\"classpath\",\"\",\"classpath\")\n\tflag.StringVar(&cmd.cpOption,\"cp\",\"\",\"classpath\")\n\t//在所有的flag定义完成之后，可以通过调用flag.Parse()进行解析。\n\tflag.Parse()\n\t//flag.Args()可以捕获未被解析的参数\n\targs := flag.Args()\n\tif len(args) > 0{\n\t\tcmd.class = args[0]\n\t\tcmd.args = args[1:]\n\t}\n\n\treturn cmd\n}\n\n```\n### 测试代码\n\n在ch01目录下创建main.go文件\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tcmd := parseCmd()\n\tif cmd.versionFlag {\n\t\tfmt.Println(\"version 0.0.1\")\n\t}else if cmd.helpFlag || cmd.class == \"\"{\n\t\tprintUsage()\n\t}else {\n\t\tstartJVM(cmd)\n\t}\n}\n//模拟启动jvm\nfunc startJVM(cmd *Cmd)  {\n\t//还未开始写，暂时打印\n\tfmt.Printf(\"classpath:%s class:%s args:%v\\n\",cmd.cpOption,cmd.class,cmd.args)\n}\n```\n\n编译main.go，并测试-version\n```bash\n$ go install jvmgo/ch01 \n$ ch01 -version\nversion 0.0.1\n```\n","source":"_posts/JVM1.md","raw":"---\ntitle: 《自己动手写JAVA虚拟机》学习笔记一【命令行工具】\ndate: 2019-02-11 17:23:04\ntags:\n    - JVM\n    - JAVA\n    - GO\n    - 学习笔记\ncategories: JVM\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n最近正在看张秀宏著的《自己动手写Java虚拟机》，这本书适合初学者更深入的理解java虚拟机的含义，也可以简单学习go语言的基本使用。\n\n## 准备工作\n\n### 安装JDK\n从Oracle官网下载最新的JDK，双击运行即可。我使用的是1.8.0_161\n\n### 安装GO\n从[GO语言官网](https://golang.org/dl/)下载最新版本的GO安装文件，双击运行即可,我使用的是1.11.2。\n测试Go环境是否安装成功\n``` bash\n～$ go version\ngo version go1.11.2 darwin/amd64\n```\n<!-- more -->\n设置环境变量\n```bash\n#添加Go的运行环境路径\nexport PATH=$PATH:/usr/local/go/bin\n#添加Go工程的工作空间,可自行修改\nexport GOPATH=/home/XXX/XXX/jvmgo/go\n```\n执行以下命令，如果GOPATH与你设置的相同环境变量设置成功,\n```base\n～$ go env\n```\n## 实现JAVA命令\n\njava命令常用选项及其用途\n\n| 选项 | 用途 |\n| :------ | :------ | \n| -version | 输出版本信息，然后退出 | \n| -?/-help\t | 输出帮助信息，然后退出 |\n| -cp/-classpath | 指定用户类路径 |\n| -Dproperty=value | 设置Java系统属性 |\n| -Xms | 设置初始堆空间大小 |\n| -Xmx | 设置最大堆空间大小 |\n| -Xss | 设置线程栈空间大小 |\n\n### 编写命令行工具\n\n首先创建项目结构\n```base\n|-jvmgo\n    |-ch01\n```\n在ch01目录下创建cmd.go文件\n```go\npackage main\n\nimport \"flag\"\nimport \"fmt\"\nimport \"os\"\n\n\n//用法: java [-options] class [args...] (执行类)\n//或  java [-options] -jar jarfile [args...] (执行 jar 文件)\ntype Cmd struct {\n\thelpFlag bool\n\tversionFlag bool\n\tcpOption string\n\tclass string\n\targs []string\n}\n\n\n//把命令的用法打印到控制台\nfunc printUsage()  {\n\tfmt.Printf(\"Usage：%s [-options] class [args...]\\n\",os.Args[0])\n}\n\n//命令解析\nfunc parseCmd() *Cmd {\n\t\n\t//声明cmd为指向空的Cmd对象的指针\n\tcmd := &Cmd{}\n\n\t//定义flag参数\n\t//Usage是一个函数，默认输出所有定义了的命令行参数和帮助信息\n\tflag.Usage = printUsage\n\tflag.BoolVar(&cmd.helpFlag,\"help\",false,\"print help message\")\n\tflag.BoolVar(&cmd.helpFlag,\"?\",false,\"print help message\")\n\tflag.BoolVar(&cmd.versionFlag,\"version\",false,\"print version and exit\")\n\tflag.StringVar(&cmd.cpOption,\"classpath\",\"\",\"classpath\")\n\tflag.StringVar(&cmd.cpOption,\"cp\",\"\",\"classpath\")\n\t//在所有的flag定义完成之后，可以通过调用flag.Parse()进行解析。\n\tflag.Parse()\n\t//flag.Args()可以捕获未被解析的参数\n\targs := flag.Args()\n\tif len(args) > 0{\n\t\tcmd.class = args[0]\n\t\tcmd.args = args[1:]\n\t}\n\n\treturn cmd\n}\n\n```\n### 测试代码\n\n在ch01目录下创建main.go文件\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tcmd := parseCmd()\n\tif cmd.versionFlag {\n\t\tfmt.Println(\"version 0.0.1\")\n\t}else if cmd.helpFlag || cmd.class == \"\"{\n\t\tprintUsage()\n\t}else {\n\t\tstartJVM(cmd)\n\t}\n}\n//模拟启动jvm\nfunc startJVM(cmd *Cmd)  {\n\t//还未开始写，暂时打印\n\tfmt.Printf(\"classpath:%s class:%s args:%v\\n\",cmd.cpOption,cmd.class,cmd.args)\n}\n```\n\n编译main.go，并测试-version\n```bash\n$ go install jvmgo/ch01 \n$ ch01 -version\nversion 0.0.1\n```\n","slug":"JVM1","published":1,"updated":"2019-07-31T13:41:40.989Z","layout":"post","photos":[],"link":"","_id":"ck8fb4a9j000yk2o5fh38du4l","content":"<p>最近正在看张秀宏著的《自己动手写Java虚拟机》，这本书适合初学者更深入的理解java虚拟机的含义，也可以简单学习go语言的基本使用。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"安装JDK\"><a href=\"#安装JDK\" class=\"headerlink\" title=\"安装JDK\"></a>安装JDK</h3><p>从Oracle官网下载最新的JDK，双击运行即可。我使用的是1.8.0_161</p>\n<h3 id=\"安装GO\"><a href=\"#安装GO\" class=\"headerlink\" title=\"安装GO\"></a>安装GO</h3><p>从<a href=\"https://golang.org/dl/\" target=\"_blank\" rel=\"noopener\">GO语言官网</a>下载最新版本的GO安装文件，双击运行即可,我使用的是1.11.2。<br>测试Go环境是否安装成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">～$ go version</span><br><span class=\"line\">go version go1.11.2 darwin/amd64</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n<p>设置环境变量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#添加Go的运行环境路径</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:/usr/<span class=\"built_in\">local</span>/go/bin</span><br><span class=\"line\"><span class=\"comment\">#添加Go工程的工作空间,可自行修改</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> GOPATH=/home/XXX/XXX/jvmgo/go</span><br></pre></td></tr></table></figure>\n\n<p>执行以下命令，如果GOPATH与你设置的相同环境变量设置成功,</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">～$ go env</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现JAVA命令\"><a href=\"#实现JAVA命令\" class=\"headerlink\" title=\"实现JAVA命令\"></a>实现JAVA命令</h2><p>java命令常用选项及其用途</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">-version</td>\n<td align=\"left\">输出版本信息，然后退出</td>\n</tr>\n<tr>\n<td align=\"left\">-?/-help</td>\n<td align=\"left\">输出帮助信息，然后退出</td>\n</tr>\n<tr>\n<td align=\"left\">-cp/-classpath</td>\n<td align=\"left\">指定用户类路径</td>\n</tr>\n<tr>\n<td align=\"left\">-Dproperty=value</td>\n<td align=\"left\">设置Java系统属性</td>\n</tr>\n<tr>\n<td align=\"left\">-Xms</td>\n<td align=\"left\">设置初始堆空间大小</td>\n</tr>\n<tr>\n<td align=\"left\">-Xmx</td>\n<td align=\"left\">设置最大堆空间大小</td>\n</tr>\n<tr>\n<td align=\"left\">-Xss</td>\n<td align=\"left\">设置线程栈空间大小</td>\n</tr>\n</tbody></table>\n<h3 id=\"编写命令行工具\"><a href=\"#编写命令行工具\" class=\"headerlink\" title=\"编写命令行工具\"></a>编写命令行工具</h3><p>首先创建项目结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-jvmgo</span><br><span class=\"line\">    |-ch01</span><br></pre></td></tr></table></figure>\n\n<p>在ch01目录下创建cmd.go文件</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"flag\"</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"os\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用法: java [-options] class [args...] (执行类)</span></span><br><span class=\"line\"><span class=\"comment\">//或  java [-options] -jar jarfile [args...] (执行 jar 文件)</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\thelpFlag <span class=\"keyword\">bool</span></span><br><span class=\"line\">\tversionFlag <span class=\"keyword\">bool</span></span><br><span class=\"line\">\tcpOption <span class=\"keyword\">string</span></span><br><span class=\"line\">\tclass <span class=\"keyword\">string</span></span><br><span class=\"line\">\targs []<span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//把命令的用法打印到控制台</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printUsage</span><span class=\"params\">()</span></span>  &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"Usage：%s [-options] class [args...]\\n\"</span>,os.Args[<span class=\"number\">0</span>])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//命令解析</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">parseCmd</span><span class=\"params\">()</span> *<span class=\"title\">Cmd</span></span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//声明cmd为指向空的Cmd对象的指针</span></span><br><span class=\"line\">\tcmd := &amp;Cmd&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//定义flag参数</span></span><br><span class=\"line\">\t<span class=\"comment\">//Usage是一个函数，默认输出所有定义了的命令行参数和帮助信息</span></span><br><span class=\"line\">\tflag.Usage = printUsage</span><br><span class=\"line\">\tflag.BoolVar(&amp;cmd.helpFlag,<span class=\"string\">\"help\"</span>,<span class=\"literal\">false</span>,<span class=\"string\">\"print help message\"</span>)</span><br><span class=\"line\">\tflag.BoolVar(&amp;cmd.helpFlag,<span class=\"string\">\"?\"</span>,<span class=\"literal\">false</span>,<span class=\"string\">\"print help message\"</span>)</span><br><span class=\"line\">\tflag.BoolVar(&amp;cmd.versionFlag,<span class=\"string\">\"version\"</span>,<span class=\"literal\">false</span>,<span class=\"string\">\"print version and exit\"</span>)</span><br><span class=\"line\">\tflag.StringVar(&amp;cmd.cpOption,<span class=\"string\">\"classpath\"</span>,<span class=\"string\">\"\"</span>,<span class=\"string\">\"classpath\"</span>)</span><br><span class=\"line\">\tflag.StringVar(&amp;cmd.cpOption,<span class=\"string\">\"cp\"</span>,<span class=\"string\">\"\"</span>,<span class=\"string\">\"classpath\"</span>)</span><br><span class=\"line\">\t<span class=\"comment\">//在所有的flag定义完成之后，可以通过调用flag.Parse()进行解析。</span></span><br><span class=\"line\">\tflag.Parse()</span><br><span class=\"line\">\t<span class=\"comment\">//flag.Args()可以捕获未被解析的参数</span></span><br><span class=\"line\">\targs := flag.Args()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(args) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">\t\tcmd.class = args[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\tcmd.args = args[<span class=\"number\">1</span>:]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cmd</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h3><p>在ch01目录下创建main.go文件</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tcmd := parseCmd()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> cmd.versionFlag &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">\"version 0.0.1\"</span>)</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> cmd.helpFlag || cmd.class == <span class=\"string\">\"\"</span>&#123;</span><br><span class=\"line\">\t\tprintUsage()</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tstartJVM(cmd)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//模拟启动jvm</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">startJVM</span><span class=\"params\">(cmd *Cmd)</span></span>  &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//还未开始写，暂时打印</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"classpath:%s class:%s args:%v\\n\"</span>,cmd.cpOption,cmd.class,cmd.args)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译main.go，并测试-version</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ go install jvmgo/ch01 </span><br><span class=\"line\">$ ch01 -version</span><br><span class=\"line\">version 0.0.1</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>最近正在看张秀宏著的《自己动手写Java虚拟机》，这本书适合初学者更深入的理解java虚拟机的含义，也可以简单学习go语言的基本使用。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"安装JDK\"><a href=\"#安装JDK\" class=\"headerlink\" title=\"安装JDK\"></a>安装JDK</h3><p>从Oracle官网下载最新的JDK，双击运行即可。我使用的是1.8.0_161</p>\n<h3 id=\"安装GO\"><a href=\"#安装GO\" class=\"headerlink\" title=\"安装GO\"></a>安装GO</h3><p>从<a href=\"https://golang.org/dl/\" target=\"_blank\" rel=\"noopener\">GO语言官网</a>下载最新版本的GO安装文件，双击运行即可,我使用的是1.11.2。<br>测试Go环境是否安装成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">～$ go version</span><br><span class=\"line\">go version go1.11.2 darwin/amd64</span><br></pre></td></tr></table></figure>","more":"<p>设置环境变量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#添加Go的运行环境路径</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:/usr/<span class=\"built_in\">local</span>/go/bin</span><br><span class=\"line\"><span class=\"comment\">#添加Go工程的工作空间,可自行修改</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> GOPATH=/home/XXX/XXX/jvmgo/go</span><br></pre></td></tr></table></figure>\n\n<p>执行以下命令，如果GOPATH与你设置的相同环境变量设置成功,</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">～$ go env</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现JAVA命令\"><a href=\"#实现JAVA命令\" class=\"headerlink\" title=\"实现JAVA命令\"></a>实现JAVA命令</h2><p>java命令常用选项及其用途</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">-version</td>\n<td align=\"left\">输出版本信息，然后退出</td>\n</tr>\n<tr>\n<td align=\"left\">-?/-help</td>\n<td align=\"left\">输出帮助信息，然后退出</td>\n</tr>\n<tr>\n<td align=\"left\">-cp/-classpath</td>\n<td align=\"left\">指定用户类路径</td>\n</tr>\n<tr>\n<td align=\"left\">-Dproperty=value</td>\n<td align=\"left\">设置Java系统属性</td>\n</tr>\n<tr>\n<td align=\"left\">-Xms</td>\n<td align=\"left\">设置初始堆空间大小</td>\n</tr>\n<tr>\n<td align=\"left\">-Xmx</td>\n<td align=\"left\">设置最大堆空间大小</td>\n</tr>\n<tr>\n<td align=\"left\">-Xss</td>\n<td align=\"left\">设置线程栈空间大小</td>\n</tr>\n</tbody></table>\n<h3 id=\"编写命令行工具\"><a href=\"#编写命令行工具\" class=\"headerlink\" title=\"编写命令行工具\"></a>编写命令行工具</h3><p>首先创建项目结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-jvmgo</span><br><span class=\"line\">    |-ch01</span><br></pre></td></tr></table></figure>\n\n<p>在ch01目录下创建cmd.go文件</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"flag\"</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"os\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用法: java [-options] class [args...] (执行类)</span></span><br><span class=\"line\"><span class=\"comment\">//或  java [-options] -jar jarfile [args...] (执行 jar 文件)</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\thelpFlag <span class=\"keyword\">bool</span></span><br><span class=\"line\">\tversionFlag <span class=\"keyword\">bool</span></span><br><span class=\"line\">\tcpOption <span class=\"keyword\">string</span></span><br><span class=\"line\">\tclass <span class=\"keyword\">string</span></span><br><span class=\"line\">\targs []<span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//把命令的用法打印到控制台</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printUsage</span><span class=\"params\">()</span></span>  &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"Usage：%s [-options] class [args...]\\n\"</span>,os.Args[<span class=\"number\">0</span>])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//命令解析</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">parseCmd</span><span class=\"params\">()</span> *<span class=\"title\">Cmd</span></span> &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//声明cmd为指向空的Cmd对象的指针</span></span><br><span class=\"line\">\tcmd := &amp;Cmd&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//定义flag参数</span></span><br><span class=\"line\">\t<span class=\"comment\">//Usage是一个函数，默认输出所有定义了的命令行参数和帮助信息</span></span><br><span class=\"line\">\tflag.Usage = printUsage</span><br><span class=\"line\">\tflag.BoolVar(&amp;cmd.helpFlag,<span class=\"string\">\"help\"</span>,<span class=\"literal\">false</span>,<span class=\"string\">\"print help message\"</span>)</span><br><span class=\"line\">\tflag.BoolVar(&amp;cmd.helpFlag,<span class=\"string\">\"?\"</span>,<span class=\"literal\">false</span>,<span class=\"string\">\"print help message\"</span>)</span><br><span class=\"line\">\tflag.BoolVar(&amp;cmd.versionFlag,<span class=\"string\">\"version\"</span>,<span class=\"literal\">false</span>,<span class=\"string\">\"print version and exit\"</span>)</span><br><span class=\"line\">\tflag.StringVar(&amp;cmd.cpOption,<span class=\"string\">\"classpath\"</span>,<span class=\"string\">\"\"</span>,<span class=\"string\">\"classpath\"</span>)</span><br><span class=\"line\">\tflag.StringVar(&amp;cmd.cpOption,<span class=\"string\">\"cp\"</span>,<span class=\"string\">\"\"</span>,<span class=\"string\">\"classpath\"</span>)</span><br><span class=\"line\">\t<span class=\"comment\">//在所有的flag定义完成之后，可以通过调用flag.Parse()进行解析。</span></span><br><span class=\"line\">\tflag.Parse()</span><br><span class=\"line\">\t<span class=\"comment\">//flag.Args()可以捕获未被解析的参数</span></span><br><span class=\"line\">\targs := flag.Args()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(args) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">\t\tcmd.class = args[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\tcmd.args = args[<span class=\"number\">1</span>:]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cmd</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h3><p>在ch01目录下创建main.go文件</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tcmd := parseCmd()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> cmd.versionFlag &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">\"version 0.0.1\"</span>)</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> cmd.helpFlag || cmd.class == <span class=\"string\">\"\"</span>&#123;</span><br><span class=\"line\">\t\tprintUsage()</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tstartJVM(cmd)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//模拟启动jvm</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">startJVM</span><span class=\"params\">(cmd *Cmd)</span></span>  &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//还未开始写，暂时打印</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"classpath:%s class:%s args:%v\\n\"</span>,cmd.cpOption,cmd.class,cmd.args)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译main.go，并测试-version</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ go install jvmgo/ch01 </span><br><span class=\"line\">$ ch01 -version</span><br><span class=\"line\">version 0.0.1</span><br></pre></td></tr></table></figure>"},{"title":"Java虚拟机","date":"2019-12-30T09:47:00.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"Java虚拟机(java virtual machine，JVM)，一种能够运行java字节码的虚拟机。作为一种编程语言的虚拟机，实际上不只是专用于Java语言，只要生成的编译文件匹配JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。 比如kotlin、scala等。\n\n# JVM基本结构\nJVM由三个主要的子系统构成\n* 类加载子系统\n* 运行时数据区(内存结构)\n* 执行引擎\n<img src=\"JVM-Fundamentals/1.png\" width=\"80%\" height=\"80%\">\n<!-- more -->\n\n## 类加载机制\n### 类的生命周期\n![](JVM-Fundamentals/2.png)\n\n1. 加载：将.class文件从磁盘读到内存\n    * 通过类的全限定名(com.xxx.xxx)+类加载器确定唯一的类，来获取定义此类的二进制字节流\n    * 将这个类字节流代表的静态存储结构转为方法区的运行时数据结构\n    * 在堆中生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口。\n2. 连接\n    1. 验证：验证字节码文件的正确性\n        * 文件格式验证：基于字节流验证，验证字节流是否符合Class文件格式的规范，并且能被当前虚拟机处理。\n        * 元数据验证：基于方法区的存储结构验证，对字节码描述信息进行语义验证。\n        * 字节码验证：基于方法区的存储结构验证，进行数据流和控制流的验证。\n        * 符号引用验证：基于方法区的存储结构验证，发生在解析中，是否可以将符号引用成功解析为直接引用。\n    2. 准备：给类的静态变量分配内存，并赋予`默认值`（不包括实例变量）\n        * public static int value = 123; //此时在准备阶段过后的初始值为0而不是123，在初始化过程才会被赋值为123\n        * public static final int value = 123;//value的值在准备阶段过后就是123。\n    3. 解析：类装载器装入类所引用的其它所有类\n3. 初始化：为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序编写者为变量分配的真正的初始值，执行静态代码块\n4. 使用\n5. 卸载\n\n### 类加载器的种类\n总体上分为两种：启动类加载器（C++实现） 和 其他类加载器（JAVA实现）\n#### 启动类加载器(Bootstrap ClassLoader)\n负责加载JRE的核心类库，如JRE目标下的rt.jar，charsets.jar等\n#### 扩展类加载器(Extension ClassLoader)\n负责加载JRE扩展目录ext中jar类包\n#### 系统类加载器(Application ClassLoader)\n负责加载ClassPath路径下的类包\n#### 用户自定义加载器(User ClassLoader)\n负责加载用户自定义路径下的类包\n<img src=\"JVM-Fundamentals/3.png\" width=\"50%\" height=\"50%\">\n\n### 类加载机制\n#### 全盘负责委托机制\n当一个ClassLoader加载一个类的时候，除非显示的使用另一个ClassLoader，该类所依赖和引用的类也由这个 ClassLoader载入\n\n#### 双亲委派机制\n指先委托父类加载器寻找目标类，在找不到的情况下，在自己的路径中查找并载入目标类\n<img src=\"JVM-Fundamentals/4.png\" width=\"50%\" height=\"50%\">\n1. 当有类需要加载，系统类加载器先判断有没有父类，有交给扩展类加载器加载\n2. 扩展类加载器判断有没有父类，有交给启动类加载器\n3. 启动类加载器没有父类，去实际加载该类，该类不是JRE包下的类，交给子类扩展类加载器去加载\n4. 扩展类加载器去加载该类，发现该类不是ext中的包，交给系统类加载器加载\n5. 系统类加载器加载，发现是classPath路径下的包，进行加载。\n\n##### 双亲委派模式的优势\n* 沙箱安全机制:比如自己写的String.class类不会被加载，这样可以防止核心库被随意篡改\n* 避免类的重复加载:当父ClassLoader已经加载了该类的时候，就不需要子ClassLoader再加载一次\n\n##### 为什么要打破双亲委派模式\n例如：tomcat \nTomcat是个web容器,可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。 \n如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加载器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。\n\n##### 如何打破双亲委派模式\n1. 继承ClassLoader\n2. 重写findClass()方法\n3. 重写loadClass()方法\n\n## 运行时数据区(内存结构)\n![](JVM-Fundamentals/5.png)\n\n### 虚拟机栈\njava虚拟机栈是线程私有的，每个方法执行都会创建一个栈帧，栈帧包含局部变量表、操作数栈、动态连接、方法出口等。\n\n#### 栈与栈帧\n每一个方法的执行到执行完成，对应着一个栈帧在虚拟机中从入栈到出栈的过程。java虚拟机栈栈顶的栈帧就是当前执行方法的栈帧。PC寄存器会指向该地址。当这个方法调用其他方法的时候久会创建一个新的栈帧，这个新的栈帧会被方法Java虚拟机栈的栈顶，变为当前的活动栈，在当前只有当前活动栈的本地变量才能被使用，当这个栈帧所有指令都完成的时候，这个栈帧被移除，之前的栈帧变为活动栈，前面移除栈帧的返回值变为这个栈帧的一个操作数。\n\n#### 栈帧\n栈帧包含局部变量表、操作数栈、动态连接、方法返回地址\n\n##### 局部变量表\n* 局部变量表是变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在java编译成class文件的时候，就在方法的Code属性的max_locals数据项中确定该方法需要分配的最大局部变量表的容量。\n* 局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放32位（4 字节）以内的数据类型（ boolean、byte、char、short、int、float、reference和returnAddress八种）\n* 对于64位长度的数据类型（long，double），虚拟机会以高位对齐方式为其分配`两个连续的Slot`空间，也就是相当于把一次long和double数据类型读写分割成为两次32位读写。\n* reference类型虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。\n* Slot是可以重用的，当Slot中的变量超出了作用域，那么下一次分配Slot的时候，将会覆盖原来的数据。Slot对对象的引用会影响GC（要是被引用，将不会被回收）。  \n* 系统不会为局部变量赋予初始值（实例变量和类变量都会被赋予初始值）。也就是说不存在类变量那样的准备阶段。\n\n##### 操作数栈\n* 操作数栈和局部变量表一样，在编译时期就已经确定了该方法所需要分配的局部变量表的最大容量。\n* 操作数栈的每一个元素可用是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型占用的栈容量为2。\n* 当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈 / 入栈操作（例如：在做算术运算的时候是通过操作数栈来进行的，又或者在调用其它方法的时候是通过操作数栈来进行参数传递的）。\n\n##### 动态连接\n直接引用：有具体引用地址的指针，被引用的类、方法或者变量已经被加载到内存中\n符号引用：即用用字符串符号的形式来表示引用，其实被引用的类、方法或者变量还没有被加载到内存中。\n举个例子：\n```java\n/**\n* 符号引用\n*/\nString str = \"abc\";\nSystem.out.println(\"str=\" + str);\n/**\n* 直接引用\n*/\nSystem.out.println(\"str=\" + \"abc\");\n```\n\n动态链接：在程序运行过程中，由符号引用转化为直接引用。\n静态链接：在类加载过程中，由符号引用转化为直接引用。\n\n##### 方法返回地址\n当一个方法开始执行时，可能有两种方式退出该方法：\n* 正常完成出口\n    * 正常完成出口是指方法正常完成并退出，没有抛出任何异常(包括Java虚拟机异常以及执行时通过throw语句显示抛出的异常)。如果当前方法正常完成，则根据当前方法返回的字节码指令，这时有可能会有返回值传递给方法调用者(调用它的方法)，或者无返回值。具体是否有返回值以及返回值的数据类型将根据该方法返回的字节码指令确定。\n* 异常完成出口\n    * 异常完成出口是指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退出。\n    \n无论方法采用何种方式退出，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在当前栈帧中保存一些信息，用来帮他恢复它的上层方法执行状态。\n方法退出过程实际上就等同于把当前栈帧出栈，因此退出可以执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压如调用者的操作数栈中，调整PC计数器的值以指向方法调用指令后的下一条指令。\n一般来说，方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理器表确定的，栈帧中一般不会保存此部分信息。\n\n```java\npublic class Demo {\n    public int math(){\n        int a = 1;\n        int b = 2;\n        int c = (a + b)*10;\n        return c;\n    }\n    public static void main(String[] args) {\n        Demo demo = new Demo();\n        demo.math();\n    }\n}\n```\n当执行👆Demo的math方法时，主线程内存会如何操作\n<img src=\"JVM-Fundamentals/5.1.png\" width=\"50%\" height=\"50%\">\n第一步，现将1放入`操作数栈`\n<img src=\"JVM-Fundamentals/5.2.png\" width=\"50%\" height=\"50%\">\n第二步，将1放入`局部变量表`中第一个槽里\n<img src=\"JVM-Fundamentals/5.3.png\" width=\"50%\" height=\"50%\">\n第三步，第四步同上，最终将2放入`局部变量表`中第二个槽里\n<img src=\"JVM-Fundamentals/5.4.png\" width=\"50%\" height=\"50%\">\n第五步，将1复制一份放入`操作数栈`的栈顶\n第六步，将2复制一份放入`操作数栈`的栈顶\n<img src=\"JVM-Fundamentals/5.5.png\" width=\"50%\" height=\"50%\">\n第七步，将2，1弹出操作数栈交给cpu去运算得到3，放到`操作数栈`的栈顶\n<img src=\"JVM-Fundamentals/5.6.png\" width=\"50%\" height=\"50%\">\n第八步，从常量池（-128～127）里拿到10，放入`操作数栈`顶\n<img src=\"JVM-Fundamentals/5.7.png\" width=\"50%\" height=\"50%\">\n第九步，弹出10，3交给cpu去运算得到30，放到`操作数栈`的栈顶（jvm1.6开始进行了指令优化，第8、9步合并成了一步操作）\n<img src=\"JVM-Fundamentals/5.8.png\" width=\"50%\" height=\"50%\">\n第十步，将30放到`局部变量表`中第3个槽里。\n<img src=\"JVM-Fundamentals/5.9.png\" width=\"50%\" height=\"50%\">\n第十一步，将30复制一份放入`操作数栈`第栈顶。\n第十二步，将30弹出操作数栈，通过`返回地址`返回。\n\n### 程序计数器\n就是一个指针，指向方法区中的方法字节码(用来存储**指向下一跳指令的地址**，也就是当前线程将要执行的指令代码)，\n由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计，用来保证线程间切换后正确执行。\n\n### 本地方法栈\n和栈作用很相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行native方法服务。\n登记native方法，在Execution Engine执行时加载本地方法库。\n\n### 方法区（永久代/持久代，元空间）\n类的所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在这里定义。\n简单来说，所有定义的方法的信息都保存在该区域，静态变量+常量+类信息(构造方法/接口定义)+运行时常量池都存在方法区中，\n虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap(非堆)，目的应该是为了和Java的堆区分开(jdk1.8以前hotspot虚拟机叫永久代、持久代，jdk1.8时叫元空间)\n\n永久代和元空间区别在于元数据区不在虚拟机当中，而是用的`本地内存`，永久代在虚拟机当中，永久代逻辑结构上也属于堆，但是物理上不属于。\n\n#### 为什么移除了永久代?\n参考官方解释http://openjdk.java.net/jeps/122\n大概意思是移除永久代是为融合HotSpot与 JRockit而做出的努力，因为JRockit没有永久代，不需要配置永久代。\n![](JVM-Fundamentals/7.png)\n\n\n### 堆\n虚拟机启动时自动分配创建，用于存放`对象`的实例，几乎所有对象都在堆上分配内存，当对象无法在该空间申请到内\n存是将抛出OutOfMemoryError异常。同时也是垃圾收集器管理的主要区域。\n![](JVM-Fundamentals/6.jpeg)\n\n#### 新生代(Young Generation)\n类出生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。\n新生代分为两部分:`伊甸区`(Eden space)和`幸存者区`(Survivor space)，所有的类都是在伊甸区被new出来的。\n幸存区(Survivor space):分为From和To区,TO区永远保持空。\n当Eden区的空间用完是，程序又需要创建对象，JVM的垃圾回收器将Eden区进行垃圾回收(`Minor GC`)，将Eden区中的不再被其它对象应用的对象进行销毁。\n然后将Eden区中剩余的对象移到From Survivor区。若From Survivor区也满了，再对该区进行垃圾回收，然后移动到To Survivor区，From区为空后，将To和From区转换，保证To区为空，并且对象年龄加一。\n当对象年龄默认加到15（因为**对象头只有4个bits**是存对象年龄，最大为15）时将剩下的对象移到老年代。\n\n### 老年代(Old Generation)\n新生代经过多次GC仍然存货的对象移动到老年区。\n若老年代也满了，这时候将发生Major GC(也可以叫`Full GC`)， 进行老年区的内存清理。\n若老年区执行了Full GC之后发现依然无法进行对象的保存，就会抛出 OOM(OutOfMemoryError)异常.\n\n\n## GC算法和收集器\n几种常见GC：\nMinorGC/YoungGC 新生代\nOldGC CMS特有\nFullGC/MajorGC 回收所有\nMixedGC（FullGC+YoungGC）  G1特有\n\n### 如何判断对象可以被回收\n堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡(即不能再被任何途径使用的对象)\n\n#### 引用计数法\n给对象添加一个引用计数器，每当有一个地方引用，计数器就加1。当引用失效，计数器就减1。任何时候计数器为0 的对象就是不可能再被使用的。\n\n这个方法实现简单，效率高，但是目前主流的虚拟机中没有选择这个算法来管理内存，最主要的原因是它很难解决**对象之前相互循环引用**的问题。所谓对象之间的相互引用问题，通过下面代码所示:除了对象a和b相互引用着对方之外，这两个对象之间再无任何引用。但是它们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数器法无法通知GC回收器回收它们。\n\n```java\npublic class CounterGC{\n    Object instance = null;\n    public static void main(String[] args){\n      CounterGC a = new CounterGC();\n      CounterGC b = new CounterGC();\n      a.instance = b;\n      b.instance = a;\n      a = null;\n      b = null;\n    }\n}\n```\n\n#### 可达性分析算法\n这个算法的基本思想就是通过一系列的称为\"GC Roots\"的对象作为起点，从这些节点开始向下搜索，节点所走过的路\n径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象时不可用的。\n\n`GC Roots根节点`:类加载器、Thread、虚拟机栈的局部变量表、static成员、常量引用、本地方法栈的变量等等.\n![](JVM-Fundamentals/8.png)\n\n### 如何判断一个常量是废弃常量\n运行时常量池主要回收的是废弃的常量。那么，我们怎么判断一个常量时废弃常量呢?\n假如在常量池中存在字符串\"abc\"，如果当前没有任何String对象引用该字符串常量的话，就说明常量\"abc\"就是废弃常量，如果这时发生内存回收的话而且有必要的话（内存不够用时才会发生回收），\"abc\"会被系统清理出常量池。\n\n### 如何判断一个类是无用的类\n需要满足以下三个条件:\n* 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\n* 加载该类的 ClassLoader 已经被回收。\n* 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n虚拟机可以对满足上述3个条件的无用类进行回收，这里仅仅是\"**可以**\"，而并不是和对象一样不适用了就必然会被回收。\n\n\n### 垃圾回收算法\n![](JVM-Fundamentals/9.png)\n\n#### 标记-清除算法\n它是最基础的收集算法，这个算法分为两个阶段，`标记`和`清除`。首先标记出所有需要回收的对象，在标记完成后\n统一回收所有被标记的对象。它有两个不足的地方:\n1. 效率问题，标记和清除两个过程的效率都不高;\n2. 空间问题，标记清除后会产生大量不连续的碎片;\n![](JVM-Fundamentals/9.1.png)\n\n#### 复制算法\n为了解决效率问题，复制算法出现了。它可以把内存分为大小相同的两块，每次只使用其中的一块。\n当这一块的内存使用完后，就将还存活的对象复制到另一块区，然后再把使用的空间一次清理掉。\n这样就使每次的内存回收都是对内存区间的一半进行回收\n![](JVM-Fundamentals/9.2.png)\n\n#### 标记-整理算法\n根据老年代的特点提出的一种标记算法，标记过程和“标记-清除”算法一样，但是后续步骤不是直接对可回收对象进行回收，而是让所有存活的对象向一段移动，然后直接清理掉边界以外的内存\n![](JVM-Fundamentals/9.3.png)\n\n#### 分代收集算法\n现在的商用虚拟机的垃圾收集器基本都采用\"分代收集\"算法，这种算法就是根据对象存活周期的不同将内存分为几块。\n一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n在新生代中，每次收集都有大量对象死去，所以可以选择复制算法，只要付出少量对象的复制成本就可以完成每次垃圾收集。\n而老年代的对象存活几率时比较高的，而且没有额外的空间对它进行分配担保，就必须选择“标记-清除”或 者“标记-整理”算法进行垃圾收集。\n\n### 垃圾收集器\n![](JVM-Fundamentals/10.png)\n#### Serial收集器\nSerial(串行)收集器收集器是最基本、历史最悠久的垃圾收集器了。\n大家看名字就知道这个收集器是一个单线程收集器了。\n它的`单线程`的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程( “Stop The World” )，直到它收集结束。\n**新生代采用复制算法，老年代采用标记-整理算法。**\n![](JVM-Fundamentals/10.1.png)\n虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短(仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续)。\n但是Serial收集器有没有优于其他垃圾收集器的地方呢?\n当然有，它简单而高效(与其他收集器的单线程相比)。 Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。\n\n#### ParNew收集器\nParNew收集器其实就是Serial收集器的`多线程`版本，除了使用多线程进行垃圾收集外，其余行为(控制参数、收集算法、回收策略等等)和Serial收集器完全一样。\n**新生代采用复制算法，老年代采用标记-整理算法。**\n![](JVM-Fundamentals/10.2.png)\n它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器(真正意义上的并发收集器，后面会介绍到)配合工作。\n\n#### Parallel Scavenge收集器(JDK1.8)\nParallel Scavenge 收集器类似于ParNew收集器。\nParallel Scavenge收集器关注点是`吞吐量`(高效率的利用CPU)。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。\nCMS等垃圾收集器的关注点更多的是用户线程的`停顿时间`(提高用户体验)。 Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。\n**新生代采用复制算法，老年代采用标记-整理算法。**\n![](JVM-Fundamentals/10.2.png)\n\n#### Serial Old收集器\nSerial收集器的老年代版本，它同样是一个`单线程`收集器，采用**标记-整理**算法。\n它主要有两大用途:一种用途是在JDK1.5以及以前的版本 中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。\n\n#### Parallel Old收集器\nParallel Scavenge收集器的老年代版本。使用`多线程`和**标记-整理**算法。\n在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。\n\n#### **CMS收集器**\n并行和并发概念补充:\n* 并行(Parallel) :指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 \n* 并发(Concurrent):指用户线程与垃圾收集线程同时执行(但不一定是并行，可能会交替执行)，用户程序 在继续运行，而垃圾收集器运行在另一个CPU上。\n\nCMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。\nCMS(Concurrent Mark Sweep)收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作。\n\n从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种**标记-清除**算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。\n整个过程分为四个步骤:\n* 初始标记(CMS initial mark): 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 \n* 并发标记(CMS concurrent mark): **同时开启GC和用户线程**，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\n* 重新标记(CMS remark): 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶 段时间短\n* 并发清除(CMS concurrent sweep): 开启用户线程，同时GC线程开始对为标记的区域做清扫。\n![](JVM-Fundamentals/10.3.png)\nCMS主要优点:并发收集、低停顿。\n但是它有下面三个明显的缺点:\n* 对CPU资源敏感;\n* 无法处理浮动垃圾;\n* 它使用的回收算法-**标记-清除**算法会导致收集结束时会有大量空间碎片产生。\n\n#### G1收集器\nG1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC停顿时间要求的同时,还具备高吞吐量性能特征.\n![](JVM-Fundamentals/10.3.png)\n被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点:\n* 并行与并发:G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU(CPU或者CPU核心)来缩短Stop- The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行 \n* 分代收集:虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。 空间整合:与CMS的“标记–清理”算法不同，G1从整体来看是基于**标记整理**算法实现的收集器;从局部上来看是基于**标记复制**算法实现的\n* **可预测的停顿**:这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内\n\nG1收集器的运作大致分为以下几个步骤:\n* 初始标记\n* 并发标记\n* 最终标记\n* 筛选回收\n\nG1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名 字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率(把内存化整为零)。\n\n#### 怎么选择垃圾收集器?（尽量由JVM自己选择）\n1. 优先调整堆的大小让服务器自己来选择\n2. 如果内存小于100m，使用串行收集器\n3. 如果是单核，并且没有停顿时间的要求，串行或JVM自己选择 \n4. 如果允许停顿时间超过1秒，选择并行或者JVM自己选\n5. 如果响应时间最重要，并且不能超过1秒，使用并发收集器\n官方推荐ZGC(java最新版本垃圾收器器，可预测的停顿最低2ms)，性能高。\n\n## JDK性能调优监控工具\n虚拟机参数分析网站：https://www.perfma.com/product/opts\n### jps\n显示当前系统的java进程情况\n```bash\ngdeMacBook-Pro:~ g$ jps\n94673 AppServiceApplication\n54995\n55011 RemoteMavenServer36\n94696 AppServiceApplication\n96956 Jps\n```\n(空白的54995是idea)\n### Jinfo\n查看正在运行的Java程序的扩展参数\n#### 查看JVM的参数\n```bash\ngdeMacBook-Pro:~ g$ jinfo -flags 94673\nVM Flags:\n-XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote -XX:CICompilerCount=4 -XX:ConcGCThreads=3 -XX:G1ConcRefinementThreads=10 -XX:G1HeapRegionSize=1048576 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=268435456 -XX:+ManagementServer -XX:MarkStackSize=4194304 -XX:MaxHeapSize=4294967296 -XX:MaxNewSize=2576351232 -XX:MinHeapDeltaBytes=1048576 -XX:NonNMethodCodeHeapSize=7549744 -XX:NonProfiledCodeHeapSize=244108496 -XX:ProfiledCodeHeapSize=0 -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:TieredStopAtLevel=1 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC\n```\n#### 查看java系统属性\n```bash\njinfo -sysprops 94673\n```\n\n\n### Jstat\njstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令格式:\njstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]\n```bash\ngdeMacBook-Pro:~ g$ jstat -gc 94673\n S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT\n 0.0   2048.0  0.0   2048.0 96256.0  68608.0   163840.0   132934.6  131280.0 127368.5 14720.0 13850.3    185    1.219   0      0.000  112     0.661    1.880\n```\n* S0C：第一个幸存区的大小\n* S1C：第二个幸存区的大小\n* S0U：第一个幸存区的使用大小\n* S1U：第二个幸存区的使用大小\n* EC：伊甸园区的大小\n* EU：伊甸园区的使用大小\n* OC：老年代大小\n* OU：老年代使用大小\n* MC：方法区大小\n* MU：方法区使用大小\n* CCSC:压缩类空间大小\n* CCSU:压缩类空间使用大小\n* YGC：年轻代垃圾回收次数\n* YGCT：年轻代垃圾回收消耗时间\n* FGC：老年代垃圾回收次数\n* FGCT：老年代垃圾回收消耗时间\n* GCT：垃圾回收消耗总时间\n\n### Jmap\n可以用来查看内存信息\n#### 堆的对象统计\n```bash\ngdeMacBook-Pro:~ g$ jmap -histo 94673 > xxx.txt\n```\n部分如下\n```text\n num     #instances         #bytes  class name (module)\n-------------------------------------------------------\n   1:        380588       39857240  [B (java.base@11.0.4)\n   2:         71568        8387344  [Ljava.lang.Object; (java.base@11.0.4)\n   3:        301995        7247880  java.lang.String (java.base@11.0.4)\n   4:         25762        5316280  [I (java.base@11.0.4)\n   5:         47736        4200768  java.lang.reflect.Method (java.base@11.0.4)\n   6:        126275        4040800  java.util.concurrent.ConcurrentHashMap$Node (java.base@11.0.4)\n   7:         69142        3871952  java.util.LinkedHashMap (java.base@11.0.4)\n   8:          2483        3656120  [C (java.base@11.0.4)\n   9:         46566        3352752  io.netty.channel.DefaultChannelHandlerContext\n  10:        104582        3346624  java.util.HashMap$Node (java.base@11.0.4)\n  11:         20887        2551232  java.lang.Class (java.base@11.0.4)\n  12:         32461        2077504  java.util.concurrent.ConcurrentHashMap (java.base@11.0.4)\n  13:         48062        1922480  java.util.HashMap$KeyIterator (java.base@11.0.4)\n  14:         17400        1720040  [Ljava.util.HashMap$Node; (java.base@11.0.4)\n  15:          2184        1432704  io.netty.util.internal.shaded.org.jctools.queues.MpscArrayQueue\n  16:         35693        1427720  java.util.LinkedHashMap$Entry (java.base@11.0.4)\n  17:         88742        1419872  java.lang.Object (java.base@11.0.4)\n  18:          1671        1195280  [Ljava.util.concurrent.ConcurrentHashMap$Node; (java.base@11.0.4)\n  19:         10270        1150240  sun.nio.ch.SocketChannelImpl (java.base@11.0.4)\n  20:         10237        1064648  io.netty.channel.socket.nio.NioSocketChannel\n  21:         42359        1016616  java.util.ArrayList (java.base@11.0.4)\n  22:         60868         973888  java.lang.Integer (java.base@11.0.4)\n  23:         20436         817440  io.netty.util.DefaultAttributeMap$DefaultAttribute\n  24:         10533         758376  org.springframework.core.type.classreading.AnnotationMetadataReadingVisitor\n  25:         18570         742800  com.meituan.service.mobile.mtthrift.mtrace.MtraceServerTBinaryProtocol$Factory\n  26:         10239         737208  io.netty.channel.DefaultChannelPipeline$HeadContext\n  27:         10239         737208  io.netty.channel.DefaultChannelPipeline$TailContext\n  28:         30914         729768  [Ljava.lang.Class; (java.base@11.0.4)\n  29:         21894         700608  java.util.concurrent.locks.ReentrantLock$NonfairSync (java.base@11.0.4)\n------省略----\n```\n* Num:序号\n* Instances:实例数量\n* Bytes:占用空间大小\n* Class Name:类名\n\n#### 堆信息\n```bash\ngdeMacBook-Pro:~ g$ jmap -heap 94673\nError: -heap option used\nCannot connect to core dump or remote debug server. Use jhsdb jmap instead\n```\njdk9及以上版本使用jmap -heap pid命令查看当前heap使用情况时，发现报错，提示需要使用jhsdb jmap来替代\n```bash\ngdeMacBook-Pro:~ g$ jhsdb jmap --heap --pid 94673\n```\n\n\n\n\n","source":"_posts/JVM-Fundamentals.md","raw":"---\ntitle: Java虚拟机\ndate: 2019-12-30 17:47:00\ntags:\n    - JVM\n    - JAVA\n    - 学习笔记\ncategories: JVM\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\nJava虚拟机(java virtual machine，JVM)，一种能够运行java字节码的虚拟机。作为一种编程语言的虚拟机，实际上不只是专用于Java语言，只要生成的编译文件匹配JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。 比如kotlin、scala等。\n\n# JVM基本结构\nJVM由三个主要的子系统构成\n* 类加载子系统\n* 运行时数据区(内存结构)\n* 执行引擎\n<img src=\"JVM-Fundamentals/1.png\" width=\"80%\" height=\"80%\">\n<!-- more -->\n\n## 类加载机制\n### 类的生命周期\n![](JVM-Fundamentals/2.png)\n\n1. 加载：将.class文件从磁盘读到内存\n    * 通过类的全限定名(com.xxx.xxx)+类加载器确定唯一的类，来获取定义此类的二进制字节流\n    * 将这个类字节流代表的静态存储结构转为方法区的运行时数据结构\n    * 在堆中生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口。\n2. 连接\n    1. 验证：验证字节码文件的正确性\n        * 文件格式验证：基于字节流验证，验证字节流是否符合Class文件格式的规范，并且能被当前虚拟机处理。\n        * 元数据验证：基于方法区的存储结构验证，对字节码描述信息进行语义验证。\n        * 字节码验证：基于方法区的存储结构验证，进行数据流和控制流的验证。\n        * 符号引用验证：基于方法区的存储结构验证，发生在解析中，是否可以将符号引用成功解析为直接引用。\n    2. 准备：给类的静态变量分配内存，并赋予`默认值`（不包括实例变量）\n        * public static int value = 123; //此时在准备阶段过后的初始值为0而不是123，在初始化过程才会被赋值为123\n        * public static final int value = 123;//value的值在准备阶段过后就是123。\n    3. 解析：类装载器装入类所引用的其它所有类\n3. 初始化：为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序编写者为变量分配的真正的初始值，执行静态代码块\n4. 使用\n5. 卸载\n\n### 类加载器的种类\n总体上分为两种：启动类加载器（C++实现） 和 其他类加载器（JAVA实现）\n#### 启动类加载器(Bootstrap ClassLoader)\n负责加载JRE的核心类库，如JRE目标下的rt.jar，charsets.jar等\n#### 扩展类加载器(Extension ClassLoader)\n负责加载JRE扩展目录ext中jar类包\n#### 系统类加载器(Application ClassLoader)\n负责加载ClassPath路径下的类包\n#### 用户自定义加载器(User ClassLoader)\n负责加载用户自定义路径下的类包\n<img src=\"JVM-Fundamentals/3.png\" width=\"50%\" height=\"50%\">\n\n### 类加载机制\n#### 全盘负责委托机制\n当一个ClassLoader加载一个类的时候，除非显示的使用另一个ClassLoader，该类所依赖和引用的类也由这个 ClassLoader载入\n\n#### 双亲委派机制\n指先委托父类加载器寻找目标类，在找不到的情况下，在自己的路径中查找并载入目标类\n<img src=\"JVM-Fundamentals/4.png\" width=\"50%\" height=\"50%\">\n1. 当有类需要加载，系统类加载器先判断有没有父类，有交给扩展类加载器加载\n2. 扩展类加载器判断有没有父类，有交给启动类加载器\n3. 启动类加载器没有父类，去实际加载该类，该类不是JRE包下的类，交给子类扩展类加载器去加载\n4. 扩展类加载器去加载该类，发现该类不是ext中的包，交给系统类加载器加载\n5. 系统类加载器加载，发现是classPath路径下的包，进行加载。\n\n##### 双亲委派模式的优势\n* 沙箱安全机制:比如自己写的String.class类不会被加载，这样可以防止核心库被随意篡改\n* 避免类的重复加载:当父ClassLoader已经加载了该类的时候，就不需要子ClassLoader再加载一次\n\n##### 为什么要打破双亲委派模式\n例如：tomcat \nTomcat是个web容器,可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。 \n如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加载器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。\n\n##### 如何打破双亲委派模式\n1. 继承ClassLoader\n2. 重写findClass()方法\n3. 重写loadClass()方法\n\n## 运行时数据区(内存结构)\n![](JVM-Fundamentals/5.png)\n\n### 虚拟机栈\njava虚拟机栈是线程私有的，每个方法执行都会创建一个栈帧，栈帧包含局部变量表、操作数栈、动态连接、方法出口等。\n\n#### 栈与栈帧\n每一个方法的执行到执行完成，对应着一个栈帧在虚拟机中从入栈到出栈的过程。java虚拟机栈栈顶的栈帧就是当前执行方法的栈帧。PC寄存器会指向该地址。当这个方法调用其他方法的时候久会创建一个新的栈帧，这个新的栈帧会被方法Java虚拟机栈的栈顶，变为当前的活动栈，在当前只有当前活动栈的本地变量才能被使用，当这个栈帧所有指令都完成的时候，这个栈帧被移除，之前的栈帧变为活动栈，前面移除栈帧的返回值变为这个栈帧的一个操作数。\n\n#### 栈帧\n栈帧包含局部变量表、操作数栈、动态连接、方法返回地址\n\n##### 局部变量表\n* 局部变量表是变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在java编译成class文件的时候，就在方法的Code属性的max_locals数据项中确定该方法需要分配的最大局部变量表的容量。\n* 局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放32位（4 字节）以内的数据类型（ boolean、byte、char、short、int、float、reference和returnAddress八种）\n* 对于64位长度的数据类型（long，double），虚拟机会以高位对齐方式为其分配`两个连续的Slot`空间，也就是相当于把一次long和double数据类型读写分割成为两次32位读写。\n* reference类型虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。\n* Slot是可以重用的，当Slot中的变量超出了作用域，那么下一次分配Slot的时候，将会覆盖原来的数据。Slot对对象的引用会影响GC（要是被引用，将不会被回收）。  \n* 系统不会为局部变量赋予初始值（实例变量和类变量都会被赋予初始值）。也就是说不存在类变量那样的准备阶段。\n\n##### 操作数栈\n* 操作数栈和局部变量表一样，在编译时期就已经确定了该方法所需要分配的局部变量表的最大容量。\n* 操作数栈的每一个元素可用是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型占用的栈容量为2。\n* 当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈 / 入栈操作（例如：在做算术运算的时候是通过操作数栈来进行的，又或者在调用其它方法的时候是通过操作数栈来进行参数传递的）。\n\n##### 动态连接\n直接引用：有具体引用地址的指针，被引用的类、方法或者变量已经被加载到内存中\n符号引用：即用用字符串符号的形式来表示引用，其实被引用的类、方法或者变量还没有被加载到内存中。\n举个例子：\n```java\n/**\n* 符号引用\n*/\nString str = \"abc\";\nSystem.out.println(\"str=\" + str);\n/**\n* 直接引用\n*/\nSystem.out.println(\"str=\" + \"abc\");\n```\n\n动态链接：在程序运行过程中，由符号引用转化为直接引用。\n静态链接：在类加载过程中，由符号引用转化为直接引用。\n\n##### 方法返回地址\n当一个方法开始执行时，可能有两种方式退出该方法：\n* 正常完成出口\n    * 正常完成出口是指方法正常完成并退出，没有抛出任何异常(包括Java虚拟机异常以及执行时通过throw语句显示抛出的异常)。如果当前方法正常完成，则根据当前方法返回的字节码指令，这时有可能会有返回值传递给方法调用者(调用它的方法)，或者无返回值。具体是否有返回值以及返回值的数据类型将根据该方法返回的字节码指令确定。\n* 异常完成出口\n    * 异常完成出口是指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退出。\n    \n无论方法采用何种方式退出，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在当前栈帧中保存一些信息，用来帮他恢复它的上层方法执行状态。\n方法退出过程实际上就等同于把当前栈帧出栈，因此退出可以执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压如调用者的操作数栈中，调整PC计数器的值以指向方法调用指令后的下一条指令。\n一般来说，方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理器表确定的，栈帧中一般不会保存此部分信息。\n\n```java\npublic class Demo {\n    public int math(){\n        int a = 1;\n        int b = 2;\n        int c = (a + b)*10;\n        return c;\n    }\n    public static void main(String[] args) {\n        Demo demo = new Demo();\n        demo.math();\n    }\n}\n```\n当执行👆Demo的math方法时，主线程内存会如何操作\n<img src=\"JVM-Fundamentals/5.1.png\" width=\"50%\" height=\"50%\">\n第一步，现将1放入`操作数栈`\n<img src=\"JVM-Fundamentals/5.2.png\" width=\"50%\" height=\"50%\">\n第二步，将1放入`局部变量表`中第一个槽里\n<img src=\"JVM-Fundamentals/5.3.png\" width=\"50%\" height=\"50%\">\n第三步，第四步同上，最终将2放入`局部变量表`中第二个槽里\n<img src=\"JVM-Fundamentals/5.4.png\" width=\"50%\" height=\"50%\">\n第五步，将1复制一份放入`操作数栈`的栈顶\n第六步，将2复制一份放入`操作数栈`的栈顶\n<img src=\"JVM-Fundamentals/5.5.png\" width=\"50%\" height=\"50%\">\n第七步，将2，1弹出操作数栈交给cpu去运算得到3，放到`操作数栈`的栈顶\n<img src=\"JVM-Fundamentals/5.6.png\" width=\"50%\" height=\"50%\">\n第八步，从常量池（-128～127）里拿到10，放入`操作数栈`顶\n<img src=\"JVM-Fundamentals/5.7.png\" width=\"50%\" height=\"50%\">\n第九步，弹出10，3交给cpu去运算得到30，放到`操作数栈`的栈顶（jvm1.6开始进行了指令优化，第8、9步合并成了一步操作）\n<img src=\"JVM-Fundamentals/5.8.png\" width=\"50%\" height=\"50%\">\n第十步，将30放到`局部变量表`中第3个槽里。\n<img src=\"JVM-Fundamentals/5.9.png\" width=\"50%\" height=\"50%\">\n第十一步，将30复制一份放入`操作数栈`第栈顶。\n第十二步，将30弹出操作数栈，通过`返回地址`返回。\n\n### 程序计数器\n就是一个指针，指向方法区中的方法字节码(用来存储**指向下一跳指令的地址**，也就是当前线程将要执行的指令代码)，\n由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计，用来保证线程间切换后正确执行。\n\n### 本地方法栈\n和栈作用很相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行native方法服务。\n登记native方法，在Execution Engine执行时加载本地方法库。\n\n### 方法区（永久代/持久代，元空间）\n类的所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在这里定义。\n简单来说，所有定义的方法的信息都保存在该区域，静态变量+常量+类信息(构造方法/接口定义)+运行时常量池都存在方法区中，\n虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap(非堆)，目的应该是为了和Java的堆区分开(jdk1.8以前hotspot虚拟机叫永久代、持久代，jdk1.8时叫元空间)\n\n永久代和元空间区别在于元数据区不在虚拟机当中，而是用的`本地内存`，永久代在虚拟机当中，永久代逻辑结构上也属于堆，但是物理上不属于。\n\n#### 为什么移除了永久代?\n参考官方解释http://openjdk.java.net/jeps/122\n大概意思是移除永久代是为融合HotSpot与 JRockit而做出的努力，因为JRockit没有永久代，不需要配置永久代。\n![](JVM-Fundamentals/7.png)\n\n\n### 堆\n虚拟机启动时自动分配创建，用于存放`对象`的实例，几乎所有对象都在堆上分配内存，当对象无法在该空间申请到内\n存是将抛出OutOfMemoryError异常。同时也是垃圾收集器管理的主要区域。\n![](JVM-Fundamentals/6.jpeg)\n\n#### 新生代(Young Generation)\n类出生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。\n新生代分为两部分:`伊甸区`(Eden space)和`幸存者区`(Survivor space)，所有的类都是在伊甸区被new出来的。\n幸存区(Survivor space):分为From和To区,TO区永远保持空。\n当Eden区的空间用完是，程序又需要创建对象，JVM的垃圾回收器将Eden区进行垃圾回收(`Minor GC`)，将Eden区中的不再被其它对象应用的对象进行销毁。\n然后将Eden区中剩余的对象移到From Survivor区。若From Survivor区也满了，再对该区进行垃圾回收，然后移动到To Survivor区，From区为空后，将To和From区转换，保证To区为空，并且对象年龄加一。\n当对象年龄默认加到15（因为**对象头只有4个bits**是存对象年龄，最大为15）时将剩下的对象移到老年代。\n\n### 老年代(Old Generation)\n新生代经过多次GC仍然存货的对象移动到老年区。\n若老年代也满了，这时候将发生Major GC(也可以叫`Full GC`)， 进行老年区的内存清理。\n若老年区执行了Full GC之后发现依然无法进行对象的保存，就会抛出 OOM(OutOfMemoryError)异常.\n\n\n## GC算法和收集器\n几种常见GC：\nMinorGC/YoungGC 新生代\nOldGC CMS特有\nFullGC/MajorGC 回收所有\nMixedGC（FullGC+YoungGC）  G1特有\n\n### 如何判断对象可以被回收\n堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡(即不能再被任何途径使用的对象)\n\n#### 引用计数法\n给对象添加一个引用计数器，每当有一个地方引用，计数器就加1。当引用失效，计数器就减1。任何时候计数器为0 的对象就是不可能再被使用的。\n\n这个方法实现简单，效率高，但是目前主流的虚拟机中没有选择这个算法来管理内存，最主要的原因是它很难解决**对象之前相互循环引用**的问题。所谓对象之间的相互引用问题，通过下面代码所示:除了对象a和b相互引用着对方之外，这两个对象之间再无任何引用。但是它们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数器法无法通知GC回收器回收它们。\n\n```java\npublic class CounterGC{\n    Object instance = null;\n    public static void main(String[] args){\n      CounterGC a = new CounterGC();\n      CounterGC b = new CounterGC();\n      a.instance = b;\n      b.instance = a;\n      a = null;\n      b = null;\n    }\n}\n```\n\n#### 可达性分析算法\n这个算法的基本思想就是通过一系列的称为\"GC Roots\"的对象作为起点，从这些节点开始向下搜索，节点所走过的路\n径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象时不可用的。\n\n`GC Roots根节点`:类加载器、Thread、虚拟机栈的局部变量表、static成员、常量引用、本地方法栈的变量等等.\n![](JVM-Fundamentals/8.png)\n\n### 如何判断一个常量是废弃常量\n运行时常量池主要回收的是废弃的常量。那么，我们怎么判断一个常量时废弃常量呢?\n假如在常量池中存在字符串\"abc\"，如果当前没有任何String对象引用该字符串常量的话，就说明常量\"abc\"就是废弃常量，如果这时发生内存回收的话而且有必要的话（内存不够用时才会发生回收），\"abc\"会被系统清理出常量池。\n\n### 如何判断一个类是无用的类\n需要满足以下三个条件:\n* 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\n* 加载该类的 ClassLoader 已经被回收。\n* 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n虚拟机可以对满足上述3个条件的无用类进行回收，这里仅仅是\"**可以**\"，而并不是和对象一样不适用了就必然会被回收。\n\n\n### 垃圾回收算法\n![](JVM-Fundamentals/9.png)\n\n#### 标记-清除算法\n它是最基础的收集算法，这个算法分为两个阶段，`标记`和`清除`。首先标记出所有需要回收的对象，在标记完成后\n统一回收所有被标记的对象。它有两个不足的地方:\n1. 效率问题，标记和清除两个过程的效率都不高;\n2. 空间问题，标记清除后会产生大量不连续的碎片;\n![](JVM-Fundamentals/9.1.png)\n\n#### 复制算法\n为了解决效率问题，复制算法出现了。它可以把内存分为大小相同的两块，每次只使用其中的一块。\n当这一块的内存使用完后，就将还存活的对象复制到另一块区，然后再把使用的空间一次清理掉。\n这样就使每次的内存回收都是对内存区间的一半进行回收\n![](JVM-Fundamentals/9.2.png)\n\n#### 标记-整理算法\n根据老年代的特点提出的一种标记算法，标记过程和“标记-清除”算法一样，但是后续步骤不是直接对可回收对象进行回收，而是让所有存活的对象向一段移动，然后直接清理掉边界以外的内存\n![](JVM-Fundamentals/9.3.png)\n\n#### 分代收集算法\n现在的商用虚拟机的垃圾收集器基本都采用\"分代收集\"算法，这种算法就是根据对象存活周期的不同将内存分为几块。\n一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n在新生代中，每次收集都有大量对象死去，所以可以选择复制算法，只要付出少量对象的复制成本就可以完成每次垃圾收集。\n而老年代的对象存活几率时比较高的，而且没有额外的空间对它进行分配担保，就必须选择“标记-清除”或 者“标记-整理”算法进行垃圾收集。\n\n### 垃圾收集器\n![](JVM-Fundamentals/10.png)\n#### Serial收集器\nSerial(串行)收集器收集器是最基本、历史最悠久的垃圾收集器了。\n大家看名字就知道这个收集器是一个单线程收集器了。\n它的`单线程`的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程( “Stop The World” )，直到它收集结束。\n**新生代采用复制算法，老年代采用标记-整理算法。**\n![](JVM-Fundamentals/10.1.png)\n虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短(仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续)。\n但是Serial收集器有没有优于其他垃圾收集器的地方呢?\n当然有，它简单而高效(与其他收集器的单线程相比)。 Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。\n\n#### ParNew收集器\nParNew收集器其实就是Serial收集器的`多线程`版本，除了使用多线程进行垃圾收集外，其余行为(控制参数、收集算法、回收策略等等)和Serial收集器完全一样。\n**新生代采用复制算法，老年代采用标记-整理算法。**\n![](JVM-Fundamentals/10.2.png)\n它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器(真正意义上的并发收集器，后面会介绍到)配合工作。\n\n#### Parallel Scavenge收集器(JDK1.8)\nParallel Scavenge 收集器类似于ParNew收集器。\nParallel Scavenge收集器关注点是`吞吐量`(高效率的利用CPU)。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。\nCMS等垃圾收集器的关注点更多的是用户线程的`停顿时间`(提高用户体验)。 Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。\n**新生代采用复制算法，老年代采用标记-整理算法。**\n![](JVM-Fundamentals/10.2.png)\n\n#### Serial Old收集器\nSerial收集器的老年代版本，它同样是一个`单线程`收集器，采用**标记-整理**算法。\n它主要有两大用途:一种用途是在JDK1.5以及以前的版本 中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。\n\n#### Parallel Old收集器\nParallel Scavenge收集器的老年代版本。使用`多线程`和**标记-整理**算法。\n在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。\n\n#### **CMS收集器**\n并行和并发概念补充:\n* 并行(Parallel) :指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 \n* 并发(Concurrent):指用户线程与垃圾收集线程同时执行(但不一定是并行，可能会交替执行)，用户程序 在继续运行，而垃圾收集器运行在另一个CPU上。\n\nCMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。\nCMS(Concurrent Mark Sweep)收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作。\n\n从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种**标记-清除**算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。\n整个过程分为四个步骤:\n* 初始标记(CMS initial mark): 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 \n* 并发标记(CMS concurrent mark): **同时开启GC和用户线程**，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\n* 重新标记(CMS remark): 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶 段时间短\n* 并发清除(CMS concurrent sweep): 开启用户线程，同时GC线程开始对为标记的区域做清扫。\n![](JVM-Fundamentals/10.3.png)\nCMS主要优点:并发收集、低停顿。\n但是它有下面三个明显的缺点:\n* 对CPU资源敏感;\n* 无法处理浮动垃圾;\n* 它使用的回收算法-**标记-清除**算法会导致收集结束时会有大量空间碎片产生。\n\n#### G1收集器\nG1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC停顿时间要求的同时,还具备高吞吐量性能特征.\n![](JVM-Fundamentals/10.3.png)\n被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点:\n* 并行与并发:G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU(CPU或者CPU核心)来缩短Stop- The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行 \n* 分代收集:虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。 空间整合:与CMS的“标记–清理”算法不同，G1从整体来看是基于**标记整理**算法实现的收集器;从局部上来看是基于**标记复制**算法实现的\n* **可预测的停顿**:这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内\n\nG1收集器的运作大致分为以下几个步骤:\n* 初始标记\n* 并发标记\n* 最终标记\n* 筛选回收\n\nG1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名 字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率(把内存化整为零)。\n\n#### 怎么选择垃圾收集器?（尽量由JVM自己选择）\n1. 优先调整堆的大小让服务器自己来选择\n2. 如果内存小于100m，使用串行收集器\n3. 如果是单核，并且没有停顿时间的要求，串行或JVM自己选择 \n4. 如果允许停顿时间超过1秒，选择并行或者JVM自己选\n5. 如果响应时间最重要，并且不能超过1秒，使用并发收集器\n官方推荐ZGC(java最新版本垃圾收器器，可预测的停顿最低2ms)，性能高。\n\n## JDK性能调优监控工具\n虚拟机参数分析网站：https://www.perfma.com/product/opts\n### jps\n显示当前系统的java进程情况\n```bash\ngdeMacBook-Pro:~ g$ jps\n94673 AppServiceApplication\n54995\n55011 RemoteMavenServer36\n94696 AppServiceApplication\n96956 Jps\n```\n(空白的54995是idea)\n### Jinfo\n查看正在运行的Java程序的扩展参数\n#### 查看JVM的参数\n```bash\ngdeMacBook-Pro:~ g$ jinfo -flags 94673\nVM Flags:\n-XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote -XX:CICompilerCount=4 -XX:ConcGCThreads=3 -XX:G1ConcRefinementThreads=10 -XX:G1HeapRegionSize=1048576 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=268435456 -XX:+ManagementServer -XX:MarkStackSize=4194304 -XX:MaxHeapSize=4294967296 -XX:MaxNewSize=2576351232 -XX:MinHeapDeltaBytes=1048576 -XX:NonNMethodCodeHeapSize=7549744 -XX:NonProfiledCodeHeapSize=244108496 -XX:ProfiledCodeHeapSize=0 -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:TieredStopAtLevel=1 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC\n```\n#### 查看java系统属性\n```bash\njinfo -sysprops 94673\n```\n\n\n### Jstat\njstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令格式:\njstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]\n```bash\ngdeMacBook-Pro:~ g$ jstat -gc 94673\n S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT\n 0.0   2048.0  0.0   2048.0 96256.0  68608.0   163840.0   132934.6  131280.0 127368.5 14720.0 13850.3    185    1.219   0      0.000  112     0.661    1.880\n```\n* S0C：第一个幸存区的大小\n* S1C：第二个幸存区的大小\n* S0U：第一个幸存区的使用大小\n* S1U：第二个幸存区的使用大小\n* EC：伊甸园区的大小\n* EU：伊甸园区的使用大小\n* OC：老年代大小\n* OU：老年代使用大小\n* MC：方法区大小\n* MU：方法区使用大小\n* CCSC:压缩类空间大小\n* CCSU:压缩类空间使用大小\n* YGC：年轻代垃圾回收次数\n* YGCT：年轻代垃圾回收消耗时间\n* FGC：老年代垃圾回收次数\n* FGCT：老年代垃圾回收消耗时间\n* GCT：垃圾回收消耗总时间\n\n### Jmap\n可以用来查看内存信息\n#### 堆的对象统计\n```bash\ngdeMacBook-Pro:~ g$ jmap -histo 94673 > xxx.txt\n```\n部分如下\n```text\n num     #instances         #bytes  class name (module)\n-------------------------------------------------------\n   1:        380588       39857240  [B (java.base@11.0.4)\n   2:         71568        8387344  [Ljava.lang.Object; (java.base@11.0.4)\n   3:        301995        7247880  java.lang.String (java.base@11.0.4)\n   4:         25762        5316280  [I (java.base@11.0.4)\n   5:         47736        4200768  java.lang.reflect.Method (java.base@11.0.4)\n   6:        126275        4040800  java.util.concurrent.ConcurrentHashMap$Node (java.base@11.0.4)\n   7:         69142        3871952  java.util.LinkedHashMap (java.base@11.0.4)\n   8:          2483        3656120  [C (java.base@11.0.4)\n   9:         46566        3352752  io.netty.channel.DefaultChannelHandlerContext\n  10:        104582        3346624  java.util.HashMap$Node (java.base@11.0.4)\n  11:         20887        2551232  java.lang.Class (java.base@11.0.4)\n  12:         32461        2077504  java.util.concurrent.ConcurrentHashMap (java.base@11.0.4)\n  13:         48062        1922480  java.util.HashMap$KeyIterator (java.base@11.0.4)\n  14:         17400        1720040  [Ljava.util.HashMap$Node; (java.base@11.0.4)\n  15:          2184        1432704  io.netty.util.internal.shaded.org.jctools.queues.MpscArrayQueue\n  16:         35693        1427720  java.util.LinkedHashMap$Entry (java.base@11.0.4)\n  17:         88742        1419872  java.lang.Object (java.base@11.0.4)\n  18:          1671        1195280  [Ljava.util.concurrent.ConcurrentHashMap$Node; (java.base@11.0.4)\n  19:         10270        1150240  sun.nio.ch.SocketChannelImpl (java.base@11.0.4)\n  20:         10237        1064648  io.netty.channel.socket.nio.NioSocketChannel\n  21:         42359        1016616  java.util.ArrayList (java.base@11.0.4)\n  22:         60868         973888  java.lang.Integer (java.base@11.0.4)\n  23:         20436         817440  io.netty.util.DefaultAttributeMap$DefaultAttribute\n  24:         10533         758376  org.springframework.core.type.classreading.AnnotationMetadataReadingVisitor\n  25:         18570         742800  com.meituan.service.mobile.mtthrift.mtrace.MtraceServerTBinaryProtocol$Factory\n  26:         10239         737208  io.netty.channel.DefaultChannelPipeline$HeadContext\n  27:         10239         737208  io.netty.channel.DefaultChannelPipeline$TailContext\n  28:         30914         729768  [Ljava.lang.Class; (java.base@11.0.4)\n  29:         21894         700608  java.util.concurrent.locks.ReentrantLock$NonfairSync (java.base@11.0.4)\n------省略----\n```\n* Num:序号\n* Instances:实例数量\n* Bytes:占用空间大小\n* Class Name:类名\n\n#### 堆信息\n```bash\ngdeMacBook-Pro:~ g$ jmap -heap 94673\nError: -heap option used\nCannot connect to core dump or remote debug server. Use jhsdb jmap instead\n```\njdk9及以上版本使用jmap -heap pid命令查看当前heap使用情况时，发现报错，提示需要使用jhsdb jmap来替代\n```bash\ngdeMacBook-Pro:~ g$ jhsdb jmap --heap --pid 94673\n```\n\n\n\n\n","slug":"JVM-Fundamentals","published":1,"updated":"2020-03-15T07:29:36.731Z","layout":"post","photos":[],"link":"","_id":"ck8fb4a9o0011k2o5ns7o6spj","content":"<p>Java虚拟机(java virtual machine，JVM)，一种能够运行java字节码的虚拟机。作为一种编程语言的虚拟机，实际上不只是专用于Java语言，只要生成的编译文件匹配JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。 比如kotlin、scala等。</p>\n<h1 id=\"JVM基本结构\"><a href=\"#JVM基本结构\" class=\"headerlink\" title=\"JVM基本结构\"></a>JVM基本结构</h1><p>JVM由三个主要的子系统构成</p>\n<ul>\n<li>类加载子系统</li>\n<li>运行时数据区(内存结构)</li>\n<li>执行引擎<img src=\"/JVM/JVM-Fundamentals/1.png\" width=\"80%\" height=\"80%\">\n<a id=\"more\"></a>\n\n</li>\n</ul>\n<h2 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h2><h3 id=\"类的生命周期\"><a href=\"#类的生命周期\" class=\"headerlink\" title=\"类的生命周期\"></a>类的生命周期</h3><p><img src=\"/JVM/JVM-Fundamentals/2.png\" alt=\"\"></p>\n<ol>\n<li>加载：将.class文件从磁盘读到内存<ul>\n<li>通过类的全限定名(com.xxx.xxx)+类加载器确定唯一的类，来获取定义此类的二进制字节流</li>\n<li>将这个类字节流代表的静态存储结构转为方法区的运行时数据结构</li>\n<li>在堆中生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口。</li>\n</ul>\n</li>\n<li>连接<ol>\n<li>验证：验证字节码文件的正确性<ul>\n<li>文件格式验证：基于字节流验证，验证字节流是否符合Class文件格式的规范，并且能被当前虚拟机处理。</li>\n<li>元数据验证：基于方法区的存储结构验证，对字节码描述信息进行语义验证。</li>\n<li>字节码验证：基于方法区的存储结构验证，进行数据流和控制流的验证。</li>\n<li>符号引用验证：基于方法区的存储结构验证，发生在解析中，是否可以将符号引用成功解析为直接引用。</li>\n</ul>\n</li>\n<li>准备：给类的静态变量分配内存，并赋予<code>默认值</code>（不包括实例变量）<ul>\n<li>public static int value = 123; //此时在准备阶段过后的初始值为0而不是123，在初始化过程才会被赋值为123</li>\n<li>public static final int value = 123;//value的值在准备阶段过后就是123。</li>\n</ul>\n</li>\n<li>解析：类装载器装入类所引用的其它所有类</li>\n</ol>\n</li>\n<li>初始化：为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序编写者为变量分配的真正的初始值，执行静态代码块</li>\n<li>使用</li>\n<li>卸载</li>\n</ol>\n<h3 id=\"类加载器的种类\"><a href=\"#类加载器的种类\" class=\"headerlink\" title=\"类加载器的种类\"></a>类加载器的种类</h3><p>总体上分为两种：启动类加载器（C++实现） 和 其他类加载器（JAVA实现）</p>\n<h4 id=\"启动类加载器-Bootstrap-ClassLoader\"><a href=\"#启动类加载器-Bootstrap-ClassLoader\" class=\"headerlink\" title=\"启动类加载器(Bootstrap ClassLoader)\"></a>启动类加载器(Bootstrap ClassLoader)</h4><p>负责加载JRE的核心类库，如JRE目标下的rt.jar，charsets.jar等</p>\n<h4 id=\"扩展类加载器-Extension-ClassLoader\"><a href=\"#扩展类加载器-Extension-ClassLoader\" class=\"headerlink\" title=\"扩展类加载器(Extension ClassLoader)\"></a>扩展类加载器(Extension ClassLoader)</h4><p>负责加载JRE扩展目录ext中jar类包</p>\n<h4 id=\"系统类加载器-Application-ClassLoader\"><a href=\"#系统类加载器-Application-ClassLoader\" class=\"headerlink\" title=\"系统类加载器(Application ClassLoader)\"></a>系统类加载器(Application ClassLoader)</h4><p>负责加载ClassPath路径下的类包</p>\n<h4 id=\"用户自定义加载器-User-ClassLoader\"><a href=\"#用户自定义加载器-User-ClassLoader\" class=\"headerlink\" title=\"用户自定义加载器(User ClassLoader)\"></a>用户自定义加载器(User ClassLoader)</h4><p>负责加载用户自定义路径下的类包<br><img src=\"/JVM/JVM-Fundamentals/3.png\" width=\"50%\" height=\"50%\"></p>\n<h3 id=\"类加载机制-1\"><a href=\"#类加载机制-1\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h3><h4 id=\"全盘负责委托机制\"><a href=\"#全盘负责委托机制\" class=\"headerlink\" title=\"全盘负责委托机制\"></a>全盘负责委托机制</h4><p>当一个ClassLoader加载一个类的时候，除非显示的使用另一个ClassLoader，该类所依赖和引用的类也由这个 ClassLoader载入</p>\n<h4 id=\"双亲委派机制\"><a href=\"#双亲委派机制\" class=\"headerlink\" title=\"双亲委派机制\"></a>双亲委派机制</h4><p>指先委托父类加载器寻找目标类，在找不到的情况下，在自己的路径中查找并载入目标类<br><img src=\"/JVM/JVM-Fundamentals/4.png\" width=\"50%\" height=\"50%\"></p>\n<ol>\n<li>当有类需要加载，系统类加载器先判断有没有父类，有交给扩展类加载器加载</li>\n<li>扩展类加载器判断有没有父类，有交给启动类加载器</li>\n<li>启动类加载器没有父类，去实际加载该类，该类不是JRE包下的类，交给子类扩展类加载器去加载</li>\n<li>扩展类加载器去加载该类，发现该类不是ext中的包，交给系统类加载器加载</li>\n<li>系统类加载器加载，发现是classPath路径下的包，进行加载。</li>\n</ol>\n<h5 id=\"双亲委派模式的优势\"><a href=\"#双亲委派模式的优势\" class=\"headerlink\" title=\"双亲委派模式的优势\"></a>双亲委派模式的优势</h5><ul>\n<li>沙箱安全机制:比如自己写的String.class类不会被加载，这样可以防止核心库被随意篡改</li>\n<li>避免类的重复加载:当父ClassLoader已经加载了该类的时候，就不需要子ClassLoader再加载一次</li>\n</ul>\n<h5 id=\"为什么要打破双亲委派模式\"><a href=\"#为什么要打破双亲委派模式\" class=\"headerlink\" title=\"为什么要打破双亲委派模式\"></a>为什么要打破双亲委派模式</h5><p>例如：tomcat<br>Tomcat是个web容器,可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。<br>如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加载器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。</p>\n<h5 id=\"如何打破双亲委派模式\"><a href=\"#如何打破双亲委派模式\" class=\"headerlink\" title=\"如何打破双亲委派模式\"></a>如何打破双亲委派模式</h5><ol>\n<li>继承ClassLoader</li>\n<li>重写findClass()方法</li>\n<li>重写loadClass()方法</li>\n</ol>\n<h2 id=\"运行时数据区-内存结构\"><a href=\"#运行时数据区-内存结构\" class=\"headerlink\" title=\"运行时数据区(内存结构)\"></a>运行时数据区(内存结构)</h2><p><img src=\"/JVM/JVM-Fundamentals/5.png\" alt=\"\"></p>\n<h3 id=\"虚拟机栈\"><a href=\"#虚拟机栈\" class=\"headerlink\" title=\"虚拟机栈\"></a>虚拟机栈</h3><p>java虚拟机栈是线程私有的，每个方法执行都会创建一个栈帧，栈帧包含局部变量表、操作数栈、动态连接、方法出口等。</p>\n<h4 id=\"栈与栈帧\"><a href=\"#栈与栈帧\" class=\"headerlink\" title=\"栈与栈帧\"></a>栈与栈帧</h4><p>每一个方法的执行到执行完成，对应着一个栈帧在虚拟机中从入栈到出栈的过程。java虚拟机栈栈顶的栈帧就是当前执行方法的栈帧。PC寄存器会指向该地址。当这个方法调用其他方法的时候久会创建一个新的栈帧，这个新的栈帧会被方法Java虚拟机栈的栈顶，变为当前的活动栈，在当前只有当前活动栈的本地变量才能被使用，当这个栈帧所有指令都完成的时候，这个栈帧被移除，之前的栈帧变为活动栈，前面移除栈帧的返回值变为这个栈帧的一个操作数。</p>\n<h4 id=\"栈帧\"><a href=\"#栈帧\" class=\"headerlink\" title=\"栈帧\"></a>栈帧</h4><p>栈帧包含局部变量表、操作数栈、动态连接、方法返回地址</p>\n<h5 id=\"局部变量表\"><a href=\"#局部变量表\" class=\"headerlink\" title=\"局部变量表\"></a>局部变量表</h5><ul>\n<li>局部变量表是变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在java编译成class文件的时候，就在方法的Code属性的max_locals数据项中确定该方法需要分配的最大局部变量表的容量。</li>\n<li>局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放32位（4 字节）以内的数据类型（ boolean、byte、char、short、int、float、reference和returnAddress八种）</li>\n<li>对于64位长度的数据类型（long，double），虚拟机会以高位对齐方式为其分配<code>两个连续的Slot</code>空间，也就是相当于把一次long和double数据类型读写分割成为两次32位读写。</li>\n<li>reference类型虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。</li>\n<li>Slot是可以重用的，当Slot中的变量超出了作用域，那么下一次分配Slot的时候，将会覆盖原来的数据。Slot对对象的引用会影响GC（要是被引用，将不会被回收）。  </li>\n<li>系统不会为局部变量赋予初始值（实例变量和类变量都会被赋予初始值）。也就是说不存在类变量那样的准备阶段。</li>\n</ul>\n<h5 id=\"操作数栈\"><a href=\"#操作数栈\" class=\"headerlink\" title=\"操作数栈\"></a>操作数栈</h5><ul>\n<li>操作数栈和局部变量表一样，在编译时期就已经确定了该方法所需要分配的局部变量表的最大容量。</li>\n<li>操作数栈的每一个元素可用是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型占用的栈容量为2。</li>\n<li>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈 / 入栈操作（例如：在做算术运算的时候是通过操作数栈来进行的，又或者在调用其它方法的时候是通过操作数栈来进行参数传递的）。</li>\n</ul>\n<h5 id=\"动态连接\"><a href=\"#动态连接\" class=\"headerlink\" title=\"动态连接\"></a>动态连接</h5><p>直接引用：有具体引用地址的指针，被引用的类、方法或者变量已经被加载到内存中<br>符号引用：即用用字符串符号的形式来表示引用，其实被引用的类、方法或者变量还没有被加载到内存中。<br>举个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 符号引用</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">String str = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"str=\"</span> + str);</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 直接引用</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"str=\"</span> + <span class=\"string\">\"abc\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>动态链接：在程序运行过程中，由符号引用转化为直接引用。<br>静态链接：在类加载过程中，由符号引用转化为直接引用。</p>\n<h5 id=\"方法返回地址\"><a href=\"#方法返回地址\" class=\"headerlink\" title=\"方法返回地址\"></a>方法返回地址</h5><p>当一个方法开始执行时，可能有两种方式退出该方法：</p>\n<ul>\n<li>正常完成出口<ul>\n<li>正常完成出口是指方法正常完成并退出，没有抛出任何异常(包括Java虚拟机异常以及执行时通过throw语句显示抛出的异常)。如果当前方法正常完成，则根据当前方法返回的字节码指令，这时有可能会有返回值传递给方法调用者(调用它的方法)，或者无返回值。具体是否有返回值以及返回值的数据类型将根据该方法返回的字节码指令确定。</li>\n</ul>\n</li>\n<li>异常完成出口<ul>\n<li>异常完成出口是指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退出。</li>\n</ul>\n</li>\n</ul>\n<p>无论方法采用何种方式退出，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在当前栈帧中保存一些信息，用来帮他恢复它的上层方法执行状态。<br>方法退出过程实际上就等同于把当前栈帧出栈，因此退出可以执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压如调用者的操作数栈中，调整PC计数器的值以指向方法调用指令后的下一条指令。<br>一般来说，方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理器表确定的，栈帧中一般不会保存此部分信息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">math</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = (a + b)*<span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Demo demo = <span class=\"keyword\">new</span> Demo();</span><br><span class=\"line\">        demo.math();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当执行👆Demo的math方法时，主线程内存会如何操作<br><img src=\"/JVM/JVM-Fundamentals/5.1.png\" width=\"50%\" height=\"50%\"><br>第一步，现将1放入<code>操作数栈</code><br><img src=\"/JVM/JVM-Fundamentals/5.2.png\" width=\"50%\" height=\"50%\"><br>第二步，将1放入<code>局部变量表</code>中第一个槽里<br><img src=\"/JVM/JVM-Fundamentals/5.3.png\" width=\"50%\" height=\"50%\"><br>第三步，第四步同上，最终将2放入<code>局部变量表</code>中第二个槽里<br><img src=\"/JVM/JVM-Fundamentals/5.4.png\" width=\"50%\" height=\"50%\"><br>第五步，将1复制一份放入<code>操作数栈</code>的栈顶<br>第六步，将2复制一份放入<code>操作数栈</code>的栈顶<br><img src=\"/JVM/JVM-Fundamentals/5.5.png\" width=\"50%\" height=\"50%\"><br>第七步，将2，1弹出操作数栈交给cpu去运算得到3，放到<code>操作数栈</code>的栈顶<br><img src=\"/JVM/JVM-Fundamentals/5.6.png\" width=\"50%\" height=\"50%\"><br>第八步，从常量池（-128～127）里拿到10，放入<code>操作数栈</code>顶<br><img src=\"/JVM/JVM-Fundamentals/5.7.png\" width=\"50%\" height=\"50%\"><br>第九步，弹出10，3交给cpu去运算得到30，放到<code>操作数栈</code>的栈顶（jvm1.6开始进行了指令优化，第8、9步合并成了一步操作）<br><img src=\"/JVM/JVM-Fundamentals/5.8.png\" width=\"50%\" height=\"50%\"><br>第十步，将30放到<code>局部变量表</code>中第3个槽里。<br><img src=\"/JVM/JVM-Fundamentals/5.9.png\" width=\"50%\" height=\"50%\"><br>第十一步，将30复制一份放入<code>操作数栈</code>第栈顶。<br>第十二步，将30弹出操作数栈，通过<code>返回地址</code>返回。</p>\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>就是一个指针，指向方法区中的方法字节码(用来存储<strong>指向下一跳指令的地址</strong>，也就是当前线程将要执行的指令代码)，<br>由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计，用来保证线程间切换后正确执行。</p>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>和栈作用很相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行native方法服务。<br>登记native方法，在Execution Engine执行时加载本地方法库。</p>\n<h3 id=\"方法区（永久代-持久代，元空间）\"><a href=\"#方法区（永久代-持久代，元空间）\" class=\"headerlink\" title=\"方法区（永久代/持久代，元空间）\"></a>方法区（永久代/持久代，元空间）</h3><p>类的所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在这里定义。<br>简单来说，所有定义的方法的信息都保存在该区域，静态变量+常量+类信息(构造方法/接口定义)+运行时常量池都存在方法区中，<br>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap(非堆)，目的应该是为了和Java的堆区分开(jdk1.8以前hotspot虚拟机叫永久代、持久代，jdk1.8时叫元空间)</p>\n<p>永久代和元空间区别在于元数据区不在虚拟机当中，而是用的<code>本地内存</code>，永久代在虚拟机当中，永久代逻辑结构上也属于堆，但是物理上不属于。</p>\n<h4 id=\"为什么移除了永久代\"><a href=\"#为什么移除了永久代\" class=\"headerlink\" title=\"为什么移除了永久代?\"></a>为什么移除了永久代?</h4><p>参考官方解释<a href=\"http://openjdk.java.net/jeps/122\" target=\"_blank\" rel=\"noopener\">http://openjdk.java.net/jeps/122</a><br>大概意思是移除永久代是为融合HotSpot与 JRockit而做出的努力，因为JRockit没有永久代，不需要配置永久代。<br><img src=\"/JVM/JVM-Fundamentals/7.png\" alt=\"\"></p>\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><p>虚拟机启动时自动分配创建，用于存放<code>对象</code>的实例，几乎所有对象都在堆上分配内存，当对象无法在该空间申请到内<br>存是将抛出OutOfMemoryError异常。同时也是垃圾收集器管理的主要区域。<br><img src=\"/JVM/JVM-Fundamentals/6.jpeg\" alt=\"\"></p>\n<h4 id=\"新生代-Young-Generation\"><a href=\"#新生代-Young-Generation\" class=\"headerlink\" title=\"新生代(Young Generation)\"></a>新生代(Young Generation)</h4><p>类出生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。<br>新生代分为两部分:<code>伊甸区</code>(Eden space)和<code>幸存者区</code>(Survivor space)，所有的类都是在伊甸区被new出来的。<br>幸存区(Survivor space):分为From和To区,TO区永远保持空。<br>当Eden区的空间用完是，程序又需要创建对象，JVM的垃圾回收器将Eden区进行垃圾回收(<code>Minor GC</code>)，将Eden区中的不再被其它对象应用的对象进行销毁。<br>然后将Eden区中剩余的对象移到From Survivor区。若From Survivor区也满了，再对该区进行垃圾回收，然后移动到To Survivor区，From区为空后，将To和From区转换，保证To区为空，并且对象年龄加一。<br>当对象年龄默认加到15（因为<strong>对象头只有4个bits</strong>是存对象年龄，最大为15）时将剩下的对象移到老年代。</p>\n<h3 id=\"老年代-Old-Generation\"><a href=\"#老年代-Old-Generation\" class=\"headerlink\" title=\"老年代(Old Generation)\"></a>老年代(Old Generation)</h3><p>新生代经过多次GC仍然存货的对象移动到老年区。<br>若老年代也满了，这时候将发生Major GC(也可以叫<code>Full GC</code>)， 进行老年区的内存清理。<br>若老年区执行了Full GC之后发现依然无法进行对象的保存，就会抛出 OOM(OutOfMemoryError)异常.</p>\n<h2 id=\"GC算法和收集器\"><a href=\"#GC算法和收集器\" class=\"headerlink\" title=\"GC算法和收集器\"></a>GC算法和收集器</h2><p>几种常见GC：<br>MinorGC/YoungGC 新生代<br>OldGC CMS特有<br>FullGC/MajorGC 回收所有<br>MixedGC（FullGC+YoungGC）  G1特有</p>\n<h3 id=\"如何判断对象可以被回收\"><a href=\"#如何判断对象可以被回收\" class=\"headerlink\" title=\"如何判断对象可以被回收\"></a>如何判断对象可以被回收</h3><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡(即不能再被任何途径使用的对象)</p>\n<h4 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h4><p>给对象添加一个引用计数器，每当有一个地方引用，计数器就加1。当引用失效，计数器就减1。任何时候计数器为0 的对象就是不可能再被使用的。</p>\n<p>这个方法实现简单，效率高，但是目前主流的虚拟机中没有选择这个算法来管理内存，最主要的原因是它很难解决<strong>对象之前相互循环引用</strong>的问题。所谓对象之间的相互引用问题，通过下面代码所示:除了对象a和b相互引用着对方之外，这两个对象之间再无任何引用。但是它们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数器法无法通知GC回收器回收它们。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CounterGC</span></span>&#123;</span><br><span class=\"line\">    Object instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">      CounterGC a = <span class=\"keyword\">new</span> CounterGC();</span><br><span class=\"line\">      CounterGC b = <span class=\"keyword\">new</span> CounterGC();</span><br><span class=\"line\">      a.instance = b;</span><br><span class=\"line\">      b.instance = a;</span><br><span class=\"line\">      a = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      b = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h4><p>这个算法的基本思想就是通过一系列的称为”GC Roots”的对象作为起点，从这些节点开始向下搜索，节点所走过的路<br>径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象时不可用的。</p>\n<p><code>GC Roots根节点</code>:类加载器、Thread、虚拟机栈的局部变量表、static成员、常量引用、本地方法栈的变量等等.<br><img src=\"/JVM/JVM-Fundamentals/8.png\" alt=\"\"></p>\n<h3 id=\"如何判断一个常量是废弃常量\"><a href=\"#如何判断一个常量是废弃常量\" class=\"headerlink\" title=\"如何判断一个常量是废弃常量\"></a>如何判断一个常量是废弃常量</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们怎么判断一个常量时废弃常量呢?<br>假如在常量池中存在字符串”abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量”abc”就是废弃常量，如果这时发生内存回收的话而且有必要的话（内存不够用时才会发生回收），”abc”会被系统清理出常量池。</p>\n<h3 id=\"如何判断一个类是无用的类\"><a href=\"#如何判断一个类是无用的类\" class=\"headerlink\" title=\"如何判断一个类是无用的类\"></a>如何判断一个类是无用的类</h3><p>需要满足以下三个条件:</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>\n<li>加载该类的 ClassLoader 已经被回收。</li>\n<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。<br>虚拟机可以对满足上述3个条件的无用类进行回收，这里仅仅是”<strong>可以</strong>“，而并不是和对象一样不适用了就必然会被回收。</li>\n</ul>\n<h3 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h3><p><img src=\"/JVM/JVM-Fundamentals/9.png\" alt=\"\"></p>\n<h4 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h4><p>它是最基础的收集算法，这个算法分为两个阶段，<code>标记</code>和<code>清除</code>。首先标记出所有需要回收的对象，在标记完成后<br>统一回收所有被标记的对象。它有两个不足的地方:</p>\n<ol>\n<li>效率问题，标记和清除两个过程的效率都不高;</li>\n<li>空间问题，标记清除后会产生大量不连续的碎片;<br><img src=\"/JVM/JVM-Fundamentals/9.1.png\" alt=\"\"></li>\n</ol>\n<h4 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h4><p>为了解决效率问题，复制算法出现了。它可以把内存分为大小相同的两块，每次只使用其中的一块。<br>当这一块的内存使用完后，就将还存活的对象复制到另一块区，然后再把使用的空间一次清理掉。<br>这样就使每次的内存回收都是对内存区间的一半进行回收<br><img src=\"/JVM/JVM-Fundamentals/9.2.png\" alt=\"\"></p>\n<h4 id=\"标记-整理算法\"><a href=\"#标记-整理算法\" class=\"headerlink\" title=\"标记-整理算法\"></a>标记-整理算法</h4><p>根据老年代的特点提出的一种标记算法，标记过程和“标记-清除”算法一样，但是后续步骤不是直接对可回收对象进行回收，而是让所有存活的对象向一段移动，然后直接清理掉边界以外的内存<br><img src=\"/JVM/JVM-Fundamentals/9.3.png\" alt=\"\"></p>\n<h4 id=\"分代收集算法\"><a href=\"#分代收集算法\" class=\"headerlink\" title=\"分代收集算法\"></a>分代收集算法</h4><p>现在的商用虚拟机的垃圾收集器基本都采用”分代收集”算法，这种算法就是根据对象存活周期的不同将内存分为几块。<br>一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。<br>在新生代中，每次收集都有大量对象死去，所以可以选择复制算法，只要付出少量对象的复制成本就可以完成每次垃圾收集。<br>而老年代的对象存活几率时比较高的，而且没有额外的空间对它进行分配担保，就必须选择“标记-清除”或 者“标记-整理”算法进行垃圾收集。</p>\n<h3 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h3><p><img src=\"/JVM/JVM-Fundamentals/10.png\" alt=\"\"></p>\n<h4 id=\"Serial收集器\"><a href=\"#Serial收集器\" class=\"headerlink\" title=\"Serial收集器\"></a>Serial收集器</h4><p>Serial(串行)收集器收集器是最基本、历史最悠久的垃圾收集器了。<br>大家看名字就知道这个收集器是一个单线程收集器了。<br>它的<code>单线程</code>的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程( “Stop The World” )，直到它收集结束。<br><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img src=\"/JVM/JVM-Fundamentals/10.1.png\" alt=\"\"><br>虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短(仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续)。<br>但是Serial收集器有没有优于其他垃圾收集器的地方呢?<br>当然有，它简单而高效(与其他收集器的单线程相比)。 Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。</p>\n<h4 id=\"ParNew收集器\"><a href=\"#ParNew收集器\" class=\"headerlink\" title=\"ParNew收集器\"></a>ParNew收集器</h4><p>ParNew收集器其实就是Serial收集器的<code>多线程</code>版本，除了使用多线程进行垃圾收集外，其余行为(控制参数、收集算法、回收策略等等)和Serial收集器完全一样。<br><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img src=\"/JVM/JVM-Fundamentals/10.2.png\" alt=\"\"><br>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器(真正意义上的并发收集器，后面会介绍到)配合工作。</p>\n<h4 id=\"Parallel-Scavenge收集器-JDK1-8\"><a href=\"#Parallel-Scavenge收集器-JDK1-8\" class=\"headerlink\" title=\"Parallel Scavenge收集器(JDK1.8)\"></a>Parallel Scavenge收集器(JDK1.8)</h4><p>Parallel Scavenge 收集器类似于ParNew收集器。<br>Parallel Scavenge收集器关注点是<code>吞吐量</code>(高效率的利用CPU)。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。<br>CMS等垃圾收集器的关注点更多的是用户线程的<code>停顿时间</code>(提高用户体验)。 Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。<br><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img src=\"/JVM/JVM-Fundamentals/10.2.png\" alt=\"\"></p>\n<h4 id=\"Serial-Old收集器\"><a href=\"#Serial-Old收集器\" class=\"headerlink\" title=\"Serial Old收集器\"></a>Serial Old收集器</h4><p>Serial收集器的老年代版本，它同样是一个<code>单线程</code>收集器，采用<strong>标记-整理</strong>算法。<br>它主要有两大用途:一种用途是在JDK1.5以及以前的版本 中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。</p>\n<h4 id=\"Parallel-Old收集器\"><a href=\"#Parallel-Old收集器\" class=\"headerlink\" title=\"Parallel Old收集器\"></a>Parallel Old收集器</h4><p>Parallel Scavenge收集器的老年代版本。使用<code>多线程</code>和<strong>标记-整理</strong>算法。<br>在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。</p>\n<h4 id=\"CMS收集器\"><a href=\"#CMS收集器\" class=\"headerlink\" title=\"CMS收集器\"></a><strong>CMS收集器</strong></h4><p>并行和并发概念补充:</p>\n<ul>\n<li>并行(Parallel) :指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 </li>\n<li>并发(Concurrent):指用户线程与垃圾收集线程同时执行(但不一定是并行，可能会交替执行)，用户程序 在继续运行，而垃圾收集器运行在另一个CPU上。</li>\n</ul>\n<p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。<br>CMS(Concurrent Mark Sweep)收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作。</p>\n<p>从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种<strong>标记-清除</strong>算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。<br>整个过程分为四个步骤:</p>\n<ul>\n<li>初始标记(CMS initial mark): 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 </li>\n<li>并发标记(CMS concurrent mark): <strong>同时开启GC和用户线程</strong>，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>\n<li>重新标记(CMS remark): 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶 段时间短</li>\n<li>并发清除(CMS concurrent sweep): 开启用户线程，同时GC线程开始对为标记的区域做清扫。<br><img src=\"/JVM/JVM-Fundamentals/10.3.png\" alt=\"\"><br>CMS主要优点:并发收集、低停顿。<br>但是它有下面三个明显的缺点:</li>\n<li>对CPU资源敏感;</li>\n<li>无法处理浮动垃圾;</li>\n<li>它使用的回收算法-<strong>标记-清除</strong>算法会导致收集结束时会有大量空间碎片产生。</li>\n</ul>\n<h4 id=\"G1收集器\"><a href=\"#G1收集器\" class=\"headerlink\" title=\"G1收集器\"></a>G1收集器</h4><p>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC停顿时间要求的同时,还具备高吞吐量性能特征.<br><img src=\"/JVM/JVM-Fundamentals/10.3.png\" alt=\"\"><br>被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点:</p>\n<ul>\n<li>并行与并发:G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU(CPU或者CPU核心)来缩短Stop- The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行 </li>\n<li>分代收集:虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。 空间整合:与CMS的“标记–清理”算法不同，G1从整体来看是基于<strong>标记整理</strong>算法实现的收集器;从局部上来看是基于<strong>标记复制</strong>算法实现的</li>\n<li><strong>可预测的停顿</strong>:这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内</li>\n</ul>\n<p>G1收集器的运作大致分为以下几个步骤:</p>\n<ul>\n<li>初始标记</li>\n<li>并发标记</li>\n<li>最终标记</li>\n<li>筛选回收</li>\n</ul>\n<p>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名 字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率(把内存化整为零)。</p>\n<h4 id=\"怎么选择垃圾收集器-（尽量由JVM自己选择）\"><a href=\"#怎么选择垃圾收集器-（尽量由JVM自己选择）\" class=\"headerlink\" title=\"怎么选择垃圾收集器?（尽量由JVM自己选择）\"></a>怎么选择垃圾收集器?（尽量由JVM自己选择）</h4><ol>\n<li>优先调整堆的大小让服务器自己来选择</li>\n<li>如果内存小于100m，使用串行收集器</li>\n<li>如果是单核，并且没有停顿时间的要求，串行或JVM自己选择 </li>\n<li>如果允许停顿时间超过1秒，选择并行或者JVM自己选</li>\n<li>如果响应时间最重要，并且不能超过1秒，使用并发收集器<br>官方推荐ZGC(java最新版本垃圾收器器，可预测的停顿最低2ms)，性能高。</li>\n</ol>\n<h2 id=\"JDK性能调优监控工具\"><a href=\"#JDK性能调优监控工具\" class=\"headerlink\" title=\"JDK性能调优监控工具\"></a>JDK性能调优监控工具</h2><p>虚拟机参数分析网站：<a href=\"https://www.perfma.com/product/opts\" target=\"_blank\" rel=\"noopener\">https://www.perfma.com/product/opts</a></p>\n<h3 id=\"jps\"><a href=\"#jps\" class=\"headerlink\" title=\"jps\"></a>jps</h3><p>显示当前系统的java进程情况</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdeMacBook-Pro:~ g$ jps</span><br><span class=\"line\">94673 AppServiceApplication</span><br><span class=\"line\">54995</span><br><span class=\"line\">55011 RemoteMavenServer36</span><br><span class=\"line\">94696 AppServiceApplication</span><br><span class=\"line\">96956 Jps</span><br></pre></td></tr></table></figure>\n\n<p>(空白的54995是idea)</p>\n<h3 id=\"Jinfo\"><a href=\"#Jinfo\" class=\"headerlink\" title=\"Jinfo\"></a>Jinfo</h3><p>查看正在运行的Java程序的扩展参数</p>\n<h4 id=\"查看JVM的参数\"><a href=\"#查看JVM的参数\" class=\"headerlink\" title=\"查看JVM的参数\"></a>查看JVM的参数</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdeMacBook-Pro:~ g$ jinfo -flags 94673</span><br><span class=\"line\">VM Flags:</span><br><span class=\"line\">-XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote -XX:CICompilerCount=4 -XX:ConcGCThreads=3 -XX:G1ConcRefinementThreads=10 -XX:G1HeapRegionSize=1048576 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=268435456 -XX:+ManagementServer -XX:MarkStackSize=4194304 -XX:MaxHeapSize=4294967296 -XX:MaxNewSize=2576351232 -XX:MinHeapDeltaBytes=1048576 -XX:NonNMethodCodeHeapSize=7549744 -XX:NonProfiledCodeHeapSize=244108496 -XX:ProfiledCodeHeapSize=0 -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:TieredStopAtLevel=1 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查看java系统属性\"><a href=\"#查看java系统属性\" class=\"headerlink\" title=\"查看java系统属性\"></a>查看java系统属性</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jinfo -sysprops 94673</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Jstat\"><a href=\"#Jstat\" class=\"headerlink\" title=\"Jstat\"></a>Jstat</h3><p>jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令格式:<br>jstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdeMacBook-Pro:~ g$ jstat -gc 94673</span><br><span class=\"line\"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT</span><br><span class=\"line\"> 0.0   2048.0  0.0   2048.0 96256.0  68608.0   163840.0   132934.6  131280.0 127368.5 14720.0 13850.3    185    1.219   0      0.000  112     0.661    1.880</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>S0C：第一个幸存区的大小</li>\n<li>S1C：第二个幸存区的大小</li>\n<li>S0U：第一个幸存区的使用大小</li>\n<li>S1U：第二个幸存区的使用大小</li>\n<li>EC：伊甸园区的大小</li>\n<li>EU：伊甸园区的使用大小</li>\n<li>OC：老年代大小</li>\n<li>OU：老年代使用大小</li>\n<li>MC：方法区大小</li>\n<li>MU：方法区使用大小</li>\n<li>CCSC:压缩类空间大小</li>\n<li>CCSU:压缩类空间使用大小</li>\n<li>YGC：年轻代垃圾回收次数</li>\n<li>YGCT：年轻代垃圾回收消耗时间</li>\n<li>FGC：老年代垃圾回收次数</li>\n<li>FGCT：老年代垃圾回收消耗时间</li>\n<li>GCT：垃圾回收消耗总时间</li>\n</ul>\n<h3 id=\"Jmap\"><a href=\"#Jmap\" class=\"headerlink\" title=\"Jmap\"></a>Jmap</h3><p>可以用来查看内存信息</p>\n<h4 id=\"堆的对象统计\"><a href=\"#堆的对象统计\" class=\"headerlink\" title=\"堆的对象统计\"></a>堆的对象统计</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdeMacBook-Pro:~ g$ jmap -histo 94673 &gt; xxx.txt</span><br></pre></td></tr></table></figure>\n\n<p>部分如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> num     #instances         #bytes  class name (module)</span><br><span class=\"line\">-------------------------------------------------------</span><br><span class=\"line\">   1:        380588       39857240  [B (java.base@11.0.4)</span><br><span class=\"line\">   2:         71568        8387344  [Ljava.lang.Object; (java.base@11.0.4)</span><br><span class=\"line\">   3:        301995        7247880  java.lang.String (java.base@11.0.4)</span><br><span class=\"line\">   4:         25762        5316280  [I (java.base@11.0.4)</span><br><span class=\"line\">   5:         47736        4200768  java.lang.reflect.Method (java.base@11.0.4)</span><br><span class=\"line\">   6:        126275        4040800  java.util.concurrent.ConcurrentHashMap$Node (java.base@11.0.4)</span><br><span class=\"line\">   7:         69142        3871952  java.util.LinkedHashMap (java.base@11.0.4)</span><br><span class=\"line\">   8:          2483        3656120  [C (java.base@11.0.4)</span><br><span class=\"line\">   9:         46566        3352752  io.netty.channel.DefaultChannelHandlerContext</span><br><span class=\"line\">  10:        104582        3346624  java.util.HashMap$Node (java.base@11.0.4)</span><br><span class=\"line\">  11:         20887        2551232  java.lang.Class (java.base@11.0.4)</span><br><span class=\"line\">  12:         32461        2077504  java.util.concurrent.ConcurrentHashMap (java.base@11.0.4)</span><br><span class=\"line\">  13:         48062        1922480  java.util.HashMap$KeyIterator (java.base@11.0.4)</span><br><span class=\"line\">  14:         17400        1720040  [Ljava.util.HashMap$Node; (java.base@11.0.4)</span><br><span class=\"line\">  15:          2184        1432704  io.netty.util.internal.shaded.org.jctools.queues.MpscArrayQueue</span><br><span class=\"line\">  16:         35693        1427720  java.util.LinkedHashMap$Entry (java.base@11.0.4)</span><br><span class=\"line\">  17:         88742        1419872  java.lang.Object (java.base@11.0.4)</span><br><span class=\"line\">  18:          1671        1195280  [Ljava.util.concurrent.ConcurrentHashMap$Node; (java.base@11.0.4)</span><br><span class=\"line\">  19:         10270        1150240  sun.nio.ch.SocketChannelImpl (java.base@11.0.4)</span><br><span class=\"line\">  20:         10237        1064648  io.netty.channel.socket.nio.NioSocketChannel</span><br><span class=\"line\">  21:         42359        1016616  java.util.ArrayList (java.base@11.0.4)</span><br><span class=\"line\">  22:         60868         973888  java.lang.Integer (java.base@11.0.4)</span><br><span class=\"line\">  23:         20436         817440  io.netty.util.DefaultAttributeMap$DefaultAttribute</span><br><span class=\"line\">  24:         10533         758376  org.springframework.core.type.classreading.AnnotationMetadataReadingVisitor</span><br><span class=\"line\">  25:         18570         742800  com.meituan.service.mobile.mtthrift.mtrace.MtraceServerTBinaryProtocol$Factory</span><br><span class=\"line\">  26:         10239         737208  io.netty.channel.DefaultChannelPipeline$HeadContext</span><br><span class=\"line\">  27:         10239         737208  io.netty.channel.DefaultChannelPipeline$TailContext</span><br><span class=\"line\">  28:         30914         729768  [Ljava.lang.Class; (java.base@11.0.4)</span><br><span class=\"line\">  29:         21894         700608  java.util.concurrent.locks.ReentrantLock$NonfairSync (java.base@11.0.4)</span><br><span class=\"line\">------省略----</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Num:序号</li>\n<li>Instances:实例数量</li>\n<li>Bytes:占用空间大小</li>\n<li>Class Name:类名</li>\n</ul>\n<h4 id=\"堆信息\"><a href=\"#堆信息\" class=\"headerlink\" title=\"堆信息\"></a>堆信息</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdeMacBook-Pro:~ g$ jmap -heap 94673</span><br><span class=\"line\">Error: -heap option used</span><br><span class=\"line\">Cannot connect to core dump or remote debug server. Use jhsdb jmap instead</span><br></pre></td></tr></table></figure>\n\n<p>jdk9及以上版本使用jmap -heap pid命令查看当前heap使用情况时，发现报错，提示需要使用jhsdb jmap来替代</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdeMacBook-Pro:~ g$ jhsdb jmap --heap --pid 94673</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>Java虚拟机(java virtual machine，JVM)，一种能够运行java字节码的虚拟机。作为一种编程语言的虚拟机，实际上不只是专用于Java语言，只要生成的编译文件匹配JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。 比如kotlin、scala等。</p>\n<h1 id=\"JVM基本结构\"><a href=\"#JVM基本结构\" class=\"headerlink\" title=\"JVM基本结构\"></a>JVM基本结构</h1><p>JVM由三个主要的子系统构成</p>\n<ul>\n<li>类加载子系统</li>\n<li>运行时数据区(内存结构)</li>\n<li>执行引擎<img src=\"/JVM/JVM-Fundamentals/1.png\" width=\"80%\" height=\"80%\"></li></ul>","more":"\n\n<h2 id=\"类加载机制\"><a href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h2><h3 id=\"类的生命周期\"><a href=\"#类的生命周期\" class=\"headerlink\" title=\"类的生命周期\"></a>类的生命周期</h3><p><img src=\"/JVM/JVM-Fundamentals/2.png\" alt=\"\"></p>\n<ol>\n<li>加载：将.class文件从磁盘读到内存<ul>\n<li>通过类的全限定名(com.xxx.xxx)+类加载器确定唯一的类，来获取定义此类的二进制字节流</li>\n<li>将这个类字节流代表的静态存储结构转为方法区的运行时数据结构</li>\n<li>在堆中生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口。</li>\n</ul>\n</li>\n<li>连接<ol>\n<li>验证：验证字节码文件的正确性<ul>\n<li>文件格式验证：基于字节流验证，验证字节流是否符合Class文件格式的规范，并且能被当前虚拟机处理。</li>\n<li>元数据验证：基于方法区的存储结构验证，对字节码描述信息进行语义验证。</li>\n<li>字节码验证：基于方法区的存储结构验证，进行数据流和控制流的验证。</li>\n<li>符号引用验证：基于方法区的存储结构验证，发生在解析中，是否可以将符号引用成功解析为直接引用。</li>\n</ul>\n</li>\n<li>准备：给类的静态变量分配内存，并赋予<code>默认值</code>（不包括实例变量）<ul>\n<li>public static int value = 123; //此时在准备阶段过后的初始值为0而不是123，在初始化过程才会被赋值为123</li>\n<li>public static final int value = 123;//value的值在准备阶段过后就是123。</li>\n</ul>\n</li>\n<li>解析：类装载器装入类所引用的其它所有类</li>\n</ol>\n</li>\n<li>初始化：为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序编写者为变量分配的真正的初始值，执行静态代码块</li>\n<li>使用</li>\n<li>卸载</li>\n</ol>\n<h3 id=\"类加载器的种类\"><a href=\"#类加载器的种类\" class=\"headerlink\" title=\"类加载器的种类\"></a>类加载器的种类</h3><p>总体上分为两种：启动类加载器（C++实现） 和 其他类加载器（JAVA实现）</p>\n<h4 id=\"启动类加载器-Bootstrap-ClassLoader\"><a href=\"#启动类加载器-Bootstrap-ClassLoader\" class=\"headerlink\" title=\"启动类加载器(Bootstrap ClassLoader)\"></a>启动类加载器(Bootstrap ClassLoader)</h4><p>负责加载JRE的核心类库，如JRE目标下的rt.jar，charsets.jar等</p>\n<h4 id=\"扩展类加载器-Extension-ClassLoader\"><a href=\"#扩展类加载器-Extension-ClassLoader\" class=\"headerlink\" title=\"扩展类加载器(Extension ClassLoader)\"></a>扩展类加载器(Extension ClassLoader)</h4><p>负责加载JRE扩展目录ext中jar类包</p>\n<h4 id=\"系统类加载器-Application-ClassLoader\"><a href=\"#系统类加载器-Application-ClassLoader\" class=\"headerlink\" title=\"系统类加载器(Application ClassLoader)\"></a>系统类加载器(Application ClassLoader)</h4><p>负责加载ClassPath路径下的类包</p>\n<h4 id=\"用户自定义加载器-User-ClassLoader\"><a href=\"#用户自定义加载器-User-ClassLoader\" class=\"headerlink\" title=\"用户自定义加载器(User ClassLoader)\"></a>用户自定义加载器(User ClassLoader)</h4><p>负责加载用户自定义路径下的类包<br><img src=\"/JVM/JVM-Fundamentals/3.png\" width=\"50%\" height=\"50%\"></p>\n<h3 id=\"类加载机制-1\"><a href=\"#类加载机制-1\" class=\"headerlink\" title=\"类加载机制\"></a>类加载机制</h3><h4 id=\"全盘负责委托机制\"><a href=\"#全盘负责委托机制\" class=\"headerlink\" title=\"全盘负责委托机制\"></a>全盘负责委托机制</h4><p>当一个ClassLoader加载一个类的时候，除非显示的使用另一个ClassLoader，该类所依赖和引用的类也由这个 ClassLoader载入</p>\n<h4 id=\"双亲委派机制\"><a href=\"#双亲委派机制\" class=\"headerlink\" title=\"双亲委派机制\"></a>双亲委派机制</h4><p>指先委托父类加载器寻找目标类，在找不到的情况下，在自己的路径中查找并载入目标类<br><img src=\"/JVM/JVM-Fundamentals/4.png\" width=\"50%\" height=\"50%\"></p>\n<ol>\n<li>当有类需要加载，系统类加载器先判断有没有父类，有交给扩展类加载器加载</li>\n<li>扩展类加载器判断有没有父类，有交给启动类加载器</li>\n<li>启动类加载器没有父类，去实际加载该类，该类不是JRE包下的类，交给子类扩展类加载器去加载</li>\n<li>扩展类加载器去加载该类，发现该类不是ext中的包，交给系统类加载器加载</li>\n<li>系统类加载器加载，发现是classPath路径下的包，进行加载。</li>\n</ol>\n<h5 id=\"双亲委派模式的优势\"><a href=\"#双亲委派模式的优势\" class=\"headerlink\" title=\"双亲委派模式的优势\"></a>双亲委派模式的优势</h5><ul>\n<li>沙箱安全机制:比如自己写的String.class类不会被加载，这样可以防止核心库被随意篡改</li>\n<li>避免类的重复加载:当父ClassLoader已经加载了该类的时候，就不需要子ClassLoader再加载一次</li>\n</ul>\n<h5 id=\"为什么要打破双亲委派模式\"><a href=\"#为什么要打破双亲委派模式\" class=\"headerlink\" title=\"为什么要打破双亲委派模式\"></a>为什么要打破双亲委派模式</h5><p>例如：tomcat<br>Tomcat是个web容器,可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。<br>如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加载器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。</p>\n<h5 id=\"如何打破双亲委派模式\"><a href=\"#如何打破双亲委派模式\" class=\"headerlink\" title=\"如何打破双亲委派模式\"></a>如何打破双亲委派模式</h5><ol>\n<li>继承ClassLoader</li>\n<li>重写findClass()方法</li>\n<li>重写loadClass()方法</li>\n</ol>\n<h2 id=\"运行时数据区-内存结构\"><a href=\"#运行时数据区-内存结构\" class=\"headerlink\" title=\"运行时数据区(内存结构)\"></a>运行时数据区(内存结构)</h2><p><img src=\"/JVM/JVM-Fundamentals/5.png\" alt=\"\"></p>\n<h3 id=\"虚拟机栈\"><a href=\"#虚拟机栈\" class=\"headerlink\" title=\"虚拟机栈\"></a>虚拟机栈</h3><p>java虚拟机栈是线程私有的，每个方法执行都会创建一个栈帧，栈帧包含局部变量表、操作数栈、动态连接、方法出口等。</p>\n<h4 id=\"栈与栈帧\"><a href=\"#栈与栈帧\" class=\"headerlink\" title=\"栈与栈帧\"></a>栈与栈帧</h4><p>每一个方法的执行到执行完成，对应着一个栈帧在虚拟机中从入栈到出栈的过程。java虚拟机栈栈顶的栈帧就是当前执行方法的栈帧。PC寄存器会指向该地址。当这个方法调用其他方法的时候久会创建一个新的栈帧，这个新的栈帧会被方法Java虚拟机栈的栈顶，变为当前的活动栈，在当前只有当前活动栈的本地变量才能被使用，当这个栈帧所有指令都完成的时候，这个栈帧被移除，之前的栈帧变为活动栈，前面移除栈帧的返回值变为这个栈帧的一个操作数。</p>\n<h4 id=\"栈帧\"><a href=\"#栈帧\" class=\"headerlink\" title=\"栈帧\"></a>栈帧</h4><p>栈帧包含局部变量表、操作数栈、动态连接、方法返回地址</p>\n<h5 id=\"局部变量表\"><a href=\"#局部变量表\" class=\"headerlink\" title=\"局部变量表\"></a>局部变量表</h5><ul>\n<li>局部变量表是变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在java编译成class文件的时候，就在方法的Code属性的max_locals数据项中确定该方法需要分配的最大局部变量表的容量。</li>\n<li>局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放32位（4 字节）以内的数据类型（ boolean、byte、char、short、int、float、reference和returnAddress八种）</li>\n<li>对于64位长度的数据类型（long，double），虚拟机会以高位对齐方式为其分配<code>两个连续的Slot</code>空间，也就是相当于把一次long和double数据类型读写分割成为两次32位读写。</li>\n<li>reference类型虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。</li>\n<li>Slot是可以重用的，当Slot中的变量超出了作用域，那么下一次分配Slot的时候，将会覆盖原来的数据。Slot对对象的引用会影响GC（要是被引用，将不会被回收）。  </li>\n<li>系统不会为局部变量赋予初始值（实例变量和类变量都会被赋予初始值）。也就是说不存在类变量那样的准备阶段。</li>\n</ul>\n<h5 id=\"操作数栈\"><a href=\"#操作数栈\" class=\"headerlink\" title=\"操作数栈\"></a>操作数栈</h5><ul>\n<li>操作数栈和局部变量表一样，在编译时期就已经确定了该方法所需要分配的局部变量表的最大容量。</li>\n<li>操作数栈的每一个元素可用是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型占用的栈容量为2。</li>\n<li>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈 / 入栈操作（例如：在做算术运算的时候是通过操作数栈来进行的，又或者在调用其它方法的时候是通过操作数栈来进行参数传递的）。</li>\n</ul>\n<h5 id=\"动态连接\"><a href=\"#动态连接\" class=\"headerlink\" title=\"动态连接\"></a>动态连接</h5><p>直接引用：有具体引用地址的指针，被引用的类、方法或者变量已经被加载到内存中<br>符号引用：即用用字符串符号的形式来表示引用，其实被引用的类、方法或者变量还没有被加载到内存中。<br>举个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 符号引用</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">String str = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"str=\"</span> + str);</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 直接引用</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"str=\"</span> + <span class=\"string\">\"abc\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>动态链接：在程序运行过程中，由符号引用转化为直接引用。<br>静态链接：在类加载过程中，由符号引用转化为直接引用。</p>\n<h5 id=\"方法返回地址\"><a href=\"#方法返回地址\" class=\"headerlink\" title=\"方法返回地址\"></a>方法返回地址</h5><p>当一个方法开始执行时，可能有两种方式退出该方法：</p>\n<ul>\n<li>正常完成出口<ul>\n<li>正常完成出口是指方法正常完成并退出，没有抛出任何异常(包括Java虚拟机异常以及执行时通过throw语句显示抛出的异常)。如果当前方法正常完成，则根据当前方法返回的字节码指令，这时有可能会有返回值传递给方法调用者(调用它的方法)，或者无返回值。具体是否有返回值以及返回值的数据类型将根据该方法返回的字节码指令确定。</li>\n</ul>\n</li>\n<li>异常完成出口<ul>\n<li>异常完成出口是指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退出。</li>\n</ul>\n</li>\n</ul>\n<p>无论方法采用何种方式退出，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在当前栈帧中保存一些信息，用来帮他恢复它的上层方法执行状态。<br>方法退出过程实际上就等同于把当前栈帧出栈，因此退出可以执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压如调用者的操作数栈中，调整PC计数器的值以指向方法调用指令后的下一条指令。<br>一般来说，方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理器表确定的，栈帧中一般不会保存此部分信息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">math</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = (a + b)*<span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Demo demo = <span class=\"keyword\">new</span> Demo();</span><br><span class=\"line\">        demo.math();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当执行👆Demo的math方法时，主线程内存会如何操作<br><img src=\"/JVM/JVM-Fundamentals/5.1.png\" width=\"50%\" height=\"50%\"><br>第一步，现将1放入<code>操作数栈</code><br><img src=\"/JVM/JVM-Fundamentals/5.2.png\" width=\"50%\" height=\"50%\"><br>第二步，将1放入<code>局部变量表</code>中第一个槽里<br><img src=\"/JVM/JVM-Fundamentals/5.3.png\" width=\"50%\" height=\"50%\"><br>第三步，第四步同上，最终将2放入<code>局部变量表</code>中第二个槽里<br><img src=\"/JVM/JVM-Fundamentals/5.4.png\" width=\"50%\" height=\"50%\"><br>第五步，将1复制一份放入<code>操作数栈</code>的栈顶<br>第六步，将2复制一份放入<code>操作数栈</code>的栈顶<br><img src=\"/JVM/JVM-Fundamentals/5.5.png\" width=\"50%\" height=\"50%\"><br>第七步，将2，1弹出操作数栈交给cpu去运算得到3，放到<code>操作数栈</code>的栈顶<br><img src=\"/JVM/JVM-Fundamentals/5.6.png\" width=\"50%\" height=\"50%\"><br>第八步，从常量池（-128～127）里拿到10，放入<code>操作数栈</code>顶<br><img src=\"/JVM/JVM-Fundamentals/5.7.png\" width=\"50%\" height=\"50%\"><br>第九步，弹出10，3交给cpu去运算得到30，放到<code>操作数栈</code>的栈顶（jvm1.6开始进行了指令优化，第8、9步合并成了一步操作）<br><img src=\"/JVM/JVM-Fundamentals/5.8.png\" width=\"50%\" height=\"50%\"><br>第十步，将30放到<code>局部变量表</code>中第3个槽里。<br><img src=\"/JVM/JVM-Fundamentals/5.9.png\" width=\"50%\" height=\"50%\"><br>第十一步，将30复制一份放入<code>操作数栈</code>第栈顶。<br>第十二步，将30弹出操作数栈，通过<code>返回地址</code>返回。</p>\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>就是一个指针，指向方法区中的方法字节码(用来存储<strong>指向下一跳指令的地址</strong>，也就是当前线程将要执行的指令代码)，<br>由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计，用来保证线程间切换后正确执行。</p>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>和栈作用很相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行native方法服务。<br>登记native方法，在Execution Engine执行时加载本地方法库。</p>\n<h3 id=\"方法区（永久代-持久代，元空间）\"><a href=\"#方法区（永久代-持久代，元空间）\" class=\"headerlink\" title=\"方法区（永久代/持久代，元空间）\"></a>方法区（永久代/持久代，元空间）</h3><p>类的所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在这里定义。<br>简单来说，所有定义的方法的信息都保存在该区域，静态变量+常量+类信息(构造方法/接口定义)+运行时常量池都存在方法区中，<br>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap(非堆)，目的应该是为了和Java的堆区分开(jdk1.8以前hotspot虚拟机叫永久代、持久代，jdk1.8时叫元空间)</p>\n<p>永久代和元空间区别在于元数据区不在虚拟机当中，而是用的<code>本地内存</code>，永久代在虚拟机当中，永久代逻辑结构上也属于堆，但是物理上不属于。</p>\n<h4 id=\"为什么移除了永久代\"><a href=\"#为什么移除了永久代\" class=\"headerlink\" title=\"为什么移除了永久代?\"></a>为什么移除了永久代?</h4><p>参考官方解释<a href=\"http://openjdk.java.net/jeps/122\" target=\"_blank\" rel=\"noopener\">http://openjdk.java.net/jeps/122</a><br>大概意思是移除永久代是为融合HotSpot与 JRockit而做出的努力，因为JRockit没有永久代，不需要配置永久代。<br><img src=\"/JVM/JVM-Fundamentals/7.png\" alt=\"\"></p>\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><p>虚拟机启动时自动分配创建，用于存放<code>对象</code>的实例，几乎所有对象都在堆上分配内存，当对象无法在该空间申请到内<br>存是将抛出OutOfMemoryError异常。同时也是垃圾收集器管理的主要区域。<br><img src=\"/JVM/JVM-Fundamentals/6.jpeg\" alt=\"\"></p>\n<h4 id=\"新生代-Young-Generation\"><a href=\"#新生代-Young-Generation\" class=\"headerlink\" title=\"新生代(Young Generation)\"></a>新生代(Young Generation)</h4><p>类出生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。<br>新生代分为两部分:<code>伊甸区</code>(Eden space)和<code>幸存者区</code>(Survivor space)，所有的类都是在伊甸区被new出来的。<br>幸存区(Survivor space):分为From和To区,TO区永远保持空。<br>当Eden区的空间用完是，程序又需要创建对象，JVM的垃圾回收器将Eden区进行垃圾回收(<code>Minor GC</code>)，将Eden区中的不再被其它对象应用的对象进行销毁。<br>然后将Eden区中剩余的对象移到From Survivor区。若From Survivor区也满了，再对该区进行垃圾回收，然后移动到To Survivor区，From区为空后，将To和From区转换，保证To区为空，并且对象年龄加一。<br>当对象年龄默认加到15（因为<strong>对象头只有4个bits</strong>是存对象年龄，最大为15）时将剩下的对象移到老年代。</p>\n<h3 id=\"老年代-Old-Generation\"><a href=\"#老年代-Old-Generation\" class=\"headerlink\" title=\"老年代(Old Generation)\"></a>老年代(Old Generation)</h3><p>新生代经过多次GC仍然存货的对象移动到老年区。<br>若老年代也满了，这时候将发生Major GC(也可以叫<code>Full GC</code>)， 进行老年区的内存清理。<br>若老年区执行了Full GC之后发现依然无法进行对象的保存，就会抛出 OOM(OutOfMemoryError)异常.</p>\n<h2 id=\"GC算法和收集器\"><a href=\"#GC算法和收集器\" class=\"headerlink\" title=\"GC算法和收集器\"></a>GC算法和收集器</h2><p>几种常见GC：<br>MinorGC/YoungGC 新生代<br>OldGC CMS特有<br>FullGC/MajorGC 回收所有<br>MixedGC（FullGC+YoungGC）  G1特有</p>\n<h3 id=\"如何判断对象可以被回收\"><a href=\"#如何判断对象可以被回收\" class=\"headerlink\" title=\"如何判断对象可以被回收\"></a>如何判断对象可以被回收</h3><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡(即不能再被任何途径使用的对象)</p>\n<h4 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h4><p>给对象添加一个引用计数器，每当有一个地方引用，计数器就加1。当引用失效，计数器就减1。任何时候计数器为0 的对象就是不可能再被使用的。</p>\n<p>这个方法实现简单，效率高，但是目前主流的虚拟机中没有选择这个算法来管理内存，最主要的原因是它很难解决<strong>对象之前相互循环引用</strong>的问题。所谓对象之间的相互引用问题，通过下面代码所示:除了对象a和b相互引用着对方之外，这两个对象之间再无任何引用。但是它们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数器法无法通知GC回收器回收它们。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CounterGC</span></span>&#123;</span><br><span class=\"line\">    Object instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">      CounterGC a = <span class=\"keyword\">new</span> CounterGC();</span><br><span class=\"line\">      CounterGC b = <span class=\"keyword\">new</span> CounterGC();</span><br><span class=\"line\">      a.instance = b;</span><br><span class=\"line\">      b.instance = a;</span><br><span class=\"line\">      a = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      b = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h4><p>这个算法的基本思想就是通过一系列的称为”GC Roots”的对象作为起点，从这些节点开始向下搜索，节点所走过的路<br>径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象时不可用的。</p>\n<p><code>GC Roots根节点</code>:类加载器、Thread、虚拟机栈的局部变量表、static成员、常量引用、本地方法栈的变量等等.<br><img src=\"/JVM/JVM-Fundamentals/8.png\" alt=\"\"></p>\n<h3 id=\"如何判断一个常量是废弃常量\"><a href=\"#如何判断一个常量是废弃常量\" class=\"headerlink\" title=\"如何判断一个常量是废弃常量\"></a>如何判断一个常量是废弃常量</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们怎么判断一个常量时废弃常量呢?<br>假如在常量池中存在字符串”abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量”abc”就是废弃常量，如果这时发生内存回收的话而且有必要的话（内存不够用时才会发生回收），”abc”会被系统清理出常量池。</p>\n<h3 id=\"如何判断一个类是无用的类\"><a href=\"#如何判断一个类是无用的类\" class=\"headerlink\" title=\"如何判断一个类是无用的类\"></a>如何判断一个类是无用的类</h3><p>需要满足以下三个条件:</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>\n<li>加载该类的 ClassLoader 已经被回收。</li>\n<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。<br>虚拟机可以对满足上述3个条件的无用类进行回收，这里仅仅是”<strong>可以</strong>“，而并不是和对象一样不适用了就必然会被回收。</li>\n</ul>\n<h3 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h3><p><img src=\"/JVM/JVM-Fundamentals/9.png\" alt=\"\"></p>\n<h4 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h4><p>它是最基础的收集算法，这个算法分为两个阶段，<code>标记</code>和<code>清除</code>。首先标记出所有需要回收的对象，在标记完成后<br>统一回收所有被标记的对象。它有两个不足的地方:</p>\n<ol>\n<li>效率问题，标记和清除两个过程的效率都不高;</li>\n<li>空间问题，标记清除后会产生大量不连续的碎片;<br><img src=\"/JVM/JVM-Fundamentals/9.1.png\" alt=\"\"></li>\n</ol>\n<h4 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h4><p>为了解决效率问题，复制算法出现了。它可以把内存分为大小相同的两块，每次只使用其中的一块。<br>当这一块的内存使用完后，就将还存活的对象复制到另一块区，然后再把使用的空间一次清理掉。<br>这样就使每次的内存回收都是对内存区间的一半进行回收<br><img src=\"/JVM/JVM-Fundamentals/9.2.png\" alt=\"\"></p>\n<h4 id=\"标记-整理算法\"><a href=\"#标记-整理算法\" class=\"headerlink\" title=\"标记-整理算法\"></a>标记-整理算法</h4><p>根据老年代的特点提出的一种标记算法，标记过程和“标记-清除”算法一样，但是后续步骤不是直接对可回收对象进行回收，而是让所有存活的对象向一段移动，然后直接清理掉边界以外的内存<br><img src=\"/JVM/JVM-Fundamentals/9.3.png\" alt=\"\"></p>\n<h4 id=\"分代收集算法\"><a href=\"#分代收集算法\" class=\"headerlink\" title=\"分代收集算法\"></a>分代收集算法</h4><p>现在的商用虚拟机的垃圾收集器基本都采用”分代收集”算法，这种算法就是根据对象存活周期的不同将内存分为几块。<br>一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。<br>在新生代中，每次收集都有大量对象死去，所以可以选择复制算法，只要付出少量对象的复制成本就可以完成每次垃圾收集。<br>而老年代的对象存活几率时比较高的，而且没有额外的空间对它进行分配担保，就必须选择“标记-清除”或 者“标记-整理”算法进行垃圾收集。</p>\n<h3 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h3><p><img src=\"/JVM/JVM-Fundamentals/10.png\" alt=\"\"></p>\n<h4 id=\"Serial收集器\"><a href=\"#Serial收集器\" class=\"headerlink\" title=\"Serial收集器\"></a>Serial收集器</h4><p>Serial(串行)收集器收集器是最基本、历史最悠久的垃圾收集器了。<br>大家看名字就知道这个收集器是一个单线程收集器了。<br>它的<code>单线程</code>的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程( “Stop The World” )，直到它收集结束。<br><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img src=\"/JVM/JVM-Fundamentals/10.1.png\" alt=\"\"><br>虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短(仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续)。<br>但是Serial收集器有没有优于其他垃圾收集器的地方呢?<br>当然有，它简单而高效(与其他收集器的单线程相比)。 Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。</p>\n<h4 id=\"ParNew收集器\"><a href=\"#ParNew收集器\" class=\"headerlink\" title=\"ParNew收集器\"></a>ParNew收集器</h4><p>ParNew收集器其实就是Serial收集器的<code>多线程</code>版本，除了使用多线程进行垃圾收集外，其余行为(控制参数、收集算法、回收策略等等)和Serial收集器完全一样。<br><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img src=\"/JVM/JVM-Fundamentals/10.2.png\" alt=\"\"><br>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器(真正意义上的并发收集器，后面会介绍到)配合工作。</p>\n<h4 id=\"Parallel-Scavenge收集器-JDK1-8\"><a href=\"#Parallel-Scavenge收集器-JDK1-8\" class=\"headerlink\" title=\"Parallel Scavenge收集器(JDK1.8)\"></a>Parallel Scavenge收集器(JDK1.8)</h4><p>Parallel Scavenge 收集器类似于ParNew收集器。<br>Parallel Scavenge收集器关注点是<code>吞吐量</code>(高效率的利用CPU)。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。<br>CMS等垃圾收集器的关注点更多的是用户线程的<code>停顿时间</code>(提高用户体验)。 Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。<br><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img src=\"/JVM/JVM-Fundamentals/10.2.png\" alt=\"\"></p>\n<h4 id=\"Serial-Old收集器\"><a href=\"#Serial-Old收集器\" class=\"headerlink\" title=\"Serial Old收集器\"></a>Serial Old收集器</h4><p>Serial收集器的老年代版本，它同样是一个<code>单线程</code>收集器，采用<strong>标记-整理</strong>算法。<br>它主要有两大用途:一种用途是在JDK1.5以及以前的版本 中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。</p>\n<h4 id=\"Parallel-Old收集器\"><a href=\"#Parallel-Old收集器\" class=\"headerlink\" title=\"Parallel Old收集器\"></a>Parallel Old收集器</h4><p>Parallel Scavenge收集器的老年代版本。使用<code>多线程</code>和<strong>标记-整理</strong>算法。<br>在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。</p>\n<h4 id=\"CMS收集器\"><a href=\"#CMS收集器\" class=\"headerlink\" title=\"CMS收集器\"></a><strong>CMS收集器</strong></h4><p>并行和并发概念补充:</p>\n<ul>\n<li>并行(Parallel) :指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 </li>\n<li>并发(Concurrent):指用户线程与垃圾收集线程同时执行(但不一定是并行，可能会交替执行)，用户程序 在继续运行，而垃圾收集器运行在另一个CPU上。</li>\n</ul>\n<p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。<br>CMS(Concurrent Mark Sweep)收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作。</p>\n<p>从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种<strong>标记-清除</strong>算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。<br>整个过程分为四个步骤:</p>\n<ul>\n<li>初始标记(CMS initial mark): 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 </li>\n<li>并发标记(CMS concurrent mark): <strong>同时开启GC和用户线程</strong>，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>\n<li>重新标记(CMS remark): 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶 段时间短</li>\n<li>并发清除(CMS concurrent sweep): 开启用户线程，同时GC线程开始对为标记的区域做清扫。<br><img src=\"/JVM/JVM-Fundamentals/10.3.png\" alt=\"\"><br>CMS主要优点:并发收集、低停顿。<br>但是它有下面三个明显的缺点:</li>\n<li>对CPU资源敏感;</li>\n<li>无法处理浮动垃圾;</li>\n<li>它使用的回收算法-<strong>标记-清除</strong>算法会导致收集结束时会有大量空间碎片产生。</li>\n</ul>\n<h4 id=\"G1收集器\"><a href=\"#G1收集器\" class=\"headerlink\" title=\"G1收集器\"></a>G1收集器</h4><p>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC停顿时间要求的同时,还具备高吞吐量性能特征.<br><img src=\"/JVM/JVM-Fundamentals/10.3.png\" alt=\"\"><br>被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点:</p>\n<ul>\n<li>并行与并发:G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU(CPU或者CPU核心)来缩短Stop- The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行 </li>\n<li>分代收集:虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。 空间整合:与CMS的“标记–清理”算法不同，G1从整体来看是基于<strong>标记整理</strong>算法实现的收集器;从局部上来看是基于<strong>标记复制</strong>算法实现的</li>\n<li><strong>可预测的停顿</strong>:这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内</li>\n</ul>\n<p>G1收集器的运作大致分为以下几个步骤:</p>\n<ul>\n<li>初始标记</li>\n<li>并发标记</li>\n<li>最终标记</li>\n<li>筛选回收</li>\n</ul>\n<p>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名 字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率(把内存化整为零)。</p>\n<h4 id=\"怎么选择垃圾收集器-（尽量由JVM自己选择）\"><a href=\"#怎么选择垃圾收集器-（尽量由JVM自己选择）\" class=\"headerlink\" title=\"怎么选择垃圾收集器?（尽量由JVM自己选择）\"></a>怎么选择垃圾收集器?（尽量由JVM自己选择）</h4><ol>\n<li>优先调整堆的大小让服务器自己来选择</li>\n<li>如果内存小于100m，使用串行收集器</li>\n<li>如果是单核，并且没有停顿时间的要求，串行或JVM自己选择 </li>\n<li>如果允许停顿时间超过1秒，选择并行或者JVM自己选</li>\n<li>如果响应时间最重要，并且不能超过1秒，使用并发收集器<br>官方推荐ZGC(java最新版本垃圾收器器，可预测的停顿最低2ms)，性能高。</li>\n</ol>\n<h2 id=\"JDK性能调优监控工具\"><a href=\"#JDK性能调优监控工具\" class=\"headerlink\" title=\"JDK性能调优监控工具\"></a>JDK性能调优监控工具</h2><p>虚拟机参数分析网站：<a href=\"https://www.perfma.com/product/opts\" target=\"_blank\" rel=\"noopener\">https://www.perfma.com/product/opts</a></p>\n<h3 id=\"jps\"><a href=\"#jps\" class=\"headerlink\" title=\"jps\"></a>jps</h3><p>显示当前系统的java进程情况</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdeMacBook-Pro:~ g$ jps</span><br><span class=\"line\">94673 AppServiceApplication</span><br><span class=\"line\">54995</span><br><span class=\"line\">55011 RemoteMavenServer36</span><br><span class=\"line\">94696 AppServiceApplication</span><br><span class=\"line\">96956 Jps</span><br></pre></td></tr></table></figure>\n\n<p>(空白的54995是idea)</p>\n<h3 id=\"Jinfo\"><a href=\"#Jinfo\" class=\"headerlink\" title=\"Jinfo\"></a>Jinfo</h3><p>查看正在运行的Java程序的扩展参数</p>\n<h4 id=\"查看JVM的参数\"><a href=\"#查看JVM的参数\" class=\"headerlink\" title=\"查看JVM的参数\"></a>查看JVM的参数</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdeMacBook-Pro:~ g$ jinfo -flags 94673</span><br><span class=\"line\">VM Flags:</span><br><span class=\"line\">-XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote -XX:CICompilerCount=4 -XX:ConcGCThreads=3 -XX:G1ConcRefinementThreads=10 -XX:G1HeapRegionSize=1048576 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=268435456 -XX:+ManagementServer -XX:MarkStackSize=4194304 -XX:MaxHeapSize=4294967296 -XX:MaxNewSize=2576351232 -XX:MinHeapDeltaBytes=1048576 -XX:NonNMethodCodeHeapSize=7549744 -XX:NonProfiledCodeHeapSize=244108496 -XX:ProfiledCodeHeapSize=0 -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:TieredStopAtLevel=1 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查看java系统属性\"><a href=\"#查看java系统属性\" class=\"headerlink\" title=\"查看java系统属性\"></a>查看java系统属性</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jinfo -sysprops 94673</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Jstat\"><a href=\"#Jstat\" class=\"headerlink\" title=\"Jstat\"></a>Jstat</h3><p>jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令格式:<br>jstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdeMacBook-Pro:~ g$ jstat -gc 94673</span><br><span class=\"line\"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT</span><br><span class=\"line\"> 0.0   2048.0  0.0   2048.0 96256.0  68608.0   163840.0   132934.6  131280.0 127368.5 14720.0 13850.3    185    1.219   0      0.000  112     0.661    1.880</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>S0C：第一个幸存区的大小</li>\n<li>S1C：第二个幸存区的大小</li>\n<li>S0U：第一个幸存区的使用大小</li>\n<li>S1U：第二个幸存区的使用大小</li>\n<li>EC：伊甸园区的大小</li>\n<li>EU：伊甸园区的使用大小</li>\n<li>OC：老年代大小</li>\n<li>OU：老年代使用大小</li>\n<li>MC：方法区大小</li>\n<li>MU：方法区使用大小</li>\n<li>CCSC:压缩类空间大小</li>\n<li>CCSU:压缩类空间使用大小</li>\n<li>YGC：年轻代垃圾回收次数</li>\n<li>YGCT：年轻代垃圾回收消耗时间</li>\n<li>FGC：老年代垃圾回收次数</li>\n<li>FGCT：老年代垃圾回收消耗时间</li>\n<li>GCT：垃圾回收消耗总时间</li>\n</ul>\n<h3 id=\"Jmap\"><a href=\"#Jmap\" class=\"headerlink\" title=\"Jmap\"></a>Jmap</h3><p>可以用来查看内存信息</p>\n<h4 id=\"堆的对象统计\"><a href=\"#堆的对象统计\" class=\"headerlink\" title=\"堆的对象统计\"></a>堆的对象统计</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdeMacBook-Pro:~ g$ jmap -histo 94673 &gt; xxx.txt</span><br></pre></td></tr></table></figure>\n\n<p>部分如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> num     #instances         #bytes  class name (module)</span><br><span class=\"line\">-------------------------------------------------------</span><br><span class=\"line\">   1:        380588       39857240  [B (java.base@11.0.4)</span><br><span class=\"line\">   2:         71568        8387344  [Ljava.lang.Object; (java.base@11.0.4)</span><br><span class=\"line\">   3:        301995        7247880  java.lang.String (java.base@11.0.4)</span><br><span class=\"line\">   4:         25762        5316280  [I (java.base@11.0.4)</span><br><span class=\"line\">   5:         47736        4200768  java.lang.reflect.Method (java.base@11.0.4)</span><br><span class=\"line\">   6:        126275        4040800  java.util.concurrent.ConcurrentHashMap$Node (java.base@11.0.4)</span><br><span class=\"line\">   7:         69142        3871952  java.util.LinkedHashMap (java.base@11.0.4)</span><br><span class=\"line\">   8:          2483        3656120  [C (java.base@11.0.4)</span><br><span class=\"line\">   9:         46566        3352752  io.netty.channel.DefaultChannelHandlerContext</span><br><span class=\"line\">  10:        104582        3346624  java.util.HashMap$Node (java.base@11.0.4)</span><br><span class=\"line\">  11:         20887        2551232  java.lang.Class (java.base@11.0.4)</span><br><span class=\"line\">  12:         32461        2077504  java.util.concurrent.ConcurrentHashMap (java.base@11.0.4)</span><br><span class=\"line\">  13:         48062        1922480  java.util.HashMap$KeyIterator (java.base@11.0.4)</span><br><span class=\"line\">  14:         17400        1720040  [Ljava.util.HashMap$Node; (java.base@11.0.4)</span><br><span class=\"line\">  15:          2184        1432704  io.netty.util.internal.shaded.org.jctools.queues.MpscArrayQueue</span><br><span class=\"line\">  16:         35693        1427720  java.util.LinkedHashMap$Entry (java.base@11.0.4)</span><br><span class=\"line\">  17:         88742        1419872  java.lang.Object (java.base@11.0.4)</span><br><span class=\"line\">  18:          1671        1195280  [Ljava.util.concurrent.ConcurrentHashMap$Node; (java.base@11.0.4)</span><br><span class=\"line\">  19:         10270        1150240  sun.nio.ch.SocketChannelImpl (java.base@11.0.4)</span><br><span class=\"line\">  20:         10237        1064648  io.netty.channel.socket.nio.NioSocketChannel</span><br><span class=\"line\">  21:         42359        1016616  java.util.ArrayList (java.base@11.0.4)</span><br><span class=\"line\">  22:         60868         973888  java.lang.Integer (java.base@11.0.4)</span><br><span class=\"line\">  23:         20436         817440  io.netty.util.DefaultAttributeMap$DefaultAttribute</span><br><span class=\"line\">  24:         10533         758376  org.springframework.core.type.classreading.AnnotationMetadataReadingVisitor</span><br><span class=\"line\">  25:         18570         742800  com.meituan.service.mobile.mtthrift.mtrace.MtraceServerTBinaryProtocol$Factory</span><br><span class=\"line\">  26:         10239         737208  io.netty.channel.DefaultChannelPipeline$HeadContext</span><br><span class=\"line\">  27:         10239         737208  io.netty.channel.DefaultChannelPipeline$TailContext</span><br><span class=\"line\">  28:         30914         729768  [Ljava.lang.Class; (java.base@11.0.4)</span><br><span class=\"line\">  29:         21894         700608  java.util.concurrent.locks.ReentrantLock$NonfairSync (java.base@11.0.4)</span><br><span class=\"line\">------省略----</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Num:序号</li>\n<li>Instances:实例数量</li>\n<li>Bytes:占用空间大小</li>\n<li>Class Name:类名</li>\n</ul>\n<h4 id=\"堆信息\"><a href=\"#堆信息\" class=\"headerlink\" title=\"堆信息\"></a>堆信息</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdeMacBook-Pro:~ g$ jmap -heap 94673</span><br><span class=\"line\">Error: -heap option used</span><br><span class=\"line\">Cannot connect to core dump or remote debug server. Use jhsdb jmap instead</span><br></pre></td></tr></table></figure>\n\n<p>jdk9及以上版本使用jmap -heap pid命令查看当前heap使用情况时，发现报错，提示需要使用jhsdb jmap来替代</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gdeMacBook-Pro:~ g$ jhsdb jmap --heap --pid 94673</span><br></pre></td></tr></table></figure>"},{"title":"《自己动手写JAVA虚拟机》学习笔记二【搜索class文件】","date":"2019-02-12T08:14:04.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"```java\npublic class HelloWorld {\n    public static void main(String[] args){\n        System.out.println(\"Hello, world!\");\n    }\n}\n```\n运行上面的java程序时，我们知道首先要启动java虚拟机，然后加载主类，最后调用主类的main方法。但是在加载HelloWorld类之前，首先要加载它的超类java.lang.Object，在调用main()函数之前，虚拟机要准备好参数数组，所以需要加载java.lang.String和java.lang.String[]类。把字符串打印到控制台还需要加载java.lang.System类，等等。。那么java虚拟机如何寻找这些类的呢？\n\n## 类路径\n类路径可以分为以下三种：\n * 启动类路径(bootstrap classpath)：启动类路径默认对应jre/lib目录，Java标准库位于该路径。\n * 扩展类路径(extention classpath)：扩展类路径默认对应jre/lib/ext目录，使用Java扩展机制的类位于该路径。\n * 用户类路径(user classpath)：我们自己实现的类，以及第三方类库则位于用户类路径。用户类路径的默认值是当前路径，也就是”.”，可以给java命令传递-classpath选项来指定。\n\n<!-- more -->\n### 准备工作\n\n把ch01的目录结构复制一份改名ch02，在ch02的目录中创建一个classpath子目录。\n```base\n|-jvmgo\n    |-ch01\n    |-ch01\n        |-classpath\n        |-cmd.go\n        |-main.go\n```\n修改cmd结构体，添加XjreOption字段\n```go\ntype Cmd struct {\n\thelpFlag bool\n\tversionFlag bool\n\tcpOption string\n\tXjreOption string\n\tclass string\n\targs []string\n}\n```\nparseCmd()函数也对应添加Xjre\n```go\n//命令解析\nfunc parseCmd() *Cmd {\n    ...//其他代码不变\n\tflag.StringVar(&cmd.cpOption,\"cp\",\"\",\"classpath\")\n\tflag.StringVar(&cmd.XjreOption,\"Xjre\",\"\",\"path to jre\")\n\t//解析命令行参数到定义的flag\n\tflag.Parse()\n\t...//其他代码不变\n}\n```\n### 实现类路径 \n\n采用组合模式来实现类路径，把类路径当成一个大的整体，由启动类路径、扩展类路径和用户类路径三个小路径构成，三个小路径又分别由更小的路径构成。\n\n首先定义一个Entry接口\n```go\n//获取系统分隔符，windows是;类UNIX系统是:号\nconst pathListSeparator = string(os.PathListSeparator)\n\ntype Entry interface {\n\t//寻找和加载class文件  参数：class文件相对路径，路径之间用/，文件名有.class后缀\n\t//例如读取java.lang.Object入参是java/lang/Object.class\n\treadClass(classname string) ([]byte, Entry, error)\n\n\t//toString\n\tString() string\n}\n```\nEntry接口一共有四种实现，CompositeEntry，WildcardEntry，ZipEntry，DirEntry\n#### DirEntry\nDirEntry相对简单些，表示目录形式的类路径\n```go\npackage classpath\n\nimport (\n\t\"path/filepath\"\n\t\"io/ioutil\"\n)\n\ntype DirEntry struct {\n\t//存放目录的绝对路径\n\tabsDir string\n}\n\n//相当于构造函数\nfunc newDirEntry(path string) *DirEntry {\n\t//将参数转换成绝对路径\n\tabsDir, err := filepath.Abs(path)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn &DirEntry{absDir}\n}\n//读取class文件\nfunc (self *DirEntry) readClass (className string) ([]byte, Entry, error) {\n\t//把目录和class名拼成完成路径\n\tfileName := filepath.Join(self.absDir,className)\n\t//读取class文件内容\n\tdata, err := ioutil.ReadFile(fileName)\n\treturn data,self,err\n}\n\n//直接返回目录\nfunc (self *DirEntry) String() string{\n\treturn self.absDir\n}\n```\n#### ZipEntry\nZipEntry表示ZIP或者JAR文件形式的类路径\n```go\npackage classpath\n\nimport (\n\t\"path/filepath\"\n\t\"archive/zip\"\n\t\"io/ioutil\"\n\t\"errors\"\n)\n\ntype ZipEntry struct {\n\t//存放目录的绝对路径\n\tabsPath string\n}\n\n//相当于构造函数\nfunc newZipEntry(path string) *ZipEntry {\n\t//将参数转换成绝对路径\n\tabsPath, err := filepath.Abs(path)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn &ZipEntry{absPath}\n}\n\n//读取class文件\nfunc (self *ZipEntry) readClass(classname string) ([]byte, Entry, error) {\n\t//打开zip文件\n\tr, err := zip.OpenReader(self.absPath)\n\tif err != nil {\n\t\treturn nil,nil,err\n\t}\n\tdefer r.Close()\n\n\t//遍历zip包里的文件\n\tfor _, f := range r.File {\n\t\t//找到class文件\n\t\tif f.Name == classname {\n\t\t\t//打开class文件\n\t\t\trc , err := f.Open()\n\t\t\tif err != nil {\n\t\t\t\treturn nil,nil,err\n\t\t\t}\n\t\t\tdefer rc.Close()\n\t\t\t//读取class文件内容\n\t\t\tdata, err := ioutil.ReadAll(rc)\n\t\t\tif err != nil {\n\t\t\t\treturn nil,nil,err\n\t\t\t}\n\t\t\treturn data,self,err\n\t\t}\n\t}\n\t//未找到class文件\n\treturn nil,nil,errors.New(\"class not found :\" +classname)\n}\n\n//直接返回目录\nfunc (self *ZipEntry) String() string {\n\treturn self.absPath\n}\n```\n#### CompositeEntry\nCompositeEntry表示有分隔符的类路径，CompositeEntry由更小的Entry组成，可以表示成[]Entry，go语言中则使用便利的slice\n\n```go\npackage classpath\n\nimport (\n\t\"strings\"\n\t\"errors\"\n)\n\ntype CompositeEntry []Entry\n\n\n//将每个小路径转换成具体的Entry\nfunc newCompositeEntry(pathList string) CompositeEntry {\n\tvar compositeEntry []Entry\n\t//将路径按照分隔符进行分割\n\tfor _, path := range strings.Split(pathList,pathListSeparator){\n\t\tentry := newEntry(path)\n\t\tcompositeEntry = append(compositeEntry,entry)\n\t}\n\treturn compositeEntry\n}\n\nfunc (self CompositeEntry) readClass(classname string) ([]byte, Entry, error) {\n\t//遍历entry数据\n\tfor _, entry := range self{\n\t\t//读取class文件，依次调用每一个子路径的readClass方法\n\t\tdata, from, err := entry.readClass(classname)\n\t\tif err == nil{\n\t\t\treturn data,from,err\n\t\t}\n\t}\n\treturn nil,nil,errors.New(\"class not found :\" +classname)\n}\n//调用每个子路径的String方法，用分隔符拼接起来\nfunc (self CompositeEntry) String() string {\n\tstrs := make([]string,len(self))\n\tfor i, entry := range self{\n\t\tstrs[i] = entry.String()\n\t}\n\treturn strings.Join(strs,pathListSeparator)\n}\n```\n#### WildcardEntry\nWildcardEntry表示以*结尾的类路径，实际上也是CompositeEntry，因此就不再新定义类型类\n```go\npackage classpath\n\nimport (\n\t\"strings\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc newWildcardEntry(path string) CompositeEntry {\n\t//去掉尾部的*\n\tbaseDir := path[:len(path)-1]\n\tvar compositeEntry []Entry\n\twalkFn := func(path string, info os.FileInfo, err error) error{\n\t\tif err != nil{\n\t\t\treturn err\n\t\t}\n\t\t//如果不是目录，返回跳过标识\n\t\tif info.IsDir() && path != baseDir {\n\t\t\treturn filepath.SkipDir\n\t\t}\n\t\t//选出jar文件\n\t\tif strings.HasSuffix(path,\".jar\") || strings.HasSuffix(path,\".JAR\"){\n\t\t\tjarEntry := newZipEntry(path)\n\t\t\tcompositeEntry = append(compositeEntry,jarEntry)\n\t\t}\n\t\treturn nil\n\t}\n\t//遍历baseDir路径，创建zipEntry\n\tfilepath.Walk(baseDir,walkFn)\n\t//fmt.Printf(\"compositeEntry : %s\\n\",compositeEntry)\n\treturn compositeEntry\n}\n```\n#### Entry\n四种类路径都实现完之后，再来完善下Entry接口，添加Entry实例的构造方法。\n````go\nfunc newEntry(path string) Entry {\n\t//如果路径中含有分隔符\n\tif strings.Contains(path,pathListSeparator){\n\t\treturn newCompositeEntry(path)\n\t}\n\t//如果路径末尾是*\n\tif strings.HasSuffix(path,\"*\"){\n\t\treturn newWildcardEntry(path)\n\t}\n\t//如果路径以jar或者zip结尾\n\tif strings.HasSuffix(path,\".jar\") || strings.HasSuffix(path,\".JAR\")||\n\t\tstrings.HasSuffix(path,\".zip\") || strings.HasSuffix(path,\".ZIP\"){\n\t\t\treturn newZipEntry(path)\n\t}\n\treturn newDirEntry(path)\n}\n````\n#### 实现Classpath\n```go\npackage classpath\n\nimport (\n\t\"path/filepath\"\n\t\"os\"\n\t\"fmt\"\n)\n\ntype Classpath struct {\n\tbootClasspath Entry\n\textClasspath Entry\n\tuserClasspath Entry\n}\n//使用-Xjre选项解析启动类路径和扩展类路径，使用-classpath/-cp选项解析用户类路径\nfunc Parse(jreOption,cpOption string) *Classpath  {\n\tcp := &Classpath{}\n\t//解析启动类路径和扩展类路径\n\tcp.parseBootAndExtClasspath(jreOption)\n\n\t//解析用户类路径\n\tcp.parseUserClasspath(cpOption)\n\treturn cp\n}\n\nfunc getJreDir(jreOption string) string {\n\t//优先使用用户输入的-Xjre作为目录\n\tif jreOption != \"\" && exists(jreOption){\n\t\treturn jreOption\n\t}\n\t//在当前目录下寻找jre目录\n\tif exists(\"./jre\") {\n\t\treturn \"./jre\"\n\t}\n\t//尝试使用JAVA_HOME环境变量\n\tif jh := os.Getenv(\"JAVA_HOME\"); jh != \"\"{\n\t\treturn filepath.Join(jh,\"jre\")\n\t}\n\tpanic(\"Can not find jre folder\")\n}\n\n//判断目录是否存在\nfunc exists(path string) bool {\n\tif _, err := os.Stat(path); err != nil{\n\t\tif os.IsNotExist(err){\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (self *Classpath) parseBootAndExtClasspath(jreOption string) {\n\t// 获取jre目录\n\tjreDir := getJreDir(jreOption)\n\t//jre/lib/*\n\tjreLibPath := filepath.Join(jreDir,\"lib\",\"*\")\n\tself.bootClasspath = newWildcardEntry(jreLibPath)\n\t//jre/lib/ext/*\n\tjreExtPath := filepath.Join(jreDir,\"lib\",\"ext\",\"*\")\n\tself.extClasspath = newWildcardEntry(jreExtPath)\n}\n\n//解析用户类路径\nfunc (self *Classpath) parseUserClasspath(cpOption string) {\n\t// 如果用户没有提供-classpath/-cp选项，则使用当前目录作为用户类路径\n\tif cpOption == \"\"{\n\t\tcpOption = \".\"\n\t}\n\tself.userClasspath = newEntry(cpOption)\n}\n\n//寻找class方法\nfunc (self *Classpath) ReadClass(classname string) ([]byte, Entry, error) {\n\t//访问ReadClass方法只需传递类名，不用包含\".class\"后缀\n\tclassname = classname + \".class\"\n\t// 从bootClasspath寻找class文件\n\tif data, entry, err := self.bootClasspath.readClass(classname); err == nil{\n\t\treturn data, entry, err\n\t}\n\t// 从extClasspath寻找class文件\n\tif data, entry, err := self.extClasspath.readClass(classname); err == nil{\n\t\treturn data, entry, err\n\t}\n\t// 从userClasspath寻找class文件\n\treturn self.userClasspath.readClass(classname)\n}\n\nfunc (self *Classpath) String() string {\n\treturn self.userClasspath.String()\n}\n```\n### 测试代码\n\n完善main.go中的startJVM\n```go\n//模拟启动jvm\nfunc startJVM(cmd *Cmd)  {\n\t// 获取Classpath\n\tcp := classpath.Parse(cmd.XjreOption,cmd.cpOption)\n\tfmt.Printf(\"classpath:%s class:%s args:%v\\n\",cp,cmd.class,cmd.args)\n\t// 将.替换成/(java.lang.String -> java/lang/String)\n\tclassName := strings.Replace(cmd.class,\".\",\"/\",-1)\n\t// 读取class\n\tclassData, _, err := cp.ReadClass(className)\n\tif err != nil {\n\t\tfmt.Printf(\"Could not find or load main class %s\\n\",cmd.class)\n\t\treturn\n\t}\n\tfmt.Printf(\"class data : %v\\n\",classData)\n}\n```\n\n编译main.go，并测试-version\n```bash\n$ go install jvmgo/ch02 \n$ ch02 java.lang.String\n# 没有传递-Xjre，会去读取$JAVA_HOME，成功打印出String.class的内容\n$ ch02 -Xjre /opt  java.lang.Object \n# 传递错误-Xjre会打印出Could not find or load main class java.lang.Object\n```\n","source":"_posts/JVM2.md","raw":"---\ntitle: 《自己动手写JAVA虚拟机》学习笔记二【搜索class文件】\ndate: 2019-02-12 16:14:04\ntags:\n    - JVM\n    - JAVA\n    - GO\n    - 学习笔记\ncategories: JVM\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n```java\npublic class HelloWorld {\n    public static void main(String[] args){\n        System.out.println(\"Hello, world!\");\n    }\n}\n```\n运行上面的java程序时，我们知道首先要启动java虚拟机，然后加载主类，最后调用主类的main方法。但是在加载HelloWorld类之前，首先要加载它的超类java.lang.Object，在调用main()函数之前，虚拟机要准备好参数数组，所以需要加载java.lang.String和java.lang.String[]类。把字符串打印到控制台还需要加载java.lang.System类，等等。。那么java虚拟机如何寻找这些类的呢？\n\n## 类路径\n类路径可以分为以下三种：\n * 启动类路径(bootstrap classpath)：启动类路径默认对应jre/lib目录，Java标准库位于该路径。\n * 扩展类路径(extention classpath)：扩展类路径默认对应jre/lib/ext目录，使用Java扩展机制的类位于该路径。\n * 用户类路径(user classpath)：我们自己实现的类，以及第三方类库则位于用户类路径。用户类路径的默认值是当前路径，也就是”.”，可以给java命令传递-classpath选项来指定。\n\n<!-- more -->\n### 准备工作\n\n把ch01的目录结构复制一份改名ch02，在ch02的目录中创建一个classpath子目录。\n```base\n|-jvmgo\n    |-ch01\n    |-ch01\n        |-classpath\n        |-cmd.go\n        |-main.go\n```\n修改cmd结构体，添加XjreOption字段\n```go\ntype Cmd struct {\n\thelpFlag bool\n\tversionFlag bool\n\tcpOption string\n\tXjreOption string\n\tclass string\n\targs []string\n}\n```\nparseCmd()函数也对应添加Xjre\n```go\n//命令解析\nfunc parseCmd() *Cmd {\n    ...//其他代码不变\n\tflag.StringVar(&cmd.cpOption,\"cp\",\"\",\"classpath\")\n\tflag.StringVar(&cmd.XjreOption,\"Xjre\",\"\",\"path to jre\")\n\t//解析命令行参数到定义的flag\n\tflag.Parse()\n\t...//其他代码不变\n}\n```\n### 实现类路径 \n\n采用组合模式来实现类路径，把类路径当成一个大的整体，由启动类路径、扩展类路径和用户类路径三个小路径构成，三个小路径又分别由更小的路径构成。\n\n首先定义一个Entry接口\n```go\n//获取系统分隔符，windows是;类UNIX系统是:号\nconst pathListSeparator = string(os.PathListSeparator)\n\ntype Entry interface {\n\t//寻找和加载class文件  参数：class文件相对路径，路径之间用/，文件名有.class后缀\n\t//例如读取java.lang.Object入参是java/lang/Object.class\n\treadClass(classname string) ([]byte, Entry, error)\n\n\t//toString\n\tString() string\n}\n```\nEntry接口一共有四种实现，CompositeEntry，WildcardEntry，ZipEntry，DirEntry\n#### DirEntry\nDirEntry相对简单些，表示目录形式的类路径\n```go\npackage classpath\n\nimport (\n\t\"path/filepath\"\n\t\"io/ioutil\"\n)\n\ntype DirEntry struct {\n\t//存放目录的绝对路径\n\tabsDir string\n}\n\n//相当于构造函数\nfunc newDirEntry(path string) *DirEntry {\n\t//将参数转换成绝对路径\n\tabsDir, err := filepath.Abs(path)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn &DirEntry{absDir}\n}\n//读取class文件\nfunc (self *DirEntry) readClass (className string) ([]byte, Entry, error) {\n\t//把目录和class名拼成完成路径\n\tfileName := filepath.Join(self.absDir,className)\n\t//读取class文件内容\n\tdata, err := ioutil.ReadFile(fileName)\n\treturn data,self,err\n}\n\n//直接返回目录\nfunc (self *DirEntry) String() string{\n\treturn self.absDir\n}\n```\n#### ZipEntry\nZipEntry表示ZIP或者JAR文件形式的类路径\n```go\npackage classpath\n\nimport (\n\t\"path/filepath\"\n\t\"archive/zip\"\n\t\"io/ioutil\"\n\t\"errors\"\n)\n\ntype ZipEntry struct {\n\t//存放目录的绝对路径\n\tabsPath string\n}\n\n//相当于构造函数\nfunc newZipEntry(path string) *ZipEntry {\n\t//将参数转换成绝对路径\n\tabsPath, err := filepath.Abs(path)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn &ZipEntry{absPath}\n}\n\n//读取class文件\nfunc (self *ZipEntry) readClass(classname string) ([]byte, Entry, error) {\n\t//打开zip文件\n\tr, err := zip.OpenReader(self.absPath)\n\tif err != nil {\n\t\treturn nil,nil,err\n\t}\n\tdefer r.Close()\n\n\t//遍历zip包里的文件\n\tfor _, f := range r.File {\n\t\t//找到class文件\n\t\tif f.Name == classname {\n\t\t\t//打开class文件\n\t\t\trc , err := f.Open()\n\t\t\tif err != nil {\n\t\t\t\treturn nil,nil,err\n\t\t\t}\n\t\t\tdefer rc.Close()\n\t\t\t//读取class文件内容\n\t\t\tdata, err := ioutil.ReadAll(rc)\n\t\t\tif err != nil {\n\t\t\t\treturn nil,nil,err\n\t\t\t}\n\t\t\treturn data,self,err\n\t\t}\n\t}\n\t//未找到class文件\n\treturn nil,nil,errors.New(\"class not found :\" +classname)\n}\n\n//直接返回目录\nfunc (self *ZipEntry) String() string {\n\treturn self.absPath\n}\n```\n#### CompositeEntry\nCompositeEntry表示有分隔符的类路径，CompositeEntry由更小的Entry组成，可以表示成[]Entry，go语言中则使用便利的slice\n\n```go\npackage classpath\n\nimport (\n\t\"strings\"\n\t\"errors\"\n)\n\ntype CompositeEntry []Entry\n\n\n//将每个小路径转换成具体的Entry\nfunc newCompositeEntry(pathList string) CompositeEntry {\n\tvar compositeEntry []Entry\n\t//将路径按照分隔符进行分割\n\tfor _, path := range strings.Split(pathList,pathListSeparator){\n\t\tentry := newEntry(path)\n\t\tcompositeEntry = append(compositeEntry,entry)\n\t}\n\treturn compositeEntry\n}\n\nfunc (self CompositeEntry) readClass(classname string) ([]byte, Entry, error) {\n\t//遍历entry数据\n\tfor _, entry := range self{\n\t\t//读取class文件，依次调用每一个子路径的readClass方法\n\t\tdata, from, err := entry.readClass(classname)\n\t\tif err == nil{\n\t\t\treturn data,from,err\n\t\t}\n\t}\n\treturn nil,nil,errors.New(\"class not found :\" +classname)\n}\n//调用每个子路径的String方法，用分隔符拼接起来\nfunc (self CompositeEntry) String() string {\n\tstrs := make([]string,len(self))\n\tfor i, entry := range self{\n\t\tstrs[i] = entry.String()\n\t}\n\treturn strings.Join(strs,pathListSeparator)\n}\n```\n#### WildcardEntry\nWildcardEntry表示以*结尾的类路径，实际上也是CompositeEntry，因此就不再新定义类型类\n```go\npackage classpath\n\nimport (\n\t\"strings\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc newWildcardEntry(path string) CompositeEntry {\n\t//去掉尾部的*\n\tbaseDir := path[:len(path)-1]\n\tvar compositeEntry []Entry\n\twalkFn := func(path string, info os.FileInfo, err error) error{\n\t\tif err != nil{\n\t\t\treturn err\n\t\t}\n\t\t//如果不是目录，返回跳过标识\n\t\tif info.IsDir() && path != baseDir {\n\t\t\treturn filepath.SkipDir\n\t\t}\n\t\t//选出jar文件\n\t\tif strings.HasSuffix(path,\".jar\") || strings.HasSuffix(path,\".JAR\"){\n\t\t\tjarEntry := newZipEntry(path)\n\t\t\tcompositeEntry = append(compositeEntry,jarEntry)\n\t\t}\n\t\treturn nil\n\t}\n\t//遍历baseDir路径，创建zipEntry\n\tfilepath.Walk(baseDir,walkFn)\n\t//fmt.Printf(\"compositeEntry : %s\\n\",compositeEntry)\n\treturn compositeEntry\n}\n```\n#### Entry\n四种类路径都实现完之后，再来完善下Entry接口，添加Entry实例的构造方法。\n````go\nfunc newEntry(path string) Entry {\n\t//如果路径中含有分隔符\n\tif strings.Contains(path,pathListSeparator){\n\t\treturn newCompositeEntry(path)\n\t}\n\t//如果路径末尾是*\n\tif strings.HasSuffix(path,\"*\"){\n\t\treturn newWildcardEntry(path)\n\t}\n\t//如果路径以jar或者zip结尾\n\tif strings.HasSuffix(path,\".jar\") || strings.HasSuffix(path,\".JAR\")||\n\t\tstrings.HasSuffix(path,\".zip\") || strings.HasSuffix(path,\".ZIP\"){\n\t\t\treturn newZipEntry(path)\n\t}\n\treturn newDirEntry(path)\n}\n````\n#### 实现Classpath\n```go\npackage classpath\n\nimport (\n\t\"path/filepath\"\n\t\"os\"\n\t\"fmt\"\n)\n\ntype Classpath struct {\n\tbootClasspath Entry\n\textClasspath Entry\n\tuserClasspath Entry\n}\n//使用-Xjre选项解析启动类路径和扩展类路径，使用-classpath/-cp选项解析用户类路径\nfunc Parse(jreOption,cpOption string) *Classpath  {\n\tcp := &Classpath{}\n\t//解析启动类路径和扩展类路径\n\tcp.parseBootAndExtClasspath(jreOption)\n\n\t//解析用户类路径\n\tcp.parseUserClasspath(cpOption)\n\treturn cp\n}\n\nfunc getJreDir(jreOption string) string {\n\t//优先使用用户输入的-Xjre作为目录\n\tif jreOption != \"\" && exists(jreOption){\n\t\treturn jreOption\n\t}\n\t//在当前目录下寻找jre目录\n\tif exists(\"./jre\") {\n\t\treturn \"./jre\"\n\t}\n\t//尝试使用JAVA_HOME环境变量\n\tif jh := os.Getenv(\"JAVA_HOME\"); jh != \"\"{\n\t\treturn filepath.Join(jh,\"jre\")\n\t}\n\tpanic(\"Can not find jre folder\")\n}\n\n//判断目录是否存在\nfunc exists(path string) bool {\n\tif _, err := os.Stat(path); err != nil{\n\t\tif os.IsNotExist(err){\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (self *Classpath) parseBootAndExtClasspath(jreOption string) {\n\t// 获取jre目录\n\tjreDir := getJreDir(jreOption)\n\t//jre/lib/*\n\tjreLibPath := filepath.Join(jreDir,\"lib\",\"*\")\n\tself.bootClasspath = newWildcardEntry(jreLibPath)\n\t//jre/lib/ext/*\n\tjreExtPath := filepath.Join(jreDir,\"lib\",\"ext\",\"*\")\n\tself.extClasspath = newWildcardEntry(jreExtPath)\n}\n\n//解析用户类路径\nfunc (self *Classpath) parseUserClasspath(cpOption string) {\n\t// 如果用户没有提供-classpath/-cp选项，则使用当前目录作为用户类路径\n\tif cpOption == \"\"{\n\t\tcpOption = \".\"\n\t}\n\tself.userClasspath = newEntry(cpOption)\n}\n\n//寻找class方法\nfunc (self *Classpath) ReadClass(classname string) ([]byte, Entry, error) {\n\t//访问ReadClass方法只需传递类名，不用包含\".class\"后缀\n\tclassname = classname + \".class\"\n\t// 从bootClasspath寻找class文件\n\tif data, entry, err := self.bootClasspath.readClass(classname); err == nil{\n\t\treturn data, entry, err\n\t}\n\t// 从extClasspath寻找class文件\n\tif data, entry, err := self.extClasspath.readClass(classname); err == nil{\n\t\treturn data, entry, err\n\t}\n\t// 从userClasspath寻找class文件\n\treturn self.userClasspath.readClass(classname)\n}\n\nfunc (self *Classpath) String() string {\n\treturn self.userClasspath.String()\n}\n```\n### 测试代码\n\n完善main.go中的startJVM\n```go\n//模拟启动jvm\nfunc startJVM(cmd *Cmd)  {\n\t// 获取Classpath\n\tcp := classpath.Parse(cmd.XjreOption,cmd.cpOption)\n\tfmt.Printf(\"classpath:%s class:%s args:%v\\n\",cp,cmd.class,cmd.args)\n\t// 将.替换成/(java.lang.String -> java/lang/String)\n\tclassName := strings.Replace(cmd.class,\".\",\"/\",-1)\n\t// 读取class\n\tclassData, _, err := cp.ReadClass(className)\n\tif err != nil {\n\t\tfmt.Printf(\"Could not find or load main class %s\\n\",cmd.class)\n\t\treturn\n\t}\n\tfmt.Printf(\"class data : %v\\n\",classData)\n}\n```\n\n编译main.go，并测试-version\n```bash\n$ go install jvmgo/ch02 \n$ ch02 java.lang.String\n# 没有传递-Xjre，会去读取$JAVA_HOME，成功打印出String.class的内容\n$ ch02 -Xjre /opt  java.lang.Object \n# 传递错误-Xjre会打印出Could not find or load main class java.lang.Object\n```\n","slug":"JVM2","published":1,"updated":"2019-07-31T13:41:40.989Z","layout":"post","photos":[],"link":"","_id":"ck8fb4a9t0014k2o5dvor3mq2","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Hello, world!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行上面的java程序时，我们知道首先要启动java虚拟机，然后加载主类，最后调用主类的main方法。但是在加载HelloWorld类之前，首先要加载它的超类java.lang.Object，在调用main()函数之前，虚拟机要准备好参数数组，所以需要加载java.lang.String和java.lang.String[]类。把字符串打印到控制台还需要加载java.lang.System类，等等。。那么java虚拟机如何寻找这些类的呢？</p>\n<h2 id=\"类路径\"><a href=\"#类路径\" class=\"headerlink\" title=\"类路径\"></a>类路径</h2><p>类路径可以分为以下三种：</p>\n<ul>\n<li>启动类路径(bootstrap classpath)：启动类路径默认对应jre/lib目录，Java标准库位于该路径。</li>\n<li>扩展类路径(extention classpath)：扩展类路径默认对应jre/lib/ext目录，使用Java扩展机制的类位于该路径。</li>\n<li>用户类路径(user classpath)：我们自己实现的类，以及第三方类库则位于用户类路径。用户类路径的默认值是当前路径，也就是”.”，可以给java命令传递-classpath选项来指定。</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>把ch01的目录结构复制一份改名ch02，在ch02的目录中创建一个classpath子目录。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-jvmgo</span><br><span class=\"line\">    |-ch01</span><br><span class=\"line\">    |-ch01</span><br><span class=\"line\">        |-classpath</span><br><span class=\"line\">        |-cmd.go</span><br><span class=\"line\">        |-main.go</span><br></pre></td></tr></table></figure>\n\n<p>修改cmd结构体，添加XjreOption字段</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\thelpFlag <span class=\"keyword\">bool</span></span><br><span class=\"line\">\tversionFlag <span class=\"keyword\">bool</span></span><br><span class=\"line\">\tcpOption <span class=\"keyword\">string</span></span><br><span class=\"line\">\tXjreOption <span class=\"keyword\">string</span></span><br><span class=\"line\">\tclass <span class=\"keyword\">string</span></span><br><span class=\"line\">\targs []<span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>parseCmd()函数也对应添加Xjre</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//命令解析</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">parseCmd</span><span class=\"params\">()</span> *<span class=\"title\">Cmd</span></span> &#123;</span><br><span class=\"line\">    ...<span class=\"comment\">//其他代码不变</span></span><br><span class=\"line\">\tflag.StringVar(&amp;cmd.cpOption,<span class=\"string\">\"cp\"</span>,<span class=\"string\">\"\"</span>,<span class=\"string\">\"classpath\"</span>)</span><br><span class=\"line\">\tflag.StringVar(&amp;cmd.XjreOption,<span class=\"string\">\"Xjre\"</span>,<span class=\"string\">\"\"</span>,<span class=\"string\">\"path to jre\"</span>)</span><br><span class=\"line\">\t<span class=\"comment\">//解析命令行参数到定义的flag</span></span><br><span class=\"line\">\tflag.Parse()</span><br><span class=\"line\">\t...<span class=\"comment\">//其他代码不变</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实现类路径\"><a href=\"#实现类路径\" class=\"headerlink\" title=\"实现类路径\"></a>实现类路径</h3><p>采用组合模式来实现类路径，把类路径当成一个大的整体，由启动类路径、扩展类路径和用户类路径三个小路径构成，三个小路径又分别由更小的路径构成。</p>\n<p>首先定义一个Entry接口</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取系统分隔符，windows是;类UNIX系统是:号</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pathListSeparator = <span class=\"keyword\">string</span>(os.PathListSeparator)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Entry <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//寻找和加载class文件  参数：class文件相对路径，路径之间用/，文件名有.class后缀</span></span><br><span class=\"line\">\t<span class=\"comment\">//例如读取java.lang.Object入参是java/lang/Object.class</span></span><br><span class=\"line\">\treadClass(classname <span class=\"keyword\">string</span>) ([]<span class=\"keyword\">byte</span>, Entry, error)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//toString</span></span><br><span class=\"line\">\tString() <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Entry接口一共有四种实现，CompositeEntry，WildcardEntry，ZipEntry，DirEntry</p>\n<h4 id=\"DirEntry\"><a href=\"#DirEntry\" class=\"headerlink\" title=\"DirEntry\"></a>DirEntry</h4><p>DirEntry相对简单些，表示目录形式的类路径</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> classpath</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"path/filepath\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"io/ioutil\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> DirEntry <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//存放目录的绝对路径</span></span><br><span class=\"line\">\tabsDir <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//相当于构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newDirEntry</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> *<span class=\"title\">DirEntry</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将参数转换成绝对路径</span></span><br><span class=\"line\">\tabsDir, err := filepath.Abs(path)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;DirEntry&#123;absDir&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//读取class文件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *DirEntry)</span> <span class=\"title\">readClass</span> <span class=\"params\">(className <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, Entry, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//把目录和class名拼成完成路径</span></span><br><span class=\"line\">\tfileName := filepath.Join(self.absDir,className)</span><br><span class=\"line\">\t<span class=\"comment\">//读取class文件内容</span></span><br><span class=\"line\">\tdata, err := ioutil.ReadFile(fileName)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> data,self,err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//直接返回目录</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *DirEntry)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.absDir</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ZipEntry\"><a href=\"#ZipEntry\" class=\"headerlink\" title=\"ZipEntry\"></a>ZipEntry</h4><p>ZipEntry表示ZIP或者JAR文件形式的类路径</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> classpath</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"path/filepath\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"archive/zip\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"io/ioutil\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"errors\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ZipEntry <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//存放目录的绝对路径</span></span><br><span class=\"line\">\tabsPath <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//相当于构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newZipEntry</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> *<span class=\"title\">ZipEntry</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将参数转换成绝对路径</span></span><br><span class=\"line\">\tabsPath, err := filepath.Abs(path)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;ZipEntry&#123;absPath&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读取class文件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ZipEntry)</span> <span class=\"title\">readClass</span><span class=\"params\">(classname <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, Entry, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//打开zip文件</span></span><br><span class=\"line\">\tr, err := zip.OpenReader(self.absPath)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>,<span class=\"literal\">nil</span>,err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> r.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//遍历zip包里的文件</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, f := <span class=\"keyword\">range</span> r.File &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//找到class文件</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> f.Name == classname &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//打开class文件</span></span><br><span class=\"line\">\t\t\trc , err := f.Open()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>,<span class=\"literal\">nil</span>,err</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">defer</span> rc.Close()</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//读取class文件内容</span></span><br><span class=\"line\">\t\t\tdata, err := ioutil.ReadAll(rc)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>,<span class=\"literal\">nil</span>,err</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> data,self,err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//未找到class文件</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>,<span class=\"literal\">nil</span>,errors.New(<span class=\"string\">\"class not found :\"</span> +classname)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//直接返回目录</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ZipEntry)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.absPath</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"CompositeEntry\"><a href=\"#CompositeEntry\" class=\"headerlink\" title=\"CompositeEntry\"></a>CompositeEntry</h4><p>CompositeEntry表示有分隔符的类路径，CompositeEntry由更小的Entry组成，可以表示成[]Entry，go语言中则使用便利的slice</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> classpath</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"strings\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"errors\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> CompositeEntry []Entry</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将每个小路径转换成具体的Entry</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newCompositeEntry</span><span class=\"params\">(pathList <span class=\"keyword\">string</span>)</span> <span class=\"title\">CompositeEntry</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> compositeEntry []Entry</span><br><span class=\"line\">\t<span class=\"comment\">//将路径按照分隔符进行分割</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, path := <span class=\"keyword\">range</span> strings.Split(pathList,pathListSeparator)&#123;</span><br><span class=\"line\">\t\tentry := newEntry(path)</span><br><span class=\"line\">\t\tcompositeEntry = <span class=\"built_in\">append</span>(compositeEntry,entry)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> compositeEntry</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self CompositeEntry)</span> <span class=\"title\">readClass</span><span class=\"params\">(classname <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, Entry, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//遍历entry数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, entry := <span class=\"keyword\">range</span> self&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//读取class文件，依次调用每一个子路径的readClass方法</span></span><br><span class=\"line\">\t\tdata, from, err := entry.readClass(classname)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> data,from,err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>,<span class=\"literal\">nil</span>,errors.New(<span class=\"string\">\"class not found :\"</span> +classname)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//调用每个子路径的String方法，用分隔符拼接起来</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self CompositeEntry)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\tstrs := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>,<span class=\"built_in\">len</span>(self))</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, entry := <span class=\"keyword\">range</span> self&#123;</span><br><span class=\"line\">\t\tstrs[i] = entry.String()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> strings.Join(strs,pathListSeparator)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"WildcardEntry\"><a href=\"#WildcardEntry\" class=\"headerlink\" title=\"WildcardEntry\"></a>WildcardEntry</h4><p>WildcardEntry表示以*结尾的类路径，实际上也是CompositeEntry，因此就不再新定义类型类</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> classpath</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"strings\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"os\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"path/filepath\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newWildcardEntry</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"title\">CompositeEntry</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//去掉尾部的*</span></span><br><span class=\"line\">\tbaseDir := path[:<span class=\"built_in\">len</span>(path)<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> compositeEntry []Entry</span><br><span class=\"line\">\twalkFn := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(path <span class=\"keyword\">string</span>, info os.FileInfo, err error)</span> <span class=\"title\">error</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//如果不是目录，返回跳过标识</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> info.IsDir() &amp;&amp; path != baseDir &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> filepath.SkipDir</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//选出jar文件</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> strings.HasSuffix(path,<span class=\"string\">\".jar\"</span>) || strings.HasSuffix(path,<span class=\"string\">\".JAR\"</span>)&#123;</span><br><span class=\"line\">\t\t\tjarEntry := newZipEntry(path)</span><br><span class=\"line\">\t\t\tcompositeEntry = <span class=\"built_in\">append</span>(compositeEntry,jarEntry)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//遍历baseDir路径，创建zipEntry</span></span><br><span class=\"line\">\tfilepath.Walk(baseDir,walkFn)</span><br><span class=\"line\">\t<span class=\"comment\">//fmt.Printf(\"compositeEntry : %s\\n\",compositeEntry)</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> compositeEntry</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Entry\"><a href=\"#Entry\" class=\"headerlink\" title=\"Entry\"></a>Entry</h4><p>四种类路径都实现完之后，再来完善下Entry接口，添加Entry实例的构造方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newEntry</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"title\">Entry</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//如果路径中含有分隔符</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> strings.Contains(path,pathListSeparator)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> newCompositeEntry(path)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//如果路径末尾是*</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> strings.HasSuffix(path,<span class=\"string\">\"*\"</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> newWildcardEntry(path)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//如果路径以jar或者zip结尾</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> strings.HasSuffix(path,<span class=\"string\">\".jar\"</span>) || strings.HasSuffix(path,<span class=\"string\">\".JAR\"</span>)||</span><br><span class=\"line\">\t\tstrings.HasSuffix(path,<span class=\"string\">\".zip\"</span>) || strings.HasSuffix(path,<span class=\"string\">\".ZIP\"</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> newZipEntry(path)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> newDirEntry(path)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"实现Classpath\"><a href=\"#实现Classpath\" class=\"headerlink\" title=\"实现Classpath\"></a>实现Classpath</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> classpath</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"path/filepath\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"os\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Classpath <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tbootClasspath Entry</span><br><span class=\"line\">\textClasspath Entry</span><br><span class=\"line\">\tuserClasspath Entry</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用-Xjre选项解析启动类路径和扩展类路径，使用-classpath/-cp选项解析用户类路径</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Parse</span><span class=\"params\">(jreOption,cpOption <span class=\"keyword\">string</span>)</span> *<span class=\"title\">Classpath</span></span>  &#123;</span><br><span class=\"line\">\tcp := &amp;Classpath&#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//解析启动类路径和扩展类路径</span></span><br><span class=\"line\">\tcp.parseBootAndExtClasspath(jreOption)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//解析用户类路径</span></span><br><span class=\"line\">\tcp.parseUserClasspath(cpOption)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cp</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getJreDir</span><span class=\"params\">(jreOption <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//优先使用用户输入的-Xjre作为目录</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> jreOption != <span class=\"string\">\"\"</span> &amp;&amp; exists(jreOption)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> jreOption</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//在当前目录下寻找jre目录</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> exists(<span class=\"string\">\"./jre\"</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"./jre\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//尝试使用JAVA_HOME环境变量</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> jh := os.Getenv(<span class=\"string\">\"JAVA_HOME\"</span>); jh != <span class=\"string\">\"\"</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> filepath.Join(jh,<span class=\"string\">\"jre\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"Can not find jre folder\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//判断目录是否存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">exists</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, err := os.Stat(path); err != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> os.IsNotExist(err)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Classpath)</span> <span class=\"title\">parseBootAndExtClasspath</span><span class=\"params\">(jreOption <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取jre目录</span></span><br><span class=\"line\">\tjreDir := getJreDir(jreOption)</span><br><span class=\"line\">\t<span class=\"comment\">//jre/lib/*</span></span><br><span class=\"line\">\tjreLibPath := filepath.Join(jreDir,<span class=\"string\">\"lib\"</span>,<span class=\"string\">\"*\"</span>)</span><br><span class=\"line\">\tself.bootClasspath = newWildcardEntry(jreLibPath)</span><br><span class=\"line\">\t<span class=\"comment\">//jre/lib/ext/*</span></span><br><span class=\"line\">\tjreExtPath := filepath.Join(jreDir,<span class=\"string\">\"lib\"</span>,<span class=\"string\">\"ext\"</span>,<span class=\"string\">\"*\"</span>)</span><br><span class=\"line\">\tself.extClasspath = newWildcardEntry(jreExtPath)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//解析用户类路径</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Classpath)</span> <span class=\"title\">parseUserClasspath</span><span class=\"params\">(cpOption <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果用户没有提供-classpath/-cp选项，则使用当前目录作为用户类路径</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> cpOption == <span class=\"string\">\"\"</span>&#123;</span><br><span class=\"line\">\t\tcpOption = <span class=\"string\">\".\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tself.userClasspath = newEntry(cpOption)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//寻找class方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Classpath)</span> <span class=\"title\">ReadClass</span><span class=\"params\">(classname <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, Entry, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//访问ReadClass方法只需传递类名，不用包含\".class\"后缀</span></span><br><span class=\"line\">\tclassname = classname + <span class=\"string\">\".class\"</span></span><br><span class=\"line\">\t<span class=\"comment\">// 从bootClasspath寻找class文件</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> data, entry, err := self.bootClasspath.readClass(classname); err == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> data, entry, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 从extClasspath寻找class文件</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> data, entry, err := self.extClasspath.readClass(classname); err == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> data, entry, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 从userClasspath寻找class文件</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.userClasspath.readClass(classname)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Classpath)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.userClasspath.String()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h3><p>完善main.go中的startJVM</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模拟启动jvm</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">startJVM</span><span class=\"params\">(cmd *Cmd)</span></span>  &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取Classpath</span></span><br><span class=\"line\">\tcp := classpath.Parse(cmd.XjreOption,cmd.cpOption)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"classpath:%s class:%s args:%v\\n\"</span>,cp,cmd.class,cmd.args)</span><br><span class=\"line\">\t<span class=\"comment\">// 将.替换成/(java.lang.String -&gt; java/lang/String)</span></span><br><span class=\"line\">\tclassName := strings.Replace(cmd.class,<span class=\"string\">\".\"</span>,<span class=\"string\">\"/\"</span>,<span class=\"number\">-1</span>)</span><br><span class=\"line\">\t<span class=\"comment\">// 读取class</span></span><br><span class=\"line\">\tclassData, _, err := cp.ReadClass(className)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"Could not find or load main class %s\\n\"</span>,cmd.class)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"class data : %v\\n\"</span>,classData)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译main.go，并测试-version</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ go install jvmgo/ch02 </span><br><span class=\"line\">$ ch02 java.lang.String</span><br><span class=\"line\"><span class=\"comment\"># 没有传递-Xjre，会去读取$JAVA_HOME，成功打印出String.class的内容</span></span><br><span class=\"line\">$ ch02 -Xjre /opt  java.lang.Object </span><br><span class=\"line\"><span class=\"comment\"># 传递错误-Xjre会打印出Could not find or load main class java.lang.Object</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Hello, world!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行上面的java程序时，我们知道首先要启动java虚拟机，然后加载主类，最后调用主类的main方法。但是在加载HelloWorld类之前，首先要加载它的超类java.lang.Object，在调用main()函数之前，虚拟机要准备好参数数组，所以需要加载java.lang.String和java.lang.String[]类。把字符串打印到控制台还需要加载java.lang.System类，等等。。那么java虚拟机如何寻找这些类的呢？</p>\n<h2 id=\"类路径\"><a href=\"#类路径\" class=\"headerlink\" title=\"类路径\"></a>类路径</h2><p>类路径可以分为以下三种：</p>\n<ul>\n<li>启动类路径(bootstrap classpath)：启动类路径默认对应jre/lib目录，Java标准库位于该路径。</li>\n<li>扩展类路径(extention classpath)：扩展类路径默认对应jre/lib/ext目录，使用Java扩展机制的类位于该路径。</li>\n<li>用户类路径(user classpath)：我们自己实现的类，以及第三方类库则位于用户类路径。用户类路径的默认值是当前路径，也就是”.”，可以给java命令传递-classpath选项来指定。</li>\n</ul>","more":"<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>把ch01的目录结构复制一份改名ch02，在ch02的目录中创建一个classpath子目录。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-jvmgo</span><br><span class=\"line\">    |-ch01</span><br><span class=\"line\">    |-ch01</span><br><span class=\"line\">        |-classpath</span><br><span class=\"line\">        |-cmd.go</span><br><span class=\"line\">        |-main.go</span><br></pre></td></tr></table></figure>\n\n<p>修改cmd结构体，添加XjreOption字段</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\thelpFlag <span class=\"keyword\">bool</span></span><br><span class=\"line\">\tversionFlag <span class=\"keyword\">bool</span></span><br><span class=\"line\">\tcpOption <span class=\"keyword\">string</span></span><br><span class=\"line\">\tXjreOption <span class=\"keyword\">string</span></span><br><span class=\"line\">\tclass <span class=\"keyword\">string</span></span><br><span class=\"line\">\targs []<span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>parseCmd()函数也对应添加Xjre</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//命令解析</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">parseCmd</span><span class=\"params\">()</span> *<span class=\"title\">Cmd</span></span> &#123;</span><br><span class=\"line\">    ...<span class=\"comment\">//其他代码不变</span></span><br><span class=\"line\">\tflag.StringVar(&amp;cmd.cpOption,<span class=\"string\">\"cp\"</span>,<span class=\"string\">\"\"</span>,<span class=\"string\">\"classpath\"</span>)</span><br><span class=\"line\">\tflag.StringVar(&amp;cmd.XjreOption,<span class=\"string\">\"Xjre\"</span>,<span class=\"string\">\"\"</span>,<span class=\"string\">\"path to jre\"</span>)</span><br><span class=\"line\">\t<span class=\"comment\">//解析命令行参数到定义的flag</span></span><br><span class=\"line\">\tflag.Parse()</span><br><span class=\"line\">\t...<span class=\"comment\">//其他代码不变</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实现类路径\"><a href=\"#实现类路径\" class=\"headerlink\" title=\"实现类路径\"></a>实现类路径</h3><p>采用组合模式来实现类路径，把类路径当成一个大的整体，由启动类路径、扩展类路径和用户类路径三个小路径构成，三个小路径又分别由更小的路径构成。</p>\n<p>首先定义一个Entry接口</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取系统分隔符，windows是;类UNIX系统是:号</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pathListSeparator = <span class=\"keyword\">string</span>(os.PathListSeparator)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Entry <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//寻找和加载class文件  参数：class文件相对路径，路径之间用/，文件名有.class后缀</span></span><br><span class=\"line\">\t<span class=\"comment\">//例如读取java.lang.Object入参是java/lang/Object.class</span></span><br><span class=\"line\">\treadClass(classname <span class=\"keyword\">string</span>) ([]<span class=\"keyword\">byte</span>, Entry, error)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//toString</span></span><br><span class=\"line\">\tString() <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Entry接口一共有四种实现，CompositeEntry，WildcardEntry，ZipEntry，DirEntry</p>\n<h4 id=\"DirEntry\"><a href=\"#DirEntry\" class=\"headerlink\" title=\"DirEntry\"></a>DirEntry</h4><p>DirEntry相对简单些，表示目录形式的类路径</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> classpath</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"path/filepath\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"io/ioutil\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> DirEntry <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//存放目录的绝对路径</span></span><br><span class=\"line\">\tabsDir <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//相当于构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newDirEntry</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> *<span class=\"title\">DirEntry</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将参数转换成绝对路径</span></span><br><span class=\"line\">\tabsDir, err := filepath.Abs(path)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;DirEntry&#123;absDir&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//读取class文件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *DirEntry)</span> <span class=\"title\">readClass</span> <span class=\"params\">(className <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, Entry, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//把目录和class名拼成完成路径</span></span><br><span class=\"line\">\tfileName := filepath.Join(self.absDir,className)</span><br><span class=\"line\">\t<span class=\"comment\">//读取class文件内容</span></span><br><span class=\"line\">\tdata, err := ioutil.ReadFile(fileName)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> data,self,err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//直接返回目录</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *DirEntry)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.absDir</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ZipEntry\"><a href=\"#ZipEntry\" class=\"headerlink\" title=\"ZipEntry\"></a>ZipEntry</h4><p>ZipEntry表示ZIP或者JAR文件形式的类路径</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> classpath</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"path/filepath\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"archive/zip\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"io/ioutil\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"errors\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ZipEntry <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//存放目录的绝对路径</span></span><br><span class=\"line\">\tabsPath <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//相当于构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newZipEntry</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> *<span class=\"title\">ZipEntry</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将参数转换成绝对路径</span></span><br><span class=\"line\">\tabsPath, err := filepath.Abs(path)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;ZipEntry&#123;absPath&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读取class文件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ZipEntry)</span> <span class=\"title\">readClass</span><span class=\"params\">(classname <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, Entry, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//打开zip文件</span></span><br><span class=\"line\">\tr, err := zip.OpenReader(self.absPath)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>,<span class=\"literal\">nil</span>,err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> r.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//遍历zip包里的文件</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, f := <span class=\"keyword\">range</span> r.File &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//找到class文件</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> f.Name == classname &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//打开class文件</span></span><br><span class=\"line\">\t\t\trc , err := f.Open()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>,<span class=\"literal\">nil</span>,err</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">defer</span> rc.Close()</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//读取class文件内容</span></span><br><span class=\"line\">\t\t\tdata, err := ioutil.ReadAll(rc)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>,<span class=\"literal\">nil</span>,err</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> data,self,err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//未找到class文件</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>,<span class=\"literal\">nil</span>,errors.New(<span class=\"string\">\"class not found :\"</span> +classname)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//直接返回目录</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ZipEntry)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.absPath</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"CompositeEntry\"><a href=\"#CompositeEntry\" class=\"headerlink\" title=\"CompositeEntry\"></a>CompositeEntry</h4><p>CompositeEntry表示有分隔符的类路径，CompositeEntry由更小的Entry组成，可以表示成[]Entry，go语言中则使用便利的slice</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> classpath</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"strings\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"errors\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> CompositeEntry []Entry</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将每个小路径转换成具体的Entry</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newCompositeEntry</span><span class=\"params\">(pathList <span class=\"keyword\">string</span>)</span> <span class=\"title\">CompositeEntry</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> compositeEntry []Entry</span><br><span class=\"line\">\t<span class=\"comment\">//将路径按照分隔符进行分割</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, path := <span class=\"keyword\">range</span> strings.Split(pathList,pathListSeparator)&#123;</span><br><span class=\"line\">\t\tentry := newEntry(path)</span><br><span class=\"line\">\t\tcompositeEntry = <span class=\"built_in\">append</span>(compositeEntry,entry)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> compositeEntry</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self CompositeEntry)</span> <span class=\"title\">readClass</span><span class=\"params\">(classname <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, Entry, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//遍历entry数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, entry := <span class=\"keyword\">range</span> self&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//读取class文件，依次调用每一个子路径的readClass方法</span></span><br><span class=\"line\">\t\tdata, from, err := entry.readClass(classname)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> data,from,err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>,<span class=\"literal\">nil</span>,errors.New(<span class=\"string\">\"class not found :\"</span> +classname)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//调用每个子路径的String方法，用分隔符拼接起来</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self CompositeEntry)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\tstrs := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>,<span class=\"built_in\">len</span>(self))</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, entry := <span class=\"keyword\">range</span> self&#123;</span><br><span class=\"line\">\t\tstrs[i] = entry.String()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> strings.Join(strs,pathListSeparator)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"WildcardEntry\"><a href=\"#WildcardEntry\" class=\"headerlink\" title=\"WildcardEntry\"></a>WildcardEntry</h4><p>WildcardEntry表示以*结尾的类路径，实际上也是CompositeEntry，因此就不再新定义类型类</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> classpath</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"strings\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"os\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"path/filepath\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newWildcardEntry</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"title\">CompositeEntry</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//去掉尾部的*</span></span><br><span class=\"line\">\tbaseDir := path[:<span class=\"built_in\">len</span>(path)<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> compositeEntry []Entry</span><br><span class=\"line\">\twalkFn := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(path <span class=\"keyword\">string</span>, info os.FileInfo, err error)</span> <span class=\"title\">error</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//如果不是目录，返回跳过标识</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> info.IsDir() &amp;&amp; path != baseDir &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> filepath.SkipDir</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//选出jar文件</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> strings.HasSuffix(path,<span class=\"string\">\".jar\"</span>) || strings.HasSuffix(path,<span class=\"string\">\".JAR\"</span>)&#123;</span><br><span class=\"line\">\t\t\tjarEntry := newZipEntry(path)</span><br><span class=\"line\">\t\t\tcompositeEntry = <span class=\"built_in\">append</span>(compositeEntry,jarEntry)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//遍历baseDir路径，创建zipEntry</span></span><br><span class=\"line\">\tfilepath.Walk(baseDir,walkFn)</span><br><span class=\"line\">\t<span class=\"comment\">//fmt.Printf(\"compositeEntry : %s\\n\",compositeEntry)</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> compositeEntry</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Entry\"><a href=\"#Entry\" class=\"headerlink\" title=\"Entry\"></a>Entry</h4><p>四种类路径都实现完之后，再来完善下Entry接口，添加Entry实例的构造方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newEntry</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"title\">Entry</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//如果路径中含有分隔符</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> strings.Contains(path,pathListSeparator)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> newCompositeEntry(path)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//如果路径末尾是*</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> strings.HasSuffix(path,<span class=\"string\">\"*\"</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> newWildcardEntry(path)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//如果路径以jar或者zip结尾</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> strings.HasSuffix(path,<span class=\"string\">\".jar\"</span>) || strings.HasSuffix(path,<span class=\"string\">\".JAR\"</span>)||</span><br><span class=\"line\">\t\tstrings.HasSuffix(path,<span class=\"string\">\".zip\"</span>) || strings.HasSuffix(path,<span class=\"string\">\".ZIP\"</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> newZipEntry(path)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> newDirEntry(path)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"实现Classpath\"><a href=\"#实现Classpath\" class=\"headerlink\" title=\"实现Classpath\"></a>实现Classpath</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> classpath</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"path/filepath\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"os\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Classpath <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tbootClasspath Entry</span><br><span class=\"line\">\textClasspath Entry</span><br><span class=\"line\">\tuserClasspath Entry</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用-Xjre选项解析启动类路径和扩展类路径，使用-classpath/-cp选项解析用户类路径</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Parse</span><span class=\"params\">(jreOption,cpOption <span class=\"keyword\">string</span>)</span> *<span class=\"title\">Classpath</span></span>  &#123;</span><br><span class=\"line\">\tcp := &amp;Classpath&#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//解析启动类路径和扩展类路径</span></span><br><span class=\"line\">\tcp.parseBootAndExtClasspath(jreOption)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//解析用户类路径</span></span><br><span class=\"line\">\tcp.parseUserClasspath(cpOption)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cp</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getJreDir</span><span class=\"params\">(jreOption <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//优先使用用户输入的-Xjre作为目录</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> jreOption != <span class=\"string\">\"\"</span> &amp;&amp; exists(jreOption)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> jreOption</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//在当前目录下寻找jre目录</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> exists(<span class=\"string\">\"./jre\"</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"./jre\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//尝试使用JAVA_HOME环境变量</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> jh := os.Getenv(<span class=\"string\">\"JAVA_HOME\"</span>); jh != <span class=\"string\">\"\"</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> filepath.Join(jh,<span class=\"string\">\"jre\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"Can not find jre folder\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//判断目录是否存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">exists</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, err := os.Stat(path); err != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> os.IsNotExist(err)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Classpath)</span> <span class=\"title\">parseBootAndExtClasspath</span><span class=\"params\">(jreOption <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取jre目录</span></span><br><span class=\"line\">\tjreDir := getJreDir(jreOption)</span><br><span class=\"line\">\t<span class=\"comment\">//jre/lib/*</span></span><br><span class=\"line\">\tjreLibPath := filepath.Join(jreDir,<span class=\"string\">\"lib\"</span>,<span class=\"string\">\"*\"</span>)</span><br><span class=\"line\">\tself.bootClasspath = newWildcardEntry(jreLibPath)</span><br><span class=\"line\">\t<span class=\"comment\">//jre/lib/ext/*</span></span><br><span class=\"line\">\tjreExtPath := filepath.Join(jreDir,<span class=\"string\">\"lib\"</span>,<span class=\"string\">\"ext\"</span>,<span class=\"string\">\"*\"</span>)</span><br><span class=\"line\">\tself.extClasspath = newWildcardEntry(jreExtPath)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//解析用户类路径</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Classpath)</span> <span class=\"title\">parseUserClasspath</span><span class=\"params\">(cpOption <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果用户没有提供-classpath/-cp选项，则使用当前目录作为用户类路径</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> cpOption == <span class=\"string\">\"\"</span>&#123;</span><br><span class=\"line\">\t\tcpOption = <span class=\"string\">\".\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tself.userClasspath = newEntry(cpOption)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//寻找class方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Classpath)</span> <span class=\"title\">ReadClass</span><span class=\"params\">(classname <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, Entry, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//访问ReadClass方法只需传递类名，不用包含\".class\"后缀</span></span><br><span class=\"line\">\tclassname = classname + <span class=\"string\">\".class\"</span></span><br><span class=\"line\">\t<span class=\"comment\">// 从bootClasspath寻找class文件</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> data, entry, err := self.bootClasspath.readClass(classname); err == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> data, entry, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 从extClasspath寻找class文件</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> data, entry, err := self.extClasspath.readClass(classname); err == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> data, entry, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 从userClasspath寻找class文件</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.userClasspath.readClass(classname)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Classpath)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.userClasspath.String()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h3><p>完善main.go中的startJVM</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模拟启动jvm</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">startJVM</span><span class=\"params\">(cmd *Cmd)</span></span>  &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取Classpath</span></span><br><span class=\"line\">\tcp := classpath.Parse(cmd.XjreOption,cmd.cpOption)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"classpath:%s class:%s args:%v\\n\"</span>,cp,cmd.class,cmd.args)</span><br><span class=\"line\">\t<span class=\"comment\">// 将.替换成/(java.lang.String -&gt; java/lang/String)</span></span><br><span class=\"line\">\tclassName := strings.Replace(cmd.class,<span class=\"string\">\".\"</span>,<span class=\"string\">\"/\"</span>,<span class=\"number\">-1</span>)</span><br><span class=\"line\">\t<span class=\"comment\">// 读取class</span></span><br><span class=\"line\">\tclassData, _, err := cp.ReadClass(className)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"Could not find or load main class %s\\n\"</span>,cmd.class)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"class data : %v\\n\"</span>,classData)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译main.go，并测试-version</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ go install jvmgo/ch02 </span><br><span class=\"line\">$ ch02 java.lang.String</span><br><span class=\"line\"><span class=\"comment\"># 没有传递-Xjre，会去读取$JAVA_HOME，成功打印出String.class的内容</span></span><br><span class=\"line\">$ ch02 -Xjre /opt  java.lang.Object </span><br><span class=\"line\"><span class=\"comment\"># 传递错误-Xjre会打印出Could not find or load main class java.lang.Object</span></span><br></pre></td></tr></table></figure>"},{"title":"设置git忽略.idea文件","date":"2019-07-11T03:39:04.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"1.将.idea目录加入ignore：\n```bash\n$ echo '.idea' >> .gitignore\n```\n<!-- more -->\n\n2.从git中删除idea：\n```bash\n$ git rm -r --cached .idea\n```\n\n3.将.gitignore文件加入git：\n```bash\n$ git add .gitignore\n```\n\n4.提交.gitignore文件，将.idea从代码仓库中忽略：\n```bash\n$ git commit -m '忽略.idea文件夹'\n```\n\n5、Push到Git服务器：\n\n```bash\n$ git push\n```","source":"_posts/GIt-Ignore.md","raw":"---\ntitle: 设置git忽略.idea文件\ndate: 2019-07-11 11:39:04\ntags:\n    - git\n    - 教程\ncategories: 项目搭建\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n1.将.idea目录加入ignore：\n```bash\n$ echo '.idea' >> .gitignore\n```\n<!-- more -->\n\n2.从git中删除idea：\n```bash\n$ git rm -r --cached .idea\n```\n\n3.将.gitignore文件加入git：\n```bash\n$ git add .gitignore\n```\n\n4.提交.gitignore文件，将.idea从代码仓库中忽略：\n```bash\n$ git commit -m '忽略.idea文件夹'\n```\n\n5、Push到Git服务器：\n\n```bash\n$ git push\n```","slug":"GIt-Ignore","published":1,"updated":"2019-07-31T13:41:40.988Z","layout":"post","photos":[],"link":"","_id":"ck8fb4a9z0017k2o53yy94api","content":"<p>1.将.idea目录加入ignore：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">'.idea'</span> &gt;&gt; .gitignore</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<p>2.从git中删除idea：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rm -r --cached .idea</span><br></pre></td></tr></table></figure>\n\n<p>3.将.gitignore文件加入git：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .gitignore</span><br></pre></td></tr></table></figure>\n\n<p>4.提交.gitignore文件，将.idea从代码仓库中忽略：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m <span class=\"string\">'忽略.idea文件夹'</span></span><br></pre></td></tr></table></figure>\n\n<p>5、Push到Git服务器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>1.将.idea目录加入ignore：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">'.idea'</span> &gt;&gt; .gitignore</span><br></pre></td></tr></table></figure>","more":"<p>2.从git中删除idea：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rm -r --cached .idea</span><br></pre></td></tr></table></figure>\n\n<p>3.将.gitignore文件加入git：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .gitignore</span><br></pre></td></tr></table></figure>\n\n<p>4.提交.gitignore文件，将.idea从代码仓库中忽略：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m <span class=\"string\">'忽略.idea文件夹'</span></span><br></pre></td></tr></table></figure>\n\n<p>5、Push到Git服务器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push</span><br></pre></td></tr></table></figure>"},{"title":"《自己动手写JAVA虚拟机》学习笔记三【解析class文件】","date":"2019-02-14T03:38:04.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"java虚拟机规范中使用一种类似C语言结构体来描述Class文件的基本结构，具体如下：\n```java\nClassFile {\n     u4             magic;//魔数\n     u2             minor_version;//主版本号\n     u2             major_version;//次版本号\n     u2             constant_pool_count;//常量池长度\n     cp_info        constant_pool[constant_pool_count-1];//常量池信息\n     u2             access_flags;//该类的访问修饰符\n     u2             this_class;//类索引\n     u2             super_class;//父类索引\n     u2             interfaces_count;//接口个数\n     u2             interfaces[interfaces_count];//接口详细信息\n     u2             fields_count;//属性个数\n     field_info     fields[fields_count];//属性详细信息\n     u2             methods_count;//方法个数\n     method_info    methods[methods_count];//方法详情\n     u2             attributes_count;//类文件属性个数\n     attribute_info attributes[attributes_count];//类文件属性详细信息\n}\n```\n<!-- more -->\n### 准备工作\n\n把ch02的目录结构复制一份改名ch03，在ch03的目录中创建一个classfile子目录。\n```base\n|-jvmgo\n    |-ch01\n    |-ch01\n    |-ch03\n        |-classfile\n        |-classpath\n        |-cmd.go\n        |-main.go\n```\n为了学习编译后的class文件，新建一个classFileTest.java然后编译\n```java\npublic class ClassFileTest {\n    public static final boolean FLAG = true;\n    public static final byte BYTE = 123;\n    public static final char X = 'X';\n    public static final short SHORT = 12345;\n    public static final int INT = 123456789;\n    public static final long LONG = 12345678901L;\n    public static final float PI = 3.14f;\n    public static final double E = 2.71828;\n    public static void main(String[] args) throws RuntimeException {\n        System.out.println(\"Hello, World!\");\n    }\n}\n```\n用作者提供的[classpy](https://github.com/zxh0/classpy)的图形化工具，可以查看反编译后的class文件。","source":"_posts/JVM3.md","raw":"---\ntitle: 《自己动手写JAVA虚拟机》学习笔记三【解析class文件】\ndate: 2019-02-14 11:38:04\ntags:\n    - JVM\n    - JAVA\n    - GO\n    - 学习笔记\ncategories: JVM\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\njava虚拟机规范中使用一种类似C语言结构体来描述Class文件的基本结构，具体如下：\n```java\nClassFile {\n     u4             magic;//魔数\n     u2             minor_version;//主版本号\n     u2             major_version;//次版本号\n     u2             constant_pool_count;//常量池长度\n     cp_info        constant_pool[constant_pool_count-1];//常量池信息\n     u2             access_flags;//该类的访问修饰符\n     u2             this_class;//类索引\n     u2             super_class;//父类索引\n     u2             interfaces_count;//接口个数\n     u2             interfaces[interfaces_count];//接口详细信息\n     u2             fields_count;//属性个数\n     field_info     fields[fields_count];//属性详细信息\n     u2             methods_count;//方法个数\n     method_info    methods[methods_count];//方法详情\n     u2             attributes_count;//类文件属性个数\n     attribute_info attributes[attributes_count];//类文件属性详细信息\n}\n```\n<!-- more -->\n### 准备工作\n\n把ch02的目录结构复制一份改名ch03，在ch03的目录中创建一个classfile子目录。\n```base\n|-jvmgo\n    |-ch01\n    |-ch01\n    |-ch03\n        |-classfile\n        |-classpath\n        |-cmd.go\n        |-main.go\n```\n为了学习编译后的class文件，新建一个classFileTest.java然后编译\n```java\npublic class ClassFileTest {\n    public static final boolean FLAG = true;\n    public static final byte BYTE = 123;\n    public static final char X = 'X';\n    public static final short SHORT = 12345;\n    public static final int INT = 123456789;\n    public static final long LONG = 12345678901L;\n    public static final float PI = 3.14f;\n    public static final double E = 2.71828;\n    public static void main(String[] args) throws RuntimeException {\n        System.out.println(\"Hello, World!\");\n    }\n}\n```\n用作者提供的[classpy](https://github.com/zxh0/classpy)的图形化工具，可以查看反编译后的class文件。","slug":"JVM3","published":1,"updated":"2019-07-31T13:41:40.990Z","layout":"post","photos":[],"link":"","_id":"ck8fb4aa50018k2o5y60yv72v","content":"<p>java虚拟机规范中使用一种类似C语言结构体来描述Class文件的基本结构，具体如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassFile &#123;</span><br><span class=\"line\">     u4             magic;<span class=\"comment\">//魔数</span></span><br><span class=\"line\">     u2             minor_version;<span class=\"comment\">//主版本号</span></span><br><span class=\"line\">     u2             major_version;<span class=\"comment\">//次版本号</span></span><br><span class=\"line\">     u2             constant_pool_count;<span class=\"comment\">//常量池长度</span></span><br><span class=\"line\">     cp_info        constant_pool[constant_pool_count-<span class=\"number\">1</span>];<span class=\"comment\">//常量池信息</span></span><br><span class=\"line\">     u2             access_flags;<span class=\"comment\">//该类的访问修饰符</span></span><br><span class=\"line\">     u2             this_class;<span class=\"comment\">//类索引</span></span><br><span class=\"line\">     u2             super_class;<span class=\"comment\">//父类索引</span></span><br><span class=\"line\">     u2             interfaces_count;<span class=\"comment\">//接口个数</span></span><br><span class=\"line\">     u2             interfaces[interfaces_count];<span class=\"comment\">//接口详细信息</span></span><br><span class=\"line\">     u2             fields_count;<span class=\"comment\">//属性个数</span></span><br><span class=\"line\">     field_info     fields[fields_count];<span class=\"comment\">//属性详细信息</span></span><br><span class=\"line\">     u2             methods_count;<span class=\"comment\">//方法个数</span></span><br><span class=\"line\">     method_info    methods[methods_count];<span class=\"comment\">//方法详情</span></span><br><span class=\"line\">     u2             attributes_count;<span class=\"comment\">//类文件属性个数</span></span><br><span class=\"line\">     attribute_info attributes[attributes_count];<span class=\"comment\">//类文件属性详细信息</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>把ch02的目录结构复制一份改名ch03，在ch03的目录中创建一个classfile子目录。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-jvmgo</span><br><span class=\"line\">    |-ch01</span><br><span class=\"line\">    |-ch01</span><br><span class=\"line\">    |-ch03</span><br><span class=\"line\">        |-classfile</span><br><span class=\"line\">        |-classpath</span><br><span class=\"line\">        |-cmd.go</span><br><span class=\"line\">        |-main.go</span><br></pre></td></tr></table></figure>\n\n<p>为了学习编译后的class文件，新建一个classFileTest.java然后编译</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassFileTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> FLAG = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> BYTE = <span class=\"number\">123</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span> X = <span class=\"string\">'X'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">short</span> SHORT = <span class=\"number\">12345</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INT = <span class=\"number\">123456789</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> LONG = <span class=\"number\">12345678901L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> PI = <span class=\"number\">3.14f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">double</span> E = <span class=\"number\">2.71828</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> RuntimeException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Hello, World!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用作者提供的<a href=\"https://github.com/zxh0/classpy\" target=\"_blank\" rel=\"noopener\">classpy</a>的图形化工具，可以查看反编译后的class文件。</p>\n","site":{"data":{}},"excerpt":"<p>java虚拟机规范中使用一种类似C语言结构体来描述Class文件的基本结构，具体如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassFile &#123;</span><br><span class=\"line\">     u4             magic;<span class=\"comment\">//魔数</span></span><br><span class=\"line\">     u2             minor_version;<span class=\"comment\">//主版本号</span></span><br><span class=\"line\">     u2             major_version;<span class=\"comment\">//次版本号</span></span><br><span class=\"line\">     u2             constant_pool_count;<span class=\"comment\">//常量池长度</span></span><br><span class=\"line\">     cp_info        constant_pool[constant_pool_count-<span class=\"number\">1</span>];<span class=\"comment\">//常量池信息</span></span><br><span class=\"line\">     u2             access_flags;<span class=\"comment\">//该类的访问修饰符</span></span><br><span class=\"line\">     u2             this_class;<span class=\"comment\">//类索引</span></span><br><span class=\"line\">     u2             super_class;<span class=\"comment\">//父类索引</span></span><br><span class=\"line\">     u2             interfaces_count;<span class=\"comment\">//接口个数</span></span><br><span class=\"line\">     u2             interfaces[interfaces_count];<span class=\"comment\">//接口详细信息</span></span><br><span class=\"line\">     u2             fields_count;<span class=\"comment\">//属性个数</span></span><br><span class=\"line\">     field_info     fields[fields_count];<span class=\"comment\">//属性详细信息</span></span><br><span class=\"line\">     u2             methods_count;<span class=\"comment\">//方法个数</span></span><br><span class=\"line\">     method_info    methods[methods_count];<span class=\"comment\">//方法详情</span></span><br><span class=\"line\">     u2             attributes_count;<span class=\"comment\">//类文件属性个数</span></span><br><span class=\"line\">     attribute_info attributes[attributes_count];<span class=\"comment\">//类文件属性详细信息</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>把ch02的目录结构复制一份改名ch03，在ch03的目录中创建一个classfile子目录。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-jvmgo</span><br><span class=\"line\">    |-ch01</span><br><span class=\"line\">    |-ch01</span><br><span class=\"line\">    |-ch03</span><br><span class=\"line\">        |-classfile</span><br><span class=\"line\">        |-classpath</span><br><span class=\"line\">        |-cmd.go</span><br><span class=\"line\">        |-main.go</span><br></pre></td></tr></table></figure>\n\n<p>为了学习编译后的class文件，新建一个classFileTest.java然后编译</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassFileTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> FLAG = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> BYTE = <span class=\"number\">123</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span> X = <span class=\"string\">'X'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">short</span> SHORT = <span class=\"number\">12345</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INT = <span class=\"number\">123456789</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> LONG = <span class=\"number\">12345678901L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> PI = <span class=\"number\">3.14f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">double</span> E = <span class=\"number\">2.71828</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> RuntimeException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Hello, World!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用作者提供的<a href=\"https://github.com/zxh0/classpy\" target=\"_blank\" rel=\"noopener\">classpy</a>的图形化工具，可以查看反编译后的class文件。</p>"},{"title":"JAVA-CAS","date":"2019-10-23T06:41:04.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"# CAS\n\n在看线程池源码的时候发现有很多CAS操作，那么什么是CAS？\n<!-- more -->\n## 定义\nCAS是英文单词 Compare And Swap 的缩写，翻译过来就是比较并替换，它是一种原子操作，同时 CAS 是一种乐观机制。\njava.util.concurrent 包很多功能都是建立在 CAS 之上，如 ReenterLock 内部的 AQS，各种原子类，其底层都用 CAS来实现原子操作。\n\n## 如何解决并发安全问题\n在我们认识 CAS 之前，我们是通过什么来解决并发带来的安全问题呢？\nvolatile 关键字可以保证变量的可见性，但保证不了原子性；\nsynchronized 关键字利用 JVM 字节码层面来实现同步机制，它是一个悲观锁机制。\n\n```java\npublic class Test {\n  public volatile int i;\n  public void add() {\n    i++;\n  }\n}\n```\n使用 `javap -c Test.class` 命令查看看add方法的字节码指令\n```java\npublic void add();\n    Code:\n       0: aload_0\n       1: dup\n       2: getfield      #2                  // Field n:I\n       5: iconst_1\n       6: iadd\n       7: putfield      #2                  // Field n:I\n      10: return\n\n```\ni++被拆分成了几个指令：\n    1. 执行getfield拿到原始i；\n    2. 执行iadd进行加1操作；\n    3. 执行putfield写把累加后的值写回i；\n\n当线程 1 执行到加 1 步骤时，由于还没有执行赋值改变变量的值，这时候并不会刷新主内存区中的变量，\n如果此时线程 2 正好要拷贝该变量的值到自己私有缓存中，问题就出现了，当线程 2 拷贝完以后，线程1正好执行赋值运算，立马更新主内存区的值，那么此时线程 2 的副本就是旧的了，脏读又出现了。\n\n怎么解决这个问题呢？\n在 add 方法加上 synchronized 修饰解决。\n\n```java\npublic class Test {\n  public volatile int i;\n  public synchronized void add() {\n    i++;\n  }\n}\n```\n这个方案当然可行，但是大大降低了性能。\n\n## CAS原理\nCAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。\n更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存值修改为 B 并返回 true，否则什么都不做，并返回 false。\n\n### 源码分析\n\n下面以`AtomicInteger`的实现为例，分析一下CAS是如何实现的。\n\n```java\npublic class AtomicInteger extends Number implements java.io.Serializable {\n    private static final long serialVersionUID = 6214790243416807050L;\n\n    // setup to use Unsafe.compareAndSwapInt for updates\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\n    private static final long valueOffset;\n\n    static {\n        try {\n            valueOffset = unsafe.objectFieldOffset\n                (AtomicInteger.class.getDeclaredField(\"value\"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n\n    private volatile int value;\n    // 省略部分代码\n}\n\n```\n**Unsafe**：是CAS的核心类(后门类，执行CPU指令)，它可以提供硬件级别的原子操作，它可以获取某个属性在内存中的位置，也可以修改对象的字段值，其底层是用 C/C++ \n**valueOffset**：表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。\n**value**：要修改的值，用volatile修饰，保证了多线程之间的内存可见性。\n\n\n看看`AtomicInteger`如何实现并发下的累加操作：\n```java\n    // AtomicInteger.getAndAdd\n    public final int getAndAdd(int delta) {\n        return unsafe.getAndAddInt(this, valueOffset, delta);\n    }\n    \n    // unsafe.getAndAddInt\n    /**\n    * var1：要修改的值\n    * var2：期望值偏移地址\n    * var4：要增加的值\n    * var5：当前值\n    * var5 + var4： 当前值+要增加的值 = 目标值\n    */\n    public final int getAndAddInt(Object var1, long var2, int var4) {\n        int var5;\n        do {\n            var5 = this.getIntVolatile(var1, var2);//获取对象中offset偏移地址对应的整型field的值\n        } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n\n        return var5;\n    }\n```\n假设线程A和线程B同时执行getAndAdd操作（分别跑在不同CPU上）：\n\nAtomicInteger里面的value原始值为 n，根据Java内存模型，线程A和线程B各自持有一份value的副本，值为n。\n1. 线程A通过`getIntVolatile(var1, var2)`拿到value值 n，这时线程A被挂起。\n2. 线程B也通过`getIntVolatile(var1, var2)`方法获取到value值 n，运气好，线程B没有被挂起，并执行compareAndSwapInt方法比较内存值也为 n，成功修改内存值为 m。\n3. 这时线程A恢复，执行`compareAndSwapInt`方法比较，发现自己手里的值(n)和内存的值(m)不一致，说明该值已经被其它线程提前修改过了，那只能重新来一遍了。\n4. 重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总是能够看到，线程A继续执行`compareAndSwapInt`进行比较替换，直到成功。\n\n继续深入看看Unsafe类中的compareAndSwapInt方法实现。\n```java\npublic final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);\n```\nJava 并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的。Java 代码需通过 JNI 才能调用，位于 unsafe.cpp，\n在OpenJDK8里的路径为: openjdk/hotspot/src/share/vm/prims/unsafe.cpp。\n```C\nUNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))\n  UnsafeWrapper(\"Unsafe_CompareAndSwapInt\");\n  oop p = JNIHandles::resolve(obj);\n  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);\n  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;\nUNSAFE_END\n```\n逻辑执行流程：\n1. obj是AtomicInteger对象，通过 JNIHandles::resolve() 获取obj在内存中OOP实例p\n2. 根据成员变量value反射后计算出的内存偏移值offset去内存中取指针addr\n3. 获得更新值x、指针addr、期待值e三个参数后，调用Atomic::cmpxchg(x, addr, e)\n4. 通过Atomic::cmpxchg(x, addr, e)实现CAS\n对应OpenJDK8的路径是: openjdk/hotspot/src/share/vm/runtime/atomic.cpp\n\n\n```C\njbyte Atomic::cmpxchg(jbyte exchange_value, volatile jbyte* dest, jbyte compare_value) {\n  assert(sizeof(jbyte) == 1, \"assumption.\");\n  uintptr_t dest_addr = (uintptr_t)dest;\n  uintptr_t offset = dest_addr % sizeof(jint);\n  volatile jint* dest_int = (volatile jint*)(dest_addr - offset);\n  jint cur = *dest_int;\n  jbyte* cur_as_bytes = (jbyte*)(&cur);\n  jint new_val = cur;\n  jbyte* new_val_as_bytes = (jbyte*)(&new_val);\n  new_val_as_bytes[offset] = exchange_value;\n  while (cur_as_bytes[offset] == compare_value) {\n    jint res = cmpxchg(new_val, dest_int, cur);\n    if (res == cur) break;\n    cur = res;\n    new_val = cur;\n    new_val_as_bytes[offset] = exchange_value;\n  }\n  return cur_as_bytes[offset];\n}\n```\n\n其中的cmpxchg为核心内容. 但是这句代码根据操作系统和处理器的不同, 使用不同的底层代码. \n\n```C\n#include \"runtime/atomic.inline.hpp\"\n```\n\natomic.inline.hpp中定义如下，可见不同不同操作系统, 不同的处理器, 都要走不同的cmpxchg()方法的实现.\n\n```C\n#include \"runtime/atomic.hpp\"\n\n// Linux\n#ifdef TARGET_OS_ARCH_linux_x86\n# include \"atomic_linux_x86.inline.hpp\"\n#endif\n#ifdef TARGET_OS_ARCH_linux_sparc\n# include \"atomic_linux_sparc.inline.hpp\"\n#endif\n#ifdef TARGET_OS_ARCH_linux_zero\n# include \"atomic_linux_zero.inline.hpp\"\n#endif\n#ifdef TARGET_OS_ARCH_linux_arm\n# include \"atomic_linux_arm.inline.hpp\"\n#endif\n#ifdef TARGET_OS_ARCH_linux_ppc\n# include \"atomic_linux_ppc.inline.hpp\"\n#endif\n\n// Solaris\n#ifdef TARGET_OS_ARCH_solaris_x86\n# include \"atomic_solaris_x86.inline.hpp\"\n#endif\n#ifdef TARGET_OS_ARCH_solaris_sparc\n# include \"atomic_solaris_sparc.inline.hpp\"\n#endif\n\n// Windows\n#ifdef TARGET_OS_ARCH_windows_x86\n# include \"atomic_windows_x86.inline.hpp\"\n#endif\n\n// ..省略\n```\n以其中的linux操作系统 x86处理器为例, atomic_linux_x86.inline.hpp\n在OpenJDK中路径如下: openjdk/hotspot/src/os_cpu/linux_x86/vm/atomic_linux_x86.inline.hpp\n\n```C\n#define LOCK_IF_MP(mp) \"cmp $0, \" #mp \"; je 1f; lock; 1: \"\n\ninline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) {\n  int mp = os::is_MP();\n  __asm__ volatile (LOCK_IF_MP(%4) \"cmpxchgl %1,(%3)\"\n                    : \"=a\" (exchange_value)\n                    : \"r\" (exchange_value), \"a\" (compare_value), \"r\" (dest), \"r\" (mp)\n                    : \"cc\", \"memory\");\n  return exchange_value;\n}\n```\n已经开始内联汇编了，头疼\n\n`__asm__`：表示汇编的开始\n`volatile`：表示禁止编译器优化\n`cmpxchgl`：就是汇编中x86的比较并交换指令了。\n`LOCK_IF_MP`：是个内联函数，根据当前系统是否为多核处理器决定是否为cmpxchg1指令添加lock前缀。\n\n\n简单说下C内联汇编的语法格式：\n```C\n__asm__ volatile(\"Instruction List\"\n \n: Output\n \n: Input\n \n: Clobber/Modify);\n```\n**instruction list**：它是汇编指令列表\n**Clobber/Modify**：寄存器/内存修改标示。有时候,当你想通知GCC当前内联汇编语句可能会对某些寄存器或内存进行修改,希望GCC在编译时能够将这一点考虑进去;那么你就可以在Clobber/Modify部分声明这些寄存器或内存\n\n所以上述汇编指令解释为：\n嵌入式汇编规定把输出和输入寄存器按统一顺序编号，顺序是从输出寄存器序列从左到右从上到下以%0开始，分别记为%0、%1···%9。也就是说，输出的eax是%0，输入的exchange_value、compare_value、dest、mp分别是%1、%2、%3、%4。\n然后看asm里的第一行指令，**cmpxchgl %1,(%3)**，比较eax(compare_value在eax中)与dest的值，如果相等，那么将**exchange_value**的值赋值给dest；否则，将dest的值赋值给eax。\n然后看输出: \"=a\" (**exchange_value**) 表示把eax中存的值(compare_value)写入**exchange_value**变量中。\n        \n`Atomic::cmpxchg`这个函数最终返回值是exchange_value，也就有两种情况：\n1. 如果cmpxchgl执行时compare_value和dest指针指向内存值相等则会使得dest指针指向内存值变成**exchange_value**，最终eax存的compare_value赋值给了**exchange_value**变量，即函数最终返回的值是原先的compare_value。\n   此时Unsafe_CompareAndSwapInt的返回值(jint)(Atomic::cmpxchg(x, addr, e)) == e就是true，表明CAS成功。\n\n2. 如果cmpxchgl执行时compare_value和(dest)不等则会把当前dest指针指向内存的值写入eax，最终输出时赋值给**exchange_value**变量作为返回值，\n   导致(jint)(Atomic::cmpxchg(x, addr, e)) == e得到false，表明CAS失败。\n\n\n### lock前缀\n在单处理器系统中是不需要加lock的，因为能够在单条指令中完成的操作都可以认为是原子操作，中断只能发生在指令与指令之间。\n在多处理器系统中,由于系统中有多个处理器在独立的运行，即使在能单条指令中完成的操作也可能受到干扰。\n\n在所有的 X86 CPU 上都具有锁定一个特定内存地址的能力，当这个特定内存地址被锁定后，它就可以阻止其他的系统总线读取或修改这个内存地址。这种能力是通过 LOCK 指令前缀再加上前面的汇编指令来实现的。当使用 LOCK 指令前缀时，它会使 CPU 宣告一个 LOCK# 信号，这样就能确保在多处理器系统或多线程竞争的环境下互斥地使用这个内存地址。当指令执行完毕，这个锁定动作也就会消失。\n\n## 缺点\n1. CPU开销较大：在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。\n2. 不能保证代码块的原子性：CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证多个变量共同进行原子性的更新，就得使用Synchronized了。\n3. ABA问题：这是CAS机制最大的问题所在。\n\n## ABA问题\n线程 1 从内存位置 V 取出 A，这时候线程 2 也从内存位置 V 取出 A，此时线程 1 处于挂起状态，线程 2 将位置 V 的值改成 B，最后再改成 A，\n这时候线程 1 再执行，发现位置 V 的值没有变化，尽管线程 1 也更改成功了，但内存地址V中的变量已经经历了A->B->A的改变。\n\n举个例子：\n假设有一个遵循CAS原理的提款机，小灰有100元存款，要用这个提款机来提款50元。\n由于提款机硬件出了点小问题，小灰的提款操作被同时提交两次，开启了两个线程，两个线程都是获取当前值100元，要更新成50元。\n理想情况下，应该一个线程更新成功，另一个线程更新失败，小灰的存款只被扣一次。\n线程1首先执行成功，把余额从100改成50。线程2因为某种原因阻塞了。这时候，小灰的妈妈刚好给小灰汇款50元。\n线程2仍然是阻塞状态，线程3执行成功，把余额从50改成100。\n线程2恢复运行，由于阻塞之前已经获得了“当前值”100，并且经过compare检测，此时存款实际值也是100，所以成功把变量值100更新成了50。\n小灰凭空少了50元钱。\n\n所以真正要做到严谨的CAS机制，我们在Compare阶段不仅要比较期望值A和地址V中的实际值，还要比较变量的版本号是否一致。\n在Java当中，`AtomicStampedReference`类就实现了用版本号做比较的CAS机制。\n\n```java\n    private static class Pair<T> {\n        final T reference;\n        final int stamp;\n        private Pair(T reference, int stamp) {\n            this.reference = reference;\n            this.stamp = stamp;\n        }\n        static <T> Pair<T> of(T reference, int stamp) {\n            return new Pair<T>(reference, stamp);\n        }\n    }\n```\nAtomicStampedReference 的内部类 Pair, reference 维护对象的引用，stamp 维护修改的版本号。\n\n```java\n    public boolean compareAndSet(V   expectedReference,\n                                 V   newReference,\n                                 int expectedStamp,\n                                 int newStamp) {\n        Pair<V> current = pair;\n        return\n            expectedReference == current.reference &&\n            expectedStamp == current.stamp &&\n            ((newReference == current.reference &&\n              newStamp == current.stamp) ||\n             casPair(current, Pair.of(newReference, newStamp)));\n    }\n```\n从 compareAndSet 方法得知，如果要更改内存中的值，不但要值相同，还要版本号相同。\n\n\n## 参考\n* https://www.jianshu.com/p/0e312402f6ca\n* https://blog.csdn.net/dlh0313/article/details/52172833\n* https://www.cnblogs.com/noKing/p/9094983.html\n* https://www.jianshu.com/p/fb6e91b013cc\n* https://objcoding.com/2018/11/29/cas/\n* https://mp.weixin.qq.com/s/nRnQKhiSUrDKu3mz3vItWg\n","source":"_posts/Java-Cas.md","raw":"---\ntitle: JAVA-CAS\ndate: 2019-10-23 14:41:04\ntags:\n    - JAVA\n    - 并发\n    - 学习笔记\ncategories: JAVA\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n# CAS\n\n在看线程池源码的时候发现有很多CAS操作，那么什么是CAS？\n<!-- more -->\n## 定义\nCAS是英文单词 Compare And Swap 的缩写，翻译过来就是比较并替换，它是一种原子操作，同时 CAS 是一种乐观机制。\njava.util.concurrent 包很多功能都是建立在 CAS 之上，如 ReenterLock 内部的 AQS，各种原子类，其底层都用 CAS来实现原子操作。\n\n## 如何解决并发安全问题\n在我们认识 CAS 之前，我们是通过什么来解决并发带来的安全问题呢？\nvolatile 关键字可以保证变量的可见性，但保证不了原子性；\nsynchronized 关键字利用 JVM 字节码层面来实现同步机制，它是一个悲观锁机制。\n\n```java\npublic class Test {\n  public volatile int i;\n  public void add() {\n    i++;\n  }\n}\n```\n使用 `javap -c Test.class` 命令查看看add方法的字节码指令\n```java\npublic void add();\n    Code:\n       0: aload_0\n       1: dup\n       2: getfield      #2                  // Field n:I\n       5: iconst_1\n       6: iadd\n       7: putfield      #2                  // Field n:I\n      10: return\n\n```\ni++被拆分成了几个指令：\n    1. 执行getfield拿到原始i；\n    2. 执行iadd进行加1操作；\n    3. 执行putfield写把累加后的值写回i；\n\n当线程 1 执行到加 1 步骤时，由于还没有执行赋值改变变量的值，这时候并不会刷新主内存区中的变量，\n如果此时线程 2 正好要拷贝该变量的值到自己私有缓存中，问题就出现了，当线程 2 拷贝完以后，线程1正好执行赋值运算，立马更新主内存区的值，那么此时线程 2 的副本就是旧的了，脏读又出现了。\n\n怎么解决这个问题呢？\n在 add 方法加上 synchronized 修饰解决。\n\n```java\npublic class Test {\n  public volatile int i;\n  public synchronized void add() {\n    i++;\n  }\n}\n```\n这个方案当然可行，但是大大降低了性能。\n\n## CAS原理\nCAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。\n更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存值修改为 B 并返回 true，否则什么都不做，并返回 false。\n\n### 源码分析\n\n下面以`AtomicInteger`的实现为例，分析一下CAS是如何实现的。\n\n```java\npublic class AtomicInteger extends Number implements java.io.Serializable {\n    private static final long serialVersionUID = 6214790243416807050L;\n\n    // setup to use Unsafe.compareAndSwapInt for updates\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\n    private static final long valueOffset;\n\n    static {\n        try {\n            valueOffset = unsafe.objectFieldOffset\n                (AtomicInteger.class.getDeclaredField(\"value\"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n\n    private volatile int value;\n    // 省略部分代码\n}\n\n```\n**Unsafe**：是CAS的核心类(后门类，执行CPU指令)，它可以提供硬件级别的原子操作，它可以获取某个属性在内存中的位置，也可以修改对象的字段值，其底层是用 C/C++ \n**valueOffset**：表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。\n**value**：要修改的值，用volatile修饰，保证了多线程之间的内存可见性。\n\n\n看看`AtomicInteger`如何实现并发下的累加操作：\n```java\n    // AtomicInteger.getAndAdd\n    public final int getAndAdd(int delta) {\n        return unsafe.getAndAddInt(this, valueOffset, delta);\n    }\n    \n    // unsafe.getAndAddInt\n    /**\n    * var1：要修改的值\n    * var2：期望值偏移地址\n    * var4：要增加的值\n    * var5：当前值\n    * var5 + var4： 当前值+要增加的值 = 目标值\n    */\n    public final int getAndAddInt(Object var1, long var2, int var4) {\n        int var5;\n        do {\n            var5 = this.getIntVolatile(var1, var2);//获取对象中offset偏移地址对应的整型field的值\n        } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n\n        return var5;\n    }\n```\n假设线程A和线程B同时执行getAndAdd操作（分别跑在不同CPU上）：\n\nAtomicInteger里面的value原始值为 n，根据Java内存模型，线程A和线程B各自持有一份value的副本，值为n。\n1. 线程A通过`getIntVolatile(var1, var2)`拿到value值 n，这时线程A被挂起。\n2. 线程B也通过`getIntVolatile(var1, var2)`方法获取到value值 n，运气好，线程B没有被挂起，并执行compareAndSwapInt方法比较内存值也为 n，成功修改内存值为 m。\n3. 这时线程A恢复，执行`compareAndSwapInt`方法比较，发现自己手里的值(n)和内存的值(m)不一致，说明该值已经被其它线程提前修改过了，那只能重新来一遍了。\n4. 重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总是能够看到，线程A继续执行`compareAndSwapInt`进行比较替换，直到成功。\n\n继续深入看看Unsafe类中的compareAndSwapInt方法实现。\n```java\npublic final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);\n```\nJava 并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的。Java 代码需通过 JNI 才能调用，位于 unsafe.cpp，\n在OpenJDK8里的路径为: openjdk/hotspot/src/share/vm/prims/unsafe.cpp。\n```C\nUNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))\n  UnsafeWrapper(\"Unsafe_CompareAndSwapInt\");\n  oop p = JNIHandles::resolve(obj);\n  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);\n  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;\nUNSAFE_END\n```\n逻辑执行流程：\n1. obj是AtomicInteger对象，通过 JNIHandles::resolve() 获取obj在内存中OOP实例p\n2. 根据成员变量value反射后计算出的内存偏移值offset去内存中取指针addr\n3. 获得更新值x、指针addr、期待值e三个参数后，调用Atomic::cmpxchg(x, addr, e)\n4. 通过Atomic::cmpxchg(x, addr, e)实现CAS\n对应OpenJDK8的路径是: openjdk/hotspot/src/share/vm/runtime/atomic.cpp\n\n\n```C\njbyte Atomic::cmpxchg(jbyte exchange_value, volatile jbyte* dest, jbyte compare_value) {\n  assert(sizeof(jbyte) == 1, \"assumption.\");\n  uintptr_t dest_addr = (uintptr_t)dest;\n  uintptr_t offset = dest_addr % sizeof(jint);\n  volatile jint* dest_int = (volatile jint*)(dest_addr - offset);\n  jint cur = *dest_int;\n  jbyte* cur_as_bytes = (jbyte*)(&cur);\n  jint new_val = cur;\n  jbyte* new_val_as_bytes = (jbyte*)(&new_val);\n  new_val_as_bytes[offset] = exchange_value;\n  while (cur_as_bytes[offset] == compare_value) {\n    jint res = cmpxchg(new_val, dest_int, cur);\n    if (res == cur) break;\n    cur = res;\n    new_val = cur;\n    new_val_as_bytes[offset] = exchange_value;\n  }\n  return cur_as_bytes[offset];\n}\n```\n\n其中的cmpxchg为核心内容. 但是这句代码根据操作系统和处理器的不同, 使用不同的底层代码. \n\n```C\n#include \"runtime/atomic.inline.hpp\"\n```\n\natomic.inline.hpp中定义如下，可见不同不同操作系统, 不同的处理器, 都要走不同的cmpxchg()方法的实现.\n\n```C\n#include \"runtime/atomic.hpp\"\n\n// Linux\n#ifdef TARGET_OS_ARCH_linux_x86\n# include \"atomic_linux_x86.inline.hpp\"\n#endif\n#ifdef TARGET_OS_ARCH_linux_sparc\n# include \"atomic_linux_sparc.inline.hpp\"\n#endif\n#ifdef TARGET_OS_ARCH_linux_zero\n# include \"atomic_linux_zero.inline.hpp\"\n#endif\n#ifdef TARGET_OS_ARCH_linux_arm\n# include \"atomic_linux_arm.inline.hpp\"\n#endif\n#ifdef TARGET_OS_ARCH_linux_ppc\n# include \"atomic_linux_ppc.inline.hpp\"\n#endif\n\n// Solaris\n#ifdef TARGET_OS_ARCH_solaris_x86\n# include \"atomic_solaris_x86.inline.hpp\"\n#endif\n#ifdef TARGET_OS_ARCH_solaris_sparc\n# include \"atomic_solaris_sparc.inline.hpp\"\n#endif\n\n// Windows\n#ifdef TARGET_OS_ARCH_windows_x86\n# include \"atomic_windows_x86.inline.hpp\"\n#endif\n\n// ..省略\n```\n以其中的linux操作系统 x86处理器为例, atomic_linux_x86.inline.hpp\n在OpenJDK中路径如下: openjdk/hotspot/src/os_cpu/linux_x86/vm/atomic_linux_x86.inline.hpp\n\n```C\n#define LOCK_IF_MP(mp) \"cmp $0, \" #mp \"; je 1f; lock; 1: \"\n\ninline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) {\n  int mp = os::is_MP();\n  __asm__ volatile (LOCK_IF_MP(%4) \"cmpxchgl %1,(%3)\"\n                    : \"=a\" (exchange_value)\n                    : \"r\" (exchange_value), \"a\" (compare_value), \"r\" (dest), \"r\" (mp)\n                    : \"cc\", \"memory\");\n  return exchange_value;\n}\n```\n已经开始内联汇编了，头疼\n\n`__asm__`：表示汇编的开始\n`volatile`：表示禁止编译器优化\n`cmpxchgl`：就是汇编中x86的比较并交换指令了。\n`LOCK_IF_MP`：是个内联函数，根据当前系统是否为多核处理器决定是否为cmpxchg1指令添加lock前缀。\n\n\n简单说下C内联汇编的语法格式：\n```C\n__asm__ volatile(\"Instruction List\"\n \n: Output\n \n: Input\n \n: Clobber/Modify);\n```\n**instruction list**：它是汇编指令列表\n**Clobber/Modify**：寄存器/内存修改标示。有时候,当你想通知GCC当前内联汇编语句可能会对某些寄存器或内存进行修改,希望GCC在编译时能够将这一点考虑进去;那么你就可以在Clobber/Modify部分声明这些寄存器或内存\n\n所以上述汇编指令解释为：\n嵌入式汇编规定把输出和输入寄存器按统一顺序编号，顺序是从输出寄存器序列从左到右从上到下以%0开始，分别记为%0、%1···%9。也就是说，输出的eax是%0，输入的exchange_value、compare_value、dest、mp分别是%1、%2、%3、%4。\n然后看asm里的第一行指令，**cmpxchgl %1,(%3)**，比较eax(compare_value在eax中)与dest的值，如果相等，那么将**exchange_value**的值赋值给dest；否则，将dest的值赋值给eax。\n然后看输出: \"=a\" (**exchange_value**) 表示把eax中存的值(compare_value)写入**exchange_value**变量中。\n        \n`Atomic::cmpxchg`这个函数最终返回值是exchange_value，也就有两种情况：\n1. 如果cmpxchgl执行时compare_value和dest指针指向内存值相等则会使得dest指针指向内存值变成**exchange_value**，最终eax存的compare_value赋值给了**exchange_value**变量，即函数最终返回的值是原先的compare_value。\n   此时Unsafe_CompareAndSwapInt的返回值(jint)(Atomic::cmpxchg(x, addr, e)) == e就是true，表明CAS成功。\n\n2. 如果cmpxchgl执行时compare_value和(dest)不等则会把当前dest指针指向内存的值写入eax，最终输出时赋值给**exchange_value**变量作为返回值，\n   导致(jint)(Atomic::cmpxchg(x, addr, e)) == e得到false，表明CAS失败。\n\n\n### lock前缀\n在单处理器系统中是不需要加lock的，因为能够在单条指令中完成的操作都可以认为是原子操作，中断只能发生在指令与指令之间。\n在多处理器系统中,由于系统中有多个处理器在独立的运行，即使在能单条指令中完成的操作也可能受到干扰。\n\n在所有的 X86 CPU 上都具有锁定一个特定内存地址的能力，当这个特定内存地址被锁定后，它就可以阻止其他的系统总线读取或修改这个内存地址。这种能力是通过 LOCK 指令前缀再加上前面的汇编指令来实现的。当使用 LOCK 指令前缀时，它会使 CPU 宣告一个 LOCK# 信号，这样就能确保在多处理器系统或多线程竞争的环境下互斥地使用这个内存地址。当指令执行完毕，这个锁定动作也就会消失。\n\n## 缺点\n1. CPU开销较大：在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。\n2. 不能保证代码块的原子性：CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证多个变量共同进行原子性的更新，就得使用Synchronized了。\n3. ABA问题：这是CAS机制最大的问题所在。\n\n## ABA问题\n线程 1 从内存位置 V 取出 A，这时候线程 2 也从内存位置 V 取出 A，此时线程 1 处于挂起状态，线程 2 将位置 V 的值改成 B，最后再改成 A，\n这时候线程 1 再执行，发现位置 V 的值没有变化，尽管线程 1 也更改成功了，但内存地址V中的变量已经经历了A->B->A的改变。\n\n举个例子：\n假设有一个遵循CAS原理的提款机，小灰有100元存款，要用这个提款机来提款50元。\n由于提款机硬件出了点小问题，小灰的提款操作被同时提交两次，开启了两个线程，两个线程都是获取当前值100元，要更新成50元。\n理想情况下，应该一个线程更新成功，另一个线程更新失败，小灰的存款只被扣一次。\n线程1首先执行成功，把余额从100改成50。线程2因为某种原因阻塞了。这时候，小灰的妈妈刚好给小灰汇款50元。\n线程2仍然是阻塞状态，线程3执行成功，把余额从50改成100。\n线程2恢复运行，由于阻塞之前已经获得了“当前值”100，并且经过compare检测，此时存款实际值也是100，所以成功把变量值100更新成了50。\n小灰凭空少了50元钱。\n\n所以真正要做到严谨的CAS机制，我们在Compare阶段不仅要比较期望值A和地址V中的实际值，还要比较变量的版本号是否一致。\n在Java当中，`AtomicStampedReference`类就实现了用版本号做比较的CAS机制。\n\n```java\n    private static class Pair<T> {\n        final T reference;\n        final int stamp;\n        private Pair(T reference, int stamp) {\n            this.reference = reference;\n            this.stamp = stamp;\n        }\n        static <T> Pair<T> of(T reference, int stamp) {\n            return new Pair<T>(reference, stamp);\n        }\n    }\n```\nAtomicStampedReference 的内部类 Pair, reference 维护对象的引用，stamp 维护修改的版本号。\n\n```java\n    public boolean compareAndSet(V   expectedReference,\n                                 V   newReference,\n                                 int expectedStamp,\n                                 int newStamp) {\n        Pair<V> current = pair;\n        return\n            expectedReference == current.reference &&\n            expectedStamp == current.stamp &&\n            ((newReference == current.reference &&\n              newStamp == current.stamp) ||\n             casPair(current, Pair.of(newReference, newStamp)));\n    }\n```\n从 compareAndSet 方法得知，如果要更改内存中的值，不但要值相同，还要版本号相同。\n\n\n## 参考\n* https://www.jianshu.com/p/0e312402f6ca\n* https://blog.csdn.net/dlh0313/article/details/52172833\n* https://www.cnblogs.com/noKing/p/9094983.html\n* https://www.jianshu.com/p/fb6e91b013cc\n* https://objcoding.com/2018/11/29/cas/\n* https://mp.weixin.qq.com/s/nRnQKhiSUrDKu3mz3vItWg\n","slug":"Java-Cas","published":1,"updated":"2020-03-02T06:46:18.558Z","layout":"post","photos":[],"link":"","_id":"ck8fb4aaf001ck2o52sdtexij","content":"<h1 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h1><p>在看线程池源码的时候发现有很多CAS操作，那么什么是CAS？</p>\n<a id=\"more\"></a>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>CAS是英文单词 Compare And Swap 的缩写，翻译过来就是比较并替换，它是一种原子操作，同时 CAS 是一种乐观机制。<br>java.util.concurrent 包很多功能都是建立在 CAS 之上，如 ReenterLock 内部的 AQS，各种原子类，其底层都用 CAS来实现原子操作。</p>\n<h2 id=\"如何解决并发安全问题\"><a href=\"#如何解决并发安全问题\" class=\"headerlink\" title=\"如何解决并发安全问题\"></a>如何解决并发安全问题</h2><p>在我们认识 CAS 之前，我们是通过什么来解决并发带来的安全问题呢？<br>volatile 关键字可以保证变量的可见性，但保证不了原子性；<br>synchronized 关键字利用 JVM 字节码层面来实现同步机制，它是一个悲观锁机制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>javap -c Test.class</code> 命令查看看add方法的字节码指令</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">       <span class=\"number\">1</span>: dup</span><br><span class=\"line\">       2: getfield      #2                  // Field n:I</span><br><span class=\"line\">       <span class=\"number\">5</span>: iconst_1</span><br><span class=\"line\">       <span class=\"number\">6</span>: iadd</span><br><span class=\"line\">       7: putfield      #2                  // Field n:I</span><br><span class=\"line\">      <span class=\"number\">10</span>: <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n\n<p>i++被拆分成了几个指令：<br>    1. 执行getfield拿到原始i；<br>    2. 执行iadd进行加1操作；<br>    3. 执行putfield写把累加后的值写回i；</p>\n<p>当线程 1 执行到加 1 步骤时，由于还没有执行赋值改变变量的值，这时候并不会刷新主内存区中的变量，<br>如果此时线程 2 正好要拷贝该变量的值到自己私有缓存中，问题就出现了，当线程 2 拷贝完以后，线程1正好执行赋值运算，立马更新主内存区的值，那么此时线程 2 的副本就是旧的了，脏读又出现了。</p>\n<p>怎么解决这个问题呢？<br>在 add 方法加上 synchronized 修饰解决。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方案当然可行，但是大大降低了性能。</p>\n<h2 id=\"CAS原理\"><a href=\"#CAS原理\" class=\"headerlink\" title=\"CAS原理\"></a>CAS原理</h2><p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。<br>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存值修改为 B 并返回 true，否则什么都不做，并返回 false。</p>\n<h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><p>下面以<code>AtomicInteger</code>的实现为例，分析一下CAS是如何实现的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AtomicInteger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Number</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">6214790243416807050L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> valueOffset;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            valueOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">                (AtomicInteger.class.getDeclaredField(<span class=\"string\">\"value\"</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(ex); &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    <span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Unsafe</strong>：是CAS的核心类(后门类，执行CPU指令)，它可以提供硬件级别的原子操作，它可以获取某个属性在内存中的位置，也可以修改对象的字段值，其底层是用 C/C++<br><strong>valueOffset</strong>：表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。<br><strong>value</strong>：要修改的值，用volatile修饰，保证了多线程之间的内存可见性。</p>\n<p>看看<code>AtomicInteger</code>如何实现并发下的累加操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AtomicInteger.getAndAdd</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndAdd</span><span class=\"params\">(<span class=\"keyword\">int</span> delta)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, delta);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// unsafe.getAndAddInt</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* var1：要修改的值</span></span><br><span class=\"line\"><span class=\"comment\">* var2：期望值偏移地址</span></span><br><span class=\"line\"><span class=\"comment\">* var4：要增加的值</span></span><br><span class=\"line\"><span class=\"comment\">* var5：当前值</span></span><br><span class=\"line\"><span class=\"comment\">* var5 + var4： 当前值+要增加的值 = 目标值</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndAddInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> var5;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        var5 = <span class=\"keyword\">this</span>.getIntVolatile(var1, var2);<span class=\"comment\">//获取对象中offset偏移地址对应的整型field的值</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(!<span class=\"keyword\">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> var5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设线程A和线程B同时执行getAndAdd操作（分别跑在不同CPU上）：</p>\n<p>AtomicInteger里面的value原始值为 n，根据Java内存模型，线程A和线程B各自持有一份value的副本，值为n。</p>\n<ol>\n<li>线程A通过<code>getIntVolatile(var1, var2)</code>拿到value值 n，这时线程A被挂起。</li>\n<li>线程B也通过<code>getIntVolatile(var1, var2)</code>方法获取到value值 n，运气好，线程B没有被挂起，并执行compareAndSwapInt方法比较内存值也为 n，成功修改内存值为 m。</li>\n<li>这时线程A恢复，执行<code>compareAndSwapInt</code>方法比较，发现自己手里的值(n)和内存的值(m)不一致，说明该值已经被其它线程提前修改过了，那只能重新来一遍了。</li>\n<li>重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总是能够看到，线程A继续执行<code>compareAndSwapInt</code>进行比较替换，直到成功。</li>\n</ol>\n<p>继续深入看看Unsafe类中的compareAndSwapInt方法实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSwapInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4, <span class=\"keyword\">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>Java 并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的。Java 代码需通过 JNI 才能调用，位于 unsafe.cpp，<br>在OpenJDK8里的路径为: openjdk/hotspot/src/share/vm/prims/unsafe.cpp。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class=\"line\">  UnsafeWrapper(<span class=\"string\">\"Unsafe_CompareAndSwapInt\"</span>);</span><br><span class=\"line\">  oop p = JNIHandles::resolve(obj);</span><br><span class=\"line\">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class=\"line\">UNSAFE_END</span><br></pre></td></tr></table></figure>\n\n<p>逻辑执行流程：</p>\n<ol>\n<li>obj是AtomicInteger对象，通过 JNIHandles::resolve() 获取obj在内存中OOP实例p</li>\n<li>根据成员变量value反射后计算出的内存偏移值offset去内存中取指针addr</li>\n<li>获得更新值x、指针addr、期待值e三个参数后，调用Atomic::cmpxchg(x, addr, e)</li>\n<li>通过Atomic::cmpxchg(x, addr, e)实现CAS<br>对应OpenJDK8的路径是: openjdk/hotspot/src/share/vm/runtime/atomic.cpp</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jbyte Atomic::cmpxchg(jbyte exchange_value, <span class=\"keyword\">volatile</span> jbyte* dest, jbyte compare_value) &#123;</span><br><span class=\"line\">  assert(<span class=\"keyword\">sizeof</span>(jbyte) == <span class=\"number\">1</span>, <span class=\"string\">\"assumption.\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">uintptr_t</span> dest_addr = (<span class=\"keyword\">uintptr_t</span>)dest;</span><br><span class=\"line\">  <span class=\"keyword\">uintptr_t</span> offset = dest_addr % <span class=\"keyword\">sizeof</span>(jint);</span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> jint* dest_int = (<span class=\"keyword\">volatile</span> jint*)(dest_addr - offset);</span><br><span class=\"line\">  jint cur = *dest_int;</span><br><span class=\"line\">  jbyte* cur_as_bytes = (jbyte*)(&amp;cur);</span><br><span class=\"line\">  jint new_val = cur;</span><br><span class=\"line\">  jbyte* new_val_as_bytes = (jbyte*)(&amp;new_val);</span><br><span class=\"line\">  new_val_as_bytes[offset] = exchange_value;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (cur_as_bytes[offset] == compare_value) &#123;</span><br><span class=\"line\">    jint res = cmpxchg(new_val, dest_int, cur);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res == cur) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    cur = res;</span><br><span class=\"line\">    new_val = cur;</span><br><span class=\"line\">    new_val_as_bytes[offset] = exchange_value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> cur_as_bytes[offset];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中的cmpxchg为核心内容. 但是这句代码根据操作系统和处理器的不同, 使用不同的底层代码. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"runtime/atomic.inline.hpp\"</span></span></span><br></pre></td></tr></table></figure>\n\n<p>atomic.inline.hpp中定义如下，可见不同不同操作系统, 不同的处理器, 都要走不同的cmpxchg()方法的实现.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"runtime/atomic.hpp\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Linux</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> TARGET_OS_ARCH_linux_x86</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"atomic_linux_x86.inline.hpp\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> TARGET_OS_ARCH_linux_sparc</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"atomic_linux_sparc.inline.hpp\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> TARGET_OS_ARCH_linux_zero</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"atomic_linux_zero.inline.hpp\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> TARGET_OS_ARCH_linux_arm</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"atomic_linux_arm.inline.hpp\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> TARGET_OS_ARCH_linux_ppc</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"atomic_linux_ppc.inline.hpp\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Solaris</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> TARGET_OS_ARCH_solaris_x86</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"atomic_solaris_x86.inline.hpp\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> TARGET_OS_ARCH_solaris_sparc</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"atomic_solaris_sparc.inline.hpp\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Windows</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> TARGET_OS_ARCH_windows_x86</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"atomic_windows_x86.inline.hpp\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ..省略</span></span><br></pre></td></tr></table></figure>\n\n<p>以其中的linux操作系统 x86处理器为例, atomic_linux_x86.inline.hpp<br>在OpenJDK中路径如下: openjdk/hotspot/src/os_cpu/linux_x86/vm/atomic_linux_x86.inline.hpp</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LOCK_IF_MP(mp) <span class=\"meta-string\">\"cmp $0, \"</span> #mp <span class=\"meta-string\">\"; je 1f; lock; 1: \"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> jint     Atomic::cmpxchg    (jint     exchange_value, <span class=\"keyword\">volatile</span> jint*     dest, jint     compare_value) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> mp = os::is_MP();</span><br><span class=\"line\">  __<span class=\"function\">asm__ <span class=\"title\">volatile</span> <span class=\"params\">(LOCK_IF_MP(%<span class=\"number\">4</span>) <span class=\"string\">\"cmpxchgl %1,(%3)\"</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    : <span class=\"string\">\"=a\"</span> (exchange_value)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    : <span class=\"string\">\"r\"</span> (exchange_value), <span class=\"string\">\"a\"</span> (compare_value), <span class=\"string\">\"r\"</span> (dest), <span class=\"string\">\"r\"</span> (mp)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    : <span class=\"string\">\"cc\"</span>, <span class=\"string\">\"memory\"</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> exchange_value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>已经开始内联汇编了，头疼</p>\n<p><code>__asm__</code>：表示汇编的开始<br><code>volatile</code>：表示禁止编译器优化<br><code>cmpxchgl</code>：就是汇编中x86的比较并交换指令了。<br><code>LOCK_IF_MP</code>：是个内联函数，根据当前系统是否为多核处理器决定是否为cmpxchg1指令添加lock前缀。</p>\n<p>简单说下C内联汇编的语法格式：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"function\">asm__ <span class=\"title\">volatile</span><span class=\"params\">(<span class=\"string\">\"Instruction List\"</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"> </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">: Output</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"> </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">: Input</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"> </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">: Clobber/Modify)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>instruction list</strong>：它是汇编指令列表<br><strong>Clobber/Modify</strong>：寄存器/内存修改标示。有时候,当你想通知GCC当前内联汇编语句可能会对某些寄存器或内存进行修改,希望GCC在编译时能够将这一点考虑进去;那么你就可以在Clobber/Modify部分声明这些寄存器或内存</p>\n<p>所以上述汇编指令解释为：<br>嵌入式汇编规定把输出和输入寄存器按统一顺序编号，顺序是从输出寄存器序列从左到右从上到下以%0开始，分别记为%0、%1···%9。也就是说，输出的eax是%0，输入的exchange_value、compare_value、dest、mp分别是%1、%2、%3、%4。<br>然后看asm里的第一行指令，<strong>cmpxchgl %1,(%3)</strong>，比较eax(compare_value在eax中)与dest的值，如果相等，那么将<strong>exchange_value</strong>的值赋值给dest；否则，将dest的值赋值给eax。<br>然后看输出: “=a” (<strong>exchange_value</strong>) 表示把eax中存的值(compare_value)写入<strong>exchange_value</strong>变量中。</p>\n<p><code>Atomic::cmpxchg</code>这个函数最终返回值是exchange_value，也就有两种情况：</p>\n<ol>\n<li><p>如果cmpxchgl执行时compare_value和dest指针指向内存值相等则会使得dest指针指向内存值变成<strong>exchange_value</strong>，最终eax存的compare_value赋值给了<strong>exchange_value</strong>变量，即函数最终返回的值是原先的compare_value。<br>此时Unsafe_CompareAndSwapInt的返回值(jint)(Atomic::cmpxchg(x, addr, e)) == e就是true，表明CAS成功。</p>\n</li>\n<li><p>如果cmpxchgl执行时compare_value和(dest)不等则会把当前dest指针指向内存的值写入eax，最终输出时赋值给<strong>exchange_value</strong>变量作为返回值，<br>导致(jint)(Atomic::cmpxchg(x, addr, e)) == e得到false，表明CAS失败。</p>\n</li>\n</ol>\n<h3 id=\"lock前缀\"><a href=\"#lock前缀\" class=\"headerlink\" title=\"lock前缀\"></a>lock前缀</h3><p>在单处理器系统中是不需要加lock的，因为能够在单条指令中完成的操作都可以认为是原子操作，中断只能发生在指令与指令之间。<br>在多处理器系统中,由于系统中有多个处理器在独立的运行，即使在能单条指令中完成的操作也可能受到干扰。</p>\n<p>在所有的 X86 CPU 上都具有锁定一个特定内存地址的能力，当这个特定内存地址被锁定后，它就可以阻止其他的系统总线读取或修改这个内存地址。这种能力是通过 LOCK 指令前缀再加上前面的汇编指令来实现的。当使用 LOCK 指令前缀时，它会使 CPU 宣告一个 LOCK# 信号，这样就能确保在多处理器系统或多线程竞争的环境下互斥地使用这个内存地址。当指令执行完毕，这个锁定动作也就会消失。</p>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ol>\n<li>CPU开销较大：在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</li>\n<li>不能保证代码块的原子性：CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证多个变量共同进行原子性的更新，就得使用Synchronized了。</li>\n<li>ABA问题：这是CAS机制最大的问题所在。</li>\n</ol>\n<h2 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a>ABA问题</h2><p>线程 1 从内存位置 V 取出 A，这时候线程 2 也从内存位置 V 取出 A，此时线程 1 处于挂起状态，线程 2 将位置 V 的值改成 B，最后再改成 A，<br>这时候线程 1 再执行，发现位置 V 的值没有变化，尽管线程 1 也更改成功了，但内存地址V中的变量已经经历了A-&gt;B-&gt;A的改变。</p>\n<p>举个例子：<br>假设有一个遵循CAS原理的提款机，小灰有100元存款，要用这个提款机来提款50元。<br>由于提款机硬件出了点小问题，小灰的提款操作被同时提交两次，开启了两个线程，两个线程都是获取当前值100元，要更新成50元。<br>理想情况下，应该一个线程更新成功，另一个线程更新失败，小灰的存款只被扣一次。<br>线程1首先执行成功，把余额从100改成50。线程2因为某种原因阻塞了。这时候，小灰的妈妈刚好给小灰汇款50元。<br>线程2仍然是阻塞状态，线程3执行成功，把余额从50改成100。<br>线程2恢复运行，由于阻塞之前已经获得了“当前值”100，并且经过compare检测，此时存款实际值也是100，所以成功把变量值100更新成了50。<br>小灰凭空少了50元钱。</p>\n<p>所以真正要做到严谨的CAS机制，我们在Compare阶段不仅要比较期望值A和地址V中的实际值，还要比较变量的版本号是否一致。<br>在Java当中，<code>AtomicStampedReference</code>类就实现了用版本号做比较的CAS机制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> T reference;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> stamp;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Pair</span><span class=\"params\">(T reference, <span class=\"keyword\">int</span> stamp)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.reference = reference;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stamp = stamp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Pair&lt;T&gt; <span class=\"title\">of</span><span class=\"params\">(T reference, <span class=\"keyword\">int</span> stamp)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>AtomicStampedReference 的内部类 Pair, reference 维护对象的引用，stamp 维护修改的版本号。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSet</span><span class=\"params\">(V   expectedReference,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                             V   newReference,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                             <span class=\"keyword\">int</span> expectedStamp,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                             <span class=\"keyword\">int</span> newStamp)</span> </span>&#123;</span><br><span class=\"line\">    Pair&lt;V&gt; current = pair;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">        expectedReference == current.reference &amp;&amp;</span><br><span class=\"line\">        expectedStamp == current.stamp &amp;&amp;</span><br><span class=\"line\">        ((newReference == current.reference &amp;&amp;</span><br><span class=\"line\">          newStamp == current.stamp) ||</span><br><span class=\"line\">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从 compareAndSet 方法得知，如果要更改内存中的值，不但要值相同，还要版本号相同。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/0e312402f6ca\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/0e312402f6ca</a></li>\n<li><a href=\"https://blog.csdn.net/dlh0313/article/details/52172833\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/dlh0313/article/details/52172833</a></li>\n<li><a href=\"https://www.cnblogs.com/noKing/p/9094983.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/noKing/p/9094983.html</a></li>\n<li><a href=\"https://www.jianshu.com/p/fb6e91b013cc\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/fb6e91b013cc</a></li>\n<li><a href=\"https://objcoding.com/2018/11/29/cas/\" target=\"_blank\" rel=\"noopener\">https://objcoding.com/2018/11/29/cas/</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/nRnQKhiSUrDKu3mz3vItWg\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/nRnQKhiSUrDKu3mz3vItWg</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h1><p>在看线程池源码的时候发现有很多CAS操作，那么什么是CAS？</p>","more":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>CAS是英文单词 Compare And Swap 的缩写，翻译过来就是比较并替换，它是一种原子操作，同时 CAS 是一种乐观机制。<br>java.util.concurrent 包很多功能都是建立在 CAS 之上，如 ReenterLock 内部的 AQS，各种原子类，其底层都用 CAS来实现原子操作。</p>\n<h2 id=\"如何解决并发安全问题\"><a href=\"#如何解决并发安全问题\" class=\"headerlink\" title=\"如何解决并发安全问题\"></a>如何解决并发安全问题</h2><p>在我们认识 CAS 之前，我们是通过什么来解决并发带来的安全问题呢？<br>volatile 关键字可以保证变量的可见性，但保证不了原子性；<br>synchronized 关键字利用 JVM 字节码层面来实现同步机制，它是一个悲观锁机制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>javap -c Test.class</code> 命令查看看add方法的字节码指令</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">       <span class=\"number\">1</span>: dup</span><br><span class=\"line\">       2: getfield      #2                  // Field n:I</span><br><span class=\"line\">       <span class=\"number\">5</span>: iconst_1</span><br><span class=\"line\">       <span class=\"number\">6</span>: iadd</span><br><span class=\"line\">       7: putfield      #2                  // Field n:I</span><br><span class=\"line\">      <span class=\"number\">10</span>: <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n\n<p>i++被拆分成了几个指令：<br>    1. 执行getfield拿到原始i；<br>    2. 执行iadd进行加1操作；<br>    3. 执行putfield写把累加后的值写回i；</p>\n<p>当线程 1 执行到加 1 步骤时，由于还没有执行赋值改变变量的值，这时候并不会刷新主内存区中的变量，<br>如果此时线程 2 正好要拷贝该变量的值到自己私有缓存中，问题就出现了，当线程 2 拷贝完以后，线程1正好执行赋值运算，立马更新主内存区的值，那么此时线程 2 的副本就是旧的了，脏读又出现了。</p>\n<p>怎么解决这个问题呢？<br>在 add 方法加上 synchronized 修饰解决。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方案当然可行，但是大大降低了性能。</p>\n<h2 id=\"CAS原理\"><a href=\"#CAS原理\" class=\"headerlink\" title=\"CAS原理\"></a>CAS原理</h2><p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。<br>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存值修改为 B 并返回 true，否则什么都不做，并返回 false。</p>\n<h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><p>下面以<code>AtomicInteger</code>的实现为例，分析一下CAS是如何实现的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AtomicInteger</span> <span class=\"keyword\">extends</span> <span class=\"title\">Number</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">6214790243416807050L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> valueOffset;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            valueOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">                (AtomicInteger.class.getDeclaredField(<span class=\"string\">\"value\"</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(ex); &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    <span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Unsafe</strong>：是CAS的核心类(后门类，执行CPU指令)，它可以提供硬件级别的原子操作，它可以获取某个属性在内存中的位置，也可以修改对象的字段值，其底层是用 C/C++<br><strong>valueOffset</strong>：表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。<br><strong>value</strong>：要修改的值，用volatile修饰，保证了多线程之间的内存可见性。</p>\n<p>看看<code>AtomicInteger</code>如何实现并发下的累加操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AtomicInteger.getAndAdd</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndAdd</span><span class=\"params\">(<span class=\"keyword\">int</span> delta)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, delta);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// unsafe.getAndAddInt</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* var1：要修改的值</span></span><br><span class=\"line\"><span class=\"comment\">* var2：期望值偏移地址</span></span><br><span class=\"line\"><span class=\"comment\">* var4：要增加的值</span></span><br><span class=\"line\"><span class=\"comment\">* var5：当前值</span></span><br><span class=\"line\"><span class=\"comment\">* var5 + var4： 当前值+要增加的值 = 目标值</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndAddInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> var5;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        var5 = <span class=\"keyword\">this</span>.getIntVolatile(var1, var2);<span class=\"comment\">//获取对象中offset偏移地址对应的整型field的值</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(!<span class=\"keyword\">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> var5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设线程A和线程B同时执行getAndAdd操作（分别跑在不同CPU上）：</p>\n<p>AtomicInteger里面的value原始值为 n，根据Java内存模型，线程A和线程B各自持有一份value的副本，值为n。</p>\n<ol>\n<li>线程A通过<code>getIntVolatile(var1, var2)</code>拿到value值 n，这时线程A被挂起。</li>\n<li>线程B也通过<code>getIntVolatile(var1, var2)</code>方法获取到value值 n，运气好，线程B没有被挂起，并执行compareAndSwapInt方法比较内存值也为 n，成功修改内存值为 m。</li>\n<li>这时线程A恢复，执行<code>compareAndSwapInt</code>方法比较，发现自己手里的值(n)和内存的值(m)不一致，说明该值已经被其它线程提前修改过了，那只能重新来一遍了。</li>\n<li>重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总是能够看到，线程A继续执行<code>compareAndSwapInt</code>进行比较替换，直到成功。</li>\n</ol>\n<p>继续深入看看Unsafe类中的compareAndSwapInt方法实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSwapInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4, <span class=\"keyword\">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>Java 并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的。Java 代码需通过 JNI 才能调用，位于 unsafe.cpp，<br>在OpenJDK8里的路径为: openjdk/hotspot/src/share/vm/prims/unsafe.cpp。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class=\"line\">  UnsafeWrapper(<span class=\"string\">\"Unsafe_CompareAndSwapInt\"</span>);</span><br><span class=\"line\">  oop p = JNIHandles::resolve(obj);</span><br><span class=\"line\">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class=\"line\">UNSAFE_END</span><br></pre></td></tr></table></figure>\n\n<p>逻辑执行流程：</p>\n<ol>\n<li>obj是AtomicInteger对象，通过 JNIHandles::resolve() 获取obj在内存中OOP实例p</li>\n<li>根据成员变量value反射后计算出的内存偏移值offset去内存中取指针addr</li>\n<li>获得更新值x、指针addr、期待值e三个参数后，调用Atomic::cmpxchg(x, addr, e)</li>\n<li>通过Atomic::cmpxchg(x, addr, e)实现CAS<br>对应OpenJDK8的路径是: openjdk/hotspot/src/share/vm/runtime/atomic.cpp</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jbyte Atomic::cmpxchg(jbyte exchange_value, <span class=\"keyword\">volatile</span> jbyte* dest, jbyte compare_value) &#123;</span><br><span class=\"line\">  assert(<span class=\"keyword\">sizeof</span>(jbyte) == <span class=\"number\">1</span>, <span class=\"string\">\"assumption.\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">uintptr_t</span> dest_addr = (<span class=\"keyword\">uintptr_t</span>)dest;</span><br><span class=\"line\">  <span class=\"keyword\">uintptr_t</span> offset = dest_addr % <span class=\"keyword\">sizeof</span>(jint);</span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> jint* dest_int = (<span class=\"keyword\">volatile</span> jint*)(dest_addr - offset);</span><br><span class=\"line\">  jint cur = *dest_int;</span><br><span class=\"line\">  jbyte* cur_as_bytes = (jbyte*)(&amp;cur);</span><br><span class=\"line\">  jint new_val = cur;</span><br><span class=\"line\">  jbyte* new_val_as_bytes = (jbyte*)(&amp;new_val);</span><br><span class=\"line\">  new_val_as_bytes[offset] = exchange_value;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (cur_as_bytes[offset] == compare_value) &#123;</span><br><span class=\"line\">    jint res = cmpxchg(new_val, dest_int, cur);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res == cur) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    cur = res;</span><br><span class=\"line\">    new_val = cur;</span><br><span class=\"line\">    new_val_as_bytes[offset] = exchange_value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> cur_as_bytes[offset];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中的cmpxchg为核心内容. 但是这句代码根据操作系统和处理器的不同, 使用不同的底层代码. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"runtime/atomic.inline.hpp\"</span></span></span><br></pre></td></tr></table></figure>\n\n<p>atomic.inline.hpp中定义如下，可见不同不同操作系统, 不同的处理器, 都要走不同的cmpxchg()方法的实现.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"runtime/atomic.hpp\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Linux</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> TARGET_OS_ARCH_linux_x86</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"atomic_linux_x86.inline.hpp\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> TARGET_OS_ARCH_linux_sparc</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"atomic_linux_sparc.inline.hpp\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> TARGET_OS_ARCH_linux_zero</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"atomic_linux_zero.inline.hpp\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> TARGET_OS_ARCH_linux_arm</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"atomic_linux_arm.inline.hpp\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> TARGET_OS_ARCH_linux_ppc</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"atomic_linux_ppc.inline.hpp\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Solaris</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> TARGET_OS_ARCH_solaris_x86</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"atomic_solaris_x86.inline.hpp\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> TARGET_OS_ARCH_solaris_sparc</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"atomic_solaris_sparc.inline.hpp\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Windows</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> TARGET_OS_ARCH_windows_x86</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"atomic_windows_x86.inline.hpp\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ..省略</span></span><br></pre></td></tr></table></figure>\n\n<p>以其中的linux操作系统 x86处理器为例, atomic_linux_x86.inline.hpp<br>在OpenJDK中路径如下: openjdk/hotspot/src/os_cpu/linux_x86/vm/atomic_linux_x86.inline.hpp</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LOCK_IF_MP(mp) <span class=\"meta-string\">\"cmp $0, \"</span> #mp <span class=\"meta-string\">\"; je 1f; lock; 1: \"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> jint     Atomic::cmpxchg    (jint     exchange_value, <span class=\"keyword\">volatile</span> jint*     dest, jint     compare_value) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> mp = os::is_MP();</span><br><span class=\"line\">  __<span class=\"function\">asm__ <span class=\"title\">volatile</span> <span class=\"params\">(LOCK_IF_MP(%<span class=\"number\">4</span>) <span class=\"string\">\"cmpxchgl %1,(%3)\"</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    : <span class=\"string\">\"=a\"</span> (exchange_value)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    : <span class=\"string\">\"r\"</span> (exchange_value), <span class=\"string\">\"a\"</span> (compare_value), <span class=\"string\">\"r\"</span> (dest), <span class=\"string\">\"r\"</span> (mp)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    : <span class=\"string\">\"cc\"</span>, <span class=\"string\">\"memory\"</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> exchange_value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>已经开始内联汇编了，头疼</p>\n<p><code>__asm__</code>：表示汇编的开始<br><code>volatile</code>：表示禁止编译器优化<br><code>cmpxchgl</code>：就是汇编中x86的比较并交换指令了。<br><code>LOCK_IF_MP</code>：是个内联函数，根据当前系统是否为多核处理器决定是否为cmpxchg1指令添加lock前缀。</p>\n<p>简单说下C内联汇编的语法格式：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"function\">asm__ <span class=\"title\">volatile</span><span class=\"params\">(<span class=\"string\">\"Instruction List\"</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"> </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">: Output</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"> </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">: Input</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"> </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">: Clobber/Modify)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>instruction list</strong>：它是汇编指令列表<br><strong>Clobber/Modify</strong>：寄存器/内存修改标示。有时候,当你想通知GCC当前内联汇编语句可能会对某些寄存器或内存进行修改,希望GCC在编译时能够将这一点考虑进去;那么你就可以在Clobber/Modify部分声明这些寄存器或内存</p>\n<p>所以上述汇编指令解释为：<br>嵌入式汇编规定把输出和输入寄存器按统一顺序编号，顺序是从输出寄存器序列从左到右从上到下以%0开始，分别记为%0、%1···%9。也就是说，输出的eax是%0，输入的exchange_value、compare_value、dest、mp分别是%1、%2、%3、%4。<br>然后看asm里的第一行指令，<strong>cmpxchgl %1,(%3)</strong>，比较eax(compare_value在eax中)与dest的值，如果相等，那么将<strong>exchange_value</strong>的值赋值给dest；否则，将dest的值赋值给eax。<br>然后看输出: “=a” (<strong>exchange_value</strong>) 表示把eax中存的值(compare_value)写入<strong>exchange_value</strong>变量中。</p>\n<p><code>Atomic::cmpxchg</code>这个函数最终返回值是exchange_value，也就有两种情况：</p>\n<ol>\n<li><p>如果cmpxchgl执行时compare_value和dest指针指向内存值相等则会使得dest指针指向内存值变成<strong>exchange_value</strong>，最终eax存的compare_value赋值给了<strong>exchange_value</strong>变量，即函数最终返回的值是原先的compare_value。<br>此时Unsafe_CompareAndSwapInt的返回值(jint)(Atomic::cmpxchg(x, addr, e)) == e就是true，表明CAS成功。</p>\n</li>\n<li><p>如果cmpxchgl执行时compare_value和(dest)不等则会把当前dest指针指向内存的值写入eax，最终输出时赋值给<strong>exchange_value</strong>变量作为返回值，<br>导致(jint)(Atomic::cmpxchg(x, addr, e)) == e得到false，表明CAS失败。</p>\n</li>\n</ol>\n<h3 id=\"lock前缀\"><a href=\"#lock前缀\" class=\"headerlink\" title=\"lock前缀\"></a>lock前缀</h3><p>在单处理器系统中是不需要加lock的，因为能够在单条指令中完成的操作都可以认为是原子操作，中断只能发生在指令与指令之间。<br>在多处理器系统中,由于系统中有多个处理器在独立的运行，即使在能单条指令中完成的操作也可能受到干扰。</p>\n<p>在所有的 X86 CPU 上都具有锁定一个特定内存地址的能力，当这个特定内存地址被锁定后，它就可以阻止其他的系统总线读取或修改这个内存地址。这种能力是通过 LOCK 指令前缀再加上前面的汇编指令来实现的。当使用 LOCK 指令前缀时，它会使 CPU 宣告一个 LOCK# 信号，这样就能确保在多处理器系统或多线程竞争的环境下互斥地使用这个内存地址。当指令执行完毕，这个锁定动作也就会消失。</p>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ol>\n<li>CPU开销较大：在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</li>\n<li>不能保证代码块的原子性：CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证多个变量共同进行原子性的更新，就得使用Synchronized了。</li>\n<li>ABA问题：这是CAS机制最大的问题所在。</li>\n</ol>\n<h2 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a>ABA问题</h2><p>线程 1 从内存位置 V 取出 A，这时候线程 2 也从内存位置 V 取出 A，此时线程 1 处于挂起状态，线程 2 将位置 V 的值改成 B，最后再改成 A，<br>这时候线程 1 再执行，发现位置 V 的值没有变化，尽管线程 1 也更改成功了，但内存地址V中的变量已经经历了A-&gt;B-&gt;A的改变。</p>\n<p>举个例子：<br>假设有一个遵循CAS原理的提款机，小灰有100元存款，要用这个提款机来提款50元。<br>由于提款机硬件出了点小问题，小灰的提款操作被同时提交两次，开启了两个线程，两个线程都是获取当前值100元，要更新成50元。<br>理想情况下，应该一个线程更新成功，另一个线程更新失败，小灰的存款只被扣一次。<br>线程1首先执行成功，把余额从100改成50。线程2因为某种原因阻塞了。这时候，小灰的妈妈刚好给小灰汇款50元。<br>线程2仍然是阻塞状态，线程3执行成功，把余额从50改成100。<br>线程2恢复运行，由于阻塞之前已经获得了“当前值”100，并且经过compare检测，此时存款实际值也是100，所以成功把变量值100更新成了50。<br>小灰凭空少了50元钱。</p>\n<p>所以真正要做到严谨的CAS机制，我们在Compare阶段不仅要比较期望值A和地址V中的实际值，还要比较变量的版本号是否一致。<br>在Java当中，<code>AtomicStampedReference</code>类就实现了用版本号做比较的CAS机制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> T reference;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> stamp;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Pair</span><span class=\"params\">(T reference, <span class=\"keyword\">int</span> stamp)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.reference = reference;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stamp = stamp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Pair&lt;T&gt; <span class=\"title\">of</span><span class=\"params\">(T reference, <span class=\"keyword\">int</span> stamp)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>AtomicStampedReference 的内部类 Pair, reference 维护对象的引用，stamp 维护修改的版本号。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSet</span><span class=\"params\">(V   expectedReference,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                             V   newReference,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                             <span class=\"keyword\">int</span> expectedStamp,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                             <span class=\"keyword\">int</span> newStamp)</span> </span>&#123;</span><br><span class=\"line\">    Pair&lt;V&gt; current = pair;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">        expectedReference == current.reference &amp;&amp;</span><br><span class=\"line\">        expectedStamp == current.stamp &amp;&amp;</span><br><span class=\"line\">        ((newReference == current.reference &amp;&amp;</span><br><span class=\"line\">          newStamp == current.stamp) ||</span><br><span class=\"line\">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从 compareAndSet 方法得知，如果要更改内存中的值，不但要值相同，还要版本号相同。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/0e312402f6ca\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/0e312402f6ca</a></li>\n<li><a href=\"https://blog.csdn.net/dlh0313/article/details/52172833\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/dlh0313/article/details/52172833</a></li>\n<li><a href=\"https://www.cnblogs.com/noKing/p/9094983.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/noKing/p/9094983.html</a></li>\n<li><a href=\"https://www.jianshu.com/p/fb6e91b013cc\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/fb6e91b013cc</a></li>\n<li><a href=\"https://objcoding.com/2018/11/29/cas/\" target=\"_blank\" rel=\"noopener\">https://objcoding.com/2018/11/29/cas/</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/nRnQKhiSUrDKu3mz3vItWg\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/nRnQKhiSUrDKu3mz3vItWg</a></li>\n</ul>"},{"title":"JAVA-HashMap源码解析","date":"2020-03-05T07:07:00.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"# HashMap 的存储结构\nHashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的\n```java\n\tstatic class Node<K,V> implements Map.Entry<K,V> {\n\t\tfinal int hash;// key的hash值\n\t\tfinal K key; // key\n\t\tV value; // value\n\t\tNode<K,V> next; //同一个hash值下的链表/红黑树\n\n\t\tNode(int hash, K key, V value, Node<K,V> next) {\n\t\t\tthis.hash = hash;\n\t\t\tthis.key = key;\n\t\t\tthis.value = value;\n\t\t\tthis.next = next;\n\t\t}\n\n\t\tpublic final K getKey()        { return key; }\n\t\tpublic final V getValue()      { return value; }\n\t\tpublic final String toString() { return key + \"=\" + value; }\n\n\t\tpublic final int hashCode() {\n\t\t\treturn Objects.hashCode(key) ^ Objects.hashCode(value);\n\t\t}\n\n\t\tpublic final V setValue(V newValue) {\n\t\t\tV oldValue = value;\n\t\t\tvalue = newValue;\n\t\t\treturn oldValue;\n\t\t}\n\n\t\tpublic final boolean equals(Object o) {\n\t\t\tif (o == this)\n\t\t\t\treturn true;\n\t\t\tif (o instanceof Map.Entry) {\n\t\t\t\tMap.Entry<?,?> e = (Map.Entry<?,?>)o;\n\t\t\t\tif (Objects.equals(key, e.getKey()) &&\n\t\t\t\t\t\tObjects.equals(value, e.getValue()))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n```\nTreeNode<K,V> 继承 LinkedHashMap.Entry<K,V>，用来实现红黑树相关的存储结构\n```java\n     static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n         TreeNode<K,V> parent;  // 存储当前节点的父节点\n         TreeNode<K,V> left;　// 存储当前节点的左孩子\n         TreeNode<K,V> right;　// 存储当前节点的右孩子\n         TreeNode<K,V> prev;    // prev则指向前一个节点（原链表中的前一个节点）\n         boolean red;　// 存储当前节点的颜色（红、黑）\n         TreeNode(int hash, K key, V val, Node<K,V> next) {\n             super(hash, key, val, next);\n         }\n \n         final TreeNode<K,V> root() {\n         }\n \n         static <K,V> void moveRootToFront(Node<K,V>[] tab, TreeNode<K,V> root) {\n         }\n \n         final TreeNode<K,V> find(int h, Object k, Class<?> kc) {\n         }\n \n         final void treeify(Node<K,V>[] tab) {\n         }\n \n         final Node<K,V> untreeify(HashMap<K,V> map) {\n         }\n \n         final TreeNode<K,V> putTreeVal(HashMap<K,V> map, Node<K,V>[] tab,\n                                        int h, K k, V v) {\n         }\n \n         final void removeTreeNode(HashMap<K,V> map, Node<K,V>[] tab,\n                                   boolean movable) {\n         }\n \n         final void split(HashMap<K,V> map, Node<K,V>[] tab, int index, int bit) {\n         }\n \n         /* ------------------------------------------------------------ */\n         // Red-black tree methods, all adapted from CLR\n         // 红黑树相关操作\n         static <K,V> TreeNode<K,V> rotateLeft(TreeNode<K,V> root,\n                                               TreeNode<K,V> p) {\n         }\n \n         static <K,V> TreeNode<K,V> rotateRight(TreeNode<K,V> root,\n                                                TreeNode<K,V> p) {\n         }\n \n         static <K,V> TreeNode<K,V> balanceInsertion(TreeNode<K,V> root,\n                                                     TreeNode<K,V> x) {\n         }\n \n         static <K,V> TreeNode<K,V> balanceDeletion(TreeNode<K,V> root,\n                                                    TreeNode<K,V> x) {\n         }       \n \n         static <K,V> boolean checkInvariants(TreeNode<K,V> t) {\n         }\n \n     }\n```\n\n# 各常量、成员变量作用　　\n```java\n\t/**\n\t * 默认初始容量\n\t */\n\tstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n\n\t/**\n\t * 最大容量， 当传入容量过大时将被这个值替换\n\t */\n\tstatic final int MAXIMUM_CAPACITY = 1 << 30;\n\n\t/**\n\t * 默认负载因子\n\t */\n\tstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n\t/**\n\t * 当链表的长度超过8，有可能会转化成树\n\t */\n\tstatic final int TREEIFY_THRESHOLD = 8;\n\n\t/**\n\t * 当链表的长度小于6则会从红黑树转回链表\n\t */\n\tstatic final int UNTREEIFY_THRESHOLD = 6;\n\n\t/**\n\t * 在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。\n\t * 这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。\n\t */\n\tstatic final int MIN_TREEIFY_CAPACITY = 64;\n\n\t/**\n\t * 用来存储 key-value 的节点对象。在 HashMap 中它有个专业的叫法 buckets ，中文叫作桶。\n\t */\n\ttransient Node<K,V>[] table;\n\n\t/**\n\t * 同时封装了 keySet 和 values 的视图\n\t */\n\ttransient Set<Map.Entry<K,V>> entrySet;\n\n\t/**\n\t * 容器中实际存放 Node 的大小\n\t */\n\ttransient int size;\n\n\t/**\n\t * HashMap 在结构上被修改的次数，结构修改是指改变HashMap中映射的次数，或者以其他方式修改其内部结构(例如，rehash)。\n\t */\n\ttransient int modCount;\n\n\t/**\n\t * HashMap的扩容阈值(=负载因子*table的容量)\n\t * 在HashMap中存储的Node键值对超过这个数量时，自动扩容容量为原来的二倍\n\t * @serial\n\t */\n\tint threshold;\n\n\t/**\n\t * 负载因子\n\t * @serial\n\t */\n\tfinal float loadFactor;\n```\n# 构造方法\n```java\n\t/**\n\t * Constructs an empty <tt>HashMap</tt> with the specified initial\n\t * capacity and load factor.\n\t *\n\t * @param  initialCapacity 初始容量\n\t * @param  loadFactor      负载因子\n\t * @throws IllegalArgumentException 如果初始容量为负或者负载因子非正数抛出该异常\n\t */\n\tpublic HashMap(int initialCapacity, float loadFactor) {\n\t\t// 当初始容量为负\n\t\tif (initialCapacity < 0)\n\t\t\tthrow new IllegalArgumentException(\"Illegal initial capacity: \" +\n\t\t\t\t\tinitialCapacity);\n\t\t// 当初始容量大于最大容量 2^30 ，初始容量= 2^30\n\t\tif (initialCapacity > MAXIMUM_CAPACITY)\n\t\t\tinitialCapacity = MAXIMUM_CAPACITY;\n\t\t// 当负载因子非正数 或 负载因子是NaN(Not a Number，0.0f/0.0f的值就是NaN)\n\t\tif (loadFactor <= 0 || Float.isNaN(loadFactor))\n\t\t\tthrow new IllegalArgumentException(\"Illegal load factor: \" +\n\t\t\t\t\tloadFactor);\n\t\t// 赋值\n\t\tthis.loadFactor = loadFactor;\n\t\tthis.threshold = tableSizeFor(initialCapacity);\n\t}\n\n\t/**\n\t * 获取比传入参数大的最小的2的N次幂。\n\t */\n\tstatic final int tableSizeFor(int cap) {\n\t\tint n = cap - 1;\n\t\tn |= n >>> 1;\n\t\tn |= n >>> 2;\n\t\tn |= n >>> 4;\n\t\tn |= n >>> 8;\n\t\tn |= n >>> 16;\n\t\treturn (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n\t}\n```\n\n# put方法\nput方法主要是调用putVal方法\n```java\n\t/**\n\t * 使 key 和 value 产生关联，但如果有相同的 key 则新的会替换掉旧的。\n\t */\n\tpublic V put(K key, V value) {\n\t\treturn putVal(hash(key), key, value, false, true);\n\t}\n\n\t/**\n\t * h >>> 16:无符号右移动16位，意味着取高16位二进制\n\t * 低16位与高16位进行异或\n\t */\n\tstatic final int hash(Object key) {\n\t\tint h;\n\t\t// 如果为 null 则返回的就是 0，否则就是 hashCode 异或上 hashCode 无符号右移 16 位\n\t\treturn (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n\t}\n```\n\n# putVal方法\n```java\n\t/**\n\t * Implements Map.put and related methods\n\t *\n\t * @param hash key的hash值\n\t * @param key the key\n\t * @param value the value to put\n\t * @param onlyIfAbsent 如果true代表不更改现有的值\n\t * @param evict 如果为false表示table为创建状态\n\t * @return previous value, or null if none\n\t */\n\tfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n\t\t\t\t   boolean evict) {\n\t\tNode<K,V>[] tab; Node<K,V> p; int n, i;\n\t\t/**\n\t\t * 判断table是否等于空或者table的长度等于0，如果是就进行初始化\n\t\t * 此时通过resize()方法得到初始化的table\n\t\t */\n\t\tif ((tab = table) == null || (n = tab.length) == 0)\n\t\t\tn = (tab = resize()).length;\n\t\t/**\n\t\t * 对hash码进行散列 ，对值的位置进行确认\n\t\t * 如果tab[i] 为null 表示没有hash冲突，就新增一个元素\n\t\t */\n\t\tif ((p = tab[i = (n - 1) & hash]) == null)\n\t\t\ttab[i] = newNode(hash, key, value, null);\n\t\telse {\n\t\t\t// 如果tab[i] 不为null，表示该位置有值了。\n\t\t\tNode<K,V> e; K k;\n\t\t\t//HashMap中判断key相同的条件是key的hash相同，并且符合equals方法。这里判断了p.key是否和插入的key相等，如果相等，则将p的引用赋给e\n\t\t\t//这里为什么要把p赋值给e，而不是直接覆盖原值呢？答案很简单，现在我们只判断了第一个节点，后面还可能出现key相同，所以需要在最后一并处理\n\t\t\tif (p.hash == hash &&\n\t\t\t\t\t((k = p.key) == key || (key != null && key.equals(k))))\n\t\t\t\te = p;\n\t\t\t/**\n\t\t\t * 判断是否是红黑树\n\t\t\t * p是红黑树节点，那么肯定插入后仍然是红黑树节点，所以我们直接强制转型p后调用TreeNode.putTreeVal方法，返回的引用赋给e\n\t\t\t */\n\t\t\telse if (p instanceof TreeNode)\n\t\t\t\te = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n\t\t\t// 否则就是链表\n\t\t\telse {\n\t\t\t\t// 如果是链表，要遍历到最后一个节点进行插入\n\t\t\t\tfor (int binCount = 0; ; ++binCount) {\n\t\t\t\t\tif ((e = p.next) == null) {\n\t\t\t\t\t\t// 插入到链尾\n\t\t\t\t\t\tp.next = newNode(hash, key, value, null);\n\t\t\t\t\t\t// 判断节点的长度是否大于TREEIFY_THRESHOLD红黑树的阈值，是就进行转换\n\t\t\t\t\t\tif (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n\t\t\t\t\t\t\ttreeifyBin(tab, hash);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 对链表中的相同 hash 值且 key 相同的进一步作检查\n\t\t\t\t\tif (e.hash == hash &&\n\t\t\t\t\t\t\t((k = e.key) == key || (key != null && key.equals(k))))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tp = e;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/**\n\t\t\t * 插入\n\t\t\t */\n\t\t\tif (e != null) { // existing mapping for key\n\t\t\t\t// 取出旧值，onlyIfAbsent此时为 false，所以不管 oldValue 有与否，都拿新值来替换\n\t\t\t\tV oldValue = e.value;\n\t\t\t\tif (!onlyIfAbsent || oldValue == null)\n\t\t\t\t\te.value = value;\n\t\t\t\tafterNodeAccess(e);\n\t\t\t\treturn oldValue;\n\t\t\t}\n\t\t}\n\t\t// 记录修改次数\n\t\t++modCount;\n\t\t// 超过阈值 threshold = capacity * factor，调用 resize() 进行扩容\n\t\tif (++size > threshold)\n\t\t\tresize();\n\t\tafterNodeInsertion(evict);\n\t\treturn null;\n\t}\n```\n\n# resize 扩容兼初始化\n```java\n\t/**\n\t * Initializes or doubles table size.  If null, allocates in\n\t * accord with initial capacity target held in field threshold.\n\t * Otherwise, because we are using power-of-two expansion, the\n\t * elements from each bin must either stay at same index, or move\n\t * with a power of two offset in the new table.\n\t * 扩容兼初始化\n\t * @return the table\n\t */\n\tfinal Node<K,V>[] resize() {\n\t\t//将原来的table指针保存\n\t\tNode<K,V>[] oldTab = table;\n\t\t//获取原来数组的长度，oldTab为null说明还没有进行初始化\n\t\tint oldCap = (oldTab == null) ? 0 : oldTab.length;\n\t\t//保存以前重构table的阈值\n\t\tint oldThr = threshold;\n\t\tint newCap, newThr = 0;\n\t\t//oldCap > 0表示已经初始化过了\n\t\tif (oldCap > 0) {\n\t\t\t//当原来的容量已经达到最大容量的时候，将阈值设置为Integer.MAX_VALUE，这样就不会再发生重构的情况\n\t\t\tif (oldCap >= MAXIMUM_CAPACITY) {\n\t\t\t\tthreshold = Integer.MAX_VALUE;\n\t\t\t\treturn oldTab;\n\t\t\t}\n\t\t\t// 否则将旧的容量扩大两倍\n\t\t\t// 当它小于最大容量，并且旧的容量大于初始化最小容量的时候，\n\t\t\t// 将新的阈值设置为旧的阈值的两倍, 新的容量设置为旧容量的2倍\n\t\t\telse if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n\t\t\t\t\toldCap >= DEFAULT_INITIAL_CAPACITY)\n\t\t\t\tnewThr = oldThr << 1; // double threshold\n\t\t}\n\t\t//虽然还没有初始化，但是设置过了阈值，将旧的阈值设置为新的容量\n\t\telse if (oldThr > 0) // initial capacity was placed in threshold\n\t\t\tnewCap = oldThr;\n\t\telse {\n\t\t\t//没有初始化阈值的时候采用默认算法计算阈值\n\t\t\tnewCap = DEFAULT_INITIAL_CAPACITY;\n\t\t\tnewThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n\t\t}\n\t\t// 对应oldCap = 0 && oldThr > 0的情况\n\t\tif (newThr == 0) {\n\t\t\t//重新用默认负载因子计算 扩容阈值\n\t\t\tfloat ft = (float)newCap * loadFactor;\n\t\t\t// 如果新容量小于最大容量 && 新扩容阈值(ft) 小于最大容量\n\t\t\t// 新阈值 = ft 否则 新阈值 = int的最大范围\n\t\t\tnewThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n\t\t\t\t\t(int)ft : Integer.MAX_VALUE);\n\t\t}\n\t\t// 把当前阈值设为新阈值\n\t\tthreshold = newThr;\n\t\t// 根据新容量，创建新table\n\t\t@SuppressWarnings({\"rawtypes\",\"unchecked\"})\n\t\tNode<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n\t\t// 将当前table 设置为新扩容的table\n\t\ttable = newTab;\n\t\t// 如果已经被初始化过\n\t\tif (oldTab != null) {\n\t\t\t//将旧数组中的元素全部取出，重新映射到新数组中\n\t\t\tfor (int j = 0; j < oldCap; ++j) {\n\t\t\t\tNode<K,V> e;\n\t\t\t\tif ((e = oldTab[j]) != null) {\n\t\t\t\t\toldTab[j] = null;\n\t\t\t\t\tif (e.next == null)\n\t\t\t\t\t\t// 该节点没有next节点，表示没有链表，没有冲突，那重新计算下位置\n\t\t\t\t\t\tnewTab[e.hash & (newCap - 1)] = e;\n\t\t\t\t\telse if (e instanceof TreeNode)\n\t\t\t\t\t\t// 冲突的是一棵树节点，分裂成 2 个树，或者如果树很小就转成链表\n\t\t\t\t\t\t((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n\t\t\t\t\telse {\n\t\t\t\t\t\t// 对原来的链表部分进行重构\n\t\t\t\t\t\tNode<K,V> loHead = null, loTail = null;\n\t\t\t\t\t\tNode<K,V> hiHead = null, hiTail = null;\n\t\t\t\t\t\tNode<K,V> next;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tnext = e.next;\n\t\t\t\t\t\t\t// 索引不变\n\t\t\t\t\t\t\tif ((e.hash & oldCap) == 0) {\n\t\t\t\t\t\t\t\tif (loTail == null)\n\t\t\t\t\t\t\t\t\tloHead = e;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tloTail.next = e;\n\t\t\t\t\t\t\t\tloTail = e;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// 原索引+oldCap\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (hiTail == null)\n\t\t\t\t\t\t\t\t\thiHead = e;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\thiTail.next = e;\n\t\t\t\t\t\t\t\thiTail = e;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while ((e = next) != null);\n\t\t\t\t\t\t// 原索引放到 tables 里\n\t\t\t\t\t\tif (loTail != null) {\n\t\t\t\t\t\t\tloTail.next = null;\n\t\t\t\t\t\t\tnewTab[j] = loHead;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 原索引+oldCap放到  tables 里\n\t\t\t\t\t\tif (hiTail != null) {\n\t\t\t\t\t\t\thiTail.next = null;\n\t\t\t\t\t\t\tnewTab[j + oldCap] = hiHead;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 返回扩容后的table\n\t\treturn newTab;\n\t}\n```\n# split 扩容时重新划分树\n\n```java\n\t\t/**\n\t\t * 扩容时重新划分树\n\t\t * @param map the map\n\t\t * @param tab 扩容后的数组\n\t\t * @param index 数组索引\n\t\t * @param bit 原数组容量\n\t\t */\n\t\tfinal void split(HashMap<K,V> map, Node<K,V>[] tab, int index, int bit) {\n\t\t\t//b设置为当前桶的头节点\n\t\t\tTreeNode<K,V> b = this;\n\t\t\t// Relink into lo and hi lists, preserving order\n\t\t\t//低位树链表头节点，尾结点\n\t\t\tTreeNode<K,V> loHead = null, loTail = null;\n\t\t\t//高位树链表头节点，尾结点\n\t\t\tTreeNode<K,V> hiHead = null, hiTail = null;\n\t\t\t//lc低位树链表中节点个数，hc高位树链表中节点个数\n\t\t\tint lc = 0, hc = 0;\n\t\t\t//e当前遍历节点\n\t\t\tfor (TreeNode<K,V> e = b, next; e != null; e = next) {\n\t\t\t\t//当前遍历节点的后继节点\n\t\t\t\tnext = (TreeNode<K,V>)e.next;\n\t\t\t\t//将当前遍历节点后继设为null\n\t\t\t\te.next = null;\n\t\t\t\tif ((e.hash & bit) == 0) {\n\t\t\t\t\t//==0表示当前遍历节点应该存放在低位\n\t\t\t\t\t//如果低位中还没有节点\n\t\t\t\t\t//将当前遍历节点设为低位头节点\n\t\t\t\t\tif ((e.prev = loTail) == null)\n\t\t\t\t\t\tloHead = e;\n\t\t\t\t\telse\n\t\t\t\t\t\t//将当前遍历节点加入到链表的尾部\n\t\t\t\t\t\tloTail.next = e;\n\t\t\t\t\t//设置尾节点为当前遍历节点\n\t\t\t\t\tloTail = e;\n\t\t\t\t\t//低位链表中的节点数加1\n\t\t\t\t\t++lc;\n\t\t\t\t}\n\t\t\t\t//!=0表示当前遍历节点应该存放在高位\n\t\t\t\telse {\n\t\t\t\t\tif ((e.prev = hiTail) == null)\n\t\t\t\t\t\thiHead = e;\n\t\t\t\t\telse\n\t\t\t\t\t\thiTail.next = e;\n\t\t\t\t\thiTail = e;\n\t\t\t\t\t++hc;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//如果低位节点链表不为null\n\t\t\tif (loHead != null) {\n\t\t\t\t//低位节点链表中节点的个数小于6，此时需要将树结构转为链表结构\n\t\t\t\tif (lc <= UNTREEIFY_THRESHOLD)\n\t\t\t\t\ttab[index] = loHead.untreeify(map);\n\t\t\t\telse {//链表中节点的个数满足保持树型结构所需要的节点个数\n\t\t\t\t\t//低位桶的头节点设为链表的头节点\n\t\t\t\t\ttab[index] = loHead;\n\t\t\t\t\t// 高位节点链表不为null，说明有节点从原树结构中分离出去了\n\t\t\t\t\t// 原有树结构被破坏\n\t\t\t\t\t// 所以低位的节点链表需要重新构建树结构\n\t\t\t\t\tif (hiHead != null) // (else is already treeified)\n\t\t\t\t\t\tloHead.treeify(tab);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 同理\n\t\t\tif (hiHead != null) {\n\t\t\t\tif (hc <= UNTREEIFY_THRESHOLD)\n\t\t\t\t\ttab[index + bit] = hiHead.untreeify(map);\n\t\t\t\telse {\n\t\t\t\t\ttab[index + bit] = hiHead;\n\t\t\t\t\tif (loHead != null)\n\t\t\t\t\t\thiHead.treeify(tab);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n```\n\n# putTreeVal 在红黑树中添加节点\n```java\n\t\t/**\n\t\t *\n\t\t * @param map 当前节点所在的HashMap对象\n\t\t * @param tab 当前HashMap对象的元素数组\n\t\t * @param h key的hash值\n\t\t * @param k key\n\t\t * @param v value\n\t\t * @return 指定key所匹配到的节点对象，针对这个对象去修改V（返回空说明创建了一个新节点）\n\t\t */\n\t\tfinal TreeNode<K,V> putTreeVal(HashMap<K,V> map, Node<K,V>[] tab,\n\t\t\t\t\t\t\t\t\t   int h, K k, V v) {\n\t\t\t// 定义k的Class对象\n\t\t\tClass<?> kc = null;\n\t\t\t// 标识是否已经遍历过一次树，未必是从根节点遍历的，但是遍历路径上一定已经包含了后续需要比对的所有节点。\n\t\t\tboolean searched = false;\n\t\t\t//父节点不为空那么查找根节点，为空那么自身就是根节点\n\t\t\tTreeNode<K,V> root = (parent != null) ? root() : this;\n\t\t\t// 从根节点开始遍历，没有终止条件，只能从内部退出\n\t\t\tfor (TreeNode<K,V> p = root;;) {\n\t\t\t\t// 声明方向、当前节点hash值、当前节点的键对象\n\t\t\t\tint dir, ph; K pk;\n\t\t\t\t// 如果当前节点hash 大于 指定key的hash值,要添加的元素应该放置在当前节点的左侧\n\t\t\t\tif ((ph = p.hash) > h)\n\t\t\t\t\tdir = -1;\n\t\t\t\t// 如果当前节点hash 小于 指定key的hash值,要添加的元素应该放置在当前节点的右侧\n\t\t\t\telse if (ph < h)\n\t\t\t\t\tdir = 1;\n\t\t\t\t// 如果当前节点的键对象 和 指定key对象相同,那么就返回当前节点对象\n\t\t\t\telse if ((pk = p.key) == k || (k != null && k.equals(pk)))\n\t\t\t\t\treturn p;\n\t\t\t\t// 走到这一步说明 当前节点的hash值  和 指定key的hash值  是相等的，但是equals不等\n\t\t\t\telse if ((kc == null &&\n\t\t\t\t\t\t(kc = comparableClassFor(k)) == null) ||\n\t\t\t\t\t\t(dir = compareComparables(kc, k, pk)) == 0) {\n\t\t\t\t\t// 走到这里说明：指定key没有实现comparable接口   或者   实现了comparable接口并且和当前节点的键对象比较之后相等（仅限第一次循环）\n\t\t\t\t\t/**\n\t\t\t\t\t * searched 标识是否已经对比过当前节点的左右子节点了\n\t\t\t\t\t * 如果还没有遍历过，那么就递归遍历对比，看是否能够得到那个键对象equals相等的的节点\n\t\t\t\t\t * 如果得到了键的equals相等的的节点就返回\n\t\t\t\t\t * 如果还是没有键的equals相等的节点，那说明应该创建一个新节点了\n\t\t\t\t\t */\n\t\t\t\t\tif (!searched) {// 如果还没有比对过当前节点的所有子节点\n\t\t\t\t\t\t// 定义要返回的节点、和子节点\n\t\t\t\t\t\tTreeNode<K,V> q, ch;\n\t\t\t\t\t\t// 标识已经遍历过一次了\n\t\t\t\t\t\tsearched = true;\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * 红黑树也是二叉树，所以只要沿着左右两侧遍历寻找就可以了\n\t\t\t\t\t\t * 这是个短路运算，如果先从左侧就已经找到了，右侧就不需要遍历了\n\t\t\t\t\t\t * find 方法内部还会有递归调用\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (((ch = p.left) != null &&\n\t\t\t\t\t\t\t\t(q = ch.find(h, k, kc)) != null) ||\n\t\t\t\t\t\t\t\t((ch = p.right) != null &&\n\t\t\t\t\t\t\t\t\t\t(q = ch.find(h, k, kc)) != null))\n\t\t\t\t\t\t\t// 找到了指定key键对应的\n\t\t\t\t\t\t\treturn q;\n\t\t\t\t\t}\n\t\t\t\t\t// 走到这里就说明，遍历了所有子节点也没有找到和当前键equals相等的节点\n\t\t\t\t\tdir = tieBreakOrder(k, pk);// 再比较一下当前节点键和指定key键的大小\n\t\t\t\t}\n\t\t\t\t// 定义xp指向当前节点\n\t\t\t\tTreeNode<K,V> xp = p;\n\t\t\t\t/**\n\t\t\t\t * 如果dir小于等于0，那么看当前节点的左节点是否为空，\n\t\t\t\t * 如果为空，就可以把要添加的元素作为当前节点的左节点，如果不为空，还需要下一轮继续比较\n\t\t\t\t *\n\t\t\t\t * 如果dir大于等于0，那么看当前节点的右节点是否为空，\n\t\t\t\t * 如果为空，就可以把要添加的元素作为当前节点的右节点，如果不为空，还需要下一轮继续比较\n\t\t\t\t *\n\t\t\t\t * 如果以上两条当中有一个子节点不为空，\n\t\t\t\t * 这个if中还做了一件事，那就是把p已经指向了对应的不为空的子节点，开始下一轮的比较\n\t\t\t\t */\n\t\t\t\tif ((p = (dir <= 0) ? p.left : p.right) == null) {\n\t\t\t\t\t// 如果恰好要添加的方向上的子节点为空，此时节点p已经指向了这个空的子节点\n\t\t\t\t\t// 获取当前节点的next节点\n\t\t\t\t\tNode<K,V> xpn = xp.next;\n\t\t\t\t\t// 创建一个新的树节点\n\t\t\t\t\tTreeNode<K,V> x = map.newTreeNode(h, k, v, xpn);\n\t\t\t\t\tif (dir <= 0)\n\t\t\t\t\t\t// 左孩子指向到这个新的树节点\n\t\t\t\t\t\txp.left = x;\n\t\t\t\t\telse\n\t\t\t\t\t\t// 右孩子指向到这个新的树节点\n\t\t\t\t\t\txp.right = x;\n\t\t\t\t\t// 链表中的next节点指向到这个新的树节点\n\t\t\t\t\txp.next = x;\n\t\t\t\t\t// 这个新的树节点的父节点、前节点均设置为 当前的树节点\n\t\t\t\t\tx.parent = x.prev = xp;\n\t\t\t\t\t// 如果原来的next节点不为空\n\t\t\t\t\tif (xpn != null)\n\t\t\t\t\t\t// 那么原来的next节点的前节点指向到新的树节点\n\t\t\t\t\t\t((TreeNode<K,V>)xpn).prev = x;\n\t\t\t\t\t// 重新平衡，以及新的根节点置顶\n\t\t\t\t\tmoveRootToFront(tab, balanceInsertion(root, x));\n\t\t\t\t\t// 返回空，意味着产生了一个新节点\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n```\n\n# treeifyBin 链表转成红黑树\n```java\n\t/**\n\t * 将指定hash节点处的链表替换成红黑树\n\t * 除非table太小了，将用resizes（）改变树的容量\n\t * Replaces all linked nodes in bin at index for given hash unless\n\t * table is too small, in which case resizes instead.\n\t */\n\tfinal void treeifyBin(Node<K,V>[] tab, int hash) {\n\t\tint n, index; Node<K,V> e;\n\t\t// 如果 table 为null 或者\n\t\t// table的长度小于 MIN_TREEIFY_CAPACITY（默认64））不进行树化，调用resize进行扩容\n\t\tif (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)\n\t\t\tresize();\n\t\t// 如果 该hash值对应的 tab[index] 不为null，证明该位置有值\n\t\telse if ((e = tab[index = (n - 1) & hash]) != null) {\n\t\t\tTreeNode<K,V> hd = null, tl = null;\n\t\t\t// 遍历链表,将单项链表改为双向链表\n\t\t\tdo {\n\t\t\t\t// node 节点转成 TreeNode节点\n\t\t\t\tTreeNode<K,V> p = replacementTreeNode(e, null);\n\t\t\t\t// 如果树为空\n\t\t\t\tif (tl == null)\n\t\t\t\t\t// 设置树的根\n\t\t\t\t\thd = p;\n\t\t\t\telse {\n\t\t\t\t\t// 设置新节点p的上一个节点\n\t\t\t\t\tp.prev = tl;\n\t\t\t\t\t// 设置 上一节点的 next 指向当前节点\n\t\t\t\t\ttl.next = p;\n\t\t\t\t}\n\t\t\t\t//保存上一节点\n\t\t\t\ttl = p;\n\t\t\t} while ((e = e.next) != null);\n\t\t\t// 如果树的根节点不为null，调用treeify()进行树化\n\t\t\tif ((tab[index] = hd) != null)\n\t\t\t\thd.treeify(tab);\n\t\t}\n\t}\n\n\t\t/**\n\t\t * Forms tree of the nodes linked from this node.\n\t\t * @return root of tree\n\t\t */\n\t\tfinal void treeify(Node<K,V>[] tab) {\n\t\t\t// 树的根节点\n\t\t\tTreeNode<K,V> root = null;\n\t\t\t//x是当前节点，next是后继\n\t\t\tfor (TreeNode<K,V> x = this, next; x != null; x = next) {\n\t\t\t\t// 后继节点\n\t\t\t\tnext = (TreeNode<K,V>)x.next;\n\t\t\t\t// 左右儿子设为null\n\t\t\t\tx.left = x.right = null;\n\t\t\t\t// 如果根是 null\n\t\t\t\tif (root == null) {\n\t\t\t\t\t// 设置父节点为null\n\t\t\t\t\tx.parent = null;\n\t\t\t\t\t// 设置为黑色\n\t\t\t\t\tx.red = false;\n\t\t\t\t\t// 把当前节点设置为根节点\n\t\t\t\t\troot = x;\n\t\t\t\t}\n\t\t\t\t// 如果有根节点\n\t\t\t\telse {\n\t\t\t\t\tK k = x.key;\n\t\t\t\t\tint h = x.hash;\n\t\t\t\t\tClass<?> kc = null;\n\t\t\t\t\t// 遍历树，进行二叉搜索树的插入\n\t\t\t\t\tfor (TreeNode<K,V> p = root;;) {\n\t\t\t\t\t\t// p指向遍历中的当前节点，\n\t\t\t\t\t\t// x为待插入节点，\n\t\t\t\t\t\t// k是x的key，\n\t\t\t\t\t\t// h是x的hash值，\n\t\t\t\t\t\t// ph是p的hash值，\n\t\t\t\t\t\t// pk是p的key，\n\t\t\t\t\t\t// dir用来指示x节点与p的比较，-1表示比p小，1表示比p大\n\t\t\t\t\t\t// 不存在相等情况，因为HashMap中是不存在两个key完全一致的情况。\n\t\t\t\t\t\tint dir, ph;\n\t\t\t\t\t\tK pk = p.key;\n\t\t\t\t\t\t// 待插入x的hash值小于当前点p的hash值\n\t\t\t\t\t\tif ((ph = p.hash) > h)\n\t\t\t\t\t\t\tdir = -1;\n\t\t\t\t\t\telse if (ph < h)\n\t\t\t\t\t\t\tdir = 1;\n\t\t\t\t\t\t// 如果hash值相等，那么判断k是否实现了comparable接口，\n\t\t\t\t\t\t// 如果实现了comparable接口就使用compareTo进行进行比较，\n\t\t\t\t\t\t// 如果仍旧相等或者没有实现comparable接口，则在tieBreakOrder中比较\n\t\t\t\t\t\telse if ((kc == null &&\n\t\t\t\t\t\t\t\t(kc = comparableClassFor(k)) == null) ||\n\t\t\t\t\t\t\t\t(dir = compareComparables(kc, k, pk)) == 0)\n\t\t\t\t\t\t\tdir = tieBreakOrder(k, pk);\n\n\t\t\t\t\t\t// 将当前节点赋值给XP\n\t\t\t\t\t\tTreeNode<K,V> xp = p;\n\t\t\t\t\t\t// 如果dir <= 0 ,p 等于 p的左儿子，否则p 等于 p的右儿子\n\t\t\t\t\t\t// 如果 p 等于 null，则插入x节点\n\t\t\t\t\t\tif ((p = (dir <= 0) ? p.left : p.right) == null) {\n\t\t\t\t\t\t\t// x的父节点指向 xp\n\t\t\t\t\t\t\tx.parent = xp;\n\t\t\t\t\t\t\tif (dir <= 0)\n\t\t\t\t\t\t\t\txp.left = x;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\txp.right = x;\n\t\t\t\t\t\t\t// 进行平衡处理，保证红黑树的性质\n\t\t\t\t\t\t\troot = balanceInsertion(root, x);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//root节点移动到桶中的第一个元素，也就是链表的首节点\n\t\t\tmoveRootToFront(tab, root);\n\t\t}\n```\n\n\n# untreeify 树变链表\n\n```java\n\t\t/**\n\t\t * 树变链表\n\t\t * //重新创建链表节点，并形成链表结构\n\t\t */\n\t\tfinal Node<K,V> untreeify(HashMap<K,V> map) {\n\t\t\tNode<K,V> hd = null, tl = null;\n\t\t\tfor (Node<K,V> q = this; q != null; q = q.next) {\n\t\t\t\tNode<K,V> p = map.replacementNode(q, null);\n\t\t\t\tif (tl == null)\n\t\t\t\t\thd = p;\n\t\t\t\telse\n\t\t\t\t\ttl.next = p;\n\t\t\t\ttl = p;\n\t\t\t}\n\t\t\treturn hd;\n\t\t}\n```\n\n# balanceInsertion 红黑树插入平衡\n```java\n\t\t/**\n\t\t * 红黑树的插入平衡处理\n\t\t * @param root 根节点\n\t\t * @param x 新插入节点\n\t\t * @return\n\t\t */\n\t\tstatic <K,V> TreeNode<K,V> balanceInsertion(TreeNode<K,V> root,\n\t\t\t\t\t\t\t\t\t\t\t\t\tTreeNode<K,V> x) {\n\t\t\t//插入的节点默认为红色\n\t\t\tx.red = true;\n\t\t\t// xp：当前节点的父节点\n\t\t\t// xpp：爷爷节点\n\t\t\t// xppl：左叔叔节点\n\t\t\t// xppr：右叔叔节点\n\t\t\tfor (TreeNode<K,V> xp, xpp, xppl, xppr;;) {\n\t\t\t\t// L1：如果父节点为空、说明当前节点就是根节点，那么把当前节点标为黑色，返回当前节点\n\t\t\t\tif ((xp = x.parent) == null) {\n\t\t\t\t\tx.red = false;\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t\t// 父节点不为空\n\t\t\t\t// L2：如果 父节点为黑色 那么插入节点为红色不影响树的平衡\n\t\t\t\t// L3：或者 爷爷节点为空 即 父节点是根节点\n\t\t\t\t// 返回根节点\n\t\t\t\telse if (!xp.red || (xpp = xp.parent) == null)\n\t\t\t\t\treturn root;\n\t\t\t\t// L4：父节点和祖父节点都存在，并且其父节点是祖父节点的左节点\n\t\t\t\tif (xp == (xppl = xpp.left)) {\n\t\t\t\t\t// L4.1 插入节点的叔叔节点是红色\n\t\t\t\t\tif ((xppr = xpp.right) != null && xppr.red) {\n\t\t\t\t\t\t// 将叔叔设置为黑色，父亲设为黑色，爷爷设为红色\n\t\t\t\t\t\txppr.red = false;\n\t\t\t\t\t\txp.red = false;\n\t\t\t\t\t\txpp.red = true;\n\t\t\t\t\t\t// 将 爷爷 设为当前插入节点，自底向上，重新变色\n\t\t\t\t\t\tx = xpp;\n\t\t\t\t\t}\n\t\t\t\t\t//L4.2：插入节点的叔叔节点是黑色或不存在\n\t\t\t\t\telse {\n\t\t\t\t\t\t// L4.2.1 插入节点是其父节点的右孩子\n\t\t\t\t\t\tif (x == xp.right) {\n\t\t\t\t\t\t\t// x 设置为 父节点\n\t\t\t\t\t\t\t// 将 父节点 左旋\n\t\t\t\t\t\t\t// 旋转之后，原父子关系对调，因此，x还是子节点\n\t\t\t\t\t\t\troot = rotateLeft(root, x = xp);\n\t\t\t\t\t\t\t// 将xp 设为父节点，xpp设为爷爷节点\n\t\t\t\t\t\t\txpp = (xp = x.parent) == null ? null : xp.parent;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// L4.2.1 插入节点是其父节点的左孩子\n\t\t\t\t\t\tif (xp != null) {\n\t\t\t\t\t\t\t// 父节点设为黑色\n\t\t\t\t\t\t\txp.red = false;\n\t\t\t\t\t\t\t// 如果 有爷爷节点\n\t\t\t\t\t\t\tif (xpp != null) {\n\t\t\t\t\t\t\t\t// 爷爷节点设置为红色\n\t\t\t\t\t\t\t\txpp.red = true;\n\t\t\t\t\t\t\t\t//  爷爷节点右旋\n\t\t\t\t\t\t\t\troot = rotateRight(root, xpp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// L5：插入的节点父节点和祖父节点都存在，并且其 父节点是祖父节点的右节点\n\t\t\t\telse {\n\t\t\t\t\t// L5.1：插入节点的叔叔节点是红色\n\t\t\t\t\tif (xppl != null && xppl.red) {\n\t\t\t\t\t\t// 将叔叔设置为黑色，父亲设为黑色，爷爷设为红色\n\t\t\t\t\t\txppl.red = false;\n\t\t\t\t\t\txp.red = false;\n\t\t\t\t\t\txpp.red = true;\n\t\t\t\t\t\t// 将 爷爷 设为当前插入节点，自底向上，重新变色\n\t\t\t\t\t\tx = xpp;\n\t\t\t\t\t}\n\t\t\t\t\t//L5.2：插入节点的叔叔节点是黑色或不存在\n\t\t\t\t\telse {\n\t\t\t\t\t\t// L5.2.1 插入节点是其父节点的左孩子\n\t\t\t\t\t\tif (x == xp.left) {\n\t\t\t\t\t\t\t// x 设置为 父节点\n\t\t\t\t\t\t\t// 将 父节点 右旋\n\t\t\t\t\t\t\t// 旋转之后，原父子关系对调，因此，x还是子节点\n\t\t\t\t\t\t\troot = rotateRight(root, x = xp);\n\t\t\t\t\t\t\txpp = (xp = x.parent) == null ? null : xp.parent;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// L5.2.2 插入节点是其父节点的右孩子\n\t\t\t\t\t\tif (xp != null) {\n\t\t\t\t\t\t\t// 父节点设为黑色\n\t\t\t\t\t\t\txp.red = false;\n\t\t\t\t\t\t\t// 如果 有爷爷 节点\n\t\t\t\t\t\t\tif (xpp != null) {\n\t\t\t\t\t\t\t\t// 爷爷节点设置为红色\n\t\t\t\t\t\t\t\txpp.red = true;\n\t\t\t\t\t\t\t\t//  爷爷节点右旋\n\t\t\t\t\t\t\t\troot = rotateLeft(root, xpp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n```\n\n# get方法\n```java\n\tpublic V get(Object key) {\n\t\tNode<K,V> e;\n\t\treturn (e = getNode(hash(key), key)) == null ? null : e.value;\n\t}\n```\n\n# getNode\n```java\n\t/**\n\t * Implements Map.get and related methods\n\t *\n\t * @param hash key 的hash值\n\t * @param key the key\n\t * @return the node, or null if none\n\t */\n\tfinal Node<K,V> getNode(int hash, Object key) {\n\t\tNode<K,V>[] tab; Node<K,V> first, e; int n; K k;\n\t\t// table 不为null && 不为空，并且 (n - 1) & hash 算出来的index位置有值\n\t\tif ((tab = table) != null && (n = tab.length) > 0 &&\n\t\t\t\t(first = tab[(n - 1) & hash]) != null) {\n\t\t\t// 判断第一个存在的节点的key 和 hash值是否与查询的key的相等，如果是直接返回\n\t\t\tif (first.hash == hash && // always check first node\n\t\t\t\t\t((k = first.key) == key || (key != null && key.equals(k))))\n\t\t\t\treturn first;\n\t\t\t// 遍历该链表/红黑树直到next为null\n\t\t\tif ((e = first.next) != null) {\n\t\t\t\t// 如果该点是红黑树\n\t\t\t\tif (first instanceof TreeNode)\n\t\t\t\t\t// 在树上寻找对应的值\n\t\t\t\t\treturn ((TreeNode<K,V>)first).getTreeNode(hash, key);\n\t\t\t\tdo {\n\t\t\t\t\t// 遍历链表\n\t\t\t\t\tif (e.hash == hash &&\n\t\t\t\t\t\t\t((k = e.key) == key || (key != null && key.equals(k))))\n\t\t\t\t\t\treturn e;\n\t\t\t\t} while ((e = e.next) != null);\n\t\t\t}\n\t\t}\n\t\t//否则不存在，返回null\n\t\treturn null;\n\t}\n```\n\n# remove 及其相关方法\n```java\n\tpublic V remove(Object key) {\n\t\tNode<K,V> e;\n\t\treturn (e = removeNode(hash(key), key, null, false, true)) == null ?\n\t\t\t\tnull : e.value;\n\t}\n```\n# removeNode 删除节点\n```java\n\t/**\n\t * Implements Map.remove and related methods\n\t *\n\t * @param hash key的hash值\n\t * @param key the key\n\t * @param value 传入匹配的value值，如果matchValue=false，直接忽略\n\t * @param matchValue 为true时，会去进一步匹配value\n\t * @param movable if false do not move other nodes while removing\n\t * @return the node, or null if none\n\t */\n\tfinal Node<K,V> removeNode(int hash, Object key, Object value,\n\t\t\t\t\t\t\t   boolean matchValue, boolean movable) {\n\t\tNode<K,V>[] tab; Node<K,V> p; int n, index;\n\t\t//确定table已经被初始化，并且其中有元素，并且对应的 hash值有元素\n\t\tif ((tab = table) != null && (n = tab.length) > 0 &&\n\t\t\t\t(p = tab[index = (n - 1) & hash]) != null) {\n\t\t\tNode<K,V> node = null, e; K k; V v;\n\t\t\t//判断当前这个找到的元素是不是目标元素，如果是的话赋值给node\n\t\t\tif (p.hash == hash &&\n\t\t\t\t\t((k = p.key) == key || (key != null && key.equals(k))))\n\t\t\t\tnode = p;\n\t\t\t//不是的话，就从相同hash值的所有元素中去查找\n\t\t\telse if ((e = p.next) != null) {\n\t\t\t\tif (p instanceof TreeNode)\n\t\t\t\t\t//该列表已经转换成红黑树的情况\n\t\t\t\t\tnode = ((TreeNode<K,V>)p).getTreeNode(hash, key);\n\t\t\t\telse {\n\t\t\t\t\t//在链表中查找的情况\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (e.hash == hash &&\n\t\t\t\t\t\t\t\t((k = e.key) == key ||\n\t\t\t\t\t\t\t\t\t\t(key != null && key.equals(k)))) {\n\t\t\t\t\t\t\tnode = e;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp = e;\n\t\t\t\t\t} while ((e = e.next) != null);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//找到了目标节点\n\t\t\tif (node != null && (!matchValue || (v = node.value) == value ||\n\t\t\t\t\t(value != null && value.equals(v)))) {\n\t\t\t\tif (node instanceof TreeNode)\n\t\t\t\t\t//是红黑树节点的情况\n\t\t\t\t\t((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);\n\t\t\t\telse if (node == p)\n\t\t\t\t\t//是一个链表开头元素的情况\n\t\t\t\t\ttab[index] = node.next;\n\t\t\t\telse\n\t\t\t\t\t//是一个链表中间元素的情况\n\t\t\t\t\tp.next = node.next;\n\t\t\t\t//结构改变，修改次数需要加一\n\t\t\t\t++modCount;\n\t\t\t\t//元素减少size减1\n\t\t\t\t--size;\n\t\t\t\tafterNodeRemoval(node);\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n```\n# removeTreeNode 红黑树中删除节点\n```java\n\t\tfinal void removeTreeNode(HashMap<K,V> map, Node<K,V>[] tab,\n\t\t\t\t\t\t\t\t  boolean movable) {\n\t\t\tint n;\n\t\t\t// 如果 table为空 或者为0 则无法删除，返回\n\t\t\tif (tab == null || (n = tab.length) == 0)\n\t\t\t\treturn;\n\t\t\tint index = (n - 1) & hash;\n\t\t\t// first 和 root 目前都为 根结点\n\t\t\tTreeNode<K,V> first = (TreeNode<K,V>)tab[index], root = first, rl;\n\t\t\t// succ 是要删除节点的下一个，prev是要删除节点的前一个\n\t\t\tTreeNode<K,V> succ = (TreeNode<K,V>)next, pred = prev;\n\t\t\t// 首先先从TreeNode链表里将这个节点删除掉。\n\t\t\tif (pred == null)\n\t\t\t\ttab[index] = first = succ;\n\t\t\telse\n\t\t\t\tpred.next = succ;\n\t\t\tif (succ != null)\n\t\t\t\tsucc.prev = pred;\n\t\t\tif (first == null)\n\t\t\t\treturn;\n\t\t\tif (root.parent != null)\n\t\t\t\troot = root.root();\n\t\t\t// 根结点为空 或 根节点的右儿子为空 或 根结点的做儿子为空 或 根节点的做儿子的做儿子为空\n\t\t\tif (root == null || root.right == null ||\n\t\t\t\t\t(rl = root.left) == null || rl.left == null) {\n\t\t\t\t// 树太小了，从红黑树转换为链表\n\t\t\t\ttab[index] = first.untreeify(map);  // too small\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// 从红黑树删除这个节点\n\t\t\t// p是要删除的节点 pl 是 p 的左节点, pr 是 P 的右节点。\n\t\t\tTreeNode<K,V> p = this, pl = left, pr = right, replacement;\n\t\t\t// 当 p 的左右节点都不为null\n\t\t\tif (pl != null && pr != null) {\n\t\t\t\t// s 是 p的右节点 的 左叶子节点 的左节点。。。循环找到叶子节点\n\t\t\t\t// 就是查找所有比当前节点大的节点当中最小的一个节点\n\t\t\t\tTreeNode<K,V> s = pr, sl;\n\t\t\t\twhile ((sl = s.left) != null) // find successor\n\t\t\t\t\ts = sl;\n\t\t\t\t//交换 s 和 p 节点的颜色\n\t\t\t\tboolean c = s.red; s.red = p.red; p.red = c; // swap colors\n\t\t\t\t// sr ：s的右节点\n\t\t\t\tTreeNode<K,V> sr = s.right;\n\t\t\t\t// pp ：p的父节点\n\t\t\t\tTreeNode<K,V> pp = p.parent;\n\t\t\t\t//2： 如果s 等于pr 证明 p的 右节点 没有 左节点\n\t\t\t\tif (s == pr) { // p was s's direct parent\n\t\t\t\t\t//当前节点的父节点设为找到的节点\n\t\t\t\t\tp.parent = s;\n\t\t\t\t\t//找到节点的右孩子设为当前节点\n\t\t\t\t\ts.right = p;\n\t\t\t\t}\n\t\t\t\t//3： p 的右节点有左儿子\n\t\t\t\t// （以下操作就是将s和p对换了个位置和颜色，\n\t\t\t\t// 如果s有右儿子则设置为平衡点，否则p为平衡点）\n\t\t\t\telse {\n\t\t\t\t\t// sp ： s的父亲\n\t\t\t\t\tTreeNode<K,V> sp = s.parent;\n\t\t\t\t\t// 将 p 的父亲设为 sp\n\t\t\t\t\t// 如果sp 不为null\n\t\t\t\t\tif ((p.parent = sp) != null) {\n\t\t\t\t\t\t// 当前节点替代 s 节点的位置，与 s 节点的父节点进行关联\n\t\t\t\t\t\t// s 是 sp 的左儿子，左儿子设置为 p\n\t\t\t\t\t\tif (s == sp.left)\n\t\t\t\t\t\t\tsp.left = p;\n\t\t\t\t\t\telse// s 是 sp 的右儿子，右儿子设置为 p\n\t\t\t\t\t\t\tsp.right = p;\n\t\t\t\t\t}\n\t\t\t\t\t// s 的右节点设置为 p 的右孩子\n\t\t\t\t\t// 如果 p 的右孩子不为null\n\t\t\t\t\t// 右孩子的父节点设为 s 节点\n\t\t\t\t\tif ((s.right = pr) != null)\n\t\t\t\t\t\tpr.parent = s;\n\t\t\t\t}\n\t\t\t\t//当前节点的左孩子设为null\n\t\t\t\tp.left = null;\n\t\t\t\t//将 p 节点的右孩子设置为 s节点的右孩子\n\t\t\t\tif ((p.right = sr) != null)\n\t\t\t\t\tsr.parent = p; //右孩子的父节点设为当前节点\n\t\t\t\t// 将 s 节点的左儿子设置为 p节点的左儿子\n\t\t\t\tif ((s.left = pl) != null)\n\t\t\t\t\tpl.parent = s;// 左孩子的父节点设为找到节点\n\t\t\t\t// 将s的父亲 设置为 p 节点的父亲\n\t\t\t\t// 如果 p是根结点，那么根节点变为s\n\t\t\t\tif ((s.parent = pp) == null)\n\t\t\t\t\troot = s;\n\t\t\t\t// 父节点不为null，当前节点是父节点的左孩子\n\t\t\t\telse if (p == pp.left)\n\t\t\t\t\t// 父亲的左儿子改为s\n\t\t\t\t\tpp.left = s;\n\t\t\t\telse\n\t\t\t\t\t// 父亲的右儿子改为s\n\t\t\t\t\tpp.right = s;\n\t\t\t\t// s节点的右孩子不为null\n\t\t\t\tif (sr != null)\n\t\t\t\t\t// 则s节点的右孩子节点作为平衡删除的初始节点\n\t\t\t\t\treplacement = sr;\n\t\t\t\telse\n\t\t\t\t\t// 否则平衡删除的初始节点为 p。\n\t\t\t\t\treplacement = p;\n\t\t\t}\n\t\t\t//当前节点左孩子不为null，右孩子为null\n\t\t\t//当前节点的左孩子作为平衡删除的节点\n\t\t\telse if (pl != null)\n\t\t\t\treplacement = pl;\n\t\t\t//当前节点右孩子不为null，左孩子为null\n\t\t\t// 当前节点的右孩子作为平衡删除的节点\n\t\t\telse if (pr != null)\n\t\t\t\treplacement = pr;\n\t\t\telse//左右孩子都为null，当前节点作为平衡删除的节点\n\t\t\t\treplacement = p;\n\t\t\t//如果当前节点不是作为平衡删除的节点\n\t\t\tif (replacement != p) {\n\t\t\t\t//此时p.parent有三种情况，1.其原来的父节点，2.它的右子节点，3.s节点的父节点sp\n\t\t\t\t//将当前节点的父节点设为平衡删除节点的父节点\n\t\t\t\tTreeNode<K,V> pp = replacement.parent = p.parent;\n\t\t\t\t//如果当前节点的父节点为null，则表明当前节点原来是根节点，此时当前节点的父节点还是其原来的父节点\n\t\t\t\tif (pp == null)\n\t\t\t\t\troot = replacement;//设置作为平衡删除的节点为根节点\n\t\t\t\t// 如果父节点不为null，并且当前节点是父节点的左子节点\n\t\t\t\telse if (p == pp.left)//设置父节点的左子节点为作为平衡删除的节点\n\t\t\t\t\tpp.left = replacement;\n\t\t\t\telse//设置父节点的右子节点为作为平衡删除的节点\n\t\t\t\t\tpp.right = replacement;\n\t\t\t\t//将当前节点与树结构断开，因为当前节点不是作为平衡删除的节点\n\t\t\t\tp.left = p.right = p.parent = null;\n\t\t\t}\n\t\t\t// 获取根节点，如果删除节点是红色，则不需要做平衡删除，根节点不会再变\n\t\t\t// 如果删除节点是黑色，则需要做平衡删除，根节点可能会发生改变\n\t\t\tTreeNode<K,V> r = p.red ? root : balanceDeletion(root, replacement);\n\n\t\t\t//做平衡删除的节点是当前要删除的节点\n\t\t\t//平衡删除做完后将该节点从树结构中脱离出来\n\t\t\tif (replacement == p) {  // detach\n\t\t\t\tTreeNode<K,V> pp = p.parent;\n\t\t\t\tp.parent = null;\n\t\t\t\tif (pp != null) {\n\t\t\t\t\tif (p == pp.left)\n\t\t\t\t\t\tpp.left = null;\n\t\t\t\t\telse if (p == pp.right)\n\t\t\t\t\t\tpp.right = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//是否需要从新设置桶的头节点\n\t\t\tif (movable)\n\t\t\t\t//将桶的头节点设为根节点\n\t\t\t\tmoveRootToFront(tab, r);\n\t\t}\n```\n# balanceDeletion 红黑树删除平衡\n```java\n\t\t/**\n\t\t * 红黑树平衡删除，只有在删除的节点是黑色时才会调用此方法\n\t\t * @param root 根结点\n\t\t * @param x 平衡节点\n\t\t * @return\n\t\t */\n\t\tstatic <K,V> TreeNode<K,V> balanceDeletion(TreeNode<K,V> root,\n\t\t\t\t\t\t\t\t\t\t\t\t   TreeNode<K,V> x) {\n\t\t\tfor (TreeNode<K,V> xp, xpl, xpr;;)  {\n\t\t\t\t//平衡节点为null或者平衡节点是根节点，无需做平衡处理，返回根节点\n\t\t\t\tif (x == null || x == root)\n\t\t\t\t\treturn root;\n\t\t\t\t//平衡节点不是根，但平衡节点的父节点是null\n\t\t\t\t//则将平衡节点将成为根节点，将其颜色设置为黑色\n\t\t\t\telse if ((xp = x.parent) == null) {\n\t\t\t\t\tx.red = false;\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t\t//不是根节点，父节点也不为null，\n\t\t\t\t//若做平衡的节点就是要删除的节点，则设什么颜色都无所谓，直接返回根节点\n\t\t\t\t//若做平衡的节点不是要删除的节点，而且还是红色\n\t\t\t\t//则其要替换的节点就是其父节点，替换的父节点就是要删除的节点，\n\t\t\t\t//而做平衡的节点还是红色，则其父一定是黑色，其替换其父所以要变成黑色\n\t\t\t\t//因为做平衡的节点是红，它替换掉了其父（在进入此方法之前已经替换掉了）\n\t\t\t\t//其父是黑，所以只需要确保其是黑，就能确保该树枝上的黑色节点数不变\n\t\t\t\t//替换完直接返回根节点即可\n\t\t\t\telse if (x.red) {\n\t\t\t\t\tx.red = false;\n\t\t\t\t\treturn root;\n\t\t\t\t}\n\t\t\t\t//x的节点不是根，父也不为null，其颜色是黑色\n\t\t\t\t//x的节点是其父的左子节点\n\t\t\t\telse if ((xpl = xp.left) == x) {\n\t\t\t\t\t//如果它有红色的兄弟节点xpr，那么它的父亲节点xp一定是黑色节点\n\t\t\t\t\t// 将兄弟节点设为黑色，父亲节点设为红色，以父节点进行旋转\n\t\t\t\t\tif ((xpr = xp.right) != null && xpr.red) {\n\t\t\t\t\t\txpr.red = false;\n\t\t\t\t\t\txp.red = true;\n\t\t\t\t\t\t//对父节点xp做左旋转\n\t\t\t\t\t\troot = rotateLeft(root, xp);\n\t\t\t\t\t\t//重新将xp指向x的父节点，xpr指向xp新的右孩子\n\t\t\t\t\t\txpr = (xp = x.parent) == null ? null : xp.right;\n\t\t\t\t\t}\n\t\t\t\t\t//如果xpr为空，则向上继续调整，将x的父节点xp作为新的x继续循环\n\t\t\t\t\tif (xpr == null)\n\t\t\t\t\t\tx = xp;\n\t\t\t\t\telse {\n\t\t\t\t\t\t//sl和sr分别为其兄弟节点左儿子和右儿子\n\t\t\t\t\t\tTreeNode<K,V> sl = xpr.left, sr = xpr.right;\n\t\t\t\t\t\t//若sl和sr都为黑色或者不存在，即xpr没有红色孩子，则将xpr染红\n\t\t\t\t\t\tif ((sr == null || !sr.red) &&\n\t\t\t\t\t\t\t\t(sl == null || !sl.red)) {\n\t\t\t\t\t\t\txpr.red = true;\n\t\t\t\t\t\t\tx = xp;//本轮结束，继续向上循环\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t//否则的话，就需要进一步调整\n\t\t\t\t\t\t\tif (sr == null || !sr.red) {\n\t\t\t\t\t\t\t\t//若左孩子为红，右孩子不存在或为黑\n\t\t\t\t\t\t\t\tif (sl != null)\n\t\t\t\t\t\t\t\t\t//左孩子染黑\n\t\t\t\t\t\t\t\t\tsl.red = false;\n\t\t\t\t\t\t\t\t//将xpr染红\n\t\t\t\t\t\t\t\txpr.red = true;\n\t\t\t\t\t\t\t\t//右旋\n\t\t\t\t\t\t\t\troot = rotateRight(root, xpr);\n\t\t\t\t\t\t\t\t//右旋后，xpr指向xp的新右孩子，即上一步中的sl\n\t\t\t\t\t\t\t\txpr = (xp = x.parent) == null ?\n\t\t\t\t\t\t\t\t\t\tnull : xp.right;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// 如果兄弟节点 不为null\n\t\t\t\t\t\t\tif (xpr != null) {\n\t\t\t\t\t\t\t\t// 如果父节点为空，兄弟节点染为黑色，否则和父亲节点染色相同\n\t\t\t\t\t\t\t\txpr.red = (xp == null) ? false : xp.red;\n\t\t\t\t\t\t\t\t// sr 设置为兄弟节点的右孩子，如果sr不为null，将sr设置为黑色，防止出现两个红色相连\n\t\t\t\t\t\t\t\tif ((sr = xpr.right) != null)\n\t\t\t\t\t\t\t\t\tsr.red = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// 如果父节点不为null\n\t\t\t\t\t\t\tif (xp != null) {\n\t\t\t\t\t\t\t\t//将父亲节点设置为黑色\n\t\t\t\t\t\t\t\txp.red = false;\n\t\t\t\t\t\t\t\t// 左旋父节点\n\t\t\t\t\t\t\t\troot = rotateLeft(root, xp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tx = root;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//x为其父节点的右孩子，跟上面操作镜像\n\t\t\t\telse { // symmetric\n\t\t\t\t\tif (xpl != null && xpl.red) {\n\t\t\t\t\t\txpl.red = false;\n\t\t\t\t\t\txp.red = true;\n\t\t\t\t\t\troot = rotateRight(root, xp);\n\t\t\t\t\t\txpl = (xp = x.parent) == null ? null : xp.left;\n\t\t\t\t\t}\n\t\t\t\t\tif (xpl == null)\n\t\t\t\t\t\tx = xp;\n\t\t\t\t\telse {\n\t\t\t\t\t\tTreeNode<K,V> sl = xpl.left, sr = xpl.right;\n\t\t\t\t\t\tif ((sl == null || !sl.red) &&\n\t\t\t\t\t\t\t\t(sr == null || !sr.red)) {\n\t\t\t\t\t\t\txpl.red = true;\n\t\t\t\t\t\t\tx = xp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (sl == null || !sl.red) {\n\t\t\t\t\t\t\t\tif (sr != null)\n\t\t\t\t\t\t\t\t\tsr.red = false;\n\t\t\t\t\t\t\t\txpl.red = true;\n\t\t\t\t\t\t\t\troot = rotateLeft(root, xpl);\n\t\t\t\t\t\t\t\txpl = (xp = x.parent) == null ?\n\t\t\t\t\t\t\t\t\t\tnull : xp.left;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (xpl != null) {\n\t\t\t\t\t\t\t\txpl.red = (xp == null) ? false : xp.red;\n\t\t\t\t\t\t\t\tif ((sl = xpl.left) != null)\n\t\t\t\t\t\t\t\t\tsl.red = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (xp != null) {\n\t\t\t\t\t\t\t\txp.red = false;\n\t\t\t\t\t\t\t\troot = rotateRight(root, xp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tx = root;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n```\n\n# rotateLeft 红黑树左旋（右旋转同理）\n```java\n\t\t/**\n\t\t * 红黑树左旋\n\t\t * @param root 根节点\n\t\t * @param p 要左旋的节点\n\t\t *\n\t\t * @return\n\t\t */\n\t\tstatic <K,V> TreeNode<K,V> rotateLeft(TreeNode<K,V> root,\n\t\t\t\t\t\t\t\t\t\t\t  TreeNode<K,V> p) {\n\t\t\t// pp : p的父亲\n\t\t\t// r: p的右孩子\n\t\t\t// rl = p 的右孩子的左孩子 -> r的左孩子\n\t\t\tTreeNode<K,V> r, pp, rl;\n\t\t\t// 要 p 以及 p的右孩子 不为null\n\t\t\tif (p != null && (r = p.right) != null) {\n\t\t\t\t// 将p 的右孩子 设置为 rl 并且 rl不为空\n\t\t\t\tif ((rl = p.right = r.left) != null)\n\t\t\t\t\t// rl的父亲节点设置为p\n\t\t\t\t\trl.parent = p;\n\t\t\t\t// 将 r 的父亲 设置为 p的父亲（此时r 与p为兄弟）\n\t\t\t\t// 如果父亲节点为null，则此时 r为跟节点\n\t\t\t\t// 将root 设置为r ，并设置为黑色\n\t\t\t\tif ((pp = r.parent = p.parent) == null)\n\t\t\t\t\t(root = r).red = false;\n\t\t\t\t// 如果父节点的左儿子是 p\n\t\t\t\telse if (pp.left == p)\n\t\t\t\t\t// 将父节点的 左儿子 设为r\n\t\t\t\t\tpp.left = r;\n\t\t\t\telse\n\t\t\t\t\t// 否则将 右儿子 设为r\n\t\t\t\t\tpp.right = r;\n\t\t\t\t// 将 r 的左节儿子 设置为p\n\t\t\t\tr.left = p;\n\t\t\t\t// p 的父亲设置为 r\n\t\t\t\tp.parent = r;\n\t\t\t}\n\t\t\t// 返回根节点\n\t\t\treturn root;\n\t\t}\n```\n","source":"_posts/Java-HashMap.md","raw":"---\ntitle: JAVA-HashMap源码解析\ndate: 2020-03-05 15:07:00\ntags:\n    - JAVA\n    - 源码\n    - 学习笔记\ncategories: JAVA\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n# HashMap 的存储结构\nHashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的\n```java\n\tstatic class Node<K,V> implements Map.Entry<K,V> {\n\t\tfinal int hash;// key的hash值\n\t\tfinal K key; // key\n\t\tV value; // value\n\t\tNode<K,V> next; //同一个hash值下的链表/红黑树\n\n\t\tNode(int hash, K key, V value, Node<K,V> next) {\n\t\t\tthis.hash = hash;\n\t\t\tthis.key = key;\n\t\t\tthis.value = value;\n\t\t\tthis.next = next;\n\t\t}\n\n\t\tpublic final K getKey()        { return key; }\n\t\tpublic final V getValue()      { return value; }\n\t\tpublic final String toString() { return key + \"=\" + value; }\n\n\t\tpublic final int hashCode() {\n\t\t\treturn Objects.hashCode(key) ^ Objects.hashCode(value);\n\t\t}\n\n\t\tpublic final V setValue(V newValue) {\n\t\t\tV oldValue = value;\n\t\t\tvalue = newValue;\n\t\t\treturn oldValue;\n\t\t}\n\n\t\tpublic final boolean equals(Object o) {\n\t\t\tif (o == this)\n\t\t\t\treturn true;\n\t\t\tif (o instanceof Map.Entry) {\n\t\t\t\tMap.Entry<?,?> e = (Map.Entry<?,?>)o;\n\t\t\t\tif (Objects.equals(key, e.getKey()) &&\n\t\t\t\t\t\tObjects.equals(value, e.getValue()))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n```\nTreeNode<K,V> 继承 LinkedHashMap.Entry<K,V>，用来实现红黑树相关的存储结构\n```java\n     static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n         TreeNode<K,V> parent;  // 存储当前节点的父节点\n         TreeNode<K,V> left;　// 存储当前节点的左孩子\n         TreeNode<K,V> right;　// 存储当前节点的右孩子\n         TreeNode<K,V> prev;    // prev则指向前一个节点（原链表中的前一个节点）\n         boolean red;　// 存储当前节点的颜色（红、黑）\n         TreeNode(int hash, K key, V val, Node<K,V> next) {\n             super(hash, key, val, next);\n         }\n \n         final TreeNode<K,V> root() {\n         }\n \n         static <K,V> void moveRootToFront(Node<K,V>[] tab, TreeNode<K,V> root) {\n         }\n \n         final TreeNode<K,V> find(int h, Object k, Class<?> kc) {\n         }\n \n         final void treeify(Node<K,V>[] tab) {\n         }\n \n         final Node<K,V> untreeify(HashMap<K,V> map) {\n         }\n \n         final TreeNode<K,V> putTreeVal(HashMap<K,V> map, Node<K,V>[] tab,\n                                        int h, K k, V v) {\n         }\n \n         final void removeTreeNode(HashMap<K,V> map, Node<K,V>[] tab,\n                                   boolean movable) {\n         }\n \n         final void split(HashMap<K,V> map, Node<K,V>[] tab, int index, int bit) {\n         }\n \n         /* ------------------------------------------------------------ */\n         // Red-black tree methods, all adapted from CLR\n         // 红黑树相关操作\n         static <K,V> TreeNode<K,V> rotateLeft(TreeNode<K,V> root,\n                                               TreeNode<K,V> p) {\n         }\n \n         static <K,V> TreeNode<K,V> rotateRight(TreeNode<K,V> root,\n                                                TreeNode<K,V> p) {\n         }\n \n         static <K,V> TreeNode<K,V> balanceInsertion(TreeNode<K,V> root,\n                                                     TreeNode<K,V> x) {\n         }\n \n         static <K,V> TreeNode<K,V> balanceDeletion(TreeNode<K,V> root,\n                                                    TreeNode<K,V> x) {\n         }       \n \n         static <K,V> boolean checkInvariants(TreeNode<K,V> t) {\n         }\n \n     }\n```\n\n# 各常量、成员变量作用　　\n```java\n\t/**\n\t * 默认初始容量\n\t */\n\tstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n\n\t/**\n\t * 最大容量， 当传入容量过大时将被这个值替换\n\t */\n\tstatic final int MAXIMUM_CAPACITY = 1 << 30;\n\n\t/**\n\t * 默认负载因子\n\t */\n\tstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n\t/**\n\t * 当链表的长度超过8，有可能会转化成树\n\t */\n\tstatic final int TREEIFY_THRESHOLD = 8;\n\n\t/**\n\t * 当链表的长度小于6则会从红黑树转回链表\n\t */\n\tstatic final int UNTREEIFY_THRESHOLD = 6;\n\n\t/**\n\t * 在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。\n\t * 这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。\n\t */\n\tstatic final int MIN_TREEIFY_CAPACITY = 64;\n\n\t/**\n\t * 用来存储 key-value 的节点对象。在 HashMap 中它有个专业的叫法 buckets ，中文叫作桶。\n\t */\n\ttransient Node<K,V>[] table;\n\n\t/**\n\t * 同时封装了 keySet 和 values 的视图\n\t */\n\ttransient Set<Map.Entry<K,V>> entrySet;\n\n\t/**\n\t * 容器中实际存放 Node 的大小\n\t */\n\ttransient int size;\n\n\t/**\n\t * HashMap 在结构上被修改的次数，结构修改是指改变HashMap中映射的次数，或者以其他方式修改其内部结构(例如，rehash)。\n\t */\n\ttransient int modCount;\n\n\t/**\n\t * HashMap的扩容阈值(=负载因子*table的容量)\n\t * 在HashMap中存储的Node键值对超过这个数量时，自动扩容容量为原来的二倍\n\t * @serial\n\t */\n\tint threshold;\n\n\t/**\n\t * 负载因子\n\t * @serial\n\t */\n\tfinal float loadFactor;\n```\n# 构造方法\n```java\n\t/**\n\t * Constructs an empty <tt>HashMap</tt> with the specified initial\n\t * capacity and load factor.\n\t *\n\t * @param  initialCapacity 初始容量\n\t * @param  loadFactor      负载因子\n\t * @throws IllegalArgumentException 如果初始容量为负或者负载因子非正数抛出该异常\n\t */\n\tpublic HashMap(int initialCapacity, float loadFactor) {\n\t\t// 当初始容量为负\n\t\tif (initialCapacity < 0)\n\t\t\tthrow new IllegalArgumentException(\"Illegal initial capacity: \" +\n\t\t\t\t\tinitialCapacity);\n\t\t// 当初始容量大于最大容量 2^30 ，初始容量= 2^30\n\t\tif (initialCapacity > MAXIMUM_CAPACITY)\n\t\t\tinitialCapacity = MAXIMUM_CAPACITY;\n\t\t// 当负载因子非正数 或 负载因子是NaN(Not a Number，0.0f/0.0f的值就是NaN)\n\t\tif (loadFactor <= 0 || Float.isNaN(loadFactor))\n\t\t\tthrow new IllegalArgumentException(\"Illegal load factor: \" +\n\t\t\t\t\tloadFactor);\n\t\t// 赋值\n\t\tthis.loadFactor = loadFactor;\n\t\tthis.threshold = tableSizeFor(initialCapacity);\n\t}\n\n\t/**\n\t * 获取比传入参数大的最小的2的N次幂。\n\t */\n\tstatic final int tableSizeFor(int cap) {\n\t\tint n = cap - 1;\n\t\tn |= n >>> 1;\n\t\tn |= n >>> 2;\n\t\tn |= n >>> 4;\n\t\tn |= n >>> 8;\n\t\tn |= n >>> 16;\n\t\treturn (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n\t}\n```\n\n# put方法\nput方法主要是调用putVal方法\n```java\n\t/**\n\t * 使 key 和 value 产生关联，但如果有相同的 key 则新的会替换掉旧的。\n\t */\n\tpublic V put(K key, V value) {\n\t\treturn putVal(hash(key), key, value, false, true);\n\t}\n\n\t/**\n\t * h >>> 16:无符号右移动16位，意味着取高16位二进制\n\t * 低16位与高16位进行异或\n\t */\n\tstatic final int hash(Object key) {\n\t\tint h;\n\t\t// 如果为 null 则返回的就是 0，否则就是 hashCode 异或上 hashCode 无符号右移 16 位\n\t\treturn (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n\t}\n```\n\n# putVal方法\n```java\n\t/**\n\t * Implements Map.put and related methods\n\t *\n\t * @param hash key的hash值\n\t * @param key the key\n\t * @param value the value to put\n\t * @param onlyIfAbsent 如果true代表不更改现有的值\n\t * @param evict 如果为false表示table为创建状态\n\t * @return previous value, or null if none\n\t */\n\tfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n\t\t\t\t   boolean evict) {\n\t\tNode<K,V>[] tab; Node<K,V> p; int n, i;\n\t\t/**\n\t\t * 判断table是否等于空或者table的长度等于0，如果是就进行初始化\n\t\t * 此时通过resize()方法得到初始化的table\n\t\t */\n\t\tif ((tab = table) == null || (n = tab.length) == 0)\n\t\t\tn = (tab = resize()).length;\n\t\t/**\n\t\t * 对hash码进行散列 ，对值的位置进行确认\n\t\t * 如果tab[i] 为null 表示没有hash冲突，就新增一个元素\n\t\t */\n\t\tif ((p = tab[i = (n - 1) & hash]) == null)\n\t\t\ttab[i] = newNode(hash, key, value, null);\n\t\telse {\n\t\t\t// 如果tab[i] 不为null，表示该位置有值了。\n\t\t\tNode<K,V> e; K k;\n\t\t\t//HashMap中判断key相同的条件是key的hash相同，并且符合equals方法。这里判断了p.key是否和插入的key相等，如果相等，则将p的引用赋给e\n\t\t\t//这里为什么要把p赋值给e，而不是直接覆盖原值呢？答案很简单，现在我们只判断了第一个节点，后面还可能出现key相同，所以需要在最后一并处理\n\t\t\tif (p.hash == hash &&\n\t\t\t\t\t((k = p.key) == key || (key != null && key.equals(k))))\n\t\t\t\te = p;\n\t\t\t/**\n\t\t\t * 判断是否是红黑树\n\t\t\t * p是红黑树节点，那么肯定插入后仍然是红黑树节点，所以我们直接强制转型p后调用TreeNode.putTreeVal方法，返回的引用赋给e\n\t\t\t */\n\t\t\telse if (p instanceof TreeNode)\n\t\t\t\te = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n\t\t\t// 否则就是链表\n\t\t\telse {\n\t\t\t\t// 如果是链表，要遍历到最后一个节点进行插入\n\t\t\t\tfor (int binCount = 0; ; ++binCount) {\n\t\t\t\t\tif ((e = p.next) == null) {\n\t\t\t\t\t\t// 插入到链尾\n\t\t\t\t\t\tp.next = newNode(hash, key, value, null);\n\t\t\t\t\t\t// 判断节点的长度是否大于TREEIFY_THRESHOLD红黑树的阈值，是就进行转换\n\t\t\t\t\t\tif (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n\t\t\t\t\t\t\ttreeifyBin(tab, hash);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// 对链表中的相同 hash 值且 key 相同的进一步作检查\n\t\t\t\t\tif (e.hash == hash &&\n\t\t\t\t\t\t\t((k = e.key) == key || (key != null && key.equals(k))))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tp = e;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/**\n\t\t\t * 插入\n\t\t\t */\n\t\t\tif (e != null) { // existing mapping for key\n\t\t\t\t// 取出旧值，onlyIfAbsent此时为 false，所以不管 oldValue 有与否，都拿新值来替换\n\t\t\t\tV oldValue = e.value;\n\t\t\t\tif (!onlyIfAbsent || oldValue == null)\n\t\t\t\t\te.value = value;\n\t\t\t\tafterNodeAccess(e);\n\t\t\t\treturn oldValue;\n\t\t\t}\n\t\t}\n\t\t// 记录修改次数\n\t\t++modCount;\n\t\t// 超过阈值 threshold = capacity * factor，调用 resize() 进行扩容\n\t\tif (++size > threshold)\n\t\t\tresize();\n\t\tafterNodeInsertion(evict);\n\t\treturn null;\n\t}\n```\n\n# resize 扩容兼初始化\n```java\n\t/**\n\t * Initializes or doubles table size.  If null, allocates in\n\t * accord with initial capacity target held in field threshold.\n\t * Otherwise, because we are using power-of-two expansion, the\n\t * elements from each bin must either stay at same index, or move\n\t * with a power of two offset in the new table.\n\t * 扩容兼初始化\n\t * @return the table\n\t */\n\tfinal Node<K,V>[] resize() {\n\t\t//将原来的table指针保存\n\t\tNode<K,V>[] oldTab = table;\n\t\t//获取原来数组的长度，oldTab为null说明还没有进行初始化\n\t\tint oldCap = (oldTab == null) ? 0 : oldTab.length;\n\t\t//保存以前重构table的阈值\n\t\tint oldThr = threshold;\n\t\tint newCap, newThr = 0;\n\t\t//oldCap > 0表示已经初始化过了\n\t\tif (oldCap > 0) {\n\t\t\t//当原来的容量已经达到最大容量的时候，将阈值设置为Integer.MAX_VALUE，这样就不会再发生重构的情况\n\t\t\tif (oldCap >= MAXIMUM_CAPACITY) {\n\t\t\t\tthreshold = Integer.MAX_VALUE;\n\t\t\t\treturn oldTab;\n\t\t\t}\n\t\t\t// 否则将旧的容量扩大两倍\n\t\t\t// 当它小于最大容量，并且旧的容量大于初始化最小容量的时候，\n\t\t\t// 将新的阈值设置为旧的阈值的两倍, 新的容量设置为旧容量的2倍\n\t\t\telse if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n\t\t\t\t\toldCap >= DEFAULT_INITIAL_CAPACITY)\n\t\t\t\tnewThr = oldThr << 1; // double threshold\n\t\t}\n\t\t//虽然还没有初始化，但是设置过了阈值，将旧的阈值设置为新的容量\n\t\telse if (oldThr > 0) // initial capacity was placed in threshold\n\t\t\tnewCap = oldThr;\n\t\telse {\n\t\t\t//没有初始化阈值的时候采用默认算法计算阈值\n\t\t\tnewCap = DEFAULT_INITIAL_CAPACITY;\n\t\t\tnewThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n\t\t}\n\t\t// 对应oldCap = 0 && oldThr > 0的情况\n\t\tif (newThr == 0) {\n\t\t\t//重新用默认负载因子计算 扩容阈值\n\t\t\tfloat ft = (float)newCap * loadFactor;\n\t\t\t// 如果新容量小于最大容量 && 新扩容阈值(ft) 小于最大容量\n\t\t\t// 新阈值 = ft 否则 新阈值 = int的最大范围\n\t\t\tnewThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n\t\t\t\t\t(int)ft : Integer.MAX_VALUE);\n\t\t}\n\t\t// 把当前阈值设为新阈值\n\t\tthreshold = newThr;\n\t\t// 根据新容量，创建新table\n\t\t@SuppressWarnings({\"rawtypes\",\"unchecked\"})\n\t\tNode<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n\t\t// 将当前table 设置为新扩容的table\n\t\ttable = newTab;\n\t\t// 如果已经被初始化过\n\t\tif (oldTab != null) {\n\t\t\t//将旧数组中的元素全部取出，重新映射到新数组中\n\t\t\tfor (int j = 0; j < oldCap; ++j) {\n\t\t\t\tNode<K,V> e;\n\t\t\t\tif ((e = oldTab[j]) != null) {\n\t\t\t\t\toldTab[j] = null;\n\t\t\t\t\tif (e.next == null)\n\t\t\t\t\t\t// 该节点没有next节点，表示没有链表，没有冲突，那重新计算下位置\n\t\t\t\t\t\tnewTab[e.hash & (newCap - 1)] = e;\n\t\t\t\t\telse if (e instanceof TreeNode)\n\t\t\t\t\t\t// 冲突的是一棵树节点，分裂成 2 个树，或者如果树很小就转成链表\n\t\t\t\t\t\t((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n\t\t\t\t\telse {\n\t\t\t\t\t\t// 对原来的链表部分进行重构\n\t\t\t\t\t\tNode<K,V> loHead = null, loTail = null;\n\t\t\t\t\t\tNode<K,V> hiHead = null, hiTail = null;\n\t\t\t\t\t\tNode<K,V> next;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tnext = e.next;\n\t\t\t\t\t\t\t// 索引不变\n\t\t\t\t\t\t\tif ((e.hash & oldCap) == 0) {\n\t\t\t\t\t\t\t\tif (loTail == null)\n\t\t\t\t\t\t\t\t\tloHead = e;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tloTail.next = e;\n\t\t\t\t\t\t\t\tloTail = e;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// 原索引+oldCap\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (hiTail == null)\n\t\t\t\t\t\t\t\t\thiHead = e;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\thiTail.next = e;\n\t\t\t\t\t\t\t\thiTail = e;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while ((e = next) != null);\n\t\t\t\t\t\t// 原索引放到 tables 里\n\t\t\t\t\t\tif (loTail != null) {\n\t\t\t\t\t\t\tloTail.next = null;\n\t\t\t\t\t\t\tnewTab[j] = loHead;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 原索引+oldCap放到  tables 里\n\t\t\t\t\t\tif (hiTail != null) {\n\t\t\t\t\t\t\thiTail.next = null;\n\t\t\t\t\t\t\tnewTab[j + oldCap] = hiHead;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 返回扩容后的table\n\t\treturn newTab;\n\t}\n```\n# split 扩容时重新划分树\n\n```java\n\t\t/**\n\t\t * 扩容时重新划分树\n\t\t * @param map the map\n\t\t * @param tab 扩容后的数组\n\t\t * @param index 数组索引\n\t\t * @param bit 原数组容量\n\t\t */\n\t\tfinal void split(HashMap<K,V> map, Node<K,V>[] tab, int index, int bit) {\n\t\t\t//b设置为当前桶的头节点\n\t\t\tTreeNode<K,V> b = this;\n\t\t\t// Relink into lo and hi lists, preserving order\n\t\t\t//低位树链表头节点，尾结点\n\t\t\tTreeNode<K,V> loHead = null, loTail = null;\n\t\t\t//高位树链表头节点，尾结点\n\t\t\tTreeNode<K,V> hiHead = null, hiTail = null;\n\t\t\t//lc低位树链表中节点个数，hc高位树链表中节点个数\n\t\t\tint lc = 0, hc = 0;\n\t\t\t//e当前遍历节点\n\t\t\tfor (TreeNode<K,V> e = b, next; e != null; e = next) {\n\t\t\t\t//当前遍历节点的后继节点\n\t\t\t\tnext = (TreeNode<K,V>)e.next;\n\t\t\t\t//将当前遍历节点后继设为null\n\t\t\t\te.next = null;\n\t\t\t\tif ((e.hash & bit) == 0) {\n\t\t\t\t\t//==0表示当前遍历节点应该存放在低位\n\t\t\t\t\t//如果低位中还没有节点\n\t\t\t\t\t//将当前遍历节点设为低位头节点\n\t\t\t\t\tif ((e.prev = loTail) == null)\n\t\t\t\t\t\tloHead = e;\n\t\t\t\t\telse\n\t\t\t\t\t\t//将当前遍历节点加入到链表的尾部\n\t\t\t\t\t\tloTail.next = e;\n\t\t\t\t\t//设置尾节点为当前遍历节点\n\t\t\t\t\tloTail = e;\n\t\t\t\t\t//低位链表中的节点数加1\n\t\t\t\t\t++lc;\n\t\t\t\t}\n\t\t\t\t//!=0表示当前遍历节点应该存放在高位\n\t\t\t\telse {\n\t\t\t\t\tif ((e.prev = hiTail) == null)\n\t\t\t\t\t\thiHead = e;\n\t\t\t\t\telse\n\t\t\t\t\t\thiTail.next = e;\n\t\t\t\t\thiTail = e;\n\t\t\t\t\t++hc;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//如果低位节点链表不为null\n\t\t\tif (loHead != null) {\n\t\t\t\t//低位节点链表中节点的个数小于6，此时需要将树结构转为链表结构\n\t\t\t\tif (lc <= UNTREEIFY_THRESHOLD)\n\t\t\t\t\ttab[index] = loHead.untreeify(map);\n\t\t\t\telse {//链表中节点的个数满足保持树型结构所需要的节点个数\n\t\t\t\t\t//低位桶的头节点设为链表的头节点\n\t\t\t\t\ttab[index] = loHead;\n\t\t\t\t\t// 高位节点链表不为null，说明有节点从原树结构中分离出去了\n\t\t\t\t\t// 原有树结构被破坏\n\t\t\t\t\t// 所以低位的节点链表需要重新构建树结构\n\t\t\t\t\tif (hiHead != null) // (else is already treeified)\n\t\t\t\t\t\tloHead.treeify(tab);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 同理\n\t\t\tif (hiHead != null) {\n\t\t\t\tif (hc <= UNTREEIFY_THRESHOLD)\n\t\t\t\t\ttab[index + bit] = hiHead.untreeify(map);\n\t\t\t\telse {\n\t\t\t\t\ttab[index + bit] = hiHead;\n\t\t\t\t\tif (loHead != null)\n\t\t\t\t\t\thiHead.treeify(tab);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n```\n\n# putTreeVal 在红黑树中添加节点\n```java\n\t\t/**\n\t\t *\n\t\t * @param map 当前节点所在的HashMap对象\n\t\t * @param tab 当前HashMap对象的元素数组\n\t\t * @param h key的hash值\n\t\t * @param k key\n\t\t * @param v value\n\t\t * @return 指定key所匹配到的节点对象，针对这个对象去修改V（返回空说明创建了一个新节点）\n\t\t */\n\t\tfinal TreeNode<K,V> putTreeVal(HashMap<K,V> map, Node<K,V>[] tab,\n\t\t\t\t\t\t\t\t\t   int h, K k, V v) {\n\t\t\t// 定义k的Class对象\n\t\t\tClass<?> kc = null;\n\t\t\t// 标识是否已经遍历过一次树，未必是从根节点遍历的，但是遍历路径上一定已经包含了后续需要比对的所有节点。\n\t\t\tboolean searched = false;\n\t\t\t//父节点不为空那么查找根节点，为空那么自身就是根节点\n\t\t\tTreeNode<K,V> root = (parent != null) ? root() : this;\n\t\t\t// 从根节点开始遍历，没有终止条件，只能从内部退出\n\t\t\tfor (TreeNode<K,V> p = root;;) {\n\t\t\t\t// 声明方向、当前节点hash值、当前节点的键对象\n\t\t\t\tint dir, ph; K pk;\n\t\t\t\t// 如果当前节点hash 大于 指定key的hash值,要添加的元素应该放置在当前节点的左侧\n\t\t\t\tif ((ph = p.hash) > h)\n\t\t\t\t\tdir = -1;\n\t\t\t\t// 如果当前节点hash 小于 指定key的hash值,要添加的元素应该放置在当前节点的右侧\n\t\t\t\telse if (ph < h)\n\t\t\t\t\tdir = 1;\n\t\t\t\t// 如果当前节点的键对象 和 指定key对象相同,那么就返回当前节点对象\n\t\t\t\telse if ((pk = p.key) == k || (k != null && k.equals(pk)))\n\t\t\t\t\treturn p;\n\t\t\t\t// 走到这一步说明 当前节点的hash值  和 指定key的hash值  是相等的，但是equals不等\n\t\t\t\telse if ((kc == null &&\n\t\t\t\t\t\t(kc = comparableClassFor(k)) == null) ||\n\t\t\t\t\t\t(dir = compareComparables(kc, k, pk)) == 0) {\n\t\t\t\t\t// 走到这里说明：指定key没有实现comparable接口   或者   实现了comparable接口并且和当前节点的键对象比较之后相等（仅限第一次循环）\n\t\t\t\t\t/**\n\t\t\t\t\t * searched 标识是否已经对比过当前节点的左右子节点了\n\t\t\t\t\t * 如果还没有遍历过，那么就递归遍历对比，看是否能够得到那个键对象equals相等的的节点\n\t\t\t\t\t * 如果得到了键的equals相等的的节点就返回\n\t\t\t\t\t * 如果还是没有键的equals相等的节点，那说明应该创建一个新节点了\n\t\t\t\t\t */\n\t\t\t\t\tif (!searched) {// 如果还没有比对过当前节点的所有子节点\n\t\t\t\t\t\t// 定义要返回的节点、和子节点\n\t\t\t\t\t\tTreeNode<K,V> q, ch;\n\t\t\t\t\t\t// 标识已经遍历过一次了\n\t\t\t\t\t\tsearched = true;\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * 红黑树也是二叉树，所以只要沿着左右两侧遍历寻找就可以了\n\t\t\t\t\t\t * 这是个短路运算，如果先从左侧就已经找到了，右侧就不需要遍历了\n\t\t\t\t\t\t * find 方法内部还会有递归调用\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (((ch = p.left) != null &&\n\t\t\t\t\t\t\t\t(q = ch.find(h, k, kc)) != null) ||\n\t\t\t\t\t\t\t\t((ch = p.right) != null &&\n\t\t\t\t\t\t\t\t\t\t(q = ch.find(h, k, kc)) != null))\n\t\t\t\t\t\t\t// 找到了指定key键对应的\n\t\t\t\t\t\t\treturn q;\n\t\t\t\t\t}\n\t\t\t\t\t// 走到这里就说明，遍历了所有子节点也没有找到和当前键equals相等的节点\n\t\t\t\t\tdir = tieBreakOrder(k, pk);// 再比较一下当前节点键和指定key键的大小\n\t\t\t\t}\n\t\t\t\t// 定义xp指向当前节点\n\t\t\t\tTreeNode<K,V> xp = p;\n\t\t\t\t/**\n\t\t\t\t * 如果dir小于等于0，那么看当前节点的左节点是否为空，\n\t\t\t\t * 如果为空，就可以把要添加的元素作为当前节点的左节点，如果不为空，还需要下一轮继续比较\n\t\t\t\t *\n\t\t\t\t * 如果dir大于等于0，那么看当前节点的右节点是否为空，\n\t\t\t\t * 如果为空，就可以把要添加的元素作为当前节点的右节点，如果不为空，还需要下一轮继续比较\n\t\t\t\t *\n\t\t\t\t * 如果以上两条当中有一个子节点不为空，\n\t\t\t\t * 这个if中还做了一件事，那就是把p已经指向了对应的不为空的子节点，开始下一轮的比较\n\t\t\t\t */\n\t\t\t\tif ((p = (dir <= 0) ? p.left : p.right) == null) {\n\t\t\t\t\t// 如果恰好要添加的方向上的子节点为空，此时节点p已经指向了这个空的子节点\n\t\t\t\t\t// 获取当前节点的next节点\n\t\t\t\t\tNode<K,V> xpn = xp.next;\n\t\t\t\t\t// 创建一个新的树节点\n\t\t\t\t\tTreeNode<K,V> x = map.newTreeNode(h, k, v, xpn);\n\t\t\t\t\tif (dir <= 0)\n\t\t\t\t\t\t// 左孩子指向到这个新的树节点\n\t\t\t\t\t\txp.left = x;\n\t\t\t\t\telse\n\t\t\t\t\t\t// 右孩子指向到这个新的树节点\n\t\t\t\t\t\txp.right = x;\n\t\t\t\t\t// 链表中的next节点指向到这个新的树节点\n\t\t\t\t\txp.next = x;\n\t\t\t\t\t// 这个新的树节点的父节点、前节点均设置为 当前的树节点\n\t\t\t\t\tx.parent = x.prev = xp;\n\t\t\t\t\t// 如果原来的next节点不为空\n\t\t\t\t\tif (xpn != null)\n\t\t\t\t\t\t// 那么原来的next节点的前节点指向到新的树节点\n\t\t\t\t\t\t((TreeNode<K,V>)xpn).prev = x;\n\t\t\t\t\t// 重新平衡，以及新的根节点置顶\n\t\t\t\t\tmoveRootToFront(tab, balanceInsertion(root, x));\n\t\t\t\t\t// 返回空，意味着产生了一个新节点\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n```\n\n# treeifyBin 链表转成红黑树\n```java\n\t/**\n\t * 将指定hash节点处的链表替换成红黑树\n\t * 除非table太小了，将用resizes（）改变树的容量\n\t * Replaces all linked nodes in bin at index for given hash unless\n\t * table is too small, in which case resizes instead.\n\t */\n\tfinal void treeifyBin(Node<K,V>[] tab, int hash) {\n\t\tint n, index; Node<K,V> e;\n\t\t// 如果 table 为null 或者\n\t\t// table的长度小于 MIN_TREEIFY_CAPACITY（默认64））不进行树化，调用resize进行扩容\n\t\tif (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)\n\t\t\tresize();\n\t\t// 如果 该hash值对应的 tab[index] 不为null，证明该位置有值\n\t\telse if ((e = tab[index = (n - 1) & hash]) != null) {\n\t\t\tTreeNode<K,V> hd = null, tl = null;\n\t\t\t// 遍历链表,将单项链表改为双向链表\n\t\t\tdo {\n\t\t\t\t// node 节点转成 TreeNode节点\n\t\t\t\tTreeNode<K,V> p = replacementTreeNode(e, null);\n\t\t\t\t// 如果树为空\n\t\t\t\tif (tl == null)\n\t\t\t\t\t// 设置树的根\n\t\t\t\t\thd = p;\n\t\t\t\telse {\n\t\t\t\t\t// 设置新节点p的上一个节点\n\t\t\t\t\tp.prev = tl;\n\t\t\t\t\t// 设置 上一节点的 next 指向当前节点\n\t\t\t\t\ttl.next = p;\n\t\t\t\t}\n\t\t\t\t//保存上一节点\n\t\t\t\ttl = p;\n\t\t\t} while ((e = e.next) != null);\n\t\t\t// 如果树的根节点不为null，调用treeify()进行树化\n\t\t\tif ((tab[index] = hd) != null)\n\t\t\t\thd.treeify(tab);\n\t\t}\n\t}\n\n\t\t/**\n\t\t * Forms tree of the nodes linked from this node.\n\t\t * @return root of tree\n\t\t */\n\t\tfinal void treeify(Node<K,V>[] tab) {\n\t\t\t// 树的根节点\n\t\t\tTreeNode<K,V> root = null;\n\t\t\t//x是当前节点，next是后继\n\t\t\tfor (TreeNode<K,V> x = this, next; x != null; x = next) {\n\t\t\t\t// 后继节点\n\t\t\t\tnext = (TreeNode<K,V>)x.next;\n\t\t\t\t// 左右儿子设为null\n\t\t\t\tx.left = x.right = null;\n\t\t\t\t// 如果根是 null\n\t\t\t\tif (root == null) {\n\t\t\t\t\t// 设置父节点为null\n\t\t\t\t\tx.parent = null;\n\t\t\t\t\t// 设置为黑色\n\t\t\t\t\tx.red = false;\n\t\t\t\t\t// 把当前节点设置为根节点\n\t\t\t\t\troot = x;\n\t\t\t\t}\n\t\t\t\t// 如果有根节点\n\t\t\t\telse {\n\t\t\t\t\tK k = x.key;\n\t\t\t\t\tint h = x.hash;\n\t\t\t\t\tClass<?> kc = null;\n\t\t\t\t\t// 遍历树，进行二叉搜索树的插入\n\t\t\t\t\tfor (TreeNode<K,V> p = root;;) {\n\t\t\t\t\t\t// p指向遍历中的当前节点，\n\t\t\t\t\t\t// x为待插入节点，\n\t\t\t\t\t\t// k是x的key，\n\t\t\t\t\t\t// h是x的hash值，\n\t\t\t\t\t\t// ph是p的hash值，\n\t\t\t\t\t\t// pk是p的key，\n\t\t\t\t\t\t// dir用来指示x节点与p的比较，-1表示比p小，1表示比p大\n\t\t\t\t\t\t// 不存在相等情况，因为HashMap中是不存在两个key完全一致的情况。\n\t\t\t\t\t\tint dir, ph;\n\t\t\t\t\t\tK pk = p.key;\n\t\t\t\t\t\t// 待插入x的hash值小于当前点p的hash值\n\t\t\t\t\t\tif ((ph = p.hash) > h)\n\t\t\t\t\t\t\tdir = -1;\n\t\t\t\t\t\telse if (ph < h)\n\t\t\t\t\t\t\tdir = 1;\n\t\t\t\t\t\t// 如果hash值相等，那么判断k是否实现了comparable接口，\n\t\t\t\t\t\t// 如果实现了comparable接口就使用compareTo进行进行比较，\n\t\t\t\t\t\t// 如果仍旧相等或者没有实现comparable接口，则在tieBreakOrder中比较\n\t\t\t\t\t\telse if ((kc == null &&\n\t\t\t\t\t\t\t\t(kc = comparableClassFor(k)) == null) ||\n\t\t\t\t\t\t\t\t(dir = compareComparables(kc, k, pk)) == 0)\n\t\t\t\t\t\t\tdir = tieBreakOrder(k, pk);\n\n\t\t\t\t\t\t// 将当前节点赋值给XP\n\t\t\t\t\t\tTreeNode<K,V> xp = p;\n\t\t\t\t\t\t// 如果dir <= 0 ,p 等于 p的左儿子，否则p 等于 p的右儿子\n\t\t\t\t\t\t// 如果 p 等于 null，则插入x节点\n\t\t\t\t\t\tif ((p = (dir <= 0) ? p.left : p.right) == null) {\n\t\t\t\t\t\t\t// x的父节点指向 xp\n\t\t\t\t\t\t\tx.parent = xp;\n\t\t\t\t\t\t\tif (dir <= 0)\n\t\t\t\t\t\t\t\txp.left = x;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\txp.right = x;\n\t\t\t\t\t\t\t// 进行平衡处理，保证红黑树的性质\n\t\t\t\t\t\t\troot = balanceInsertion(root, x);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//root节点移动到桶中的第一个元素，也就是链表的首节点\n\t\t\tmoveRootToFront(tab, root);\n\t\t}\n```\n\n\n# untreeify 树变链表\n\n```java\n\t\t/**\n\t\t * 树变链表\n\t\t * //重新创建链表节点，并形成链表结构\n\t\t */\n\t\tfinal Node<K,V> untreeify(HashMap<K,V> map) {\n\t\t\tNode<K,V> hd = null, tl = null;\n\t\t\tfor (Node<K,V> q = this; q != null; q = q.next) {\n\t\t\t\tNode<K,V> p = map.replacementNode(q, null);\n\t\t\t\tif (tl == null)\n\t\t\t\t\thd = p;\n\t\t\t\telse\n\t\t\t\t\ttl.next = p;\n\t\t\t\ttl = p;\n\t\t\t}\n\t\t\treturn hd;\n\t\t}\n```\n\n# balanceInsertion 红黑树插入平衡\n```java\n\t\t/**\n\t\t * 红黑树的插入平衡处理\n\t\t * @param root 根节点\n\t\t * @param x 新插入节点\n\t\t * @return\n\t\t */\n\t\tstatic <K,V> TreeNode<K,V> balanceInsertion(TreeNode<K,V> root,\n\t\t\t\t\t\t\t\t\t\t\t\t\tTreeNode<K,V> x) {\n\t\t\t//插入的节点默认为红色\n\t\t\tx.red = true;\n\t\t\t// xp：当前节点的父节点\n\t\t\t// xpp：爷爷节点\n\t\t\t// xppl：左叔叔节点\n\t\t\t// xppr：右叔叔节点\n\t\t\tfor (TreeNode<K,V> xp, xpp, xppl, xppr;;) {\n\t\t\t\t// L1：如果父节点为空、说明当前节点就是根节点，那么把当前节点标为黑色，返回当前节点\n\t\t\t\tif ((xp = x.parent) == null) {\n\t\t\t\t\tx.red = false;\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t\t// 父节点不为空\n\t\t\t\t// L2：如果 父节点为黑色 那么插入节点为红色不影响树的平衡\n\t\t\t\t// L3：或者 爷爷节点为空 即 父节点是根节点\n\t\t\t\t// 返回根节点\n\t\t\t\telse if (!xp.red || (xpp = xp.parent) == null)\n\t\t\t\t\treturn root;\n\t\t\t\t// L4：父节点和祖父节点都存在，并且其父节点是祖父节点的左节点\n\t\t\t\tif (xp == (xppl = xpp.left)) {\n\t\t\t\t\t// L4.1 插入节点的叔叔节点是红色\n\t\t\t\t\tif ((xppr = xpp.right) != null && xppr.red) {\n\t\t\t\t\t\t// 将叔叔设置为黑色，父亲设为黑色，爷爷设为红色\n\t\t\t\t\t\txppr.red = false;\n\t\t\t\t\t\txp.red = false;\n\t\t\t\t\t\txpp.red = true;\n\t\t\t\t\t\t// 将 爷爷 设为当前插入节点，自底向上，重新变色\n\t\t\t\t\t\tx = xpp;\n\t\t\t\t\t}\n\t\t\t\t\t//L4.2：插入节点的叔叔节点是黑色或不存在\n\t\t\t\t\telse {\n\t\t\t\t\t\t// L4.2.1 插入节点是其父节点的右孩子\n\t\t\t\t\t\tif (x == xp.right) {\n\t\t\t\t\t\t\t// x 设置为 父节点\n\t\t\t\t\t\t\t// 将 父节点 左旋\n\t\t\t\t\t\t\t// 旋转之后，原父子关系对调，因此，x还是子节点\n\t\t\t\t\t\t\troot = rotateLeft(root, x = xp);\n\t\t\t\t\t\t\t// 将xp 设为父节点，xpp设为爷爷节点\n\t\t\t\t\t\t\txpp = (xp = x.parent) == null ? null : xp.parent;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// L4.2.1 插入节点是其父节点的左孩子\n\t\t\t\t\t\tif (xp != null) {\n\t\t\t\t\t\t\t// 父节点设为黑色\n\t\t\t\t\t\t\txp.red = false;\n\t\t\t\t\t\t\t// 如果 有爷爷节点\n\t\t\t\t\t\t\tif (xpp != null) {\n\t\t\t\t\t\t\t\t// 爷爷节点设置为红色\n\t\t\t\t\t\t\t\txpp.red = true;\n\t\t\t\t\t\t\t\t//  爷爷节点右旋\n\t\t\t\t\t\t\t\troot = rotateRight(root, xpp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// L5：插入的节点父节点和祖父节点都存在，并且其 父节点是祖父节点的右节点\n\t\t\t\telse {\n\t\t\t\t\t// L5.1：插入节点的叔叔节点是红色\n\t\t\t\t\tif (xppl != null && xppl.red) {\n\t\t\t\t\t\t// 将叔叔设置为黑色，父亲设为黑色，爷爷设为红色\n\t\t\t\t\t\txppl.red = false;\n\t\t\t\t\t\txp.red = false;\n\t\t\t\t\t\txpp.red = true;\n\t\t\t\t\t\t// 将 爷爷 设为当前插入节点，自底向上，重新变色\n\t\t\t\t\t\tx = xpp;\n\t\t\t\t\t}\n\t\t\t\t\t//L5.2：插入节点的叔叔节点是黑色或不存在\n\t\t\t\t\telse {\n\t\t\t\t\t\t// L5.2.1 插入节点是其父节点的左孩子\n\t\t\t\t\t\tif (x == xp.left) {\n\t\t\t\t\t\t\t// x 设置为 父节点\n\t\t\t\t\t\t\t// 将 父节点 右旋\n\t\t\t\t\t\t\t// 旋转之后，原父子关系对调，因此，x还是子节点\n\t\t\t\t\t\t\troot = rotateRight(root, x = xp);\n\t\t\t\t\t\t\txpp = (xp = x.parent) == null ? null : xp.parent;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// L5.2.2 插入节点是其父节点的右孩子\n\t\t\t\t\t\tif (xp != null) {\n\t\t\t\t\t\t\t// 父节点设为黑色\n\t\t\t\t\t\t\txp.red = false;\n\t\t\t\t\t\t\t// 如果 有爷爷 节点\n\t\t\t\t\t\t\tif (xpp != null) {\n\t\t\t\t\t\t\t\t// 爷爷节点设置为红色\n\t\t\t\t\t\t\t\txpp.red = true;\n\t\t\t\t\t\t\t\t//  爷爷节点右旋\n\t\t\t\t\t\t\t\troot = rotateLeft(root, xpp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n```\n\n# get方法\n```java\n\tpublic V get(Object key) {\n\t\tNode<K,V> e;\n\t\treturn (e = getNode(hash(key), key)) == null ? null : e.value;\n\t}\n```\n\n# getNode\n```java\n\t/**\n\t * Implements Map.get and related methods\n\t *\n\t * @param hash key 的hash值\n\t * @param key the key\n\t * @return the node, or null if none\n\t */\n\tfinal Node<K,V> getNode(int hash, Object key) {\n\t\tNode<K,V>[] tab; Node<K,V> first, e; int n; K k;\n\t\t// table 不为null && 不为空，并且 (n - 1) & hash 算出来的index位置有值\n\t\tif ((tab = table) != null && (n = tab.length) > 0 &&\n\t\t\t\t(first = tab[(n - 1) & hash]) != null) {\n\t\t\t// 判断第一个存在的节点的key 和 hash值是否与查询的key的相等，如果是直接返回\n\t\t\tif (first.hash == hash && // always check first node\n\t\t\t\t\t((k = first.key) == key || (key != null && key.equals(k))))\n\t\t\t\treturn first;\n\t\t\t// 遍历该链表/红黑树直到next为null\n\t\t\tif ((e = first.next) != null) {\n\t\t\t\t// 如果该点是红黑树\n\t\t\t\tif (first instanceof TreeNode)\n\t\t\t\t\t// 在树上寻找对应的值\n\t\t\t\t\treturn ((TreeNode<K,V>)first).getTreeNode(hash, key);\n\t\t\t\tdo {\n\t\t\t\t\t// 遍历链表\n\t\t\t\t\tif (e.hash == hash &&\n\t\t\t\t\t\t\t((k = e.key) == key || (key != null && key.equals(k))))\n\t\t\t\t\t\treturn e;\n\t\t\t\t} while ((e = e.next) != null);\n\t\t\t}\n\t\t}\n\t\t//否则不存在，返回null\n\t\treturn null;\n\t}\n```\n\n# remove 及其相关方法\n```java\n\tpublic V remove(Object key) {\n\t\tNode<K,V> e;\n\t\treturn (e = removeNode(hash(key), key, null, false, true)) == null ?\n\t\t\t\tnull : e.value;\n\t}\n```\n# removeNode 删除节点\n```java\n\t/**\n\t * Implements Map.remove and related methods\n\t *\n\t * @param hash key的hash值\n\t * @param key the key\n\t * @param value 传入匹配的value值，如果matchValue=false，直接忽略\n\t * @param matchValue 为true时，会去进一步匹配value\n\t * @param movable if false do not move other nodes while removing\n\t * @return the node, or null if none\n\t */\n\tfinal Node<K,V> removeNode(int hash, Object key, Object value,\n\t\t\t\t\t\t\t   boolean matchValue, boolean movable) {\n\t\tNode<K,V>[] tab; Node<K,V> p; int n, index;\n\t\t//确定table已经被初始化，并且其中有元素，并且对应的 hash值有元素\n\t\tif ((tab = table) != null && (n = tab.length) > 0 &&\n\t\t\t\t(p = tab[index = (n - 1) & hash]) != null) {\n\t\t\tNode<K,V> node = null, e; K k; V v;\n\t\t\t//判断当前这个找到的元素是不是目标元素，如果是的话赋值给node\n\t\t\tif (p.hash == hash &&\n\t\t\t\t\t((k = p.key) == key || (key != null && key.equals(k))))\n\t\t\t\tnode = p;\n\t\t\t//不是的话，就从相同hash值的所有元素中去查找\n\t\t\telse if ((e = p.next) != null) {\n\t\t\t\tif (p instanceof TreeNode)\n\t\t\t\t\t//该列表已经转换成红黑树的情况\n\t\t\t\t\tnode = ((TreeNode<K,V>)p).getTreeNode(hash, key);\n\t\t\t\telse {\n\t\t\t\t\t//在链表中查找的情况\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (e.hash == hash &&\n\t\t\t\t\t\t\t\t((k = e.key) == key ||\n\t\t\t\t\t\t\t\t\t\t(key != null && key.equals(k)))) {\n\t\t\t\t\t\t\tnode = e;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp = e;\n\t\t\t\t\t} while ((e = e.next) != null);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//找到了目标节点\n\t\t\tif (node != null && (!matchValue || (v = node.value) == value ||\n\t\t\t\t\t(value != null && value.equals(v)))) {\n\t\t\t\tif (node instanceof TreeNode)\n\t\t\t\t\t//是红黑树节点的情况\n\t\t\t\t\t((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);\n\t\t\t\telse if (node == p)\n\t\t\t\t\t//是一个链表开头元素的情况\n\t\t\t\t\ttab[index] = node.next;\n\t\t\t\telse\n\t\t\t\t\t//是一个链表中间元素的情况\n\t\t\t\t\tp.next = node.next;\n\t\t\t\t//结构改变，修改次数需要加一\n\t\t\t\t++modCount;\n\t\t\t\t//元素减少size减1\n\t\t\t\t--size;\n\t\t\t\tafterNodeRemoval(node);\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n```\n# removeTreeNode 红黑树中删除节点\n```java\n\t\tfinal void removeTreeNode(HashMap<K,V> map, Node<K,V>[] tab,\n\t\t\t\t\t\t\t\t  boolean movable) {\n\t\t\tint n;\n\t\t\t// 如果 table为空 或者为0 则无法删除，返回\n\t\t\tif (tab == null || (n = tab.length) == 0)\n\t\t\t\treturn;\n\t\t\tint index = (n - 1) & hash;\n\t\t\t// first 和 root 目前都为 根结点\n\t\t\tTreeNode<K,V> first = (TreeNode<K,V>)tab[index], root = first, rl;\n\t\t\t// succ 是要删除节点的下一个，prev是要删除节点的前一个\n\t\t\tTreeNode<K,V> succ = (TreeNode<K,V>)next, pred = prev;\n\t\t\t// 首先先从TreeNode链表里将这个节点删除掉。\n\t\t\tif (pred == null)\n\t\t\t\ttab[index] = first = succ;\n\t\t\telse\n\t\t\t\tpred.next = succ;\n\t\t\tif (succ != null)\n\t\t\t\tsucc.prev = pred;\n\t\t\tif (first == null)\n\t\t\t\treturn;\n\t\t\tif (root.parent != null)\n\t\t\t\troot = root.root();\n\t\t\t// 根结点为空 或 根节点的右儿子为空 或 根结点的做儿子为空 或 根节点的做儿子的做儿子为空\n\t\t\tif (root == null || root.right == null ||\n\t\t\t\t\t(rl = root.left) == null || rl.left == null) {\n\t\t\t\t// 树太小了，从红黑树转换为链表\n\t\t\t\ttab[index] = first.untreeify(map);  // too small\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// 从红黑树删除这个节点\n\t\t\t// p是要删除的节点 pl 是 p 的左节点, pr 是 P 的右节点。\n\t\t\tTreeNode<K,V> p = this, pl = left, pr = right, replacement;\n\t\t\t// 当 p 的左右节点都不为null\n\t\t\tif (pl != null && pr != null) {\n\t\t\t\t// s 是 p的右节点 的 左叶子节点 的左节点。。。循环找到叶子节点\n\t\t\t\t// 就是查找所有比当前节点大的节点当中最小的一个节点\n\t\t\t\tTreeNode<K,V> s = pr, sl;\n\t\t\t\twhile ((sl = s.left) != null) // find successor\n\t\t\t\t\ts = sl;\n\t\t\t\t//交换 s 和 p 节点的颜色\n\t\t\t\tboolean c = s.red; s.red = p.red; p.red = c; // swap colors\n\t\t\t\t// sr ：s的右节点\n\t\t\t\tTreeNode<K,V> sr = s.right;\n\t\t\t\t// pp ：p的父节点\n\t\t\t\tTreeNode<K,V> pp = p.parent;\n\t\t\t\t//2： 如果s 等于pr 证明 p的 右节点 没有 左节点\n\t\t\t\tif (s == pr) { // p was s's direct parent\n\t\t\t\t\t//当前节点的父节点设为找到的节点\n\t\t\t\t\tp.parent = s;\n\t\t\t\t\t//找到节点的右孩子设为当前节点\n\t\t\t\t\ts.right = p;\n\t\t\t\t}\n\t\t\t\t//3： p 的右节点有左儿子\n\t\t\t\t// （以下操作就是将s和p对换了个位置和颜色，\n\t\t\t\t// 如果s有右儿子则设置为平衡点，否则p为平衡点）\n\t\t\t\telse {\n\t\t\t\t\t// sp ： s的父亲\n\t\t\t\t\tTreeNode<K,V> sp = s.parent;\n\t\t\t\t\t// 将 p 的父亲设为 sp\n\t\t\t\t\t// 如果sp 不为null\n\t\t\t\t\tif ((p.parent = sp) != null) {\n\t\t\t\t\t\t// 当前节点替代 s 节点的位置，与 s 节点的父节点进行关联\n\t\t\t\t\t\t// s 是 sp 的左儿子，左儿子设置为 p\n\t\t\t\t\t\tif (s == sp.left)\n\t\t\t\t\t\t\tsp.left = p;\n\t\t\t\t\t\telse// s 是 sp 的右儿子，右儿子设置为 p\n\t\t\t\t\t\t\tsp.right = p;\n\t\t\t\t\t}\n\t\t\t\t\t// s 的右节点设置为 p 的右孩子\n\t\t\t\t\t// 如果 p 的右孩子不为null\n\t\t\t\t\t// 右孩子的父节点设为 s 节点\n\t\t\t\t\tif ((s.right = pr) != null)\n\t\t\t\t\t\tpr.parent = s;\n\t\t\t\t}\n\t\t\t\t//当前节点的左孩子设为null\n\t\t\t\tp.left = null;\n\t\t\t\t//将 p 节点的右孩子设置为 s节点的右孩子\n\t\t\t\tif ((p.right = sr) != null)\n\t\t\t\t\tsr.parent = p; //右孩子的父节点设为当前节点\n\t\t\t\t// 将 s 节点的左儿子设置为 p节点的左儿子\n\t\t\t\tif ((s.left = pl) != null)\n\t\t\t\t\tpl.parent = s;// 左孩子的父节点设为找到节点\n\t\t\t\t// 将s的父亲 设置为 p 节点的父亲\n\t\t\t\t// 如果 p是根结点，那么根节点变为s\n\t\t\t\tif ((s.parent = pp) == null)\n\t\t\t\t\troot = s;\n\t\t\t\t// 父节点不为null，当前节点是父节点的左孩子\n\t\t\t\telse if (p == pp.left)\n\t\t\t\t\t// 父亲的左儿子改为s\n\t\t\t\t\tpp.left = s;\n\t\t\t\telse\n\t\t\t\t\t// 父亲的右儿子改为s\n\t\t\t\t\tpp.right = s;\n\t\t\t\t// s节点的右孩子不为null\n\t\t\t\tif (sr != null)\n\t\t\t\t\t// 则s节点的右孩子节点作为平衡删除的初始节点\n\t\t\t\t\treplacement = sr;\n\t\t\t\telse\n\t\t\t\t\t// 否则平衡删除的初始节点为 p。\n\t\t\t\t\treplacement = p;\n\t\t\t}\n\t\t\t//当前节点左孩子不为null，右孩子为null\n\t\t\t//当前节点的左孩子作为平衡删除的节点\n\t\t\telse if (pl != null)\n\t\t\t\treplacement = pl;\n\t\t\t//当前节点右孩子不为null，左孩子为null\n\t\t\t// 当前节点的右孩子作为平衡删除的节点\n\t\t\telse if (pr != null)\n\t\t\t\treplacement = pr;\n\t\t\telse//左右孩子都为null，当前节点作为平衡删除的节点\n\t\t\t\treplacement = p;\n\t\t\t//如果当前节点不是作为平衡删除的节点\n\t\t\tif (replacement != p) {\n\t\t\t\t//此时p.parent有三种情况，1.其原来的父节点，2.它的右子节点，3.s节点的父节点sp\n\t\t\t\t//将当前节点的父节点设为平衡删除节点的父节点\n\t\t\t\tTreeNode<K,V> pp = replacement.parent = p.parent;\n\t\t\t\t//如果当前节点的父节点为null，则表明当前节点原来是根节点，此时当前节点的父节点还是其原来的父节点\n\t\t\t\tif (pp == null)\n\t\t\t\t\troot = replacement;//设置作为平衡删除的节点为根节点\n\t\t\t\t// 如果父节点不为null，并且当前节点是父节点的左子节点\n\t\t\t\telse if (p == pp.left)//设置父节点的左子节点为作为平衡删除的节点\n\t\t\t\t\tpp.left = replacement;\n\t\t\t\telse//设置父节点的右子节点为作为平衡删除的节点\n\t\t\t\t\tpp.right = replacement;\n\t\t\t\t//将当前节点与树结构断开，因为当前节点不是作为平衡删除的节点\n\t\t\t\tp.left = p.right = p.parent = null;\n\t\t\t}\n\t\t\t// 获取根节点，如果删除节点是红色，则不需要做平衡删除，根节点不会再变\n\t\t\t// 如果删除节点是黑色，则需要做平衡删除，根节点可能会发生改变\n\t\t\tTreeNode<K,V> r = p.red ? root : balanceDeletion(root, replacement);\n\n\t\t\t//做平衡删除的节点是当前要删除的节点\n\t\t\t//平衡删除做完后将该节点从树结构中脱离出来\n\t\t\tif (replacement == p) {  // detach\n\t\t\t\tTreeNode<K,V> pp = p.parent;\n\t\t\t\tp.parent = null;\n\t\t\t\tif (pp != null) {\n\t\t\t\t\tif (p == pp.left)\n\t\t\t\t\t\tpp.left = null;\n\t\t\t\t\telse if (p == pp.right)\n\t\t\t\t\t\tpp.right = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//是否需要从新设置桶的头节点\n\t\t\tif (movable)\n\t\t\t\t//将桶的头节点设为根节点\n\t\t\t\tmoveRootToFront(tab, r);\n\t\t}\n```\n# balanceDeletion 红黑树删除平衡\n```java\n\t\t/**\n\t\t * 红黑树平衡删除，只有在删除的节点是黑色时才会调用此方法\n\t\t * @param root 根结点\n\t\t * @param x 平衡节点\n\t\t * @return\n\t\t */\n\t\tstatic <K,V> TreeNode<K,V> balanceDeletion(TreeNode<K,V> root,\n\t\t\t\t\t\t\t\t\t\t\t\t   TreeNode<K,V> x) {\n\t\t\tfor (TreeNode<K,V> xp, xpl, xpr;;)  {\n\t\t\t\t//平衡节点为null或者平衡节点是根节点，无需做平衡处理，返回根节点\n\t\t\t\tif (x == null || x == root)\n\t\t\t\t\treturn root;\n\t\t\t\t//平衡节点不是根，但平衡节点的父节点是null\n\t\t\t\t//则将平衡节点将成为根节点，将其颜色设置为黑色\n\t\t\t\telse if ((xp = x.parent) == null) {\n\t\t\t\t\tx.red = false;\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t\t//不是根节点，父节点也不为null，\n\t\t\t\t//若做平衡的节点就是要删除的节点，则设什么颜色都无所谓，直接返回根节点\n\t\t\t\t//若做平衡的节点不是要删除的节点，而且还是红色\n\t\t\t\t//则其要替换的节点就是其父节点，替换的父节点就是要删除的节点，\n\t\t\t\t//而做平衡的节点还是红色，则其父一定是黑色，其替换其父所以要变成黑色\n\t\t\t\t//因为做平衡的节点是红，它替换掉了其父（在进入此方法之前已经替换掉了）\n\t\t\t\t//其父是黑，所以只需要确保其是黑，就能确保该树枝上的黑色节点数不变\n\t\t\t\t//替换完直接返回根节点即可\n\t\t\t\telse if (x.red) {\n\t\t\t\t\tx.red = false;\n\t\t\t\t\treturn root;\n\t\t\t\t}\n\t\t\t\t//x的节点不是根，父也不为null，其颜色是黑色\n\t\t\t\t//x的节点是其父的左子节点\n\t\t\t\telse if ((xpl = xp.left) == x) {\n\t\t\t\t\t//如果它有红色的兄弟节点xpr，那么它的父亲节点xp一定是黑色节点\n\t\t\t\t\t// 将兄弟节点设为黑色，父亲节点设为红色，以父节点进行旋转\n\t\t\t\t\tif ((xpr = xp.right) != null && xpr.red) {\n\t\t\t\t\t\txpr.red = false;\n\t\t\t\t\t\txp.red = true;\n\t\t\t\t\t\t//对父节点xp做左旋转\n\t\t\t\t\t\troot = rotateLeft(root, xp);\n\t\t\t\t\t\t//重新将xp指向x的父节点，xpr指向xp新的右孩子\n\t\t\t\t\t\txpr = (xp = x.parent) == null ? null : xp.right;\n\t\t\t\t\t}\n\t\t\t\t\t//如果xpr为空，则向上继续调整，将x的父节点xp作为新的x继续循环\n\t\t\t\t\tif (xpr == null)\n\t\t\t\t\t\tx = xp;\n\t\t\t\t\telse {\n\t\t\t\t\t\t//sl和sr分别为其兄弟节点左儿子和右儿子\n\t\t\t\t\t\tTreeNode<K,V> sl = xpr.left, sr = xpr.right;\n\t\t\t\t\t\t//若sl和sr都为黑色或者不存在，即xpr没有红色孩子，则将xpr染红\n\t\t\t\t\t\tif ((sr == null || !sr.red) &&\n\t\t\t\t\t\t\t\t(sl == null || !sl.red)) {\n\t\t\t\t\t\t\txpr.red = true;\n\t\t\t\t\t\t\tx = xp;//本轮结束，继续向上循环\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t//否则的话，就需要进一步调整\n\t\t\t\t\t\t\tif (sr == null || !sr.red) {\n\t\t\t\t\t\t\t\t//若左孩子为红，右孩子不存在或为黑\n\t\t\t\t\t\t\t\tif (sl != null)\n\t\t\t\t\t\t\t\t\t//左孩子染黑\n\t\t\t\t\t\t\t\t\tsl.red = false;\n\t\t\t\t\t\t\t\t//将xpr染红\n\t\t\t\t\t\t\t\txpr.red = true;\n\t\t\t\t\t\t\t\t//右旋\n\t\t\t\t\t\t\t\troot = rotateRight(root, xpr);\n\t\t\t\t\t\t\t\t//右旋后，xpr指向xp的新右孩子，即上一步中的sl\n\t\t\t\t\t\t\t\txpr = (xp = x.parent) == null ?\n\t\t\t\t\t\t\t\t\t\tnull : xp.right;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// 如果兄弟节点 不为null\n\t\t\t\t\t\t\tif (xpr != null) {\n\t\t\t\t\t\t\t\t// 如果父节点为空，兄弟节点染为黑色，否则和父亲节点染色相同\n\t\t\t\t\t\t\t\txpr.red = (xp == null) ? false : xp.red;\n\t\t\t\t\t\t\t\t// sr 设置为兄弟节点的右孩子，如果sr不为null，将sr设置为黑色，防止出现两个红色相连\n\t\t\t\t\t\t\t\tif ((sr = xpr.right) != null)\n\t\t\t\t\t\t\t\t\tsr.red = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// 如果父节点不为null\n\t\t\t\t\t\t\tif (xp != null) {\n\t\t\t\t\t\t\t\t//将父亲节点设置为黑色\n\t\t\t\t\t\t\t\txp.red = false;\n\t\t\t\t\t\t\t\t// 左旋父节点\n\t\t\t\t\t\t\t\troot = rotateLeft(root, xp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tx = root;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//x为其父节点的右孩子，跟上面操作镜像\n\t\t\t\telse { // symmetric\n\t\t\t\t\tif (xpl != null && xpl.red) {\n\t\t\t\t\t\txpl.red = false;\n\t\t\t\t\t\txp.red = true;\n\t\t\t\t\t\troot = rotateRight(root, xp);\n\t\t\t\t\t\txpl = (xp = x.parent) == null ? null : xp.left;\n\t\t\t\t\t}\n\t\t\t\t\tif (xpl == null)\n\t\t\t\t\t\tx = xp;\n\t\t\t\t\telse {\n\t\t\t\t\t\tTreeNode<K,V> sl = xpl.left, sr = xpl.right;\n\t\t\t\t\t\tif ((sl == null || !sl.red) &&\n\t\t\t\t\t\t\t\t(sr == null || !sr.red)) {\n\t\t\t\t\t\t\txpl.red = true;\n\t\t\t\t\t\t\tx = xp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (sl == null || !sl.red) {\n\t\t\t\t\t\t\t\tif (sr != null)\n\t\t\t\t\t\t\t\t\tsr.red = false;\n\t\t\t\t\t\t\t\txpl.red = true;\n\t\t\t\t\t\t\t\troot = rotateLeft(root, xpl);\n\t\t\t\t\t\t\t\txpl = (xp = x.parent) == null ?\n\t\t\t\t\t\t\t\t\t\tnull : xp.left;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (xpl != null) {\n\t\t\t\t\t\t\t\txpl.red = (xp == null) ? false : xp.red;\n\t\t\t\t\t\t\t\tif ((sl = xpl.left) != null)\n\t\t\t\t\t\t\t\t\tsl.red = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (xp != null) {\n\t\t\t\t\t\t\t\txp.red = false;\n\t\t\t\t\t\t\t\troot = rotateRight(root, xp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tx = root;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n```\n\n# rotateLeft 红黑树左旋（右旋转同理）\n```java\n\t\t/**\n\t\t * 红黑树左旋\n\t\t * @param root 根节点\n\t\t * @param p 要左旋的节点\n\t\t *\n\t\t * @return\n\t\t */\n\t\tstatic <K,V> TreeNode<K,V> rotateLeft(TreeNode<K,V> root,\n\t\t\t\t\t\t\t\t\t\t\t  TreeNode<K,V> p) {\n\t\t\t// pp : p的父亲\n\t\t\t// r: p的右孩子\n\t\t\t// rl = p 的右孩子的左孩子 -> r的左孩子\n\t\t\tTreeNode<K,V> r, pp, rl;\n\t\t\t// 要 p 以及 p的右孩子 不为null\n\t\t\tif (p != null && (r = p.right) != null) {\n\t\t\t\t// 将p 的右孩子 设置为 rl 并且 rl不为空\n\t\t\t\tif ((rl = p.right = r.left) != null)\n\t\t\t\t\t// rl的父亲节点设置为p\n\t\t\t\t\trl.parent = p;\n\t\t\t\t// 将 r 的父亲 设置为 p的父亲（此时r 与p为兄弟）\n\t\t\t\t// 如果父亲节点为null，则此时 r为跟节点\n\t\t\t\t// 将root 设置为r ，并设置为黑色\n\t\t\t\tif ((pp = r.parent = p.parent) == null)\n\t\t\t\t\t(root = r).red = false;\n\t\t\t\t// 如果父节点的左儿子是 p\n\t\t\t\telse if (pp.left == p)\n\t\t\t\t\t// 将父节点的 左儿子 设为r\n\t\t\t\t\tpp.left = r;\n\t\t\t\telse\n\t\t\t\t\t// 否则将 右儿子 设为r\n\t\t\t\t\tpp.right = r;\n\t\t\t\t// 将 r 的左节儿子 设置为p\n\t\t\t\tr.left = p;\n\t\t\t\t// p 的父亲设置为 r\n\t\t\t\tp.parent = r;\n\t\t\t}\n\t\t\t// 返回根节点\n\t\t\treturn root;\n\t\t}\n```\n","slug":"Java-HashMap","published":1,"updated":"2020-03-13T08:17:01.539Z","layout":"post","photos":[],"link":"","_id":"ck8fb4aao001dk2o5ncgo8hny","content":"<h1 id=\"HashMap-的存储结构\"><a href=\"#HashMap-的存储结构\" class=\"headerlink\" title=\"HashMap 的存储结构\"></a>HashMap 的存储结构</h1><p>HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;<span class=\"comment\">// key的hash值</span></span><br><span class=\"line\">\t<span class=\"keyword\">final</span> K key; <span class=\"comment\">// key</span></span><br><span class=\"line\">\tV value; <span class=\"comment\">// value</span></span><br><span class=\"line\">\tNode&lt;K,V&gt; next; <span class=\"comment\">//同一个hash值下的链表/红黑树</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tNode(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.hash = hash;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span>        </span>&#123; <span class=\"keyword\">return</span> key; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span>      </span>&#123; <span class=\"keyword\">return</span> value; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> key + <span class=\"string\">\"=\"</span> + value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">setValue</span><span class=\"params\">(V newValue)</span> </span>&#123;</span><br><span class=\"line\">\t\tV oldValue = value;</span><br><span class=\"line\">\t\tvalue = newValue;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (o == <span class=\"keyword\">this</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Map.Entry) &#123;</span><br><span class=\"line\">\t\t\tMap.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\tObjects.equals(value, e.getValue()))</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TreeNode&lt;K,V&gt; 继承 LinkedHashMap.Entry&lt;K,V&gt;，用来实现红黑树相关的存储结构</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">LinkedHashMap</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; parent;  <span class=\"comment\">// 存储当前节点的父节点</span></span><br><span class=\"line\">    TreeNode&lt;K,V&gt; left;　<span class=\"comment\">// 存储当前节点的左孩子</span></span><br><span class=\"line\">    TreeNode&lt;K,V&gt; right;　<span class=\"comment\">// 存储当前节点的右孩子</span></span><br><span class=\"line\">    TreeNode&lt;K,V&gt; prev;    <span class=\"comment\">// prev则指向前一个节点（原链表中的前一个节点）</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> red;　<span class=\"comment\">// 存储当前节点的颜色（红、黑）</span></span><br><span class=\"line\">    TreeNode(<span class=\"keyword\">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(hash, key, val, next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">root</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveRootToFront</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeify</span><span class=\"params\">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">untreeify</span><span class=\"params\">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">putTreeVal</span><span class=\"params\">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                   <span class=\"keyword\">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">removeTreeNode</span><span class=\"params\">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">split</span><span class=\"params\">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> bit)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/* ------------------------------------------------------------ */</span></span><br><span class=\"line\">    <span class=\"comment\">// Red-black tree methods, all adapted from CLR</span></span><br><span class=\"line\">    <span class=\"comment\">// 红黑树相关操作</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\">TreeNode&lt;K,V&gt; <span class=\"title\">rotateLeft</span><span class=\"params\">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                          TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\">TreeNode&lt;K,V&gt; <span class=\"title\">rotateRight</span><span class=\"params\">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                           TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\">TreeNode&lt;K,V&gt; <span class=\"title\">balanceInsertion</span><span class=\"params\">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\">TreeNode&lt;K,V&gt; <span class=\"title\">balanceDeletion</span><span class=\"params\">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                               TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class=\"line\">    &#125;       </span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">checkInvariants</span><span class=\"params\">(TreeNode&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"各常量、成员变量作用\"><a href=\"#各常量、成员变量作用\" class=\"headerlink\" title=\"各常量、成员变量作用　　\"></a>各常量、成员变量作用　　</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 默认初始容量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>; <span class=\"comment\">// aka 16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 最大容量， 当传入容量过大时将被这个值替换</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 默认负载因子</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 当链表的长度超过8，有可能会转化成树</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 当链表的长度小于6则会从红黑树转回链表</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。</span></span><br><span class=\"line\"><span class=\"comment\"> * 这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TREEIFY_CAPACITY = <span class=\"number\">64</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 用来存储 key-value 的节点对象。在 HashMap 中它有个专业的叫法 buckets ，中文叫作桶。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 同时封装了 keySet 和 values 的视图</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 容器中实际存放 Node 的大小</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * HashMap 在结构上被修改的次数，结构修改是指改变HashMap中映射的次数，或者以其他方式修改其内部结构(例如，rehash)。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * HashMap的扩容阈值(=负载因子*table的容量)</span></span><br><span class=\"line\"><span class=\"comment\"> * 在HashMap中存储的Node键值对超过这个数量时，自动扩容容量为原来的二倍</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 负载因子</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class=\"line\"><span class=\"comment\"> * capacity and load factor.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  initialCapacity 初始容量</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  loadFactor      负载因子</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> IllegalArgumentException 如果初始容量为负或者负载因子非正数抛出该异常</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 当初始容量为负</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> +</span><br><span class=\"line\">\t\t\t\tinitialCapacity);</span><br><span class=\"line\">\t<span class=\"comment\">// 当初始容量大于最大容量 2^30 ，初始容量= 2^30</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">\t\tinitialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">\t<span class=\"comment\">// 当负载因子非正数 或 负载因子是NaN(Not a Number，0.0f/0.0f的值就是NaN)</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> +</span><br><span class=\"line\">\t\t\t\tloadFactor);</span><br><span class=\"line\">\t<span class=\"comment\">// 赋值</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取比传入参数大的最小的2的N次幂。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">\tn |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\tn |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">\tn |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">\tn |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">\tn |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"put方法\"><a href=\"#put方法\" class=\"headerlink\" title=\"put方法\"></a>put方法</h1><p>put方法主要是调用putVal方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使 key 和 value 产生关联，但如果有相同的 key 则新的会替换掉旧的。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * h &gt;&gt;&gt; 16:无符号右移动16位，意味着取高16位二进制</span></span><br><span class=\"line\"><span class=\"comment\"> * 低16位与高16位进行异或</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> h;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果为 null 则返回的就是 0，否则就是 hashCode 异或上 hashCode 无符号右移 16 位</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"putVal方法\"><a href=\"#putVal方法\" class=\"headerlink\" title=\"putVal方法\"></a>putVal方法</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implements Map.put and related methods</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> hash key的hash值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value the value to put</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> onlyIfAbsent 如果true代表不更改现有的值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> evict 如果为false表示table为创建状态</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> previous value, or null if none</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">\tNode&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 判断table是否等于空或者table的长度等于0，如果是就进行初始化</span></span><br><span class=\"line\"><span class=\"comment\">\t * 此时通过resize()方法得到初始化的table</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\tn = (tab = resize()).length;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 对hash码进行散列 ，对值的位置进行确认</span></span><br><span class=\"line\"><span class=\"comment\">\t * 如果tab[i] 为null 表示没有hash冲突，就新增一个元素</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\ttab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果tab[i] 不为null，表示该位置有值了。</span></span><br><span class=\"line\">\t\tNode&lt;K,V&gt; e; K k;</span><br><span class=\"line\">\t\t<span class=\"comment\">//HashMap中判断key相同的条件是key的hash相同，并且符合equals方法。这里判断了p.key是否和插入的key相等，如果相等，则将p的引用赋给e</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//这里为什么要把p赋值给e，而不是直接覆盖原值呢？答案很简单，现在我们只判断了第一个节点，后面还可能出现key相同，所以需要在最后一并处理</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">\t\t\t\t((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">\t\t\te = p;</span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 判断是否是红黑树</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * p是红黑树节点，那么肯定插入后仍然是红黑树节点，所以我们直接强制转型p后调用TreeNode.putTreeVal方法，返回的引用赋给e</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">\t\t\te = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 否则就是链表</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果是链表，要遍历到最后一个节点进行插入</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 插入到链尾</span></span><br><span class=\"line\">\t\t\t\t\tp.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 判断节点的长度是否大于TREEIFY_THRESHOLD红黑树的阈值，是就进行转换</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">\t\t\t\t\t\ttreeifyBin(tab, hash);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 对链表中的相同 hash 值且 key 相同的进一步作检查</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t\t((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\tp = e;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 插入</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 取出旧值，onlyIfAbsent此时为 false，所以不管 oldValue 有与否，都拿新值来替换</span></span><br><span class=\"line\">\t\t\tV oldValue = e.value;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\te.value = value;</span><br><span class=\"line\">\t\t\tafterNodeAccess(e);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 记录修改次数</span></span><br><span class=\"line\">\t++modCount;</span><br><span class=\"line\">\t<span class=\"comment\">// 超过阈值 threshold = capacity * factor，调用 resize() 进行扩容</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">\t\tresize();</span><br><span class=\"line\">\tafterNodeInsertion(evict);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"resize-扩容兼初始化\"><a href=\"#resize-扩容兼初始化\" class=\"headerlink\" title=\"resize 扩容兼初始化\"></a>resize 扩容兼初始化</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class=\"line\"><span class=\"comment\"> * accord with initial capacity target held in field threshold.</span></span><br><span class=\"line\"><span class=\"comment\"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class=\"line\"><span class=\"comment\"> * elements from each bin must either stay at same index, or move</span></span><br><span class=\"line\"><span class=\"comment\"> * with a power of two offset in the new table.</span></span><br><span class=\"line\"><span class=\"comment\"> * 扩容兼初始化</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the table</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将原来的table指针保存</span></span><br><span class=\"line\">\tNode&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">\t<span class=\"comment\">//获取原来数组的长度，oldTab为null说明还没有进行初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">\t<span class=\"comment\">//保存以前重构table的阈值</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//oldCap &gt; 0表示已经初始化过了</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//当原来的容量已经达到最大容量的时候，将阈值设置为Integer.MAX_VALUE，这样就不会再发生重构的情况</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">\t\t\tthreshold = Integer.MAX_VALUE;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 否则将旧的容量扩大两倍</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 当它小于最大容量，并且旧的容量大于初始化最小容量的时候，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 将新的阈值设置为旧的阈值的两倍, 新的容量设置为旧容量的2倍</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">\t\t\t\toldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">\t\t\tnewThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//虽然还没有初始化，但是设置过了阈值，将旧的阈值设置为新的容量</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">\t\tnewCap = oldThr;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//没有初始化阈值的时候采用默认算法计算阈值</span></span><br><span class=\"line\">\t\tnewCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">\t\tnewThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 对应oldCap = 0 &amp;&amp; oldThr &gt; 0的情况</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//重新用默认负载因子计算 扩容阈值</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果新容量小于最大容量 &amp;&amp; 新扩容阈值(ft) 小于最大容量</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 新阈值 = ft 否则 新阈值 = int的最大范围</span></span><br><span class=\"line\">\t\tnewThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">\t\t\t\t(<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 把当前阈值设为新阈值</span></span><br><span class=\"line\">\tthreshold = newThr;</span><br><span class=\"line\">\t<span class=\"comment\">// 根据新容量，创建新table</span></span><br><span class=\"line\">\t<span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"rawtypes\"</span>,<span class=\"string\">\"unchecked\"</span>&#125;)</span><br><span class=\"line\">\tNode&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">\t<span class=\"comment\">// 将当前table 设置为新扩容的table</span></span><br><span class=\"line\">\ttable = newTab;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果已经被初始化过</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//将旧数组中的元素全部取出，重新映射到新数组中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">\t\t\tNode&lt;K,V&gt; e;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\toldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 该节点没有next节点，表示没有链表，没有冲突，那重新计算下位置</span></span><br><span class=\"line\">\t\t\t\t\tnewTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 冲突的是一棵树节点，分裂成 2 个树，或者如果树很小就转成链表</span></span><br><span class=\"line\">\t\t\t\t\t((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 对原来的链表部分进行重构</span></span><br><span class=\"line\">\t\t\t\t\tNode&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t\tNode&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t\tNode&lt;K,V&gt; next;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\tnext = e.next;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 索引不变</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\t\t\t\tloHead = e;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\tloTail.next = e;</span><br><span class=\"line\">\t\t\t\t\t\t\tloTail = e;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 原索引+oldCap</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\t\t\t\thiHead = e;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\thiTail.next = e;</span><br><span class=\"line\">\t\t\t\t\t\t\thiTail = e;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 原索引放到 tables 里</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tloTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t\t\tnewTab[j] = loHead;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 原索引+oldCap放到  tables 里</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\thiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t\t\tnewTab[j + oldCap] = hiHead;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 返回扩容后的table</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"split-扩容时重新划分树\"><a href=\"#split-扩容时重新划分树\" class=\"headerlink\" title=\"split 扩容时重新划分树\"></a>split 扩容时重新划分树</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 扩容时重新划分树</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> map the map</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> tab 扩容后的数组</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> index 数组索引</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> bit 原数组容量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">split</span><span class=\"params\">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> bit)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//b设置为当前桶的头节点</span></span><br><span class=\"line\">\tTreeNode&lt;K,V&gt; b = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// Relink into lo and hi lists, preserving order</span></span><br><span class=\"line\">\t<span class=\"comment\">//低位树链表头节点，尾结点</span></span><br><span class=\"line\">\tTreeNode&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//高位树链表头节点，尾结点</span></span><br><span class=\"line\">\tTreeNode&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//lc低位树链表中节点个数，hc高位树链表中节点个数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> lc = <span class=\"number\">0</span>, hc = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//e当前遍历节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class=\"keyword\">null</span>; e = next) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//当前遍历节点的后继节点</span></span><br><span class=\"line\">\t\tnext = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class=\"line\">\t\t<span class=\"comment\">//将当前遍历节点后继设为null</span></span><br><span class=\"line\">\t\te.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((e.hash &amp; bit) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//==0表示当前遍历节点应该存放在低位</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果低位中还没有节点</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//将当前遍历节点设为低位头节点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((e.prev = loTail) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\tloHead = e;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//将当前遍历节点加入到链表的尾部</span></span><br><span class=\"line\">\t\t\t\tloTail.next = e;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//设置尾节点为当前遍历节点</span></span><br><span class=\"line\">\t\t\tloTail = e;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//低位链表中的节点数加1</span></span><br><span class=\"line\">\t\t\t++lc;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//!=0表示当前遍历节点应该存放在高位</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((e.prev = hiTail) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\thiHead = e;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\thiTail.next = e;</span><br><span class=\"line\">\t\t\thiTail = e;</span><br><span class=\"line\">\t\t\t++hc;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//如果低位节点链表不为null</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (loHead != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//低位节点链表中节点的个数小于6，此时需要将树结构转为链表结构</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class=\"line\">\t\t\ttab[index] = loHead.untreeify(map);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;<span class=\"comment\">//链表中节点的个数满足保持树型结构所需要的节点个数</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//低位桶的头节点设为链表的头节点</span></span><br><span class=\"line\">\t\t\ttab[index] = loHead;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 高位节点链表不为null，说明有节点从原树结构中分离出去了</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 原有树结构被破坏</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 所以低位的节点链表需要重新构建树结构</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (hiHead != <span class=\"keyword\">null</span>) <span class=\"comment\">// (else is already treeified)</span></span><br><span class=\"line\">\t\t\t\tloHead.treeify(tab);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 同理</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (hiHead != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class=\"line\">\t\t\ttab[index + bit] = hiHead.untreeify(map);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\ttab[index + bit] = hiHead;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (loHead != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\thiHead.treeify(tab);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"putTreeVal-在红黑树中添加节点\"><a href=\"#putTreeVal-在红黑树中添加节点\" class=\"headerlink\" title=\"putTreeVal 在红黑树中添加节点\"></a>putTreeVal 在红黑树中添加节点</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> map 当前节点所在的HashMap对象</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> tab 当前HashMap对象的元素数组</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> h key的hash值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> k key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> v value</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 指定key所匹配到的节点对象，针对这个对象去修改V（返回空说明创建了一个新节点）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">putTreeVal</span><span class=\"params\">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t\t   <span class=\"keyword\">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 定义k的Class对象</span></span><br><span class=\"line\">\tClass&lt;?&gt; kc = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 标识是否已经遍历过一次树，未必是从根节点遍历的，但是遍历路径上一定已经包含了后续需要比对的所有节点。</span></span><br><span class=\"line\">\t<span class=\"keyword\">boolean</span> searched = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//父节点不为空那么查找根节点，为空那么自身就是根节点</span></span><br><span class=\"line\">\tTreeNode&lt;K,V&gt; root = (parent != <span class=\"keyword\">null</span>) ? root() : <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 从根节点开始遍历，没有终止条件，只能从内部退出</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 声明方向、当前节点hash值、当前节点的键对象</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> dir, ph; K pk;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果当前节点hash 大于 指定key的hash值,要添加的元素应该放置在当前节点的左侧</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((ph = p.hash) &gt; h)</span><br><span class=\"line\">\t\t\tdir = -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果当前节点hash 小于 指定key的hash值,要添加的元素应该放置在当前节点的右侧</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ph &lt; h)</span><br><span class=\"line\">\t\t\tdir = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果当前节点的键对象 和 指定key对象相同,那么就返回当前节点对象</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((pk = p.key) == k || (k != <span class=\"keyword\">null</span> &amp;&amp; k.equals(pk)))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 走到这一步说明 当前节点的hash值  和 指定key的hash值  是相等的，但是equals不等</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((kc == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">\t\t\t\t(kc = comparableClassFor(k)) == <span class=\"keyword\">null</span>) ||</span><br><span class=\"line\">\t\t\t\t(dir = compareComparables(kc, k, pk)) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 走到这里说明：指定key没有实现comparable接口   或者   实现了comparable接口并且和当前节点的键对象比较之后相等（仅限第一次循环）</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * searched 标识是否已经对比过当前节点的左右子节点了</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * 如果还没有遍历过，那么就递归遍历对比，看是否能够得到那个键对象equals相等的的节点</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * 如果得到了键的equals相等的的节点就返回</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * 如果还是没有键的equals相等的节点，那说明应该创建一个新节点了</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t */</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!searched) &#123;<span class=\"comment\">// 如果还没有比对过当前节点的所有子节点</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 定义要返回的节点、和子节点</span></span><br><span class=\"line\">\t\t\t\tTreeNode&lt;K,V&gt; q, ch;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 标识已经遍历过一次了</span></span><br><span class=\"line\">\t\t\t\tsearched = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t * 红黑树也是二叉树，所以只要沿着左右两侧遍历寻找就可以了</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t * 这是个短路运算，如果先从左侧就已经找到了，右侧就不需要遍历了</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t * find 方法内部还会有递归调用</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t */</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (((ch = p.left) != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t\t(q = ch.find(h, k, kc)) != <span class=\"keyword\">null</span>) ||</span><br><span class=\"line\">\t\t\t\t\t\t((ch = p.right) != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t(q = ch.find(h, k, kc)) != <span class=\"keyword\">null</span>))</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 找到了指定key键对应的</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> q;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 走到这里就说明，遍历了所有子节点也没有找到和当前键equals相等的节点</span></span><br><span class=\"line\">\t\t\tdir = tieBreakOrder(k, pk);<span class=\"comment\">// 再比较一下当前节点键和指定key键的大小</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 定义xp指向当前节点</span></span><br><span class=\"line\">\t\tTreeNode&lt;K,V&gt; xp = p;</span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 如果dir小于等于0，那么看当前节点的左节点是否为空，</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 如果为空，就可以把要添加的元素作为当前节点的左节点，如果不为空，还需要下一轮继续比较</span></span><br><span class=\"line\"><span class=\"comment\">\t\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 如果dir大于等于0，那么看当前节点的右节点是否为空，</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 如果为空，就可以把要添加的元素作为当前节点的右节点，如果不为空，还需要下一轮继续比较</span></span><br><span class=\"line\"><span class=\"comment\">\t\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 如果以上两条当中有一个子节点不为空，</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 这个if中还做了一件事，那就是把p已经指向了对应的不为空的子节点，开始下一轮的比较</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((p = (dir &lt;= <span class=\"number\">0</span>) ? p.left : p.right) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果恰好要添加的方向上的子节点为空，此时节点p已经指向了这个空的子节点</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 获取当前节点的next节点</span></span><br><span class=\"line\">\t\t\tNode&lt;K,V&gt; xpn = xp.next;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 创建一个新的树节点</span></span><br><span class=\"line\">\t\t\tTreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dir &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 左孩子指向到这个新的树节点</span></span><br><span class=\"line\">\t\t\t\txp.left = x;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 右孩子指向到这个新的树节点</span></span><br><span class=\"line\">\t\t\t\txp.right = x;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 链表中的next节点指向到这个新的树节点</span></span><br><span class=\"line\">\t\t\txp.next = x;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 这个新的树节点的父节点、前节点均设置为 当前的树节点</span></span><br><span class=\"line\">\t\t\tx.parent = x.prev = xp;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果原来的next节点不为空</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (xpn != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 那么原来的next节点的前节点指向到新的树节点</span></span><br><span class=\"line\">\t\t\t\t((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 重新平衡，以及新的根节点置顶</span></span><br><span class=\"line\">\t\t\tmoveRootToFront(tab, balanceInsertion(root, x));</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 返回空，意味着产生了一个新节点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"treeifyBin-链表转成红黑树\"><a href=\"#treeifyBin-链表转成红黑树\" class=\"headerlink\" title=\"treeifyBin 链表转成红黑树\"></a>treeifyBin 链表转成红黑树</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将指定hash节点处的链表替换成红黑树</span></span><br><span class=\"line\"><span class=\"comment\"> * 除非table太小了，将用resizes（）改变树的容量</span></span><br><span class=\"line\"><span class=\"comment\"> * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class=\"line\"><span class=\"comment\"> * table is too small, in which case resizes instead.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeifyBin</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> hash)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果 table 为null 或者</span></span><br><span class=\"line\">\t<span class=\"comment\">// table的长度小于 MIN_TREEIFY_CAPACITY（默认64））不进行树化，调用resize进行扩容</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class=\"line\">\t\tresize();</span><br><span class=\"line\">\t<span class=\"comment\">// 如果 该hash值对应的 tab[index] 不为null，证明该位置有值</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\tTreeNode&lt;K,V&gt; hd = <span class=\"keyword\">null</span>, tl = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 遍历链表,将单项链表改为双向链表</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// node 节点转成 TreeNode节点</span></span><br><span class=\"line\">\t\t\tTreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果树为空</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 设置树的根</span></span><br><span class=\"line\">\t\t\t\thd = p;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 设置新节点p的上一个节点</span></span><br><span class=\"line\">\t\t\t\tp.prev = tl;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 设置 上一节点的 next 指向当前节点</span></span><br><span class=\"line\">\t\t\t\ttl.next = p;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//保存上一节点</span></span><br><span class=\"line\">\t\t\ttl = p;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果树的根节点不为null，调用treeify()进行树化</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((tab[index] = hd) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\thd.treeify(tab);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Forms tree of the nodes linked from this node.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> root of tree</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeify</span><span class=\"params\">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 树的根节点</span></span><br><span class=\"line\">\t\tTreeNode&lt;K,V&gt; root = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//x是当前节点，next是后继</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; x = <span class=\"keyword\">this</span>, next; x != <span class=\"keyword\">null</span>; x = next) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 后继节点</span></span><br><span class=\"line\">\t\t\tnext = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 左右儿子设为null</span></span><br><span class=\"line\">\t\t\tx.left = x.right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果根是 null</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 设置父节点为null</span></span><br><span class=\"line\">\t\t\t\tx.parent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 设置为黑色</span></span><br><span class=\"line\">\t\t\t\tx.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 把当前节点设置为根节点</span></span><br><span class=\"line\">\t\t\t\troot = x;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果有根节点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tK k = x.key;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> h = x.hash;</span><br><span class=\"line\">\t\t\t\tClass&lt;?&gt; kc = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 遍历树，进行二叉搜索树的插入</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// p指向遍历中的当前节点，</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// x为待插入节点，</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// k是x的key，</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// h是x的hash值，</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// ph是p的hash值，</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// pk是p的key，</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// dir用来指示x节点与p的比较，-1表示比p小，1表示比p大</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 不存在相等情况，因为HashMap中是不存在两个key完全一致的情况。</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">int</span> dir, ph;</span><br><span class=\"line\">\t\t\t\t\tK pk = p.key;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 待插入x的hash值小于当前点p的hash值</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ((ph = p.hash) &gt; h)</span><br><span class=\"line\">\t\t\t\t\t\tdir = -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ph &lt; h)</span><br><span class=\"line\">\t\t\t\t\t\tdir = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果hash值相等，那么判断k是否实现了comparable接口，</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果实现了comparable接口就使用compareTo进行进行比较，</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果仍旧相等或者没有实现comparable接口，则在tieBreakOrder中比较</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((kc == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t\t\t(kc = comparableClassFor(k)) == <span class=\"keyword\">null</span>) ||</span><br><span class=\"line\">\t\t\t\t\t\t\t(dir = compareComparables(kc, k, pk)) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t\t\tdir = tieBreakOrder(k, pk);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 将当前节点赋值给XP</span></span><br><span class=\"line\">\t\t\t\t\tTreeNode&lt;K,V&gt; xp = p;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果dir &lt;= 0 ,p 等于 p的左儿子，否则p 等于 p的右儿子</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果 p 等于 null，则插入x节点</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ((p = (dir &lt;= <span class=\"number\">0</span>) ? p.left : p.right) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// x的父节点指向 xp</span></span><br><span class=\"line\">\t\t\t\t\t\tx.parent = xp;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> (dir &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t\t\t\txp.left = x;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t\t\t\txp.right = x;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 进行平衡处理，保证红黑树的性质</span></span><br><span class=\"line\">\t\t\t\t\t\troot = balanceInsertion(root, x);</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//root节点移动到桶中的第一个元素，也就是链表的首节点</span></span><br><span class=\"line\">\t\tmoveRootToFront(tab, root);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"untreeify-树变链表\"><a href=\"#untreeify-树变链表\" class=\"headerlink\" title=\"untreeify 树变链表\"></a>untreeify 树变链表</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 树变链表</span></span><br><span class=\"line\"><span class=\"comment\"> * //重新创建链表节点，并形成链表结构</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">untreeify</span><span class=\"params\">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class=\"line\">\tNode&lt;K,V&gt; hd = <span class=\"keyword\">null</span>, tl = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (Node&lt;K,V&gt; q = <span class=\"keyword\">this</span>; q != <span class=\"keyword\">null</span>; q = q.next) &#123;</span><br><span class=\"line\">\t\tNode&lt;K,V&gt; p = map.replacementNode(q, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\thd = p;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\ttl.next = p;</span><br><span class=\"line\">\t\ttl = p;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> hd;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"balanceInsertion-红黑树插入平衡\"><a href=\"#balanceInsertion-红黑树插入平衡\" class=\"headerlink\" title=\"balanceInsertion 红黑树插入平衡\"></a>balanceInsertion 红黑树插入平衡</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 红黑树的插入平衡处理</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> root 根节点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> x 新插入节点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\">TreeNode&lt;K,V&gt; <span class=\"title\">balanceInsertion</span><span class=\"params\">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t\t\t\t\t\tTreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//插入的节点默认为红色</span></span><br><span class=\"line\">\tx.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// xp：当前节点的父节点</span></span><br><span class=\"line\">\t<span class=\"comment\">// xpp：爷爷节点</span></span><br><span class=\"line\">\t<span class=\"comment\">// xppl：左叔叔节点</span></span><br><span class=\"line\">\t<span class=\"comment\">// xppr：右叔叔节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// L1：如果父节点为空、说明当前节点就是根节点，那么把当前节点标为黑色，返回当前节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((xp = x.parent) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tx.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 父节点不为空</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// L2：如果 父节点为黑色 那么插入节点为红色不影响树的平衡</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// L3：或者 爷爷节点为空 即 父节点是根节点</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 返回根节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!xp.red || (xpp = xp.parent) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">\t\t<span class=\"comment\">// L4：父节点和祖父节点都存在，并且其父节点是祖父节点的左节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// L4.1 插入节点的叔叔节点是红色</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((xppr = xpp.right) != <span class=\"keyword\">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 将叔叔设置为黑色，父亲设为黑色，爷爷设为红色</span></span><br><span class=\"line\">\t\t\t\txppr.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\txp.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\txpp.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 将 爷爷 设为当前插入节点，自底向上，重新变色</span></span><br><span class=\"line\">\t\t\t\tx = xpp;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//L4.2：插入节点的叔叔节点是黑色或不存在</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// L4.2.1 插入节点是其父节点的右孩子</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (x == xp.right) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// x 设置为 父节点</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 将 父节点 左旋</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 旋转之后，原父子关系对调，因此，x还是子节点</span></span><br><span class=\"line\">\t\t\t\t\troot = rotateLeft(root, x = xp);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 将xp 设为父节点，xpp设为爷爷节点</span></span><br><span class=\"line\">\t\t\t\t\txpp = (xp = x.parent) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : xp.parent;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// L4.2.1 插入节点是其父节点的左孩子</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (xp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 父节点设为黑色</span></span><br><span class=\"line\">\t\t\t\t\txp.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果 有爷爷节点</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (xpp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 爷爷节点设置为红色</span></span><br><span class=\"line\">\t\t\t\t\t\txpp.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//  爷爷节点右旋</span></span><br><span class=\"line\">\t\t\t\t\t\troot = rotateRight(root, xpp);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// L5：插入的节点父节点和祖父节点都存在，并且其 父节点是祖父节点的右节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// L5.1：插入节点的叔叔节点是红色</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (xppl != <span class=\"keyword\">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 将叔叔设置为黑色，父亲设为黑色，爷爷设为红色</span></span><br><span class=\"line\">\t\t\t\txppl.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\txp.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\txpp.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 将 爷爷 设为当前插入节点，自底向上，重新变色</span></span><br><span class=\"line\">\t\t\t\tx = xpp;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//L5.2：插入节点的叔叔节点是黑色或不存在</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// L5.2.1 插入节点是其父节点的左孩子</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (x == xp.left) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// x 设置为 父节点</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 将 父节点 右旋</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 旋转之后，原父子关系对调，因此，x还是子节点</span></span><br><span class=\"line\">\t\t\t\t\troot = rotateRight(root, x = xp);</span><br><span class=\"line\">\t\t\t\t\txpp = (xp = x.parent) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : xp.parent;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// L5.2.2 插入节点是其父节点的右孩子</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (xp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 父节点设为黑色</span></span><br><span class=\"line\">\t\t\t\t\txp.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果 有爷爷 节点</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (xpp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 爷爷节点设置为红色</span></span><br><span class=\"line\">\t\t\t\t\t\txpp.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//  爷爷节点右旋</span></span><br><span class=\"line\">\t\t\t\t\t\troot = rotateLeft(root, xpp);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"get方法\"><a href=\"#get方法\" class=\"headerlink\" title=\"get方法\"></a>get方法</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\tNode&lt;K,V&gt; e;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"getNode\"><a href=\"#getNode\" class=\"headerlink\" title=\"getNode\"></a>getNode</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implements Map.get and related methods</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> hash key 的hash值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the node, or null if none</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">\tNode&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\">\t<span class=\"comment\">// table 不为null &amp;&amp; 不为空，并且 (n - 1) &amp; hash 算出来的index位置有值</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">\t\t\t(first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 判断第一个存在的节点的key 和 hash值是否与查询的key的相等，如果是直接返回</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">\t\t\t\t((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> first;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 遍历该链表/红黑树直到next为null</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果该点是红黑树</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 在树上寻找对应的值</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 遍历链表</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t\t((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> e;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//否则不存在，返回null</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"remove-及其相关方法\"><a href=\"#remove-及其相关方法\" class=\"headerlink\" title=\"remove 及其相关方法\"></a>remove 及其相关方法</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\tNode&lt;K,V&gt; e;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (e = removeNode(hash(key), key, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>)) == <span class=\"keyword\">null</span> ?</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"removeNode-删除节点\"><a href=\"#removeNode-删除节点\" class=\"headerlink\" title=\"removeNode 删除节点\"></a>removeNode 删除节点</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implements Map.remove and related methods</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> hash key的hash值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value 传入匹配的value值，如果matchValue=false，直接忽略</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> matchValue 为true时，会去进一步匹配value</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> movable if false do not move other nodes while removing</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the node, or null if none</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">removeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key, Object value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t   <span class=\"keyword\">boolean</span> matchValue, <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;</span><br><span class=\"line\">\tNode&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, index;</span><br><span class=\"line\">\t<span class=\"comment\">//确定table已经被初始化，并且其中有元素，并且对应的 hash值有元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">\t\t\t(p = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\tNode&lt;K,V&gt; node = <span class=\"keyword\">null</span>, e; K k; V v;</span><br><span class=\"line\">\t\t<span class=\"comment\">//判断当前这个找到的元素是不是目标元素，如果是的话赋值给node</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">\t\t\t\t((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">\t\t\tnode = p;</span><br><span class=\"line\">\t\t<span class=\"comment\">//不是的话，就从相同hash值的所有元素中去查找</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = p.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//该列表已经转换成红黑树的情况</span></span><br><span class=\"line\">\t\t\t\tnode = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//在链表中查找的情况</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t\t\t((k = e.key) == key ||</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t(key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tnode = e;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tp = e;</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//找到了目标节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class=\"line\">\t\t\t\t(value != <span class=\"keyword\">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//是红黑树节点的情况</span></span><br><span class=\"line\">\t\t\t\t((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class=\"keyword\">this</span>, tab, movable);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node == p)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//是一个链表开头元素的情况</span></span><br><span class=\"line\">\t\t\t\ttab[index] = node.next;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//是一个链表中间元素的情况</span></span><br><span class=\"line\">\t\t\t\tp.next = node.next;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//结构改变，修改次数需要加一</span></span><br><span class=\"line\">\t\t\t++modCount;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//元素减少size减1</span></span><br><span class=\"line\">\t\t\t--size;</span><br><span class=\"line\">\t\t\tafterNodeRemoval(node);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> node;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"removeTreeNode-红黑树中删除节点\"><a href=\"#removeTreeNode-红黑树中删除节点\" class=\"headerlink\" title=\"removeTreeNode 红黑树中删除节点\"></a>removeTreeNode 红黑树中删除节点</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">removeTreeNode</span><span class=\"params\">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t  <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果 table为空 或者为0 则无法删除，返回</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index = (n - <span class=\"number\">1</span>) &amp; hash;</span><br><span class=\"line\">\t<span class=\"comment\">// first 和 root 目前都为 根结点</span></span><br><span class=\"line\">\tTreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class=\"line\">\t<span class=\"comment\">// succ 是要删除节点的下一个，prev是要删除节点的前一个</span></span><br><span class=\"line\">\tTreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class=\"line\">\t<span class=\"comment\">// 首先先从TreeNode链表里将这个节点删除掉。</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\ttab[index] = first = succ;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tpred.next = succ;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (succ != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\tsucc.prev = pred;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (first == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root.parent != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\troot = root.root();</span><br><span class=\"line\">\t<span class=\"comment\">// 根结点为空 或 根节点的右儿子为空 或 根结点的做儿子为空 或 根节点的做儿子的做儿子为空</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span> || root.right == <span class=\"keyword\">null</span> ||</span><br><span class=\"line\">\t\t\t(rl = root.left) == <span class=\"keyword\">null</span> || rl.left == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 树太小了，从红黑树转换为链表</span></span><br><span class=\"line\">\t\ttab[index] = first.untreeify(map);  <span class=\"comment\">// too small</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 从红黑树删除这个节点</span></span><br><span class=\"line\">\t<span class=\"comment\">// p是要删除的节点 pl 是 p 的左节点, pr 是 P 的右节点。</span></span><br><span class=\"line\">\tTreeNode&lt;K,V&gt; p = <span class=\"keyword\">this</span>, pl = left, pr = right, replacement;</span><br><span class=\"line\">\t<span class=\"comment\">// 当 p 的左右节点都不为null</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pl != <span class=\"keyword\">null</span> &amp;&amp; pr != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// s 是 p的右节点 的 左叶子节点 的左节点。。。循环找到叶子节点</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 就是查找所有比当前节点大的节点当中最小的一个节点</span></span><br><span class=\"line\">\t\tTreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> ((sl = s.left) != <span class=\"keyword\">null</span>) <span class=\"comment\">// find successor</span></span><br><span class=\"line\">\t\t\ts = sl;</span><br><span class=\"line\">\t\t<span class=\"comment\">//交换 s 和 p 节点的颜色</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class=\"comment\">// swap colors</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// sr ：s的右节点</span></span><br><span class=\"line\">\t\tTreeNode&lt;K,V&gt; sr = s.right;</span><br><span class=\"line\">\t\t<span class=\"comment\">// pp ：p的父节点</span></span><br><span class=\"line\">\t\tTreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class=\"line\">\t\t<span class=\"comment\">//2： 如果s 等于pr 证明 p的 右节点 没有 左节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s == pr) &#123; <span class=\"comment\">// p was s's direct parent</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//当前节点的父节点设为找到的节点</span></span><br><span class=\"line\">\t\t\tp.parent = s;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//找到节点的右孩子设为当前节点</span></span><br><span class=\"line\">\t\t\ts.right = p;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//3： p 的右节点有左儿子</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// （以下操作就是将s和p对换了个位置和颜色，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果s有右儿子则设置为平衡点，否则p为平衡点）</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// sp ： s的父亲</span></span><br><span class=\"line\">\t\t\tTreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 将 p 的父亲设为 sp</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果sp 不为null</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((p.parent = sp) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 当前节点替代 s 节点的位置，与 s 节点的父节点进行关联</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// s 是 sp 的左儿子，左儿子设置为 p</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (s == sp.left)</span><br><span class=\"line\">\t\t\t\t\tsp.left = p;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span><span class=\"comment\">// s 是 sp 的右儿子，右儿子设置为 p</span></span><br><span class=\"line\">\t\t\t\t\tsp.right = p;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// s 的右节点设置为 p 的右孩子</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果 p 的右孩子不为null</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 右孩子的父节点设为 s 节点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((s.right = pr) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\tpr.parent = s;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//当前节点的左孩子设为null</span></span><br><span class=\"line\">\t\tp.left = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//将 p 节点的右孩子设置为 s节点的右孩子</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((p.right = sr) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\tsr.parent = p; <span class=\"comment\">//右孩子的父节点设为当前节点</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 将 s 节点的左儿子设置为 p节点的左儿子</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((s.left = pl) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\tpl.parent = s;<span class=\"comment\">// 左孩子的父节点设为找到节点</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 将s的父亲 设置为 p 节点的父亲</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果 p是根结点，那么根节点变为s</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((s.parent = pp) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\troot = s;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 父节点不为null，当前节点是父节点的左孩子</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == pp.left)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 父亲的左儿子改为s</span></span><br><span class=\"line\">\t\t\tpp.left = s;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 父亲的右儿子改为s</span></span><br><span class=\"line\">\t\t\tpp.right = s;</span><br><span class=\"line\">\t\t<span class=\"comment\">// s节点的右孩子不为null</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sr != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 则s节点的右孩子节点作为平衡删除的初始节点</span></span><br><span class=\"line\">\t\t\treplacement = sr;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 否则平衡删除的初始节点为 p。</span></span><br><span class=\"line\">\t\t\treplacement = p;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//当前节点左孩子不为null，右孩子为null</span></span><br><span class=\"line\">\t<span class=\"comment\">//当前节点的左孩子作为平衡删除的节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pl != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\treplacement = pl;</span><br><span class=\"line\">\t<span class=\"comment\">//当前节点右孩子不为null，左孩子为null</span></span><br><span class=\"line\">\t<span class=\"comment\">// 当前节点的右孩子作为平衡删除的节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pr != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\treplacement = pr;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span><span class=\"comment\">//左右孩子都为null，当前节点作为平衡删除的节点</span></span><br><span class=\"line\">\t\treplacement = p;</span><br><span class=\"line\">\t<span class=\"comment\">//如果当前节点不是作为平衡删除的节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (replacement != p) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//此时p.parent有三种情况，1.其原来的父节点，2.它的右子节点，3.s节点的父节点sp</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//将当前节点的父节点设为平衡删除节点的父节点</span></span><br><span class=\"line\">\t\tTreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class=\"line\">\t\t<span class=\"comment\">//如果当前节点的父节点为null，则表明当前节点原来是根节点，此时当前节点的父节点还是其原来的父节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pp == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\troot = replacement;<span class=\"comment\">//设置作为平衡删除的节点为根节点</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果父节点不为null，并且当前节点是父节点的左子节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == pp.left)<span class=\"comment\">//设置父节点的左子节点为作为平衡删除的节点</span></span><br><span class=\"line\">\t\t\tpp.left = replacement;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span><span class=\"comment\">//设置父节点的右子节点为作为平衡删除的节点</span></span><br><span class=\"line\">\t\t\tpp.right = replacement;</span><br><span class=\"line\">\t\t<span class=\"comment\">//将当前节点与树结构断开，因为当前节点不是作为平衡删除的节点</span></span><br><span class=\"line\">\t\tp.left = p.right = p.parent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取根节点，如果删除节点是红色，则不需要做平衡删除，根节点不会再变</span></span><br><span class=\"line\">\t<span class=\"comment\">// 如果删除节点是黑色，则需要做平衡删除，根节点可能会发生改变</span></span><br><span class=\"line\">\tTreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//做平衡删除的节点是当前要删除的节点</span></span><br><span class=\"line\">\t<span class=\"comment\">//平衡删除做完后将该节点从树结构中脱离出来</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (replacement == p) &#123;  <span class=\"comment\">// detach</span></span><br><span class=\"line\">\t\tTreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class=\"line\">\t\tp.parent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (p == pp.left)</span><br><span class=\"line\">\t\t\t\tpp.left = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == pp.right)</span><br><span class=\"line\">\t\t\t\tpp.right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//是否需要从新设置桶的头节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (movable)</span><br><span class=\"line\">\t\t<span class=\"comment\">//将桶的头节点设为根节点</span></span><br><span class=\"line\">\t\tmoveRootToFront(tab, r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"balanceDeletion-红黑树删除平衡\"><a href=\"#balanceDeletion-红黑树删除平衡\" class=\"headerlink\" title=\"balanceDeletion 红黑树删除平衡\"></a>balanceDeletion 红黑树删除平衡</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 红黑树平衡删除，只有在删除的节点是黑色时才会调用此方法</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> root 根结点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> x 平衡节点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\">TreeNode&lt;K,V&gt; <span class=\"title\">balanceDeletion</span><span class=\"params\">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t\t\t\t\t   TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//平衡节点为null或者平衡节点是根节点，无需做平衡处理，返回根节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (x == <span class=\"keyword\">null</span> || x == root)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">\t\t<span class=\"comment\">//平衡节点不是根，但平衡节点的父节点是null</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//则将平衡节点将成为根节点，将其颜色设置为黑色</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((xp = x.parent) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tx.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//不是根节点，父节点也不为null，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//若做平衡的节点就是要删除的节点，则设什么颜色都无所谓，直接返回根节点</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//若做平衡的节点不是要删除的节点，而且还是红色</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//则其要替换的节点就是其父节点，替换的父节点就是要删除的节点，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//而做平衡的节点还是红色，则其父一定是黑色，其替换其父所以要变成黑色</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//因为做平衡的节点是红，它替换掉了其父（在进入此方法之前已经替换掉了）</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//其父是黑，所以只需要确保其是黑，就能确保该树枝上的黑色节点数不变</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//替换完直接返回根节点即可</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x.red) &#123;</span><br><span class=\"line\">\t\t\tx.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//x的节点不是根，父也不为null，其颜色是黑色</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//x的节点是其父的左子节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果它有红色的兄弟节点xpr，那么它的父亲节点xp一定是黑色节点</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 将兄弟节点设为黑色，父亲节点设为红色，以父节点进行旋转</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((xpr = xp.right) != <span class=\"keyword\">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class=\"line\">\t\t\t\txpr.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\txp.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//对父节点xp做左旋转</span></span><br><span class=\"line\">\t\t\t\troot = rotateLeft(root, xp);</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//重新将xp指向x的父节点，xpr指向xp新的右孩子</span></span><br><span class=\"line\">\t\t\t\txpr = (xp = x.parent) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : xp.right;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果xpr为空，则向上继续调整，将x的父节点xp作为新的x继续循环</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (xpr == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\tx = xp;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//sl和sr分别为其兄弟节点左儿子和右儿子</span></span><br><span class=\"line\">\t\t\t\tTreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//若sl和sr都为黑色或者不存在，即xpr没有红色孩子，则将xpr染红</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ((sr == <span class=\"keyword\">null</span> || !sr.red) &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t\t(sl == <span class=\"keyword\">null</span> || !sl.red)) &#123;</span><br><span class=\"line\">\t\t\t\t\txpr.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t\tx = xp;<span class=\"comment\">//本轮结束，继续向上循环</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//否则的话，就需要进一步调整</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (sr == <span class=\"keyword\">null</span> || !sr.red) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//若左孩子为红，右孩子不存在或为黑</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> (sl != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">//左孩子染黑</span></span><br><span class=\"line\">\t\t\t\t\t\t\tsl.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//将xpr染红</span></span><br><span class=\"line\">\t\t\t\t\t\txpr.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//右旋</span></span><br><span class=\"line\">\t\t\t\t\t\troot = rotateRight(root, xpr);</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//右旋后，xpr指向xp的新右孩子，即上一步中的sl</span></span><br><span class=\"line\">\t\t\t\t\t\txpr = (xp = x.parent) == <span class=\"keyword\">null</span> ?</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">null</span> : xp.right;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果兄弟节点 不为null</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (xpr != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 如果父节点为空，兄弟节点染为黑色，否则和父亲节点染色相同</span></span><br><span class=\"line\">\t\t\t\t\t\txpr.red = (xp == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">false</span> : xp.red;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// sr 设置为兄弟节点的右孩子，如果sr不为null，将sr设置为黑色，防止出现两个红色相连</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> ((sr = xpr.right) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\t\t\tsr.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果父节点不为null</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (xp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//将父亲节点设置为黑色</span></span><br><span class=\"line\">\t\t\t\t\t\txp.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 左旋父节点</span></span><br><span class=\"line\">\t\t\t\t\t\troot = rotateLeft(root, xp);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tx = root;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//x为其父节点的右孩子，跟上面操作镜像</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123; <span class=\"comment\">// symmetric</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (xpl != <span class=\"keyword\">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class=\"line\">\t\t\t\txpl.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\txp.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\troot = rotateRight(root, xp);</span><br><span class=\"line\">\t\t\t\txpl = (xp = x.parent) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : xp.left;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (xpl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\tx = xp;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tTreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ((sl == <span class=\"keyword\">null</span> || !sl.red) &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t\t(sr == <span class=\"keyword\">null</span> || !sr.red)) &#123;</span><br><span class=\"line\">\t\t\t\t\txpl.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t\tx = xp;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (sl == <span class=\"keyword\">null</span> || !sl.red) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> (sr != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\t\t\tsr.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\t\t\txpl.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t\t\troot = rotateLeft(root, xpl);</span><br><span class=\"line\">\t\t\t\t\t\txpl = (xp = x.parent) == <span class=\"keyword\">null</span> ?</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">null</span> : xp.left;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (xpl != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\txpl.red = (xp == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">false</span> : xp.red;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> ((sl = xpl.left) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\t\t\tsl.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (xp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\txp.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\t\t\troot = rotateRight(root, xp);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tx = root;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"rotateLeft-红黑树左旋（右旋转同理）\"><a href=\"#rotateLeft-红黑树左旋（右旋转同理）\" class=\"headerlink\" title=\"rotateLeft 红黑树左旋（右旋转同理）\"></a>rotateLeft 红黑树左旋（右旋转同理）</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 红黑树左旋</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> root 根节点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> p 要左旋的节点</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\">TreeNode&lt;K,V&gt; <span class=\"title\">rotateLeft</span><span class=\"params\">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t\t\t\t  TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// pp : p的父亲</span></span><br><span class=\"line\">\t<span class=\"comment\">// r: p的右孩子</span></span><br><span class=\"line\">\t<span class=\"comment\">// rl = p 的右孩子的左孩子 -&gt; r的左孩子</span></span><br><span class=\"line\">\tTreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class=\"line\">\t<span class=\"comment\">// 要 p 以及 p的右孩子 不为null</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span> &amp;&amp; (r = p.right) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将p 的右孩子 设置为 rl 并且 rl不为空</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((rl = p.right = r.left) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// rl的父亲节点设置为p</span></span><br><span class=\"line\">\t\t\trl.parent = p;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将 r 的父亲 设置为 p的父亲（此时r 与p为兄弟）</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果父亲节点为null，则此时 r为跟节点</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 将root 设置为r ，并设置为黑色</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((pp = r.parent = p.parent) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t(root = r).red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果父节点的左儿子是 p</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pp.left == p)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 将父节点的 左儿子 设为r</span></span><br><span class=\"line\">\t\t\tpp.left = r;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 否则将 右儿子 设为r</span></span><br><span class=\"line\">\t\t\tpp.right = r;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将 r 的左节儿子 设置为p</span></span><br><span class=\"line\">\t\tr.left = p;</span><br><span class=\"line\">\t\t<span class=\"comment\">// p 的父亲设置为 r</span></span><br><span class=\"line\">\t\tp.parent = r;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 返回根节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"HashMap-的存储结构\"><a href=\"#HashMap-的存储结构\" class=\"headerlink\" title=\"HashMap 的存储结构\"></a>HashMap 的存储结构</h1><p>HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;<span class=\"comment\">// key的hash值</span></span><br><span class=\"line\">\t<span class=\"keyword\">final</span> K key; <span class=\"comment\">// key</span></span><br><span class=\"line\">\tV value; <span class=\"comment\">// value</span></span><br><span class=\"line\">\tNode&lt;K,V&gt; next; <span class=\"comment\">//同一个hash值下的链表/红黑树</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tNode(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.hash = hash;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span>        </span>&#123; <span class=\"keyword\">return</span> key; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span>      </span>&#123; <span class=\"keyword\">return</span> value; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> key + <span class=\"string\">\"=\"</span> + value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">setValue</span><span class=\"params\">(V newValue)</span> </span>&#123;</span><br><span class=\"line\">\t\tV oldValue = value;</span><br><span class=\"line\">\t\tvalue = newValue;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (o == <span class=\"keyword\">this</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Map.Entry) &#123;</span><br><span class=\"line\">\t\t\tMap.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\tObjects.equals(value, e.getValue()))</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TreeNode&lt;K,V&gt; 继承 LinkedHashMap.Entry&lt;K,V&gt;，用来实现红黑树相关的存储结构</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">LinkedHashMap</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; parent;  <span class=\"comment\">// 存储当前节点的父节点</span></span><br><span class=\"line\">    TreeNode&lt;K,V&gt; left;　<span class=\"comment\">// 存储当前节点的左孩子</span></span><br><span class=\"line\">    TreeNode&lt;K,V&gt; right;　<span class=\"comment\">// 存储当前节点的右孩子</span></span><br><span class=\"line\">    TreeNode&lt;K,V&gt; prev;    <span class=\"comment\">// prev则指向前一个节点（原链表中的前一个节点）</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> red;　<span class=\"comment\">// 存储当前节点的颜色（红、黑）</span></span><br><span class=\"line\">    TreeNode(<span class=\"keyword\">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(hash, key, val, next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">root</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">moveRootToFront</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeify</span><span class=\"params\">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">untreeify</span><span class=\"params\">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">putTreeVal</span><span class=\"params\">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                   <span class=\"keyword\">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">removeTreeNode</span><span class=\"params\">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">split</span><span class=\"params\">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> bit)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/* ------------------------------------------------------------ */</span></span><br><span class=\"line\">    <span class=\"comment\">// Red-black tree methods, all adapted from CLR</span></span><br><span class=\"line\">    <span class=\"comment\">// 红黑树相关操作</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\">TreeNode&lt;K,V&gt; <span class=\"title\">rotateLeft</span><span class=\"params\">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                          TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\">TreeNode&lt;K,V&gt; <span class=\"title\">rotateRight</span><span class=\"params\">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                           TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\">TreeNode&lt;K,V&gt; <span class=\"title\">balanceInsertion</span><span class=\"params\">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\">TreeNode&lt;K,V&gt; <span class=\"title\">balanceDeletion</span><span class=\"params\">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                               TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class=\"line\">    &#125;       </span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">checkInvariants</span><span class=\"params\">(TreeNode&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"各常量、成员变量作用\"><a href=\"#各常量、成员变量作用\" class=\"headerlink\" title=\"各常量、成员变量作用　　\"></a>各常量、成员变量作用　　</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 默认初始容量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>; <span class=\"comment\">// aka 16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 最大容量， 当传入容量过大时将被这个值替换</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 默认负载因子</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 当链表的长度超过8，有可能会转化成树</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 当链表的长度小于6则会从红黑树转回链表</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。</span></span><br><span class=\"line\"><span class=\"comment\"> * 这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TREEIFY_CAPACITY = <span class=\"number\">64</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 用来存储 key-value 的节点对象。在 HashMap 中它有个专业的叫法 buckets ，中文叫作桶。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 同时封装了 keySet 和 values 的视图</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 容器中实际存放 Node 的大小</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * HashMap 在结构上被修改的次数，结构修改是指改变HashMap中映射的次数，或者以其他方式修改其内部结构(例如，rehash)。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * HashMap的扩容阈值(=负载因子*table的容量)</span></span><br><span class=\"line\"><span class=\"comment\"> * 在HashMap中存储的Node键值对超过这个数量时，自动扩容容量为原来的二倍</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 负载因子</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@serial</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class=\"line\"><span class=\"comment\"> * capacity and load factor.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  initialCapacity 初始容量</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  loadFactor      负载因子</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> IllegalArgumentException 如果初始容量为负或者负载因子非正数抛出该异常</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 当初始容量为负</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> +</span><br><span class=\"line\">\t\t\t\tinitialCapacity);</span><br><span class=\"line\">\t<span class=\"comment\">// 当初始容量大于最大容量 2^30 ，初始容量= 2^30</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">\t\tinitialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">\t<span class=\"comment\">// 当负载因子非正数 或 负载因子是NaN(Not a Number，0.0f/0.0f的值就是NaN)</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> +</span><br><span class=\"line\">\t\t\t\tloadFactor);</span><br><span class=\"line\">\t<span class=\"comment\">// 赋值</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取比传入参数大的最小的2的N次幂。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tableSizeFor</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n = cap - <span class=\"number\">1</span>;</span><br><span class=\"line\">\tn |= n &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\tn |= n &gt;&gt;&gt; <span class=\"number\">2</span>;</span><br><span class=\"line\">\tn |= n &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">\tn |= n &gt;&gt;&gt; <span class=\"number\">8</span>;</span><br><span class=\"line\">\tn |= n &gt;&gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (n &lt; <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"put方法\"><a href=\"#put方法\" class=\"headerlink\" title=\"put方法\"></a>put方法</h1><p>put方法主要是调用putVal方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使 key 和 value 产生关联，但如果有相同的 key 则新的会替换掉旧的。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * h &gt;&gt;&gt; 16:无符号右移动16位，意味着取高16位二进制</span></span><br><span class=\"line\"><span class=\"comment\"> * 低16位与高16位进行异或</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> h;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果为 null 则返回的就是 0，否则就是 hashCode 异或上 hashCode 无符号右移 16 位</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"putVal方法\"><a href=\"#putVal方法\" class=\"headerlink\" title=\"putVal方法\"></a>putVal方法</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implements Map.put and related methods</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> hash key的hash值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value the value to put</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> onlyIfAbsent 如果true代表不更改现有的值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> evict 如果为false表示table为创建状态</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> previous value, or null if none</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t   <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">\tNode&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 判断table是否等于空或者table的长度等于0，如果是就进行初始化</span></span><br><span class=\"line\"><span class=\"comment\">\t * 此时通过resize()方法得到初始化的table</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\tn = (tab = resize()).length;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 对hash码进行散列 ，对值的位置进行确认</span></span><br><span class=\"line\"><span class=\"comment\">\t * 如果tab[i] 为null 表示没有hash冲突，就新增一个元素</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\ttab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果tab[i] 不为null，表示该位置有值了。</span></span><br><span class=\"line\">\t\tNode&lt;K,V&gt; e; K k;</span><br><span class=\"line\">\t\t<span class=\"comment\">//HashMap中判断key相同的条件是key的hash相同，并且符合equals方法。这里判断了p.key是否和插入的key相等，如果相等，则将p的引用赋给e</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//这里为什么要把p赋值给e，而不是直接覆盖原值呢？答案很简单，现在我们只判断了第一个节点，后面还可能出现key相同，所以需要在最后一并处理</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">\t\t\t\t((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">\t\t\te = p;</span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 判断是否是红黑树</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * p是红黑树节点，那么肯定插入后仍然是红黑树节点，所以我们直接强制转型p后调用TreeNode.putTreeVal方法，返回的引用赋给e</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">\t\t\te = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 否则就是链表</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果是链表，要遍历到最后一个节点进行插入</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 插入到链尾</span></span><br><span class=\"line\">\t\t\t\t\tp.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 判断节点的长度是否大于TREEIFY_THRESHOLD红黑树的阈值，是就进行转换</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">\t\t\t\t\t\ttreeifyBin(tab, hash);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 对链表中的相同 hash 值且 key 相同的进一步作检查</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t\t((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\tp = e;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 插入</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 取出旧值，onlyIfAbsent此时为 false，所以不管 oldValue 有与否，都拿新值来替换</span></span><br><span class=\"line\">\t\t\tV oldValue = e.value;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\te.value = value;</span><br><span class=\"line\">\t\t\tafterNodeAccess(e);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 记录修改次数</span></span><br><span class=\"line\">\t++modCount;</span><br><span class=\"line\">\t<span class=\"comment\">// 超过阈值 threshold = capacity * factor，调用 resize() 进行扩容</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">\t\tresize();</span><br><span class=\"line\">\tafterNodeInsertion(evict);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"resize-扩容兼初始化\"><a href=\"#resize-扩容兼初始化\" class=\"headerlink\" title=\"resize 扩容兼初始化\"></a>resize 扩容兼初始化</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class=\"line\"><span class=\"comment\"> * accord with initial capacity target held in field threshold.</span></span><br><span class=\"line\"><span class=\"comment\"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class=\"line\"><span class=\"comment\"> * elements from each bin must either stay at same index, or move</span></span><br><span class=\"line\"><span class=\"comment\"> * with a power of two offset in the new table.</span></span><br><span class=\"line\"><span class=\"comment\"> * 扩容兼初始化</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the table</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//将原来的table指针保存</span></span><br><span class=\"line\">\tNode&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">\t<span class=\"comment\">//获取原来数组的长度，oldTab为null说明还没有进行初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">\t<span class=\"comment\">//保存以前重构table的阈值</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//oldCap &gt; 0表示已经初始化过了</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//当原来的容量已经达到最大容量的时候，将阈值设置为Integer.MAX_VALUE，这样就不会再发生重构的情况</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">\t\t\tthreshold = Integer.MAX_VALUE;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 否则将旧的容量扩大两倍</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 当它小于最大容量，并且旧的容量大于初始化最小容量的时候，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 将新的阈值设置为旧的阈值的两倍, 新的容量设置为旧容量的2倍</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">\t\t\t\toldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">\t\t\tnewThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//虽然还没有初始化，但是设置过了阈值，将旧的阈值设置为新的容量</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">\t\tnewCap = oldThr;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//没有初始化阈值的时候采用默认算法计算阈值</span></span><br><span class=\"line\">\t\tnewCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">\t\tnewThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 对应oldCap = 0 &amp;&amp; oldThr &gt; 0的情况</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//重新用默认负载因子计算 扩容阈值</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果新容量小于最大容量 &amp;&amp; 新扩容阈值(ft) 小于最大容量</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 新阈值 = ft 否则 新阈值 = int的最大范围</span></span><br><span class=\"line\">\t\tnewThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">\t\t\t\t(<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 把当前阈值设为新阈值</span></span><br><span class=\"line\">\tthreshold = newThr;</span><br><span class=\"line\">\t<span class=\"comment\">// 根据新容量，创建新table</span></span><br><span class=\"line\">\t<span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"rawtypes\"</span>,<span class=\"string\">\"unchecked\"</span>&#125;)</span><br><span class=\"line\">\tNode&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">\t<span class=\"comment\">// 将当前table 设置为新扩容的table</span></span><br><span class=\"line\">\ttable = newTab;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果已经被初始化过</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//将旧数组中的元素全部取出，重新映射到新数组中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">\t\t\tNode&lt;K,V&gt; e;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\toldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 该节点没有next节点，表示没有链表，没有冲突，那重新计算下位置</span></span><br><span class=\"line\">\t\t\t\t\tnewTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 冲突的是一棵树节点，分裂成 2 个树，或者如果树很小就转成链表</span></span><br><span class=\"line\">\t\t\t\t\t((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 对原来的链表部分进行重构</span></span><br><span class=\"line\">\t\t\t\t\tNode&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t\tNode&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t\tNode&lt;K,V&gt; next;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\tnext = e.next;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 索引不变</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\t\t\t\tloHead = e;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\tloTail.next = e;</span><br><span class=\"line\">\t\t\t\t\t\t\tloTail = e;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 原索引+oldCap</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\t\t\t\thiHead = e;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\thiTail.next = e;</span><br><span class=\"line\">\t\t\t\t\t\t\thiTail = e;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 原索引放到 tables 里</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tloTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t\t\tnewTab[j] = loHead;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 原索引+oldCap放到  tables 里</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\thiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t\t\tnewTab[j + oldCap] = hiHead;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 返回扩容后的table</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"split-扩容时重新划分树\"><a href=\"#split-扩容时重新划分树\" class=\"headerlink\" title=\"split 扩容时重新划分树\"></a>split 扩容时重新划分树</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 扩容时重新划分树</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> map the map</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> tab 扩容后的数组</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> index 数组索引</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> bit 原数组容量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">split</span><span class=\"params\">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> bit)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//b设置为当前桶的头节点</span></span><br><span class=\"line\">\tTreeNode&lt;K,V&gt; b = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// Relink into lo and hi lists, preserving order</span></span><br><span class=\"line\">\t<span class=\"comment\">//低位树链表头节点，尾结点</span></span><br><span class=\"line\">\tTreeNode&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//高位树链表头节点，尾结点</span></span><br><span class=\"line\">\tTreeNode&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//lc低位树链表中节点个数，hc高位树链表中节点个数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> lc = <span class=\"number\">0</span>, hc = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//e当前遍历节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class=\"keyword\">null</span>; e = next) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//当前遍历节点的后继节点</span></span><br><span class=\"line\">\t\tnext = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class=\"line\">\t\t<span class=\"comment\">//将当前遍历节点后继设为null</span></span><br><span class=\"line\">\t\te.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((e.hash &amp; bit) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//==0表示当前遍历节点应该存放在低位</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果低位中还没有节点</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//将当前遍历节点设为低位头节点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((e.prev = loTail) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\tloHead = e;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//将当前遍历节点加入到链表的尾部</span></span><br><span class=\"line\">\t\t\t\tloTail.next = e;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//设置尾节点为当前遍历节点</span></span><br><span class=\"line\">\t\t\tloTail = e;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//低位链表中的节点数加1</span></span><br><span class=\"line\">\t\t\t++lc;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//!=0表示当前遍历节点应该存放在高位</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((e.prev = hiTail) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\thiHead = e;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\thiTail.next = e;</span><br><span class=\"line\">\t\t\thiTail = e;</span><br><span class=\"line\">\t\t\t++hc;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//如果低位节点链表不为null</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (loHead != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//低位节点链表中节点的个数小于6，此时需要将树结构转为链表结构</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class=\"line\">\t\t\ttab[index] = loHead.untreeify(map);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;<span class=\"comment\">//链表中节点的个数满足保持树型结构所需要的节点个数</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//低位桶的头节点设为链表的头节点</span></span><br><span class=\"line\">\t\t\ttab[index] = loHead;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 高位节点链表不为null，说明有节点从原树结构中分离出去了</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 原有树结构被破坏</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 所以低位的节点链表需要重新构建树结构</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (hiHead != <span class=\"keyword\">null</span>) <span class=\"comment\">// (else is already treeified)</span></span><br><span class=\"line\">\t\t\t\tloHead.treeify(tab);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 同理</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (hiHead != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class=\"line\">\t\t\ttab[index + bit] = hiHead.untreeify(map);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\ttab[index + bit] = hiHead;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (loHead != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\thiHead.treeify(tab);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"putTreeVal-在红黑树中添加节点\"><a href=\"#putTreeVal-在红黑树中添加节点\" class=\"headerlink\" title=\"putTreeVal 在红黑树中添加节点\"></a>putTreeVal 在红黑树中添加节点</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> map 当前节点所在的HashMap对象</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> tab 当前HashMap对象的元素数组</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> h key的hash值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> k key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> v value</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 指定key所匹配到的节点对象，针对这个对象去修改V（返回空说明创建了一个新节点）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">putTreeVal</span><span class=\"params\">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t\t   <span class=\"keyword\">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 定义k的Class对象</span></span><br><span class=\"line\">\tClass&lt;?&gt; kc = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 标识是否已经遍历过一次树，未必是从根节点遍历的，但是遍历路径上一定已经包含了后续需要比对的所有节点。</span></span><br><span class=\"line\">\t<span class=\"keyword\">boolean</span> searched = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//父节点不为空那么查找根节点，为空那么自身就是根节点</span></span><br><span class=\"line\">\tTreeNode&lt;K,V&gt; root = (parent != <span class=\"keyword\">null</span>) ? root() : <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 从根节点开始遍历，没有终止条件，只能从内部退出</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 声明方向、当前节点hash值、当前节点的键对象</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> dir, ph; K pk;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果当前节点hash 大于 指定key的hash值,要添加的元素应该放置在当前节点的左侧</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((ph = p.hash) &gt; h)</span><br><span class=\"line\">\t\t\tdir = -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果当前节点hash 小于 指定key的hash值,要添加的元素应该放置在当前节点的右侧</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ph &lt; h)</span><br><span class=\"line\">\t\t\tdir = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果当前节点的键对象 和 指定key对象相同,那么就返回当前节点对象</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((pk = p.key) == k || (k != <span class=\"keyword\">null</span> &amp;&amp; k.equals(pk)))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 走到这一步说明 当前节点的hash值  和 指定key的hash值  是相等的，但是equals不等</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((kc == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">\t\t\t\t(kc = comparableClassFor(k)) == <span class=\"keyword\">null</span>) ||</span><br><span class=\"line\">\t\t\t\t(dir = compareComparables(kc, k, pk)) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 走到这里说明：指定key没有实现comparable接口   或者   实现了comparable接口并且和当前节点的键对象比较之后相等（仅限第一次循环）</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * searched 标识是否已经对比过当前节点的左右子节点了</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * 如果还没有遍历过，那么就递归遍历对比，看是否能够得到那个键对象equals相等的的节点</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * 如果得到了键的equals相等的的节点就返回</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * 如果还是没有键的equals相等的节点，那说明应该创建一个新节点了</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t */</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!searched) &#123;<span class=\"comment\">// 如果还没有比对过当前节点的所有子节点</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 定义要返回的节点、和子节点</span></span><br><span class=\"line\">\t\t\t\tTreeNode&lt;K,V&gt; q, ch;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 标识已经遍历过一次了</span></span><br><span class=\"line\">\t\t\t\tsearched = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t * 红黑树也是二叉树，所以只要沿着左右两侧遍历寻找就可以了</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t * 这是个短路运算，如果先从左侧就已经找到了，右侧就不需要遍历了</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t * find 方法内部还会有递归调用</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t */</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (((ch = p.left) != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t\t(q = ch.find(h, k, kc)) != <span class=\"keyword\">null</span>) ||</span><br><span class=\"line\">\t\t\t\t\t\t((ch = p.right) != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t(q = ch.find(h, k, kc)) != <span class=\"keyword\">null</span>))</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 找到了指定key键对应的</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> q;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 走到这里就说明，遍历了所有子节点也没有找到和当前键equals相等的节点</span></span><br><span class=\"line\">\t\t\tdir = tieBreakOrder(k, pk);<span class=\"comment\">// 再比较一下当前节点键和指定key键的大小</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 定义xp指向当前节点</span></span><br><span class=\"line\">\t\tTreeNode&lt;K,V&gt; xp = p;</span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 如果dir小于等于0，那么看当前节点的左节点是否为空，</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 如果为空，就可以把要添加的元素作为当前节点的左节点，如果不为空，还需要下一轮继续比较</span></span><br><span class=\"line\"><span class=\"comment\">\t\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 如果dir大于等于0，那么看当前节点的右节点是否为空，</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 如果为空，就可以把要添加的元素作为当前节点的右节点，如果不为空，还需要下一轮继续比较</span></span><br><span class=\"line\"><span class=\"comment\">\t\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 如果以上两条当中有一个子节点不为空，</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 这个if中还做了一件事，那就是把p已经指向了对应的不为空的子节点，开始下一轮的比较</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((p = (dir &lt;= <span class=\"number\">0</span>) ? p.left : p.right) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果恰好要添加的方向上的子节点为空，此时节点p已经指向了这个空的子节点</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 获取当前节点的next节点</span></span><br><span class=\"line\">\t\t\tNode&lt;K,V&gt; xpn = xp.next;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 创建一个新的树节点</span></span><br><span class=\"line\">\t\t\tTreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dir &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 左孩子指向到这个新的树节点</span></span><br><span class=\"line\">\t\t\t\txp.left = x;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 右孩子指向到这个新的树节点</span></span><br><span class=\"line\">\t\t\t\txp.right = x;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 链表中的next节点指向到这个新的树节点</span></span><br><span class=\"line\">\t\t\txp.next = x;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 这个新的树节点的父节点、前节点均设置为 当前的树节点</span></span><br><span class=\"line\">\t\t\tx.parent = x.prev = xp;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果原来的next节点不为空</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (xpn != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 那么原来的next节点的前节点指向到新的树节点</span></span><br><span class=\"line\">\t\t\t\t((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 重新平衡，以及新的根节点置顶</span></span><br><span class=\"line\">\t\t\tmoveRootToFront(tab, balanceInsertion(root, x));</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 返回空，意味着产生了一个新节点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"treeifyBin-链表转成红黑树\"><a href=\"#treeifyBin-链表转成红黑树\" class=\"headerlink\" title=\"treeifyBin 链表转成红黑树\"></a>treeifyBin 链表转成红黑树</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将指定hash节点处的链表替换成红黑树</span></span><br><span class=\"line\"><span class=\"comment\"> * 除非table太小了，将用resizes（）改变树的容量</span></span><br><span class=\"line\"><span class=\"comment\"> * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class=\"line\"><span class=\"comment\"> * table is too small, in which case resizes instead.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeifyBin</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> hash)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果 table 为null 或者</span></span><br><span class=\"line\">\t<span class=\"comment\">// table的长度小于 MIN_TREEIFY_CAPACITY（默认64））不进行树化，调用resize进行扩容</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class=\"line\">\t\tresize();</span><br><span class=\"line\">\t<span class=\"comment\">// 如果 该hash值对应的 tab[index] 不为null，证明该位置有值</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\tTreeNode&lt;K,V&gt; hd = <span class=\"keyword\">null</span>, tl = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 遍历链表,将单项链表改为双向链表</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// node 节点转成 TreeNode节点</span></span><br><span class=\"line\">\t\t\tTreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果树为空</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 设置树的根</span></span><br><span class=\"line\">\t\t\t\thd = p;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 设置新节点p的上一个节点</span></span><br><span class=\"line\">\t\t\t\tp.prev = tl;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 设置 上一节点的 next 指向当前节点</span></span><br><span class=\"line\">\t\t\t\ttl.next = p;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//保存上一节点</span></span><br><span class=\"line\">\t\t\ttl = p;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果树的根节点不为null，调用treeify()进行树化</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((tab[index] = hd) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\thd.treeify(tab);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Forms tree of the nodes linked from this node.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> root of tree</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeify</span><span class=\"params\">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 树的根节点</span></span><br><span class=\"line\">\t\tTreeNode&lt;K,V&gt; root = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//x是当前节点，next是后继</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; x = <span class=\"keyword\">this</span>, next; x != <span class=\"keyword\">null</span>; x = next) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 后继节点</span></span><br><span class=\"line\">\t\t\tnext = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 左右儿子设为null</span></span><br><span class=\"line\">\t\t\tx.left = x.right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果根是 null</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 设置父节点为null</span></span><br><span class=\"line\">\t\t\t\tx.parent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 设置为黑色</span></span><br><span class=\"line\">\t\t\t\tx.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 把当前节点设置为根节点</span></span><br><span class=\"line\">\t\t\t\troot = x;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果有根节点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tK k = x.key;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> h = x.hash;</span><br><span class=\"line\">\t\t\t\tClass&lt;?&gt; kc = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 遍历树，进行二叉搜索树的插入</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// p指向遍历中的当前节点，</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// x为待插入节点，</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// k是x的key，</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// h是x的hash值，</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// ph是p的hash值，</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// pk是p的key，</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// dir用来指示x节点与p的比较，-1表示比p小，1表示比p大</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 不存在相等情况，因为HashMap中是不存在两个key完全一致的情况。</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">int</span> dir, ph;</span><br><span class=\"line\">\t\t\t\t\tK pk = p.key;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 待插入x的hash值小于当前点p的hash值</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ((ph = p.hash) &gt; h)</span><br><span class=\"line\">\t\t\t\t\t\tdir = -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ph &lt; h)</span><br><span class=\"line\">\t\t\t\t\t\tdir = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果hash值相等，那么判断k是否实现了comparable接口，</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果实现了comparable接口就使用compareTo进行进行比较，</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果仍旧相等或者没有实现comparable接口，则在tieBreakOrder中比较</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((kc == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t\t\t(kc = comparableClassFor(k)) == <span class=\"keyword\">null</span>) ||</span><br><span class=\"line\">\t\t\t\t\t\t\t(dir = compareComparables(kc, k, pk)) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t\t\tdir = tieBreakOrder(k, pk);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 将当前节点赋值给XP</span></span><br><span class=\"line\">\t\t\t\t\tTreeNode&lt;K,V&gt; xp = p;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果dir &lt;= 0 ,p 等于 p的左儿子，否则p 等于 p的右儿子</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果 p 等于 null，则插入x节点</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ((p = (dir &lt;= <span class=\"number\">0</span>) ? p.left : p.right) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// x的父节点指向 xp</span></span><br><span class=\"line\">\t\t\t\t\t\tx.parent = xp;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> (dir &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t\t\t\txp.left = x;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t\t\t\txp.right = x;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 进行平衡处理，保证红黑树的性质</span></span><br><span class=\"line\">\t\t\t\t\t\troot = balanceInsertion(root, x);</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//root节点移动到桶中的第一个元素，也就是链表的首节点</span></span><br><span class=\"line\">\t\tmoveRootToFront(tab, root);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"untreeify-树变链表\"><a href=\"#untreeify-树变链表\" class=\"headerlink\" title=\"untreeify 树变链表\"></a>untreeify 树变链表</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 树变链表</span></span><br><span class=\"line\"><span class=\"comment\"> * //重新创建链表节点，并形成链表结构</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">untreeify</span><span class=\"params\">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class=\"line\">\tNode&lt;K,V&gt; hd = <span class=\"keyword\">null</span>, tl = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (Node&lt;K,V&gt; q = <span class=\"keyword\">this</span>; q != <span class=\"keyword\">null</span>; q = q.next) &#123;</span><br><span class=\"line\">\t\tNode&lt;K,V&gt; p = map.replacementNode(q, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\thd = p;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\ttl.next = p;</span><br><span class=\"line\">\t\ttl = p;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> hd;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"balanceInsertion-红黑树插入平衡\"><a href=\"#balanceInsertion-红黑树插入平衡\" class=\"headerlink\" title=\"balanceInsertion 红黑树插入平衡\"></a>balanceInsertion 红黑树插入平衡</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 红黑树的插入平衡处理</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> root 根节点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> x 新插入节点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\">TreeNode&lt;K,V&gt; <span class=\"title\">balanceInsertion</span><span class=\"params\">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t\t\t\t\t\tTreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//插入的节点默认为红色</span></span><br><span class=\"line\">\tx.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// xp：当前节点的父节点</span></span><br><span class=\"line\">\t<span class=\"comment\">// xpp：爷爷节点</span></span><br><span class=\"line\">\t<span class=\"comment\">// xppl：左叔叔节点</span></span><br><span class=\"line\">\t<span class=\"comment\">// xppr：右叔叔节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// L1：如果父节点为空、说明当前节点就是根节点，那么把当前节点标为黑色，返回当前节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((xp = x.parent) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tx.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 父节点不为空</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// L2：如果 父节点为黑色 那么插入节点为红色不影响树的平衡</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// L3：或者 爷爷节点为空 即 父节点是根节点</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 返回根节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!xp.red || (xpp = xp.parent) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">\t\t<span class=\"comment\">// L4：父节点和祖父节点都存在，并且其父节点是祖父节点的左节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// L4.1 插入节点的叔叔节点是红色</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((xppr = xpp.right) != <span class=\"keyword\">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 将叔叔设置为黑色，父亲设为黑色，爷爷设为红色</span></span><br><span class=\"line\">\t\t\t\txppr.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\txp.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\txpp.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 将 爷爷 设为当前插入节点，自底向上，重新变色</span></span><br><span class=\"line\">\t\t\t\tx = xpp;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//L4.2：插入节点的叔叔节点是黑色或不存在</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// L4.2.1 插入节点是其父节点的右孩子</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (x == xp.right) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// x 设置为 父节点</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 将 父节点 左旋</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 旋转之后，原父子关系对调，因此，x还是子节点</span></span><br><span class=\"line\">\t\t\t\t\troot = rotateLeft(root, x = xp);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 将xp 设为父节点，xpp设为爷爷节点</span></span><br><span class=\"line\">\t\t\t\t\txpp = (xp = x.parent) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : xp.parent;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// L4.2.1 插入节点是其父节点的左孩子</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (xp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 父节点设为黑色</span></span><br><span class=\"line\">\t\t\t\t\txp.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果 有爷爷节点</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (xpp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 爷爷节点设置为红色</span></span><br><span class=\"line\">\t\t\t\t\t\txpp.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//  爷爷节点右旋</span></span><br><span class=\"line\">\t\t\t\t\t\troot = rotateRight(root, xpp);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// L5：插入的节点父节点和祖父节点都存在，并且其 父节点是祖父节点的右节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// L5.1：插入节点的叔叔节点是红色</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (xppl != <span class=\"keyword\">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 将叔叔设置为黑色，父亲设为黑色，爷爷设为红色</span></span><br><span class=\"line\">\t\t\t\txppl.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\txp.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\txpp.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 将 爷爷 设为当前插入节点，自底向上，重新变色</span></span><br><span class=\"line\">\t\t\t\tx = xpp;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//L5.2：插入节点的叔叔节点是黑色或不存在</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// L5.2.1 插入节点是其父节点的左孩子</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (x == xp.left) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// x 设置为 父节点</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 将 父节点 右旋</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 旋转之后，原父子关系对调，因此，x还是子节点</span></span><br><span class=\"line\">\t\t\t\t\troot = rotateRight(root, x = xp);</span><br><span class=\"line\">\t\t\t\t\txpp = (xp = x.parent) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : xp.parent;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// L5.2.2 插入节点是其父节点的右孩子</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (xp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 父节点设为黑色</span></span><br><span class=\"line\">\t\t\t\t\txp.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果 有爷爷 节点</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (xpp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 爷爷节点设置为红色</span></span><br><span class=\"line\">\t\t\t\t\t\txpp.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//  爷爷节点右旋</span></span><br><span class=\"line\">\t\t\t\t\t\troot = rotateLeft(root, xpp);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"get方法\"><a href=\"#get方法\" class=\"headerlink\" title=\"get方法\"></a>get方法</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\tNode&lt;K,V&gt; e;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"getNode\"><a href=\"#getNode\" class=\"headerlink\" title=\"getNode\"></a>getNode</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implements Map.get and related methods</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> hash key 的hash值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the node, or null if none</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">\tNode&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\">\t<span class=\"comment\">// table 不为null &amp;&amp; 不为空，并且 (n - 1) &amp; hash 算出来的index位置有值</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">\t\t\t(first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 判断第一个存在的节点的key 和 hash值是否与查询的key的相等，如果是直接返回</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">\t\t\t\t((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> first;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 遍历该链表/红黑树直到next为null</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果该点是红黑树</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 在树上寻找对应的值</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 遍历链表</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t\t((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> e;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//否则不存在，返回null</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"remove-及其相关方法\"><a href=\"#remove-及其相关方法\" class=\"headerlink\" title=\"remove 及其相关方法\"></a>remove 及其相关方法</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">\tNode&lt;K,V&gt; e;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (e = removeNode(hash(key), key, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>)) == <span class=\"keyword\">null</span> ?</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"removeNode-删除节点\"><a href=\"#removeNode-删除节点\" class=\"headerlink\" title=\"removeNode 删除节点\"></a>removeNode 删除节点</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Implements Map.remove and related methods</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> hash key的hash值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key the key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value 传入匹配的value值，如果matchValue=false，直接忽略</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> matchValue 为true时，会去进一步匹配value</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> movable if false do not move other nodes while removing</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the node, or null if none</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">removeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key, Object value,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t   <span class=\"keyword\">boolean</span> matchValue, <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;</span><br><span class=\"line\">\tNode&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, index;</span><br><span class=\"line\">\t<span class=\"comment\">//确定table已经被初始化，并且其中有元素，并且对应的 hash值有元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">\t\t\t(p = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\tNode&lt;K,V&gt; node = <span class=\"keyword\">null</span>, e; K k; V v;</span><br><span class=\"line\">\t\t<span class=\"comment\">//判断当前这个找到的元素是不是目标元素，如果是的话赋值给node</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">\t\t\t\t((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">\t\t\tnode = p;</span><br><span class=\"line\">\t\t<span class=\"comment\">//不是的话，就从相同hash值的所有元素中去查找</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = p.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//该列表已经转换成红黑树的情况</span></span><br><span class=\"line\">\t\t\t\tnode = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//在链表中查找的情况</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t\t\t((k = e.key) == key ||</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t(key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tnode = e;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tp = e;</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//找到了目标节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class=\"line\">\t\t\t\t(value != <span class=\"keyword\">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (node <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//是红黑树节点的情况</span></span><br><span class=\"line\">\t\t\t\t((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class=\"keyword\">this</span>, tab, movable);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node == p)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//是一个链表开头元素的情况</span></span><br><span class=\"line\">\t\t\t\ttab[index] = node.next;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//是一个链表中间元素的情况</span></span><br><span class=\"line\">\t\t\t\tp.next = node.next;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//结构改变，修改次数需要加一</span></span><br><span class=\"line\">\t\t\t++modCount;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//元素减少size减1</span></span><br><span class=\"line\">\t\t\t--size;</span><br><span class=\"line\">\t\t\tafterNodeRemoval(node);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> node;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"removeTreeNode-红黑树中删除节点\"><a href=\"#removeTreeNode-红黑树中删除节点\" class=\"headerlink\" title=\"removeTreeNode 红黑树中删除节点\"></a>removeTreeNode 红黑树中删除节点</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">removeTreeNode</span><span class=\"params\">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t  <span class=\"keyword\">boolean</span> movable)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果 table为空 或者为0 则无法删除，返回</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index = (n - <span class=\"number\">1</span>) &amp; hash;</span><br><span class=\"line\">\t<span class=\"comment\">// first 和 root 目前都为 根结点</span></span><br><span class=\"line\">\tTreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class=\"line\">\t<span class=\"comment\">// succ 是要删除节点的下一个，prev是要删除节点的前一个</span></span><br><span class=\"line\">\tTreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class=\"line\">\t<span class=\"comment\">// 首先先从TreeNode链表里将这个节点删除掉。</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\ttab[index] = first = succ;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tpred.next = succ;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (succ != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\tsucc.prev = pred;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (first == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root.parent != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\troot = root.root();</span><br><span class=\"line\">\t<span class=\"comment\">// 根结点为空 或 根节点的右儿子为空 或 根结点的做儿子为空 或 根节点的做儿子的做儿子为空</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span> || root.right == <span class=\"keyword\">null</span> ||</span><br><span class=\"line\">\t\t\t(rl = root.left) == <span class=\"keyword\">null</span> || rl.left == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 树太小了，从红黑树转换为链表</span></span><br><span class=\"line\">\t\ttab[index] = first.untreeify(map);  <span class=\"comment\">// too small</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 从红黑树删除这个节点</span></span><br><span class=\"line\">\t<span class=\"comment\">// p是要删除的节点 pl 是 p 的左节点, pr 是 P 的右节点。</span></span><br><span class=\"line\">\tTreeNode&lt;K,V&gt; p = <span class=\"keyword\">this</span>, pl = left, pr = right, replacement;</span><br><span class=\"line\">\t<span class=\"comment\">// 当 p 的左右节点都不为null</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pl != <span class=\"keyword\">null</span> &amp;&amp; pr != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// s 是 p的右节点 的 左叶子节点 的左节点。。。循环找到叶子节点</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 就是查找所有比当前节点大的节点当中最小的一个节点</span></span><br><span class=\"line\">\t\tTreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> ((sl = s.left) != <span class=\"keyword\">null</span>) <span class=\"comment\">// find successor</span></span><br><span class=\"line\">\t\t\ts = sl;</span><br><span class=\"line\">\t\t<span class=\"comment\">//交换 s 和 p 节点的颜色</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class=\"comment\">// swap colors</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// sr ：s的右节点</span></span><br><span class=\"line\">\t\tTreeNode&lt;K,V&gt; sr = s.right;</span><br><span class=\"line\">\t\t<span class=\"comment\">// pp ：p的父节点</span></span><br><span class=\"line\">\t\tTreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class=\"line\">\t\t<span class=\"comment\">//2： 如果s 等于pr 证明 p的 右节点 没有 左节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s == pr) &#123; <span class=\"comment\">// p was s's direct parent</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//当前节点的父节点设为找到的节点</span></span><br><span class=\"line\">\t\t\tp.parent = s;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//找到节点的右孩子设为当前节点</span></span><br><span class=\"line\">\t\t\ts.right = p;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//3： p 的右节点有左儿子</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// （以下操作就是将s和p对换了个位置和颜色，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果s有右儿子则设置为平衡点，否则p为平衡点）</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// sp ： s的父亲</span></span><br><span class=\"line\">\t\t\tTreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 将 p 的父亲设为 sp</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果sp 不为null</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((p.parent = sp) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 当前节点替代 s 节点的位置，与 s 节点的父节点进行关联</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// s 是 sp 的左儿子，左儿子设置为 p</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (s == sp.left)</span><br><span class=\"line\">\t\t\t\t\tsp.left = p;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span><span class=\"comment\">// s 是 sp 的右儿子，右儿子设置为 p</span></span><br><span class=\"line\">\t\t\t\t\tsp.right = p;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// s 的右节点设置为 p 的右孩子</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果 p 的右孩子不为null</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 右孩子的父节点设为 s 节点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((s.right = pr) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\tpr.parent = s;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//当前节点的左孩子设为null</span></span><br><span class=\"line\">\t\tp.left = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//将 p 节点的右孩子设置为 s节点的右孩子</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((p.right = sr) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\tsr.parent = p; <span class=\"comment\">//右孩子的父节点设为当前节点</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 将 s 节点的左儿子设置为 p节点的左儿子</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((s.left = pl) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\tpl.parent = s;<span class=\"comment\">// 左孩子的父节点设为找到节点</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 将s的父亲 设置为 p 节点的父亲</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果 p是根结点，那么根节点变为s</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((s.parent = pp) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\troot = s;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 父节点不为null，当前节点是父节点的左孩子</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == pp.left)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 父亲的左儿子改为s</span></span><br><span class=\"line\">\t\t\tpp.left = s;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 父亲的右儿子改为s</span></span><br><span class=\"line\">\t\t\tpp.right = s;</span><br><span class=\"line\">\t\t<span class=\"comment\">// s节点的右孩子不为null</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sr != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 则s节点的右孩子节点作为平衡删除的初始节点</span></span><br><span class=\"line\">\t\t\treplacement = sr;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 否则平衡删除的初始节点为 p。</span></span><br><span class=\"line\">\t\t\treplacement = p;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//当前节点左孩子不为null，右孩子为null</span></span><br><span class=\"line\">\t<span class=\"comment\">//当前节点的左孩子作为平衡删除的节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pl != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\treplacement = pl;</span><br><span class=\"line\">\t<span class=\"comment\">//当前节点右孩子不为null，左孩子为null</span></span><br><span class=\"line\">\t<span class=\"comment\">// 当前节点的右孩子作为平衡删除的节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pr != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\treplacement = pr;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span><span class=\"comment\">//左右孩子都为null，当前节点作为平衡删除的节点</span></span><br><span class=\"line\">\t\treplacement = p;</span><br><span class=\"line\">\t<span class=\"comment\">//如果当前节点不是作为平衡删除的节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (replacement != p) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//此时p.parent有三种情况，1.其原来的父节点，2.它的右子节点，3.s节点的父节点sp</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//将当前节点的父节点设为平衡删除节点的父节点</span></span><br><span class=\"line\">\t\tTreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class=\"line\">\t\t<span class=\"comment\">//如果当前节点的父节点为null，则表明当前节点原来是根节点，此时当前节点的父节点还是其原来的父节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pp == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\troot = replacement;<span class=\"comment\">//设置作为平衡删除的节点为根节点</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果父节点不为null，并且当前节点是父节点的左子节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == pp.left)<span class=\"comment\">//设置父节点的左子节点为作为平衡删除的节点</span></span><br><span class=\"line\">\t\t\tpp.left = replacement;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span><span class=\"comment\">//设置父节点的右子节点为作为平衡删除的节点</span></span><br><span class=\"line\">\t\t\tpp.right = replacement;</span><br><span class=\"line\">\t\t<span class=\"comment\">//将当前节点与树结构断开，因为当前节点不是作为平衡删除的节点</span></span><br><span class=\"line\">\t\tp.left = p.right = p.parent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取根节点，如果删除节点是红色，则不需要做平衡删除，根节点不会再变</span></span><br><span class=\"line\">\t<span class=\"comment\">// 如果删除节点是黑色，则需要做平衡删除，根节点可能会发生改变</span></span><br><span class=\"line\">\tTreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//做平衡删除的节点是当前要删除的节点</span></span><br><span class=\"line\">\t<span class=\"comment\">//平衡删除做完后将该节点从树结构中脱离出来</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (replacement == p) &#123;  <span class=\"comment\">// detach</span></span><br><span class=\"line\">\t\tTreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class=\"line\">\t\tp.parent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (p == pp.left)</span><br><span class=\"line\">\t\t\t\tpp.left = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == pp.right)</span><br><span class=\"line\">\t\t\t\tpp.right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//是否需要从新设置桶的头节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (movable)</span><br><span class=\"line\">\t\t<span class=\"comment\">//将桶的头节点设为根节点</span></span><br><span class=\"line\">\t\tmoveRootToFront(tab, r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"balanceDeletion-红黑树删除平衡\"><a href=\"#balanceDeletion-红黑树删除平衡\" class=\"headerlink\" title=\"balanceDeletion 红黑树删除平衡\"></a>balanceDeletion 红黑树删除平衡</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 红黑树平衡删除，只有在删除的节点是黑色时才会调用此方法</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> root 根结点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> x 平衡节点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\">TreeNode&lt;K,V&gt; <span class=\"title\">balanceDeletion</span><span class=\"params\">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t\t\t\t\t   TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//平衡节点为null或者平衡节点是根节点，无需做平衡处理，返回根节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (x == <span class=\"keyword\">null</span> || x == root)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">\t\t<span class=\"comment\">//平衡节点不是根，但平衡节点的父节点是null</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//则将平衡节点将成为根节点，将其颜色设置为黑色</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((xp = x.parent) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tx.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//不是根节点，父节点也不为null，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//若做平衡的节点就是要删除的节点，则设什么颜色都无所谓，直接返回根节点</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//若做平衡的节点不是要删除的节点，而且还是红色</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//则其要替换的节点就是其父节点，替换的父节点就是要删除的节点，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//而做平衡的节点还是红色，则其父一定是黑色，其替换其父所以要变成黑色</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//因为做平衡的节点是红，它替换掉了其父（在进入此方法之前已经替换掉了）</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//其父是黑，所以只需要确保其是黑，就能确保该树枝上的黑色节点数不变</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//替换完直接返回根节点即可</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (x.red) &#123;</span><br><span class=\"line\">\t\t\tx.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//x的节点不是根，父也不为null，其颜色是黑色</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//x的节点是其父的左子节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果它有红色的兄弟节点xpr，那么它的父亲节点xp一定是黑色节点</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 将兄弟节点设为黑色，父亲节点设为红色，以父节点进行旋转</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((xpr = xp.right) != <span class=\"keyword\">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class=\"line\">\t\t\t\txpr.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\txp.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//对父节点xp做左旋转</span></span><br><span class=\"line\">\t\t\t\troot = rotateLeft(root, xp);</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//重新将xp指向x的父节点，xpr指向xp新的右孩子</span></span><br><span class=\"line\">\t\t\t\txpr = (xp = x.parent) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : xp.right;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果xpr为空，则向上继续调整，将x的父节点xp作为新的x继续循环</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (xpr == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\tx = xp;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//sl和sr分别为其兄弟节点左儿子和右儿子</span></span><br><span class=\"line\">\t\t\t\tTreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//若sl和sr都为黑色或者不存在，即xpr没有红色孩子，则将xpr染红</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ((sr == <span class=\"keyword\">null</span> || !sr.red) &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t\t(sl == <span class=\"keyword\">null</span> || !sl.red)) &#123;</span><br><span class=\"line\">\t\t\t\t\txpr.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t\tx = xp;<span class=\"comment\">//本轮结束，继续向上循环</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//否则的话，就需要进一步调整</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (sr == <span class=\"keyword\">null</span> || !sr.red) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//若左孩子为红，右孩子不存在或为黑</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> (sl != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">//左孩子染黑</span></span><br><span class=\"line\">\t\t\t\t\t\t\tsl.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//将xpr染红</span></span><br><span class=\"line\">\t\t\t\t\t\txpr.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//右旋</span></span><br><span class=\"line\">\t\t\t\t\t\troot = rotateRight(root, xpr);</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//右旋后，xpr指向xp的新右孩子，即上一步中的sl</span></span><br><span class=\"line\">\t\t\t\t\t\txpr = (xp = x.parent) == <span class=\"keyword\">null</span> ?</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">null</span> : xp.right;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果兄弟节点 不为null</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (xpr != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 如果父节点为空，兄弟节点染为黑色，否则和父亲节点染色相同</span></span><br><span class=\"line\">\t\t\t\t\t\txpr.red = (xp == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">false</span> : xp.red;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// sr 设置为兄弟节点的右孩子，如果sr不为null，将sr设置为黑色，防止出现两个红色相连</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> ((sr = xpr.right) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\t\t\tsr.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果父节点不为null</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (xp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//将父亲节点设置为黑色</span></span><br><span class=\"line\">\t\t\t\t\t\txp.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 左旋父节点</span></span><br><span class=\"line\">\t\t\t\t\t\troot = rotateLeft(root, xp);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tx = root;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//x为其父节点的右孩子，跟上面操作镜像</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123; <span class=\"comment\">// symmetric</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (xpl != <span class=\"keyword\">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class=\"line\">\t\t\t\txpl.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\txp.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\troot = rotateRight(root, xp);</span><br><span class=\"line\">\t\t\t\txpl = (xp = x.parent) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : xp.left;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (xpl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\tx = xp;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tTreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ((sl == <span class=\"keyword\">null</span> || !sl.red) &amp;&amp;</span><br><span class=\"line\">\t\t\t\t\t\t(sr == <span class=\"keyword\">null</span> || !sr.red)) &#123;</span><br><span class=\"line\">\t\t\t\t\txpl.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t\tx = xp;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (sl == <span class=\"keyword\">null</span> || !sl.red) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> (sr != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\t\t\tsr.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\t\t\txpl.red = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t\t\t\t\troot = rotateLeft(root, xpl);</span><br><span class=\"line\">\t\t\t\t\t\txpl = (xp = x.parent) == <span class=\"keyword\">null</span> ?</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">null</span> : xp.left;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (xpl != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\txpl.red = (xp == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">false</span> : xp.red;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> ((sl = xpl.left) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t\t\t\t\tsl.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (xp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t\txp.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t\t\t\t\troot = rotateRight(root, xp);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tx = root;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"rotateLeft-红黑树左旋（右旋转同理）\"><a href=\"#rotateLeft-红黑树左旋（右旋转同理）\" class=\"headerlink\" title=\"rotateLeft 红黑树左旋（右旋转同理）\"></a>rotateLeft 红黑树左旋（右旋转同理）</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 红黑树左旋</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> root 根节点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> p 要左旋的节点</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\">TreeNode&lt;K,V&gt; <span class=\"title\">rotateLeft</span><span class=\"params\">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t\t\t\t  TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// pp : p的父亲</span></span><br><span class=\"line\">\t<span class=\"comment\">// r: p的右孩子</span></span><br><span class=\"line\">\t<span class=\"comment\">// rl = p 的右孩子的左孩子 -&gt; r的左孩子</span></span><br><span class=\"line\">\tTreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class=\"line\">\t<span class=\"comment\">// 要 p 以及 p的右孩子 不为null</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span> &amp;&amp; (r = p.right) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将p 的右孩子 设置为 rl 并且 rl不为空</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((rl = p.right = r.left) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// rl的父亲节点设置为p</span></span><br><span class=\"line\">\t\t\trl.parent = p;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将 r 的父亲 设置为 p的父亲（此时r 与p为兄弟）</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果父亲节点为null，则此时 r为跟节点</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 将root 设置为r ，并设置为黑色</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((pp = r.parent = p.parent) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t(root = r).red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果父节点的左儿子是 p</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pp.left == p)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 将父节点的 左儿子 设为r</span></span><br><span class=\"line\">\t\t\tpp.left = r;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 否则将 右儿子 设为r</span></span><br><span class=\"line\">\t\t\tpp.right = r;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将 r 的左节儿子 设置为p</span></span><br><span class=\"line\">\t\tr.left = p;</span><br><span class=\"line\">\t\t<span class=\"comment\">// p 的父亲设置为 r</span></span><br><span class=\"line\">\t\tp.parent = r;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 返回根节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"JAVA-Spring","date":"2020-03-06T09:01:00.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"# springIOC\n## what is IOC\n> 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，将你设计好的对象交给容器控制，可以用来减低计算机代码之间的耦合度。\n> 其中最常见的方式叫做依赖注入（Dependency Injection，简称`DI`），还有一种方式叫“依赖查找”（Dependency `Lookup`）\n\n## 依赖注入（Dependency Injection）\n依赖：比如A.class中有一个B.class的属性，那么我们可以理解为A依赖了B\n依赖注入：由容器动态的将某个依赖关系注入到组件之中。\n依赖注入是实现IOC的一种方式。\n\n## 为什么要使用spring IOC？\n> 在日常程序开发过程当中，我们推荐面向抽象编程，面向抽象编程会产生类的依赖\n> 当然如果你够强大可以自己写一个管理的容器\n> 但是既然spring以及实现了，并且spring如此优秀，我们仅仅需要学习spring框架便可。\n> 当我们有了一个管理对象的容器之后，类的产生过程也交给了容器，至于我们自己的程序则可以不需要去关系这些对象的产生了。\n\n## spring实现IOC的思路和方法\n1. 应用程序中提供类，提供依赖关系（属性或者构造方法）\n2. 把需要交给容器管理的对象通过配置信息告诉容器（xml、annotation，javaconfig）\n3. 把各个类之间的依赖关系通过配置信息告诉容器\n\n> 配置这些信息的方法有三种分别是xml，annotation和javaconfig\n> 维护的过程称为自动注入，自动注入的方法有两种`构造方法和setter`\n> 自动注入的值可以是对象，数组，map，list和常量比如字符串整形等\n\n## spring编程的风格\n1. schemal-based-------xml\n2. annotation-based-----annotation\n3. java-based----java Configuration\n\n## 注入的两种方法\n官网文档已经很详细了：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed\n\n### 构造方法注入（Constructor-based Dependency Injection）\n构造方法参考文档：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection\n\n### setter方法注入（Setter-based Dependency Injection）\nsetter参考文档：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection\n\n\n## 自动装配\n上面说过，IOC的注入有两个地方需要提供依赖关系，一是类的定义中，二是在spring的配置中需要去描述。\n自动装配则把第二个取消了，即我们仅仅需要在类中提供依赖，继而把对象交给容器管理即可完成注入。\n\n自动装配的优点参考文档：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire\n缺点参考文档：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions\n\n## 自动装配的方法\n* no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。\n* byName：它根据 bean 的名称注入对象依赖项。\n* byType：它根据类型注入对象依赖项。\n* constructor：通过构造函数来注入依赖项，需要设置大量的参数。\n\n## @Component，@Service，@Controller，@Repository\n* @Component是一个通用的Spring容器管理的单例bean组件\n* @Repository 通常用于持久层\n* @Service 通常用于业务逻辑层\n* @Controller 通常用于表现层（spring-mvc的注解）\n\n`这几种注解当前的作用没有任何区别。`\n官网有这样一段话，意思是这几种注解在未来可能会有其他语意。因此推荐按照通用使用方式使用注解。\n>  @Repository, @Service, and @Controller can also carry additional semantics in future releases of the Spring Framework\n\n\n## spring懒加载\n官方文档：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init\n\n## springbean的作用域\n文档参考：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes\n\n### Singleton 中引用了一个Prototype的bean的时候引发的问题 \n官网引导我们参考：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-method-injection\n\n由于Singleton状态的bean A在初始化的时候只new一次，也只会注入一次依赖的对象B\n因此B对象设置为Prototype 就没有任何意义。解决方式参考官网。\n\n\n## 自己模拟springbean\n定义几个类\n```java\npublic interface UserDao {\n\tpublic String query();\n}\n\npublic class UserDaoImpl implements UserDao {\n\t@Override\n\tpublic String query() {\n\t\treturn \"我要减肥～～～\";\n\t}\n}\n\npublic interface UserService {\n\tpublic void find();\n}\n\npublic class UserServiceImpl implements UserService {\n\n\tUserDao userDao;\n\t@Override\n\tpublic void find() {\n\t\tSystem.out.println(userDao.query() + \"hahaha\");\n\t}\n\n\tpublic void setUserDao(UserDao userDao) {\n\t\tthis.userDao = userDao;\n\t}\n\n\n//\tpublic UserServiceImpl(UserDao userDao) {\n//\t\tthis.userDao = userDao;\n//\t}\n}\n```\n\n新建BeanFactory解析xml\n```java\npublic class BeanFactory {\n\tMap<String,Object> map = new HashMap<>();\n\n\tpublic BeanFactory(String xml) {\n\t\ttry {\n\t\t\tparseXml(xml);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tprivate void parseXml(String xml) throws Exception {\n\t\tFile file = new File(this.getClass().getResource(\"/\").getPath()+\"/\"+xml);\n\t\tSAXReader reader = new SAXReader();\n\t\t//解析XML形式的文本,得到document对象.\n\t\tDocument document = reader.read(file);\n\t\t// 获取文档的根节点.\n\t\tElement elementRoot = document.getRootElement();\n\t\t// <beans default=\"byType\">\n\t\tAttribute attribute = elementRoot.attribute(\"default-autowire\");\n\t\tboolean flag = false;\n\t\tif (attribute != null){\n\t\t\tflag = true;\n\t\t}\n\t\tfor(Iterator it = elementRoot.elementIterator();it.hasNext();) {\n\t\t\t/**\n\t\t\t * 实例化对象\n\t\t\t */\n\t\t\tElement elementFirstChil = (Element) it.next();\n\t\t\t//  <bean id=\"userDao\" class=\"com.qing.dao.UserDaoImpl\"/>\n\t\t\t// 获取id属性\n\t\t\tAttribute attributeId = elementFirstChil.attribute(\"id\");\n\t\t\t// 得到bean名称\n\t\t\tString beanName = attributeId.getValue();\n\t\t\t// 获取class属性\n\t\t\tAttribute attributeClazz = elementFirstChil.attribute(\"class\");\n\t\t\t// 得到className\n\t\t\tString className = attributeClazz.getValue();\n\t\t\tClass clazz = Class.forName(className);\n\n\t\t\t/**\n\t\t\t * 维护依赖关系\n\t\t\t * 看这个对象有没有依赖（判断是否有property。或者判断类是否有属性）\n\t\t\t * 如果有则注入\n\t\t\t */\n\t\t\tObject object = null;\n\t\t\tfor (Iterator itSon = elementFirstChil.elementIterator(); itSon.hasNext(); ) {\n\t\t\t\tElement elementSon = (Element) itSon.next();\n\t\t\t\tif (elementSon.getName().equals(\"property\")) {\n\t\t\t\t\t// setter 方法注入\n\t\t\t\t\t// <property name=\"userDao\" ref=\"userDao\"/>\n\t\t\t\t\tobject = clazz.newInstance();\n\t\t\t\t\t// 获取ref属性\n\t\t\t\t\tAttribute attributeRef = elementSon.attribute(\"ref\");\n\t\t\t\t\tObject objectSon = map.get(attributeRef.getValue());\n\t\t\t\t\t// 获取name属性\n\t\t\t\t\tAttribute attributeName = elementSon.attribute(\"name\");\n\t\t\t\t\tString name = attributeName.getValue();\n\t\t\t\t\t// 获取类本身的属性成员\n\t\t\t\t\tField field = clazz.getDeclaredField(name);\n\t\t\t\t\t// 利用反射set属性，要设置取消 Java 语言访问检查\n\t\t\t\t\tfield.setAccessible(true);\n\t\t\t\t\t// set属性\n\t\t\t\t\tfield.set(object, objectSon);\n\t\t\t\t} else if(elementSon.getName().equals(\"constructor-arg\")){\n\t\t\t\t\t//构造方法注入\n\t\t\t\t\t// 获取ref属性\n\t\t\t\t\tAttribute attributeRef = elementSon.attribute(\"ref\");\n\t\t\t\t\tObject objectSon = map.get(attributeRef.getValue());\n\t\t\t\t\t// 获取objectSon所实现的接口\n\t\t\t\t\tClass sonInterface = objectSon.getClass().getInterfaces()[0];\n\t\t\t\t\tConstructor constructor = clazz.getConstructor(sonInterface);\n\t\t\t\t\tobject = constructor.newInstance(objectSon);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(object == null){\n\t\t\t\tif (flag) {// 自动装配\n\t\t\t\t\tif (attribute.getValue().equals(\"byType\")) {\n\t\t\t\t\t\t//判斷是否有依賴\n\t\t\t\t\t\tField fields[] = clazz.getDeclaredFields();\n\t\t\t\t\t\tfor (Field field : fields) {\n\t\t\t\t\t\t\t//得到屬性的類型，比如String aa那麽這裏的field.getType()=String.class\n\t\t\t\t\t\t\tClass injectObjectClazz = field.getType();\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * 由於是bytype 所以需要遍历map当中的所有对象\n\t\t\t\t\t\t\t * 判断对象的类型是不是和这个injectObjectClazz相同\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tObject objectSon = null;\n\t\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\tfor(Map.Entry<String,Object> entry : map.entrySet()){\n\t\t\t\t\t\t\t\tClass temp = entry.getValue().getClass().getInterfaces()[0];\n\t\t\t\t\t\t\t\tif(temp.getName().equals(injectObjectClazz.getName())){\n\t\t\t\t\t\t\t\t\tobjectSon = entry.getValue();\n\t\t\t\t\t\t\t\t\tcount ++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(count > 1){\n\t\t\t\t\t\t\t\tthrow new MySpringException(\"需要一个对象，但是找到了两个对象\");\n\t\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\t\tobject = clazz.newInstance();\n\t\t\t\t\t\t\t\tfield.setAccessible(true);\n\t\t\t\t\t\t\t\tfield.set(object, objectSon);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (object == null) {//沒有子标签\n\t\t\t\tobject = clazz.newInstance();\n\t\t\t}\n\t\t\tmap.put(beanName, object);\n\t\t}\n\n\t\tSystem.out.println(map);\n\t}\n\n\n\tpublic Object getBean(String name){\n\t\treturn map.get(name);\n\t}\n\n```\n\n测试类\n```java\npublic class Test {\n\tpublic static void main(String[] args) {\n\n\t\tBeanFactory beanFactory = new BeanFactory(\"spring.xml\");\n\t\tUserService userService = (UserService) beanFactory.getBean(\"userService\");\n\t\tuserService.find();\n\t}\n}\n```\n\nxml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans default-autowire=\"byType\">\n\n<!--    setter注入-->\n    <bean id=\"userDao\" class=\"com.qing.dao.UserDaoImpl\"/>\n    <bean id=\"userService\" class=\"com.qing.service.UserServiceImpl\">\n        <property name=\"userDao\" ref=\"userDao\"/>\n    </bean>\n\n<!--    构造方法注入-->\n    <bean id=\"userDao\" class=\"com.qing.dao.UserDaoImpl\"/>\n    <bean id=\"userService\" class=\"com.qing.service.UserServiceImpl\">\n        <constructor-arg ref=\"userDao\"/>\n    </bean>\n\n\n<!--    default-autowire=\"byType\"-->\n    <bean id=\"userDao\" class=\"com.qing.dao.UserDaoImpl\"/>\n    <bean id=\"userService\" class=\"com.qing.service.UserServiceImpl\"/>\n</beans>\n```\n","source":"_posts/Java-Spring.md","raw":"---\ntitle: JAVA-Spring\ndate: 2020-03-06 17:1:00\ntags:\n    - JAVA\n    - Spring\n    - 学习笔记\ncategories: JAVA\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n# springIOC\n## what is IOC\n> 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，将你设计好的对象交给容器控制，可以用来减低计算机代码之间的耦合度。\n> 其中最常见的方式叫做依赖注入（Dependency Injection，简称`DI`），还有一种方式叫“依赖查找”（Dependency `Lookup`）\n\n## 依赖注入（Dependency Injection）\n依赖：比如A.class中有一个B.class的属性，那么我们可以理解为A依赖了B\n依赖注入：由容器动态的将某个依赖关系注入到组件之中。\n依赖注入是实现IOC的一种方式。\n\n## 为什么要使用spring IOC？\n> 在日常程序开发过程当中，我们推荐面向抽象编程，面向抽象编程会产生类的依赖\n> 当然如果你够强大可以自己写一个管理的容器\n> 但是既然spring以及实现了，并且spring如此优秀，我们仅仅需要学习spring框架便可。\n> 当我们有了一个管理对象的容器之后，类的产生过程也交给了容器，至于我们自己的程序则可以不需要去关系这些对象的产生了。\n\n## spring实现IOC的思路和方法\n1. 应用程序中提供类，提供依赖关系（属性或者构造方法）\n2. 把需要交给容器管理的对象通过配置信息告诉容器（xml、annotation，javaconfig）\n3. 把各个类之间的依赖关系通过配置信息告诉容器\n\n> 配置这些信息的方法有三种分别是xml，annotation和javaconfig\n> 维护的过程称为自动注入，自动注入的方法有两种`构造方法和setter`\n> 自动注入的值可以是对象，数组，map，list和常量比如字符串整形等\n\n## spring编程的风格\n1. schemal-based-------xml\n2. annotation-based-----annotation\n3. java-based----java Configuration\n\n## 注入的两种方法\n官网文档已经很详细了：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed\n\n### 构造方法注入（Constructor-based Dependency Injection）\n构造方法参考文档：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection\n\n### setter方法注入（Setter-based Dependency Injection）\nsetter参考文档：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection\n\n\n## 自动装配\n上面说过，IOC的注入有两个地方需要提供依赖关系，一是类的定义中，二是在spring的配置中需要去描述。\n自动装配则把第二个取消了，即我们仅仅需要在类中提供依赖，继而把对象交给容器管理即可完成注入。\n\n自动装配的优点参考文档：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire\n缺点参考文档：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions\n\n## 自动装配的方法\n* no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。\n* byName：它根据 bean 的名称注入对象依赖项。\n* byType：它根据类型注入对象依赖项。\n* constructor：通过构造函数来注入依赖项，需要设置大量的参数。\n\n## @Component，@Service，@Controller，@Repository\n* @Component是一个通用的Spring容器管理的单例bean组件\n* @Repository 通常用于持久层\n* @Service 通常用于业务逻辑层\n* @Controller 通常用于表现层（spring-mvc的注解）\n\n`这几种注解当前的作用没有任何区别。`\n官网有这样一段话，意思是这几种注解在未来可能会有其他语意。因此推荐按照通用使用方式使用注解。\n>  @Repository, @Service, and @Controller can also carry additional semantics in future releases of the Spring Framework\n\n\n## spring懒加载\n官方文档：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init\n\n## springbean的作用域\n文档参考：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes\n\n### Singleton 中引用了一个Prototype的bean的时候引发的问题 \n官网引导我们参考：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-method-injection\n\n由于Singleton状态的bean A在初始化的时候只new一次，也只会注入一次依赖的对象B\n因此B对象设置为Prototype 就没有任何意义。解决方式参考官网。\n\n\n## 自己模拟springbean\n定义几个类\n```java\npublic interface UserDao {\n\tpublic String query();\n}\n\npublic class UserDaoImpl implements UserDao {\n\t@Override\n\tpublic String query() {\n\t\treturn \"我要减肥～～～\";\n\t}\n}\n\npublic interface UserService {\n\tpublic void find();\n}\n\npublic class UserServiceImpl implements UserService {\n\n\tUserDao userDao;\n\t@Override\n\tpublic void find() {\n\t\tSystem.out.println(userDao.query() + \"hahaha\");\n\t}\n\n\tpublic void setUserDao(UserDao userDao) {\n\t\tthis.userDao = userDao;\n\t}\n\n\n//\tpublic UserServiceImpl(UserDao userDao) {\n//\t\tthis.userDao = userDao;\n//\t}\n}\n```\n\n新建BeanFactory解析xml\n```java\npublic class BeanFactory {\n\tMap<String,Object> map = new HashMap<>();\n\n\tpublic BeanFactory(String xml) {\n\t\ttry {\n\t\t\tparseXml(xml);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tprivate void parseXml(String xml) throws Exception {\n\t\tFile file = new File(this.getClass().getResource(\"/\").getPath()+\"/\"+xml);\n\t\tSAXReader reader = new SAXReader();\n\t\t//解析XML形式的文本,得到document对象.\n\t\tDocument document = reader.read(file);\n\t\t// 获取文档的根节点.\n\t\tElement elementRoot = document.getRootElement();\n\t\t// <beans default=\"byType\">\n\t\tAttribute attribute = elementRoot.attribute(\"default-autowire\");\n\t\tboolean flag = false;\n\t\tif (attribute != null){\n\t\t\tflag = true;\n\t\t}\n\t\tfor(Iterator it = elementRoot.elementIterator();it.hasNext();) {\n\t\t\t/**\n\t\t\t * 实例化对象\n\t\t\t */\n\t\t\tElement elementFirstChil = (Element) it.next();\n\t\t\t//  <bean id=\"userDao\" class=\"com.qing.dao.UserDaoImpl\"/>\n\t\t\t// 获取id属性\n\t\t\tAttribute attributeId = elementFirstChil.attribute(\"id\");\n\t\t\t// 得到bean名称\n\t\t\tString beanName = attributeId.getValue();\n\t\t\t// 获取class属性\n\t\t\tAttribute attributeClazz = elementFirstChil.attribute(\"class\");\n\t\t\t// 得到className\n\t\t\tString className = attributeClazz.getValue();\n\t\t\tClass clazz = Class.forName(className);\n\n\t\t\t/**\n\t\t\t * 维护依赖关系\n\t\t\t * 看这个对象有没有依赖（判断是否有property。或者判断类是否有属性）\n\t\t\t * 如果有则注入\n\t\t\t */\n\t\t\tObject object = null;\n\t\t\tfor (Iterator itSon = elementFirstChil.elementIterator(); itSon.hasNext(); ) {\n\t\t\t\tElement elementSon = (Element) itSon.next();\n\t\t\t\tif (elementSon.getName().equals(\"property\")) {\n\t\t\t\t\t// setter 方法注入\n\t\t\t\t\t// <property name=\"userDao\" ref=\"userDao\"/>\n\t\t\t\t\tobject = clazz.newInstance();\n\t\t\t\t\t// 获取ref属性\n\t\t\t\t\tAttribute attributeRef = elementSon.attribute(\"ref\");\n\t\t\t\t\tObject objectSon = map.get(attributeRef.getValue());\n\t\t\t\t\t// 获取name属性\n\t\t\t\t\tAttribute attributeName = elementSon.attribute(\"name\");\n\t\t\t\t\tString name = attributeName.getValue();\n\t\t\t\t\t// 获取类本身的属性成员\n\t\t\t\t\tField field = clazz.getDeclaredField(name);\n\t\t\t\t\t// 利用反射set属性，要设置取消 Java 语言访问检查\n\t\t\t\t\tfield.setAccessible(true);\n\t\t\t\t\t// set属性\n\t\t\t\t\tfield.set(object, objectSon);\n\t\t\t\t} else if(elementSon.getName().equals(\"constructor-arg\")){\n\t\t\t\t\t//构造方法注入\n\t\t\t\t\t// 获取ref属性\n\t\t\t\t\tAttribute attributeRef = elementSon.attribute(\"ref\");\n\t\t\t\t\tObject objectSon = map.get(attributeRef.getValue());\n\t\t\t\t\t// 获取objectSon所实现的接口\n\t\t\t\t\tClass sonInterface = objectSon.getClass().getInterfaces()[0];\n\t\t\t\t\tConstructor constructor = clazz.getConstructor(sonInterface);\n\t\t\t\t\tobject = constructor.newInstance(objectSon);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(object == null){\n\t\t\t\tif (flag) {// 自动装配\n\t\t\t\t\tif (attribute.getValue().equals(\"byType\")) {\n\t\t\t\t\t\t//判斷是否有依賴\n\t\t\t\t\t\tField fields[] = clazz.getDeclaredFields();\n\t\t\t\t\t\tfor (Field field : fields) {\n\t\t\t\t\t\t\t//得到屬性的類型，比如String aa那麽這裏的field.getType()=String.class\n\t\t\t\t\t\t\tClass injectObjectClazz = field.getType();\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * 由於是bytype 所以需要遍历map当中的所有对象\n\t\t\t\t\t\t\t * 判断对象的类型是不是和这个injectObjectClazz相同\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tObject objectSon = null;\n\t\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t\tfor(Map.Entry<String,Object> entry : map.entrySet()){\n\t\t\t\t\t\t\t\tClass temp = entry.getValue().getClass().getInterfaces()[0];\n\t\t\t\t\t\t\t\tif(temp.getName().equals(injectObjectClazz.getName())){\n\t\t\t\t\t\t\t\t\tobjectSon = entry.getValue();\n\t\t\t\t\t\t\t\t\tcount ++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(count > 1){\n\t\t\t\t\t\t\t\tthrow new MySpringException(\"需要一个对象，但是找到了两个对象\");\n\t\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\t\tobject = clazz.newInstance();\n\t\t\t\t\t\t\t\tfield.setAccessible(true);\n\t\t\t\t\t\t\t\tfield.set(object, objectSon);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (object == null) {//沒有子标签\n\t\t\t\tobject = clazz.newInstance();\n\t\t\t}\n\t\t\tmap.put(beanName, object);\n\t\t}\n\n\t\tSystem.out.println(map);\n\t}\n\n\n\tpublic Object getBean(String name){\n\t\treturn map.get(name);\n\t}\n\n```\n\n测试类\n```java\npublic class Test {\n\tpublic static void main(String[] args) {\n\n\t\tBeanFactory beanFactory = new BeanFactory(\"spring.xml\");\n\t\tUserService userService = (UserService) beanFactory.getBean(\"userService\");\n\t\tuserService.find();\n\t}\n}\n```\n\nxml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans default-autowire=\"byType\">\n\n<!--    setter注入-->\n    <bean id=\"userDao\" class=\"com.qing.dao.UserDaoImpl\"/>\n    <bean id=\"userService\" class=\"com.qing.service.UserServiceImpl\">\n        <property name=\"userDao\" ref=\"userDao\"/>\n    </bean>\n\n<!--    构造方法注入-->\n    <bean id=\"userDao\" class=\"com.qing.dao.UserDaoImpl\"/>\n    <bean id=\"userService\" class=\"com.qing.service.UserServiceImpl\">\n        <constructor-arg ref=\"userDao\"/>\n    </bean>\n\n\n<!--    default-autowire=\"byType\"-->\n    <bean id=\"userDao\" class=\"com.qing.dao.UserDaoImpl\"/>\n    <bean id=\"userService\" class=\"com.qing.service.UserServiceImpl\"/>\n</beans>\n```\n","slug":"Java-Spring","published":1,"updated":"2020-03-13T08:24:26.531Z","layout":"post","photos":[],"link":"","_id":"ck8fb4aav001ik2o5ugy3spbn","content":"<h1 id=\"springIOC\"><a href=\"#springIOC\" class=\"headerlink\" title=\"springIOC\"></a>springIOC</h1><h2 id=\"what-is-IOC\"><a href=\"#what-is-IOC\" class=\"headerlink\" title=\"what is IOC\"></a>what is IOC</h2><blockquote>\n<p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，将你设计好的对象交给容器控制，可以用来减低计算机代码之间的耦合度。<br>其中最常见的方式叫做依赖注入（Dependency Injection，简称<code>DI</code>），还有一种方式叫“依赖查找”（Dependency <code>Lookup</code>）</p>\n</blockquote>\n<h2 id=\"依赖注入（Dependency-Injection）\"><a href=\"#依赖注入（Dependency-Injection）\" class=\"headerlink\" title=\"依赖注入（Dependency Injection）\"></a>依赖注入（Dependency Injection）</h2><p>依赖：比如A.class中有一个B.class的属性，那么我们可以理解为A依赖了B<br>依赖注入：由容器动态的将某个依赖关系注入到组件之中。<br>依赖注入是实现IOC的一种方式。</p>\n<h2 id=\"为什么要使用spring-IOC？\"><a href=\"#为什么要使用spring-IOC？\" class=\"headerlink\" title=\"为什么要使用spring IOC？\"></a>为什么要使用spring IOC？</h2><blockquote>\n<p>在日常程序开发过程当中，我们推荐面向抽象编程，面向抽象编程会产生类的依赖<br>当然如果你够强大可以自己写一个管理的容器<br>但是既然spring以及实现了，并且spring如此优秀，我们仅仅需要学习spring框架便可。<br>当我们有了一个管理对象的容器之后，类的产生过程也交给了容器，至于我们自己的程序则可以不需要去关系这些对象的产生了。</p>\n</blockquote>\n<h2 id=\"spring实现IOC的思路和方法\"><a href=\"#spring实现IOC的思路和方法\" class=\"headerlink\" title=\"spring实现IOC的思路和方法\"></a>spring实现IOC的思路和方法</h2><ol>\n<li>应用程序中提供类，提供依赖关系（属性或者构造方法）</li>\n<li>把需要交给容器管理的对象通过配置信息告诉容器（xml、annotation，javaconfig）</li>\n<li>把各个类之间的依赖关系通过配置信息告诉容器</li>\n</ol>\n<blockquote>\n<p>配置这些信息的方法有三种分别是xml，annotation和javaconfig<br>维护的过程称为自动注入，自动注入的方法有两种<code>构造方法和setter</code><br>自动注入的值可以是对象，数组，map，list和常量比如字符串整形等</p>\n</blockquote>\n<h2 id=\"spring编程的风格\"><a href=\"#spring编程的风格\" class=\"headerlink\" title=\"spring编程的风格\"></a>spring编程的风格</h2><ol>\n<li>schemal-based——-xml</li>\n<li>annotation-based—–annotation</li>\n<li>java-based—-java Configuration</li>\n</ol>\n<h2 id=\"注入的两种方法\"><a href=\"#注入的两种方法\" class=\"headerlink\" title=\"注入的两种方法\"></a>注入的两种方法</h2><p>官网文档已经很详细了：<a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed</a></p>\n<h3 id=\"构造方法注入（Constructor-based-Dependency-Injection）\"><a href=\"#构造方法注入（Constructor-based-Dependency-Injection）\" class=\"headerlink\" title=\"构造方法注入（Constructor-based Dependency Injection）\"></a>构造方法注入（Constructor-based Dependency Injection）</h3><p>构造方法参考文档：<a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection</a></p>\n<h3 id=\"setter方法注入（Setter-based-Dependency-Injection）\"><a href=\"#setter方法注入（Setter-based-Dependency-Injection）\" class=\"headerlink\" title=\"setter方法注入（Setter-based Dependency Injection）\"></a>setter方法注入（Setter-based Dependency Injection）</h3><p>setter参考文档：<a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection</a></p>\n<h2 id=\"自动装配\"><a href=\"#自动装配\" class=\"headerlink\" title=\"自动装配\"></a>自动装配</h2><p>上面说过，IOC的注入有两个地方需要提供依赖关系，一是类的定义中，二是在spring的配置中需要去描述。<br>自动装配则把第二个取消了，即我们仅仅需要在类中提供依赖，继而把对象交给容器管理即可完成注入。</p>\n<p>自动装配的优点参考文档：<a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire</a><br>缺点参考文档：<a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions</a></p>\n<h2 id=\"自动装配的方法\"><a href=\"#自动装配的方法\" class=\"headerlink\" title=\"自动装配的方法\"></a>自动装配的方法</h2><ul>\n<li>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。</li>\n<li>byName：它根据 bean 的名称注入对象依赖项。</li>\n<li>byType：它根据类型注入对象依赖项。</li>\n<li>constructor：通过构造函数来注入依赖项，需要设置大量的参数。</li>\n</ul>\n<h2 id=\"Component，-Service，-Controller，-Repository\"><a href=\"#Component，-Service，-Controller，-Repository\" class=\"headerlink\" title=\"@Component，@Service，@Controller，@Repository\"></a>@Component，@Service，@Controller，@Repository</h2><ul>\n<li>@Component是一个通用的Spring容器管理的单例bean组件</li>\n<li>@Repository 通常用于持久层</li>\n<li>@Service 通常用于业务逻辑层</li>\n<li>@Controller 通常用于表现层（spring-mvc的注解）</li>\n</ul>\n<p><code>这几种注解当前的作用没有任何区别。</code><br>官网有这样一段话，意思是这几种注解在未来可能会有其他语意。因此推荐按照通用使用方式使用注解。</p>\n<blockquote>\n<p> @Repository, @Service, and @Controller can also carry additional semantics in future releases of the Spring Framework</p>\n</blockquote>\n<h2 id=\"spring懒加载\"><a href=\"#spring懒加载\" class=\"headerlink\" title=\"spring懒加载\"></a>spring懒加载</h2><p>官方文档：<a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init</a></p>\n<h2 id=\"springbean的作用域\"><a href=\"#springbean的作用域\" class=\"headerlink\" title=\"springbean的作用域\"></a>springbean的作用域</h2><p>文档参考：<a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes</a></p>\n<h3 id=\"Singleton-中引用了一个Prototype的bean的时候引发的问题\"><a href=\"#Singleton-中引用了一个Prototype的bean的时候引发的问题\" class=\"headerlink\" title=\"Singleton 中引用了一个Prototype的bean的时候引发的问题\"></a>Singleton 中引用了一个Prototype的bean的时候引发的问题</h3><p>官网引导我们参考：<a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-method-injection\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-method-injection</a></p>\n<p>由于Singleton状态的bean A在初始化的时候只new一次，也只会注入一次依赖的对象B<br>因此B对象设置为Prototype 就没有任何意义。解决方式参考官网。</p>\n<h2 id=\"自己模拟springbean\"><a href=\"#自己模拟springbean\" class=\"headerlink\" title=\"自己模拟springbean\"></a>自己模拟springbean</h2><p>定义几个类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserDao</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">query</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserDao</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">query</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"我要减肥～～～\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">find</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tUserDao userDao;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">find</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(userDao.query() + <span class=\"string\">\"hahaha\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUserDao</span><span class=\"params\">(UserDao userDao)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.userDao = userDao;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//\tpublic UserServiceImpl(UserDao userDao) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tthis.userDao = userDao;</span></span><br><span class=\"line\"><span class=\"comment\">//\t&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>新建BeanFactory解析xml</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanFactory</span> </span>&#123;</span><br><span class=\"line\">\tMap&lt;String,Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BeanFactory</span><span class=\"params\">(String xml)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tparseXml(xml);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">parseXml</span><span class=\"params\">(String xml)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\tFile file = <span class=\"keyword\">new</span> File(<span class=\"keyword\">this</span>.getClass().getResource(<span class=\"string\">\"/\"</span>).getPath()+<span class=\"string\">\"/\"</span>+xml);</span><br><span class=\"line\">\t\tSAXReader reader = <span class=\"keyword\">new</span> SAXReader();</span><br><span class=\"line\">\t\t<span class=\"comment\">//解析XML形式的文本,得到document对象.</span></span><br><span class=\"line\">\t\tDocument document = reader.read(file);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 获取文档的根节点.</span></span><br><span class=\"line\">\t\tElement elementRoot = document.getRootElement();</span><br><span class=\"line\">\t\t<span class=\"comment\">// &lt;beans default=\"byType\"&gt;</span></span><br><span class=\"line\">\t\tAttribute attribute = elementRoot.attribute(<span class=\"string\">\"default-autowire\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (attribute != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\tflag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Iterator it = elementRoot.elementIterator();it.hasNext();) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * 实例化对象</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t */</span></span><br><span class=\"line\">\t\t\tElement elementFirstChil = (Element) it.next();</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//  &lt;bean id=\"userDao\" class=\"com.qing.dao.UserDaoImpl\"/&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 获取id属性</span></span><br><span class=\"line\">\t\t\tAttribute attributeId = elementFirstChil.attribute(<span class=\"string\">\"id\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 得到bean名称</span></span><br><span class=\"line\">\t\t\tString beanName = attributeId.getValue();</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 获取class属性</span></span><br><span class=\"line\">\t\t\tAttribute attributeClazz = elementFirstChil.attribute(<span class=\"string\">\"class\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 得到className</span></span><br><span class=\"line\">\t\t\tString className = attributeClazz.getValue();</span><br><span class=\"line\">\t\t\tClass clazz = Class.forName(className);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * 维护依赖关系</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * 看这个对象有没有依赖（判断是否有property。或者判断类是否有属性）</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * 如果有则注入</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t */</span></span><br><span class=\"line\">\t\t\tObject object = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (Iterator itSon = elementFirstChil.elementIterator(); itSon.hasNext(); ) &#123;</span><br><span class=\"line\">\t\t\t\tElement elementSon = (Element) itSon.next();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (elementSon.getName().equals(<span class=\"string\">\"property\"</span>)) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// setter 方法注入</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// &lt;property name=\"userDao\" ref=\"userDao\"/&gt;</span></span><br><span class=\"line\">\t\t\t\t\tobject = clazz.newInstance();</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 获取ref属性</span></span><br><span class=\"line\">\t\t\t\t\tAttribute attributeRef = elementSon.attribute(<span class=\"string\">\"ref\"</span>);</span><br><span class=\"line\">\t\t\t\t\tObject objectSon = map.get(attributeRef.getValue());</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 获取name属性</span></span><br><span class=\"line\">\t\t\t\t\tAttribute attributeName = elementSon.attribute(<span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">\t\t\t\t\tString name = attributeName.getValue();</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 获取类本身的属性成员</span></span><br><span class=\"line\">\t\t\t\t\tField field = clazz.getDeclaredField(name);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 利用反射set属性，要设置取消 Java 语言访问检查</span></span><br><span class=\"line\">\t\t\t\t\tfield.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// set属性</span></span><br><span class=\"line\">\t\t\t\t\tfield.set(object, objectSon);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(elementSon.getName().equals(<span class=\"string\">\"constructor-arg\"</span>))&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//构造方法注入</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 获取ref属性</span></span><br><span class=\"line\">\t\t\t\t\tAttribute attributeRef = elementSon.attribute(<span class=\"string\">\"ref\"</span>);</span><br><span class=\"line\">\t\t\t\t\tObject objectSon = map.get(attributeRef.getValue());</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 获取objectSon所实现的接口</span></span><br><span class=\"line\">\t\t\t\t\tClass sonInterface = objectSon.getClass().getInterfaces()[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\t\t\t\tConstructor constructor = clazz.getConstructor(sonInterface);</span><br><span class=\"line\">\t\t\t\t\tobject = constructor.newInstance(objectSon);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(object == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (flag) &#123;<span class=\"comment\">// 自动装配</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (attribute.getValue().equals(<span class=\"string\">\"byType\"</span>)) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//判斷是否有依賴</span></span><br><span class=\"line\">\t\t\t\t\t\tField fields[] = clazz.getDeclaredFields();</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">for</span> (Field field : fields) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">//得到屬性的類型，比如String aa那麽這裏的field.getType()=String.class</span></span><br><span class=\"line\">\t\t\t\t\t\t\tClass injectObjectClazz = field.getType();</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t * 由於是bytype 所以需要遍历map当中的所有对象</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t * 判断对象的类型是不是和这个injectObjectClazz相同</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t */</span></span><br><span class=\"line\">\t\t\t\t\t\t\tObject objectSon = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">for</span>(Map.Entry&lt;String,Object&gt; entry : map.entrySet())&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tClass temp = entry.getValue().getClass().getInterfaces()[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">if</span>(temp.getName().equals(injectObjectClazz.getName()))&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tobjectSon = entry.getValue();</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tcount ++;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">if</span>(count &gt; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MySpringException(<span class=\"string\">\"需要一个对象，但是找到了两个对象\"</span>);</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tobject = clazz.newInstance();</span><br><span class=\"line\">\t\t\t\t\t\t\t\tfield.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\t\t\t\t\t\t\tfield.set(object, objectSon);</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (object == <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//沒有子标签</span></span><br><span class=\"line\">\t\t\t\tobject = clazz.newInstance();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tmap.put(beanName, object);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(map);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getBean</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> map.get(name);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tBeanFactory beanFactory = <span class=\"keyword\">new</span> BeanFactory(<span class=\"string\">\"spring.xml\"</span>);</span><br><span class=\"line\">\t\tUserService userService = (UserService) beanFactory.getBean(<span class=\"string\">\"userService\"</span>);</span><br><span class=\"line\">\t\tuserService.find();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">default-autowire</span>=<span class=\"string\">\"byType\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--    setter注入--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userDao\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.qing.dao.UserDaoImpl\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.qing.service.UserServiceImpl\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"userDao\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"userDao\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--    构造方法注入--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userDao\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.qing.dao.UserDaoImpl\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.qing.service.UserServiceImpl\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"userDao\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--    default-autowire=\"byType\"--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userDao\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.qing.dao.UserDaoImpl\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.qing.service.UserServiceImpl\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"springIOC\"><a href=\"#springIOC\" class=\"headerlink\" title=\"springIOC\"></a>springIOC</h1><h2 id=\"what-is-IOC\"><a href=\"#what-is-IOC\" class=\"headerlink\" title=\"what is IOC\"></a>what is IOC</h2><blockquote>\n<p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，将你设计好的对象交给容器控制，可以用来减低计算机代码之间的耦合度。<br>其中最常见的方式叫做依赖注入（Dependency Injection，简称<code>DI</code>），还有一种方式叫“依赖查找”（Dependency <code>Lookup</code>）</p>\n</blockquote>\n<h2 id=\"依赖注入（Dependency-Injection）\"><a href=\"#依赖注入（Dependency-Injection）\" class=\"headerlink\" title=\"依赖注入（Dependency Injection）\"></a>依赖注入（Dependency Injection）</h2><p>依赖：比如A.class中有一个B.class的属性，那么我们可以理解为A依赖了B<br>依赖注入：由容器动态的将某个依赖关系注入到组件之中。<br>依赖注入是实现IOC的一种方式。</p>\n<h2 id=\"为什么要使用spring-IOC？\"><a href=\"#为什么要使用spring-IOC？\" class=\"headerlink\" title=\"为什么要使用spring IOC？\"></a>为什么要使用spring IOC？</h2><blockquote>\n<p>在日常程序开发过程当中，我们推荐面向抽象编程，面向抽象编程会产生类的依赖<br>当然如果你够强大可以自己写一个管理的容器<br>但是既然spring以及实现了，并且spring如此优秀，我们仅仅需要学习spring框架便可。<br>当我们有了一个管理对象的容器之后，类的产生过程也交给了容器，至于我们自己的程序则可以不需要去关系这些对象的产生了。</p>\n</blockquote>\n<h2 id=\"spring实现IOC的思路和方法\"><a href=\"#spring实现IOC的思路和方法\" class=\"headerlink\" title=\"spring实现IOC的思路和方法\"></a>spring实现IOC的思路和方法</h2><ol>\n<li>应用程序中提供类，提供依赖关系（属性或者构造方法）</li>\n<li>把需要交给容器管理的对象通过配置信息告诉容器（xml、annotation，javaconfig）</li>\n<li>把各个类之间的依赖关系通过配置信息告诉容器</li>\n</ol>\n<blockquote>\n<p>配置这些信息的方法有三种分别是xml，annotation和javaconfig<br>维护的过程称为自动注入，自动注入的方法有两种<code>构造方法和setter</code><br>自动注入的值可以是对象，数组，map，list和常量比如字符串整形等</p>\n</blockquote>\n<h2 id=\"spring编程的风格\"><a href=\"#spring编程的风格\" class=\"headerlink\" title=\"spring编程的风格\"></a>spring编程的风格</h2><ol>\n<li>schemal-based——-xml</li>\n<li>annotation-based—–annotation</li>\n<li>java-based—-java Configuration</li>\n</ol>\n<h2 id=\"注入的两种方法\"><a href=\"#注入的两种方法\" class=\"headerlink\" title=\"注入的两种方法\"></a>注入的两种方法</h2><p>官网文档已经很详细了：<a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-properties-detailed</a></p>\n<h3 id=\"构造方法注入（Constructor-based-Dependency-Injection）\"><a href=\"#构造方法注入（Constructor-based-Dependency-Injection）\" class=\"headerlink\" title=\"构造方法注入（Constructor-based Dependency Injection）\"></a>构造方法注入（Constructor-based Dependency Injection）</h3><p>构造方法参考文档：<a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-constructor-injection</a></p>\n<h3 id=\"setter方法注入（Setter-based-Dependency-Injection）\"><a href=\"#setter方法注入（Setter-based-Dependency-Injection）\" class=\"headerlink\" title=\"setter方法注入（Setter-based Dependency Injection）\"></a>setter方法注入（Setter-based Dependency Injection）</h3><p>setter参考文档：<a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-setter-injection</a></p>\n<h2 id=\"自动装配\"><a href=\"#自动装配\" class=\"headerlink\" title=\"自动装配\"></a>自动装配</h2><p>上面说过，IOC的注入有两个地方需要提供依赖关系，一是类的定义中，二是在spring的配置中需要去描述。<br>自动装配则把第二个取消了，即我们仅仅需要在类中提供依赖，继而把对象交给容器管理即可完成注入。</p>\n<p>自动装配的优点参考文档：<a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-autowire</a><br>缺点参考文档：<a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-autowired-exceptions</a></p>\n<h2 id=\"自动装配的方法\"><a href=\"#自动装配的方法\" class=\"headerlink\" title=\"自动装配的方法\"></a>自动装配的方法</h2><ul>\n<li>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。</li>\n<li>byName：它根据 bean 的名称注入对象依赖项。</li>\n<li>byType：它根据类型注入对象依赖项。</li>\n<li>constructor：通过构造函数来注入依赖项，需要设置大量的参数。</li>\n</ul>\n<h2 id=\"Component，-Service，-Controller，-Repository\"><a href=\"#Component，-Service，-Controller，-Repository\" class=\"headerlink\" title=\"@Component，@Service，@Controller，@Repository\"></a>@Component，@Service，@Controller，@Repository</h2><ul>\n<li>@Component是一个通用的Spring容器管理的单例bean组件</li>\n<li>@Repository 通常用于持久层</li>\n<li>@Service 通常用于业务逻辑层</li>\n<li>@Controller 通常用于表现层（spring-mvc的注解）</li>\n</ul>\n<p><code>这几种注解当前的作用没有任何区别。</code><br>官网有这样一段话，意思是这几种注解在未来可能会有其他语意。因此推荐按照通用使用方式使用注解。</p>\n<blockquote>\n<p> @Repository, @Service, and @Controller can also carry additional semantics in future releases of the Spring Framework</p>\n</blockquote>\n<h2 id=\"spring懒加载\"><a href=\"#spring懒加载\" class=\"headerlink\" title=\"spring懒加载\"></a>spring懒加载</h2><p>官方文档：<a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init</a></p>\n<h2 id=\"springbean的作用域\"><a href=\"#springbean的作用域\" class=\"headerlink\" title=\"springbean的作用域\"></a>springbean的作用域</h2><p>文档参考：<a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-scopes</a></p>\n<h3 id=\"Singleton-中引用了一个Prototype的bean的时候引发的问题\"><a href=\"#Singleton-中引用了一个Prototype的bean的时候引发的问题\" class=\"headerlink\" title=\"Singleton 中引用了一个Prototype的bean的时候引发的问题\"></a>Singleton 中引用了一个Prototype的bean的时候引发的问题</h3><p>官网引导我们参考：<a href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-method-injection\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-factory-method-injection</a></p>\n<p>由于Singleton状态的bean A在初始化的时候只new一次，也只会注入一次依赖的对象B<br>因此B对象设置为Prototype 就没有任何意义。解决方式参考官网。</p>\n<h2 id=\"自己模拟springbean\"><a href=\"#自己模拟springbean\" class=\"headerlink\" title=\"自己模拟springbean\"></a>自己模拟springbean</h2><p>定义几个类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserDao</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">query</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserDao</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">query</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"我要减肥～～～\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">find</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tUserDao userDao;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">find</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(userDao.query() + <span class=\"string\">\"hahaha\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUserDao</span><span class=\"params\">(UserDao userDao)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.userDao = userDao;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//\tpublic UserServiceImpl(UserDao userDao) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\t\tthis.userDao = userDao;</span></span><br><span class=\"line\"><span class=\"comment\">//\t&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>新建BeanFactory解析xml</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanFactory</span> </span>&#123;</span><br><span class=\"line\">\tMap&lt;String,Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BeanFactory</span><span class=\"params\">(String xml)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tparseXml(xml);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">parseXml</span><span class=\"params\">(String xml)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\tFile file = <span class=\"keyword\">new</span> File(<span class=\"keyword\">this</span>.getClass().getResource(<span class=\"string\">\"/\"</span>).getPath()+<span class=\"string\">\"/\"</span>+xml);</span><br><span class=\"line\">\t\tSAXReader reader = <span class=\"keyword\">new</span> SAXReader();</span><br><span class=\"line\">\t\t<span class=\"comment\">//解析XML形式的文本,得到document对象.</span></span><br><span class=\"line\">\t\tDocument document = reader.read(file);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 获取文档的根节点.</span></span><br><span class=\"line\">\t\tElement elementRoot = document.getRootElement();</span><br><span class=\"line\">\t\t<span class=\"comment\">// &lt;beans default=\"byType\"&gt;</span></span><br><span class=\"line\">\t\tAttribute attribute = elementRoot.attribute(<span class=\"string\">\"default-autowire\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (attribute != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\tflag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Iterator it = elementRoot.elementIterator();it.hasNext();) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * 实例化对象</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t */</span></span><br><span class=\"line\">\t\t\tElement elementFirstChil = (Element) it.next();</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//  &lt;bean id=\"userDao\" class=\"com.qing.dao.UserDaoImpl\"/&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 获取id属性</span></span><br><span class=\"line\">\t\t\tAttribute attributeId = elementFirstChil.attribute(<span class=\"string\">\"id\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 得到bean名称</span></span><br><span class=\"line\">\t\t\tString beanName = attributeId.getValue();</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 获取class属性</span></span><br><span class=\"line\">\t\t\tAttribute attributeClazz = elementFirstChil.attribute(<span class=\"string\">\"class\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 得到className</span></span><br><span class=\"line\">\t\t\tString className = attributeClazz.getValue();</span><br><span class=\"line\">\t\t\tClass clazz = Class.forName(className);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * 维护依赖关系</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * 看这个对象有没有依赖（判断是否有property。或者判断类是否有属性）</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t * 如果有则注入</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t */</span></span><br><span class=\"line\">\t\t\tObject object = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (Iterator itSon = elementFirstChil.elementIterator(); itSon.hasNext(); ) &#123;</span><br><span class=\"line\">\t\t\t\tElement elementSon = (Element) itSon.next();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (elementSon.getName().equals(<span class=\"string\">\"property\"</span>)) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// setter 方法注入</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// &lt;property name=\"userDao\" ref=\"userDao\"/&gt;</span></span><br><span class=\"line\">\t\t\t\t\tobject = clazz.newInstance();</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 获取ref属性</span></span><br><span class=\"line\">\t\t\t\t\tAttribute attributeRef = elementSon.attribute(<span class=\"string\">\"ref\"</span>);</span><br><span class=\"line\">\t\t\t\t\tObject objectSon = map.get(attributeRef.getValue());</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 获取name属性</span></span><br><span class=\"line\">\t\t\t\t\tAttribute attributeName = elementSon.attribute(<span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">\t\t\t\t\tString name = attributeName.getValue();</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 获取类本身的属性成员</span></span><br><span class=\"line\">\t\t\t\t\tField field = clazz.getDeclaredField(name);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 利用反射set属性，要设置取消 Java 语言访问检查</span></span><br><span class=\"line\">\t\t\t\t\tfield.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// set属性</span></span><br><span class=\"line\">\t\t\t\t\tfield.set(object, objectSon);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(elementSon.getName().equals(<span class=\"string\">\"constructor-arg\"</span>))&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//构造方法注入</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 获取ref属性</span></span><br><span class=\"line\">\t\t\t\t\tAttribute attributeRef = elementSon.attribute(<span class=\"string\">\"ref\"</span>);</span><br><span class=\"line\">\t\t\t\t\tObject objectSon = map.get(attributeRef.getValue());</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 获取objectSon所实现的接口</span></span><br><span class=\"line\">\t\t\t\t\tClass sonInterface = objectSon.getClass().getInterfaces()[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\t\t\t\tConstructor constructor = clazz.getConstructor(sonInterface);</span><br><span class=\"line\">\t\t\t\t\tobject = constructor.newInstance(objectSon);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(object == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (flag) &#123;<span class=\"comment\">// 自动装配</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (attribute.getValue().equals(<span class=\"string\">\"byType\"</span>)) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//判斷是否有依賴</span></span><br><span class=\"line\">\t\t\t\t\t\tField fields[] = clazz.getDeclaredFields();</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">for</span> (Field field : fields) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">//得到屬性的類型，比如String aa那麽這裏的field.getType()=String.class</span></span><br><span class=\"line\">\t\t\t\t\t\t\tClass injectObjectClazz = field.getType();</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t * 由於是bytype 所以需要遍历map当中的所有对象</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t * 判断对象的类型是不是和这个injectObjectClazz相同</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t */</span></span><br><span class=\"line\">\t\t\t\t\t\t\tObject objectSon = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">for</span>(Map.Entry&lt;String,Object&gt; entry : map.entrySet())&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tClass temp = entry.getValue().getClass().getInterfaces()[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">if</span>(temp.getName().equals(injectObjectClazz.getName()))&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tobjectSon = entry.getValue();</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tcount ++;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">if</span>(count &gt; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MySpringException(<span class=\"string\">\"需要一个对象，但是找到了两个对象\"</span>);</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tobject = clazz.newInstance();</span><br><span class=\"line\">\t\t\t\t\t\t\t\tfield.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t\t\t\t\t\t\t\tfield.set(object, objectSon);</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (object == <span class=\"keyword\">null</span>) &#123;<span class=\"comment\">//沒有子标签</span></span><br><span class=\"line\">\t\t\t\tobject = clazz.newInstance();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tmap.put(beanName, object);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(map);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getBean</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> map.get(name);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tBeanFactory beanFactory = <span class=\"keyword\">new</span> BeanFactory(<span class=\"string\">\"spring.xml\"</span>);</span><br><span class=\"line\">\t\tUserService userService = (UserService) beanFactory.getBean(<span class=\"string\">\"userService\"</span>);</span><br><span class=\"line\">\t\tuserService.find();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">default-autowire</span>=<span class=\"string\">\"byType\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--    setter注入--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userDao\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.qing.dao.UserDaoImpl\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.qing.service.UserServiceImpl\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"userDao\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"userDao\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--    构造方法注入--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userDao\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.qing.dao.UserDaoImpl\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.qing.service.UserServiceImpl\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"userDao\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--    default-autowire=\"byType\"--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userDao\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.qing.dao.UserDaoImpl\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.qing.service.UserServiceImpl\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n"},{"title":"JAVA-内存模型","date":"2020-01-16T08:04:00.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"# JVM内存模型\n{% post_link JVM-Fundamentals 点击这里查看这篇文章 %}\n\n# Java内存模型\nJava内存模型(Java Memory Model，简称JMM)，本身是种`抽象的概念`，并不是像硬件架构一样真实存在的；它描述的是一组规则或规范，通过这组规范定义了程序中各个变量(包括实例字段、静态字段和构成数组对象的元素)的访问方式。\n![](Java-MemoryModel/1.png)\n<!-- more -->\n* 主内存：共享的信息\n* 工作内存：私有信息，基本数据类型，直接分配到工作内存，引用的地址存放在工作内存，引用的对象存放在堆中\n* 工作方式：\n    * 线程修改私有数据，直接在工作空间修改\n    * 线程修改共享数据，把数据复制到工作空间中去，在工作空间中修改，修改完成以后，刷新内存中的数据 \n    \n# 硬件架构\n![](Java-MemoryModel/2.png)\n* **多CPU**：一个现代计算机通常由两个或者多个CPU。其中一些CPU还有多核。从这一点可以看出，在一个有两个或者多个CPU的现代计算机上同时运行多个线程是可能的。每个CPU在某一时刻运行一个线程是没有问题的。这意味着，如果你的Java程序是多线程的，在你的Java程序中每个CPU上一个线程可能同时（并发）执行。\n* **CPU寄存器**：每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。\n* **高速缓存cache**：由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还要慢一点。每个CPU可能有一个CPU缓存层，一些CPU还有多层缓存。在某一时刻，一个或者多个缓存行（cache lines）可能被读到缓存，一个或者多个缓存行可能再被刷新回主存。\n* **内存**：一个计算机还包含一个主存。所有的CPU都可以访问主存。主存通常比CPU中的缓存大得多。\n\n运作原理：通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。\n\n* 解决方案：\n    * 总线加锁：所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被**阻塞**住,那么该处理器可以独占使用共享内存。\n    * 缓存上的一致性协议(MESI)\n  \n## 缓存一致性协议(MESI)\n多核CPU硬件架构厂商，设计之初就预测到多线程操作数据不一致的问题，因此出现了——缓存一致性协议。\n\n不同的CPU硬件生产厂商，具体的实现不一样。Intel的MESI协议最出名。\nMESI协议文档：https://en.wikipedia.org/wiki/MESI_protocol\n\n在MESI协议中，每个Cache line有4个状态，可用2个bit表示，它们分别是：\n* M(Modified): 这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。\n* E(Exclusive): 这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中。\n* S(Shared): 这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中。\n* I(Invalid): 这行数据无效。\n\nE状态示例如下：\n![](Java-MemoryModel/3.png)\n只有Core 0访问变量x，它的Cache line状态为E(Exclusive)。\n\nS状态示例如下：\n![](Java-MemoryModel/4.jpeg)\n3个Core都访问变量x，它们对应的Cache line为S(Shared)状态。\n\nM状态和I状态示例如下：\n![](Java-MemoryModel/5.jpeg)\nCore 0修改了x的值之后，这个Cache line变成了M(Modified)状态，其他Core对应的Cache line变成了I(Invalid)状态\n\n## 有了MESI，为什么还需要JMM？\n既然有了MESI协议，是不是就不需要volatile的可见性语义了？\n当然不是，还有以下问题：\n* 并不是所有的硬件架构都提供了相同的一致性保证，不同的硬件厂商实现不同，JVM需要volatile统一语义。\n* 可见性问题不仅仅局限于CPU缓存内，JVM自己维护的内存模型(JMM)中也有可见性问题。使用volatile做标记，可以解决JVM层面的可见性问题。\n\n# Java线程与硬件处理器\nJava线程的实现是基于一对一的线程模型，实际上就是通过语言级别层面程序去间接调用系统内核的线程模型，即我们在使用Java线程时，Java虚拟机内部是转而调用当前操作系统的内核线程来完成当前任务。\n![](Java-MemoryModel/6.png)\n如图所示，每个线程最终都会映射到CPU中进行处理，如果CPU存在多核，那么一个CPU将可以并行执行多个线程任务。\n\n# Java内存模型与硬件内存架构的关系\n多线程的执行最终都会映射到硬件处理器上进行执行，但Java内存模型和硬件内存架构并不完全一致。\n对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存(线程私有数据区域)和主内存(堆内存)之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响,不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。\n![](Java-MemoryModel/7.png)\n\n# Java内存模型的必要性\n如下图，主内存中存在一个共享变量x，现在有A和B两线程分别对该变量x=1进行操作,A线程想要修改x的值为2，而B线程却想要读取x的值,那么B线程读取到到是1还是2呢？\n答案：都可能，这是不确定的，这也就是所谓的线程安全问题。\n![](Java-MemoryModel/8.png)\n为了解决类似上述的问题，JVM定义了一组规则，通过这组规则来决定一个线程对共享变量的写入何时对另一个线程可见。\n\n# JMM对三个特征的保证\n## 原子性\n操作不可分割\n1. X=10 如果是私有数据具有原子性，如果是共享数据没原子性（需要先把10读到共享空间再把10写入x）  \n2. Y=x  没有原子性\n    1. 把数据X读到工作空间（原子性）\n    2. 把X的值写到Y（原子性）\n3. I++ 没有原子性\n    1. 读i到工作空间\n    2. +1\n    3. 刷新结果到内存\n    \n多个原子性的操作合并到一起没有原子性,但是可以通过Synchronized和JUC中Lock的lock来保证原子性。\n\n## 可见性\n线程只能操作自己工作空间中的数据，当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。\n* Volatile:在JMM模型上实现MESI协议\n* Synchronized:加锁\n* JUC   Lock的lock\n\n## 有序性\n有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，对于单线程而言确实如此，但对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺序未必一致。\n* Volatile\n* Synchronized\n* Happens-before原则\n    * 程序次序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。\n    * 锁定原则：后一次加锁必须等前一次解锁\n    * Volatile原则：volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。\n    * 传递原则：A先于B ，B先于C 那么A必然先于C\n    * 线程启动规则：如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见\n    * 线程终止规则：假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。\n    * 线程中断规则：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。\n    * 对象终结规则：对象的构造函数执行，结束先于finalize()方法\n    \n\n\n\n","source":"_posts/Java-MemoryModel.md","raw":"---\ntitle: JAVA-内存模型\ndate: 2020-01-16 16:04:00\ntags:\n    - JAVA\n    - 并发\n    - 学习笔记\ncategories: JAVA\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n# JVM内存模型\n{% post_link JVM-Fundamentals 点击这里查看这篇文章 %}\n\n# Java内存模型\nJava内存模型(Java Memory Model，简称JMM)，本身是种`抽象的概念`，并不是像硬件架构一样真实存在的；它描述的是一组规则或规范，通过这组规范定义了程序中各个变量(包括实例字段、静态字段和构成数组对象的元素)的访问方式。\n![](Java-MemoryModel/1.png)\n<!-- more -->\n* 主内存：共享的信息\n* 工作内存：私有信息，基本数据类型，直接分配到工作内存，引用的地址存放在工作内存，引用的对象存放在堆中\n* 工作方式：\n    * 线程修改私有数据，直接在工作空间修改\n    * 线程修改共享数据，把数据复制到工作空间中去，在工作空间中修改，修改完成以后，刷新内存中的数据 \n    \n# 硬件架构\n![](Java-MemoryModel/2.png)\n* **多CPU**：一个现代计算机通常由两个或者多个CPU。其中一些CPU还有多核。从这一点可以看出，在一个有两个或者多个CPU的现代计算机上同时运行多个线程是可能的。每个CPU在某一时刻运行一个线程是没有问题的。这意味着，如果你的Java程序是多线程的，在你的Java程序中每个CPU上一个线程可能同时（并发）执行。\n* **CPU寄存器**：每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。\n* **高速缓存cache**：由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还要慢一点。每个CPU可能有一个CPU缓存层，一些CPU还有多层缓存。在某一时刻，一个或者多个缓存行（cache lines）可能被读到缓存，一个或者多个缓存行可能再被刷新回主存。\n* **内存**：一个计算机还包含一个主存。所有的CPU都可以访问主存。主存通常比CPU中的缓存大得多。\n\n运作原理：通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。\n\n* 解决方案：\n    * 总线加锁：所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被**阻塞**住,那么该处理器可以独占使用共享内存。\n    * 缓存上的一致性协议(MESI)\n  \n## 缓存一致性协议(MESI)\n多核CPU硬件架构厂商，设计之初就预测到多线程操作数据不一致的问题，因此出现了——缓存一致性协议。\n\n不同的CPU硬件生产厂商，具体的实现不一样。Intel的MESI协议最出名。\nMESI协议文档：https://en.wikipedia.org/wiki/MESI_protocol\n\n在MESI协议中，每个Cache line有4个状态，可用2个bit表示，它们分别是：\n* M(Modified): 这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。\n* E(Exclusive): 这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中。\n* S(Shared): 这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中。\n* I(Invalid): 这行数据无效。\n\nE状态示例如下：\n![](Java-MemoryModel/3.png)\n只有Core 0访问变量x，它的Cache line状态为E(Exclusive)。\n\nS状态示例如下：\n![](Java-MemoryModel/4.jpeg)\n3个Core都访问变量x，它们对应的Cache line为S(Shared)状态。\n\nM状态和I状态示例如下：\n![](Java-MemoryModel/5.jpeg)\nCore 0修改了x的值之后，这个Cache line变成了M(Modified)状态，其他Core对应的Cache line变成了I(Invalid)状态\n\n## 有了MESI，为什么还需要JMM？\n既然有了MESI协议，是不是就不需要volatile的可见性语义了？\n当然不是，还有以下问题：\n* 并不是所有的硬件架构都提供了相同的一致性保证，不同的硬件厂商实现不同，JVM需要volatile统一语义。\n* 可见性问题不仅仅局限于CPU缓存内，JVM自己维护的内存模型(JMM)中也有可见性问题。使用volatile做标记，可以解决JVM层面的可见性问题。\n\n# Java线程与硬件处理器\nJava线程的实现是基于一对一的线程模型，实际上就是通过语言级别层面程序去间接调用系统内核的线程模型，即我们在使用Java线程时，Java虚拟机内部是转而调用当前操作系统的内核线程来完成当前任务。\n![](Java-MemoryModel/6.png)\n如图所示，每个线程最终都会映射到CPU中进行处理，如果CPU存在多核，那么一个CPU将可以并行执行多个线程任务。\n\n# Java内存模型与硬件内存架构的关系\n多线程的执行最终都会映射到硬件处理器上进行执行，但Java内存模型和硬件内存架构并不完全一致。\n对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存(线程私有数据区域)和主内存(堆内存)之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响,不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。\n![](Java-MemoryModel/7.png)\n\n# Java内存模型的必要性\n如下图，主内存中存在一个共享变量x，现在有A和B两线程分别对该变量x=1进行操作,A线程想要修改x的值为2，而B线程却想要读取x的值,那么B线程读取到到是1还是2呢？\n答案：都可能，这是不确定的，这也就是所谓的线程安全问题。\n![](Java-MemoryModel/8.png)\n为了解决类似上述的问题，JVM定义了一组规则，通过这组规则来决定一个线程对共享变量的写入何时对另一个线程可见。\n\n# JMM对三个特征的保证\n## 原子性\n操作不可分割\n1. X=10 如果是私有数据具有原子性，如果是共享数据没原子性（需要先把10读到共享空间再把10写入x）  \n2. Y=x  没有原子性\n    1. 把数据X读到工作空间（原子性）\n    2. 把X的值写到Y（原子性）\n3. I++ 没有原子性\n    1. 读i到工作空间\n    2. +1\n    3. 刷新结果到内存\n    \n多个原子性的操作合并到一起没有原子性,但是可以通过Synchronized和JUC中Lock的lock来保证原子性。\n\n## 可见性\n线程只能操作自己工作空间中的数据，当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。\n* Volatile:在JMM模型上实现MESI协议\n* Synchronized:加锁\n* JUC   Lock的lock\n\n## 有序性\n有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，对于单线程而言确实如此，但对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺序未必一致。\n* Volatile\n* Synchronized\n* Happens-before原则\n    * 程序次序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。\n    * 锁定原则：后一次加锁必须等前一次解锁\n    * Volatile原则：volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。\n    * 传递原则：A先于B ，B先于C 那么A必然先于C\n    * 线程启动规则：如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见\n    * 线程终止规则：假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。\n    * 线程中断规则：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。\n    * 对象终结规则：对象的构造函数执行，结束先于finalize()方法\n    \n\n\n\n","slug":"Java-MemoryModel","published":1,"updated":"2020-02-29T07:00:12.225Z","layout":"post","photos":[],"link":"","_id":"ck8fb4ab2001kk2o5t4933ytk","content":"<h1 id=\"JVM内存模型\"><a href=\"#JVM内存模型\" class=\"headerlink\" title=\"JVM内存模型\"></a>JVM内存模型</h1><a href=\"/JVM/JVM-Fundamentals/\" title=\"点击这里查看这篇文章\">点击这里查看这篇文章</a>\n\n<h1 id=\"Java内存模型\"><a href=\"#Java内存模型\" class=\"headerlink\" title=\"Java内存模型\"></a>Java内存模型</h1><p>Java内存模型(Java Memory Model，简称JMM)，本身是种<code>抽象的概念</code>，并不是像硬件架构一样真实存在的；它描述的是一组规则或规范，通过这组规范定义了程序中各个变量(包括实例字段、静态字段和构成数组对象的元素)的访问方式。<br><img src=\"/JAVA/Java-MemoryModel/1.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<ul>\n<li>主内存：共享的信息</li>\n<li>工作内存：私有信息，基本数据类型，直接分配到工作内存，引用的地址存放在工作内存，引用的对象存放在堆中</li>\n<li>工作方式：<ul>\n<li>线程修改私有数据，直接在工作空间修改</li>\n<li>线程修改共享数据，把数据复制到工作空间中去，在工作空间中修改，修改完成以后，刷新内存中的数据 </li>\n</ul>\n</li>\n</ul>\n<h1 id=\"硬件架构\"><a href=\"#硬件架构\" class=\"headerlink\" title=\"硬件架构\"></a>硬件架构</h1><p><img src=\"/JAVA/Java-MemoryModel/2.png\" alt=\"\"></p>\n<ul>\n<li><strong>多CPU</strong>：一个现代计算机通常由两个或者多个CPU。其中一些CPU还有多核。从这一点可以看出，在一个有两个或者多个CPU的现代计算机上同时运行多个线程是可能的。每个CPU在某一时刻运行一个线程是没有问题的。这意味着，如果你的Java程序是多线程的，在你的Java程序中每个CPU上一个线程可能同时（并发）执行。</li>\n<li><strong>CPU寄存器</strong>：每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。</li>\n<li><strong>高速缓存cache</strong>：由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还要慢一点。每个CPU可能有一个CPU缓存层，一些CPU还有多层缓存。在某一时刻，一个或者多个缓存行（cache lines）可能被读到缓存，一个或者多个缓存行可能再被刷新回主存。</li>\n<li><strong>内存</strong>：一个计算机还包含一个主存。所有的CPU都可以访问主存。主存通常比CPU中的缓存大得多。</li>\n</ul>\n<p>运作原理：通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。</p>\n<ul>\n<li>解决方案：<ul>\n<li>总线加锁：所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被<strong>阻塞</strong>住,那么该处理器可以独占使用共享内存。</li>\n<li>缓存上的一致性协议(MESI)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"缓存一致性协议-MESI\"><a href=\"#缓存一致性协议-MESI\" class=\"headerlink\" title=\"缓存一致性协议(MESI)\"></a>缓存一致性协议(MESI)</h2><p>多核CPU硬件架构厂商，设计之初就预测到多线程操作数据不一致的问题，因此出现了——缓存一致性协议。</p>\n<p>不同的CPU硬件生产厂商，具体的实现不一样。Intel的MESI协议最出名。<br>MESI协议文档：<a href=\"https://en.wikipedia.org/wiki/MESI_protocol\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/MESI_protocol</a></p>\n<p>在MESI协议中，每个Cache line有4个状态，可用2个bit表示，它们分别是：</p>\n<ul>\n<li>M(Modified): 这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</li>\n<li>E(Exclusive): 这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中。</li>\n<li>S(Shared): 这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中。</li>\n<li>I(Invalid): 这行数据无效。</li>\n</ul>\n<p>E状态示例如下：<br><img src=\"/JAVA/Java-MemoryModel/3.png\" alt=\"\"><br>只有Core 0访问变量x，它的Cache line状态为E(Exclusive)。</p>\n<p>S状态示例如下：<br><img src=\"/JAVA/Java-MemoryModel/4.jpeg\" alt=\"\"><br>3个Core都访问变量x，它们对应的Cache line为S(Shared)状态。</p>\n<p>M状态和I状态示例如下：<br><img src=\"/JAVA/Java-MemoryModel/5.jpeg\" alt=\"\"><br>Core 0修改了x的值之后，这个Cache line变成了M(Modified)状态，其他Core对应的Cache line变成了I(Invalid)状态</p>\n<h2 id=\"有了MESI，为什么还需要JMM？\"><a href=\"#有了MESI，为什么还需要JMM？\" class=\"headerlink\" title=\"有了MESI，为什么还需要JMM？\"></a>有了MESI，为什么还需要JMM？</h2><p>既然有了MESI协议，是不是就不需要volatile的可见性语义了？<br>当然不是，还有以下问题：</p>\n<ul>\n<li>并不是所有的硬件架构都提供了相同的一致性保证，不同的硬件厂商实现不同，JVM需要volatile统一语义。</li>\n<li>可见性问题不仅仅局限于CPU缓存内，JVM自己维护的内存模型(JMM)中也有可见性问题。使用volatile做标记，可以解决JVM层面的可见性问题。</li>\n</ul>\n<h1 id=\"Java线程与硬件处理器\"><a href=\"#Java线程与硬件处理器\" class=\"headerlink\" title=\"Java线程与硬件处理器\"></a>Java线程与硬件处理器</h1><p>Java线程的实现是基于一对一的线程模型，实际上就是通过语言级别层面程序去间接调用系统内核的线程模型，即我们在使用Java线程时，Java虚拟机内部是转而调用当前操作系统的内核线程来完成当前任务。<br><img src=\"/JAVA/Java-MemoryModel/6.png\" alt=\"\"><br>如图所示，每个线程最终都会映射到CPU中进行处理，如果CPU存在多核，那么一个CPU将可以并行执行多个线程任务。</p>\n<h1 id=\"Java内存模型与硬件内存架构的关系\"><a href=\"#Java内存模型与硬件内存架构的关系\" class=\"headerlink\" title=\"Java内存模型与硬件内存架构的关系\"></a>Java内存模型与硬件内存架构的关系</h1><p>多线程的执行最终都会映射到硬件处理器上进行执行，但Java内存模型和硬件内存架构并不完全一致。<br>对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存(线程私有数据区域)和主内存(堆内存)之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响,不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。<br><img src=\"/JAVA/Java-MemoryModel/7.png\" alt=\"\"></p>\n<h1 id=\"Java内存模型的必要性\"><a href=\"#Java内存模型的必要性\" class=\"headerlink\" title=\"Java内存模型的必要性\"></a>Java内存模型的必要性</h1><p>如下图，主内存中存在一个共享变量x，现在有A和B两线程分别对该变量x=1进行操作,A线程想要修改x的值为2，而B线程却想要读取x的值,那么B线程读取到到是1还是2呢？<br>答案：都可能，这是不确定的，这也就是所谓的线程安全问题。<br><img src=\"/JAVA/Java-MemoryModel/8.png\" alt=\"\"><br>为了解决类似上述的问题，JVM定义了一组规则，通过这组规则来决定一个线程对共享变量的写入何时对另一个线程可见。</p>\n<h1 id=\"JMM对三个特征的保证\"><a href=\"#JMM对三个特征的保证\" class=\"headerlink\" title=\"JMM对三个特征的保证\"></a>JMM对三个特征的保证</h1><h2 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h2><p>操作不可分割</p>\n<ol>\n<li>X=10 如果是私有数据具有原子性，如果是共享数据没原子性（需要先把10读到共享空间再把10写入x）  </li>\n<li>Y=x  没有原子性<ol>\n<li>把数据X读到工作空间（原子性）</li>\n<li>把X的值写到Y（原子性）</li>\n</ol>\n</li>\n<li>I++ 没有原子性<ol>\n<li>读i到工作空间</li>\n<li>+1</li>\n<li>刷新结果到内存</li>\n</ol>\n</li>\n</ol>\n<p>多个原子性的操作合并到一起没有原子性,但是可以通过Synchronized和JUC中Lock的lock来保证原子性。</p>\n<h2 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h2><p>线程只能操作自己工作空间中的数据，当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。</p>\n<ul>\n<li>Volatile:在JMM模型上实现MESI协议</li>\n<li>Synchronized:加锁</li>\n<li>JUC   Lock的lock</li>\n</ul>\n<h2 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h2><p>有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，对于单线程而言确实如此，但对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺序未必一致。</p>\n<ul>\n<li>Volatile</li>\n<li>Synchronized</li>\n<li>Happens-before原则<ul>\n<li>程序次序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</li>\n<li>锁定原则：后一次加锁必须等前一次解锁</li>\n<li>Volatile原则：volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。</li>\n<li>传递原则：A先于B ，B先于C 那么A必然先于C</li>\n<li>线程启动规则：如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见</li>\n<li>线程终止规则：假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。</li>\n<li>线程中断规则：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</li>\n<li>对象终结规则：对象的构造函数执行，结束先于finalize()方法</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"JVM内存模型\"><a href=\"#JVM内存模型\" class=\"headerlink\" title=\"JVM内存模型\"></a>JVM内存模型</h1><a href=\"/JVM/JVM-Fundamentals/\" title=\"点击这里查看这篇文章\">点击这里查看这篇文章</a>\n\n<h1 id=\"Java内存模型\"><a href=\"#Java内存模型\" class=\"headerlink\" title=\"Java内存模型\"></a>Java内存模型</h1><p>Java内存模型(Java Memory Model，简称JMM)，本身是种<code>抽象的概念</code>，并不是像硬件架构一样真实存在的；它描述的是一组规则或规范，通过这组规范定义了程序中各个变量(包括实例字段、静态字段和构成数组对象的元素)的访问方式。<br><img src=\"/JAVA/Java-MemoryModel/1.png\" alt=\"\"></p>","more":"<ul>\n<li>主内存：共享的信息</li>\n<li>工作内存：私有信息，基本数据类型，直接分配到工作内存，引用的地址存放在工作内存，引用的对象存放在堆中</li>\n<li>工作方式：<ul>\n<li>线程修改私有数据，直接在工作空间修改</li>\n<li>线程修改共享数据，把数据复制到工作空间中去，在工作空间中修改，修改完成以后，刷新内存中的数据 </li>\n</ul>\n</li>\n</ul>\n<h1 id=\"硬件架构\"><a href=\"#硬件架构\" class=\"headerlink\" title=\"硬件架构\"></a>硬件架构</h1><p><img src=\"/JAVA/Java-MemoryModel/2.png\" alt=\"\"></p>\n<ul>\n<li><strong>多CPU</strong>：一个现代计算机通常由两个或者多个CPU。其中一些CPU还有多核。从这一点可以看出，在一个有两个或者多个CPU的现代计算机上同时运行多个线程是可能的。每个CPU在某一时刻运行一个线程是没有问题的。这意味着，如果你的Java程序是多线程的，在你的Java程序中每个CPU上一个线程可能同时（并发）执行。</li>\n<li><strong>CPU寄存器</strong>：每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。</li>\n<li><strong>高速缓存cache</strong>：由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还要慢一点。每个CPU可能有一个CPU缓存层，一些CPU还有多层缓存。在某一时刻，一个或者多个缓存行（cache lines）可能被读到缓存，一个或者多个缓存行可能再被刷新回主存。</li>\n<li><strong>内存</strong>：一个计算机还包含一个主存。所有的CPU都可以访问主存。主存通常比CPU中的缓存大得多。</li>\n</ul>\n<p>运作原理：通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。</p>\n<ul>\n<li>解决方案：<ul>\n<li>总线加锁：所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被<strong>阻塞</strong>住,那么该处理器可以独占使用共享内存。</li>\n<li>缓存上的一致性协议(MESI)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"缓存一致性协议-MESI\"><a href=\"#缓存一致性协议-MESI\" class=\"headerlink\" title=\"缓存一致性协议(MESI)\"></a>缓存一致性协议(MESI)</h2><p>多核CPU硬件架构厂商，设计之初就预测到多线程操作数据不一致的问题，因此出现了——缓存一致性协议。</p>\n<p>不同的CPU硬件生产厂商，具体的实现不一样。Intel的MESI协议最出名。<br>MESI协议文档：<a href=\"https://en.wikipedia.org/wiki/MESI_protocol\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/MESI_protocol</a></p>\n<p>在MESI协议中，每个Cache line有4个状态，可用2个bit表示，它们分别是：</p>\n<ul>\n<li>M(Modified): 这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</li>\n<li>E(Exclusive): 这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中。</li>\n<li>S(Shared): 这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中。</li>\n<li>I(Invalid): 这行数据无效。</li>\n</ul>\n<p>E状态示例如下：<br><img src=\"/JAVA/Java-MemoryModel/3.png\" alt=\"\"><br>只有Core 0访问变量x，它的Cache line状态为E(Exclusive)。</p>\n<p>S状态示例如下：<br><img src=\"/JAVA/Java-MemoryModel/4.jpeg\" alt=\"\"><br>3个Core都访问变量x，它们对应的Cache line为S(Shared)状态。</p>\n<p>M状态和I状态示例如下：<br><img src=\"/JAVA/Java-MemoryModel/5.jpeg\" alt=\"\"><br>Core 0修改了x的值之后，这个Cache line变成了M(Modified)状态，其他Core对应的Cache line变成了I(Invalid)状态</p>\n<h2 id=\"有了MESI，为什么还需要JMM？\"><a href=\"#有了MESI，为什么还需要JMM？\" class=\"headerlink\" title=\"有了MESI，为什么还需要JMM？\"></a>有了MESI，为什么还需要JMM？</h2><p>既然有了MESI协议，是不是就不需要volatile的可见性语义了？<br>当然不是，还有以下问题：</p>\n<ul>\n<li>并不是所有的硬件架构都提供了相同的一致性保证，不同的硬件厂商实现不同，JVM需要volatile统一语义。</li>\n<li>可见性问题不仅仅局限于CPU缓存内，JVM自己维护的内存模型(JMM)中也有可见性问题。使用volatile做标记，可以解决JVM层面的可见性问题。</li>\n</ul>\n<h1 id=\"Java线程与硬件处理器\"><a href=\"#Java线程与硬件处理器\" class=\"headerlink\" title=\"Java线程与硬件处理器\"></a>Java线程与硬件处理器</h1><p>Java线程的实现是基于一对一的线程模型，实际上就是通过语言级别层面程序去间接调用系统内核的线程模型，即我们在使用Java线程时，Java虚拟机内部是转而调用当前操作系统的内核线程来完成当前任务。<br><img src=\"/JAVA/Java-MemoryModel/6.png\" alt=\"\"><br>如图所示，每个线程最终都会映射到CPU中进行处理，如果CPU存在多核，那么一个CPU将可以并行执行多个线程任务。</p>\n<h1 id=\"Java内存模型与硬件内存架构的关系\"><a href=\"#Java内存模型与硬件内存架构的关系\" class=\"headerlink\" title=\"Java内存模型与硬件内存架构的关系\"></a>Java内存模型与硬件内存架构的关系</h1><p>多线程的执行最终都会映射到硬件处理器上进行执行，但Java内存模型和硬件内存架构并不完全一致。<br>对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存(线程私有数据区域)和主内存(堆内存)之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响,不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。<br><img src=\"/JAVA/Java-MemoryModel/7.png\" alt=\"\"></p>\n<h1 id=\"Java内存模型的必要性\"><a href=\"#Java内存模型的必要性\" class=\"headerlink\" title=\"Java内存模型的必要性\"></a>Java内存模型的必要性</h1><p>如下图，主内存中存在一个共享变量x，现在有A和B两线程分别对该变量x=1进行操作,A线程想要修改x的值为2，而B线程却想要读取x的值,那么B线程读取到到是1还是2呢？<br>答案：都可能，这是不确定的，这也就是所谓的线程安全问题。<br><img src=\"/JAVA/Java-MemoryModel/8.png\" alt=\"\"><br>为了解决类似上述的问题，JVM定义了一组规则，通过这组规则来决定一个线程对共享变量的写入何时对另一个线程可见。</p>\n<h1 id=\"JMM对三个特征的保证\"><a href=\"#JMM对三个特征的保证\" class=\"headerlink\" title=\"JMM对三个特征的保证\"></a>JMM对三个特征的保证</h1><h2 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h2><p>操作不可分割</p>\n<ol>\n<li>X=10 如果是私有数据具有原子性，如果是共享数据没原子性（需要先把10读到共享空间再把10写入x）  </li>\n<li>Y=x  没有原子性<ol>\n<li>把数据X读到工作空间（原子性）</li>\n<li>把X的值写到Y（原子性）</li>\n</ol>\n</li>\n<li>I++ 没有原子性<ol>\n<li>读i到工作空间</li>\n<li>+1</li>\n<li>刷新结果到内存</li>\n</ol>\n</li>\n</ol>\n<p>多个原子性的操作合并到一起没有原子性,但是可以通过Synchronized和JUC中Lock的lock来保证原子性。</p>\n<h2 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h2><p>线程只能操作自己工作空间中的数据，当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。</p>\n<ul>\n<li>Volatile:在JMM模型上实现MESI协议</li>\n<li>Synchronized:加锁</li>\n<li>JUC   Lock的lock</li>\n</ul>\n<h2 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h2><p>有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，对于单线程而言确实如此，但对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺序未必一致。</p>\n<ul>\n<li>Volatile</li>\n<li>Synchronized</li>\n<li>Happens-before原则<ul>\n<li>程序次序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</li>\n<li>锁定原则：后一次加锁必须等前一次解锁</li>\n<li>Volatile原则：volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。</li>\n<li>传递原则：A先于B ，B先于C 那么A必然先于C</li>\n<li>线程启动规则：如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见</li>\n<li>线程终止规则：假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。</li>\n<li>线程中断规则：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</li>\n<li>对象终结规则：对象的构造函数执行，结束先于finalize()方法</li>\n</ul>\n</li>\n</ul>"},{"title":"JAVA-Spring-AOP","date":"2020-03-09T07:07:00.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"# AOP\n与OOP对比，面向切面，传统的OOP开发中的代码逻辑是自上而下的，而这些过程会产生一些横切性问题，这些横切性的问题和我们的主业务逻辑关系不大，这些横切性问题不会影响到主逻辑实现的，但是会散落到代码的各个部分，难以维护。AOP是处理一些横切性问题，AOP的编程思想就是把这些问题和主业务逻辑分开，达到与主业务逻辑解耦的目的。使代码的重用性和开发效率更高。\n## AOP的应用场景\n日志记录、权限验证、效率检查、事务管理、exception\n## springAop的概念\n* 切面(Aspect)：切面是通知和切点的结合，通知和切点共同定义了切面的全部内容\n* 连接点(Join point)：目标对象中的方法。\n* 通知(Advice)：定义了切面是做什么以及何时使用。\n* 切点(Pointcut)：表示连接点的集合。（PointCut是JoinPoint的谓语，这是一个动作，主要是告诉通知连接点在哪里，切点表达式决定 JoinPoint 的数量）\n* 目标对象(Target object)：目标对象 原始对象\n* aop代理(AOP proxy)：代理对象  包含了原始对象的代码和增加后的代码的那个对象\n* 织入(Weaving)：把代理逻辑加入到目标对象上的过程\n\n## advice通知类型\n* **Before** 连接点执行之前，但是无法阻止连接点的正常执行，除非该段执行抛出异常\n* **After**  连接点正常执行之后，执行过程中正常执行返回退出，非异常退出\n* **After throwing**  执行抛出异常的时候\n* **After (finally)**  无论连接点是正常退出还是异常退出，都会执行\n* **Around advice** 围绕连接点执行，例如方法调用。这是最有用的切面方式。around通知可以在方法调用之前和之后执行自定义行为。它还负责选择是继续加入点还是通过返回自己的返回值或抛出异常来快速建议的方法执行。\n\n## springAop支持AspectJ\n### 启用@AspectJ支持\n1. 使用Java @Configuration启用@AspectJ支持，添加@EnableAspectJAutoProxy注释\n    ```java\n    @Configuration\n    @EnableAspectJAutoProxy\n    public class AppConfig {\n    \n    }\n    ```\n2. 使用XML配置启用@AspectJ支持\n   ```java\n    <aop:aspectj-autoproxy/>\n   ```\n### 声明一个Aspect\n```java\n@Component\n@Aspect\npublic class UserAspect {\n}\n```\n### 声明明一个pointCut\n切入点表达式由@Pointcut注释表示。切入点声明由两部分组成:一个签名包含名称和任何参数，以及一个切入点表达式，该表达式确定我们对哪个方法执行感兴趣。\n```java\n@Pointcut(\"execution(* transfer(..))\")// 切入点表达式\nprivate void anyOldTransfer() {}// 切入点签名\n```\n\n\n### 声明一个Advice通知\n```java\n/**\n * 申明Aspect，并且交给spring容器管理\n */\n@Component\n@Aspect\npublic class UserAspect {\n    /**\n     * 申明切入点，匹配UserDao所有方法调用\n     * execution匹配方法执行连接点\n     * within:将匹配限制为特定类型中的连接点\n     * args：参数\n     * target：目标对象\n     * this：代理对象\n     */\n    @Pointcut(\"execution(* com.yao.dao.UserDao.*(..))\")\n    public void pintCut(){\n        System.out.println(\"point cut\");\n    }\n    /**\n     * 申明before通知,在pintCut切入点前执行\n     * 通知与切入点表达式相关联，\n     * 并在切入点匹配的方法执行之前、之后或前后运行。\n     * 切入点表达式可以是对指定切入点的简单引用，也可以是在适当位置声明的切入点表达式。\n     */\n    @Before(\"com.yao.aop.UserAspect.pintCut()\")\n    public void beforeAdvice(){\n        System.out.println(\"before\");\n    }\n}\n```\n\n\n\n\n## 连接点joinPoint的意义\n1. execution：用于匹配方法执行 join points连接点，最小粒度方法，在aop中主要使用。\n   > execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)\n   > 这里问号表示当前项可以有也可以没有，其中各项的语义如下\n   > **modifiers-pattern**：方法的可见性，如public，protected；\n   > **ret-type-pattern**：方法的返回值类型，如int，void等；\n   > **declaring-type-pattern**：方法所在类的全路径名，如com.spring.Aspect；\n   > **name-pattern**：方法名类型，如buisinessService()；\n   > **param-pattern**：方法的参数类型，如java.lang.String；\n   > **throws-pattern**：方法抛出的异常类型，如java.lang.Exception；\n   \n   example:\n   ```java\n       @Pointcut(\"execution(* com.chenss.dao.*.*(..))\")//匹配com.chenss.dao包下的任意接口和类的任意方法\n       @Pointcut(\"execution(public * com.chenss.dao.*.*(..))\")//匹配com.chenss.dao包下的任意接口和类的public方法\n       @Pointcut(\"execution(public * com.chenss.dao.*.*())\")//匹配com.chenss.dao包下的任意接口和类的public 无方法参数的方法\n       @Pointcut(\"execution(* com.chenss.dao.*.*(java.lang.String, ..))\")//匹配com.chenss.dao包下的任意接口和类的第一个参数为String类型的方法\n       @Pointcut(\"execution(* com.chenss.dao.*.*(java.lang.String))\")//匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法\n       @Pointcut(\"execution(* com.chenss.dao.*.*(java.lang.String))\")//匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法\n       @Pointcut(\"execution(public * *(..))\")//匹配任意的public方法\n       @Pointcut(\"execution(* te*(..))\")//匹配任意的以te开头的方法\n       @Pointcut(\"execution(* com.chenss.dao.IndexDao.*(..))\")//匹配com.chenss.dao.IndexDao接口中任意的方法\n       @Pointcut(\"execution(* com.chenss.dao..*.*(..))\")//匹配com.chenss.dao包及其子包中任意的方法\n   ```\n   由于Spring切面粒度最小是达到方法级别，而execution表达式可以用于明确指定方法返回类型，类名，方法名和参数名等与方法相关的信息，并且在Spring中，大部分需要使用AOP的业务场景也只需要达到方法级别即可，因而execution表达式的使用是最为广泛的\n2. within:表达式的最小粒度为类\n   ```java\n       @Pointcut(\"within(com.chenss.dao.*)\")//匹配com.chenss.dao包中的任意方法\n       @Pointcut(\"within(com.chenss.dao..*)\")//匹配com.chenss.dao包及其子包中的任意方法\n   ```\n   within与execution相比，粒度更大，仅能实现到包和接口、类级别。而execution可以精确到方法的返回值，参数个数、修饰符、参数类型等\n3. args:表达式的作用是匹配指定参数类型和指定参数数量的方法,与包名和类名无关\n   ```java\n       @Pointcut(\"args(java.io.Serializable)\")//匹配运行时传递的参数类型为指定类型的、且参数个数和顺序匹配\n       @Pointcut(\"@args(com.chenss.anno.Chenss)\")//接受一个参数，并且传递的参数的运行时类型具有@Classified\n   ```\n   args同execution不同的地方在于,args匹配的是运行时传递给方法的参数类型,execution(* *(java.io.Serializable))匹配的是方法在声明时指定的方法参数类型。\n4. this:JDK代理时，指向接口和代理类proxy，cglib代理时 指向接口和子类(不使用proxy)\n5. target:指向接口和子类\n   ```java\n        /**\n         * 此处需要注意的是，如果配置设置proxyTargetClass=false，或默认为false，则是用JDK代理，否则使用的是CGLIB代理\n         * JDK代理的实现方式是基于接口实现，代理类继承Proxy，实现接口。\n         * 而CGLIB继承被代理的类来实现。\n         * 所以使用target会保证目标不变，关联对象不会受到这个设置的影响。\n         * 但是使用this对象时，会根据该选项的设置，判断是否能找到对象。\n         */\n        @Pointcut(\"target(com.chenss.dao.IndexDaoImpl)\")//目标对象，也就是被代理的对象。限制目标对象为com.chenss.dao.IndexDaoImpl类\n        @Pointcut(\"this(com.chenss.dao.IndexDaoImpl)\")//当前对象，也就是代理对象，代理对象时通过代理目标对象的方式获取新的对象，与原值并非一个\n        @Pointcut(\"@target(com.chenss.anno.Chenss)\")//具有@Chenss的目标对象中的任意方法\n        @Pointcut(\"@within(com.chenss.anno.Chenss)\")//等同于@targ\n   ```\n   \n   \n\n\n","source":"_posts/Java-SpringAOP.md","raw":"---\ntitle: JAVA-Spring-AOP\ndate: 2020-03-09 15:07:00\ntags:\n    - JAVA\n    - Spring\n    - 学习笔记\ncategories: JAVA\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n# AOP\n与OOP对比，面向切面，传统的OOP开发中的代码逻辑是自上而下的，而这些过程会产生一些横切性问题，这些横切性的问题和我们的主业务逻辑关系不大，这些横切性问题不会影响到主逻辑实现的，但是会散落到代码的各个部分，难以维护。AOP是处理一些横切性问题，AOP的编程思想就是把这些问题和主业务逻辑分开，达到与主业务逻辑解耦的目的。使代码的重用性和开发效率更高。\n## AOP的应用场景\n日志记录、权限验证、效率检查、事务管理、exception\n## springAop的概念\n* 切面(Aspect)：切面是通知和切点的结合，通知和切点共同定义了切面的全部内容\n* 连接点(Join point)：目标对象中的方法。\n* 通知(Advice)：定义了切面是做什么以及何时使用。\n* 切点(Pointcut)：表示连接点的集合。（PointCut是JoinPoint的谓语，这是一个动作，主要是告诉通知连接点在哪里，切点表达式决定 JoinPoint 的数量）\n* 目标对象(Target object)：目标对象 原始对象\n* aop代理(AOP proxy)：代理对象  包含了原始对象的代码和增加后的代码的那个对象\n* 织入(Weaving)：把代理逻辑加入到目标对象上的过程\n\n## advice通知类型\n* **Before** 连接点执行之前，但是无法阻止连接点的正常执行，除非该段执行抛出异常\n* **After**  连接点正常执行之后，执行过程中正常执行返回退出，非异常退出\n* **After throwing**  执行抛出异常的时候\n* **After (finally)**  无论连接点是正常退出还是异常退出，都会执行\n* **Around advice** 围绕连接点执行，例如方法调用。这是最有用的切面方式。around通知可以在方法调用之前和之后执行自定义行为。它还负责选择是继续加入点还是通过返回自己的返回值或抛出异常来快速建议的方法执行。\n\n## springAop支持AspectJ\n### 启用@AspectJ支持\n1. 使用Java @Configuration启用@AspectJ支持，添加@EnableAspectJAutoProxy注释\n    ```java\n    @Configuration\n    @EnableAspectJAutoProxy\n    public class AppConfig {\n    \n    }\n    ```\n2. 使用XML配置启用@AspectJ支持\n   ```java\n    <aop:aspectj-autoproxy/>\n   ```\n### 声明一个Aspect\n```java\n@Component\n@Aspect\npublic class UserAspect {\n}\n```\n### 声明明一个pointCut\n切入点表达式由@Pointcut注释表示。切入点声明由两部分组成:一个签名包含名称和任何参数，以及一个切入点表达式，该表达式确定我们对哪个方法执行感兴趣。\n```java\n@Pointcut(\"execution(* transfer(..))\")// 切入点表达式\nprivate void anyOldTransfer() {}// 切入点签名\n```\n\n\n### 声明一个Advice通知\n```java\n/**\n * 申明Aspect，并且交给spring容器管理\n */\n@Component\n@Aspect\npublic class UserAspect {\n    /**\n     * 申明切入点，匹配UserDao所有方法调用\n     * execution匹配方法执行连接点\n     * within:将匹配限制为特定类型中的连接点\n     * args：参数\n     * target：目标对象\n     * this：代理对象\n     */\n    @Pointcut(\"execution(* com.yao.dao.UserDao.*(..))\")\n    public void pintCut(){\n        System.out.println(\"point cut\");\n    }\n    /**\n     * 申明before通知,在pintCut切入点前执行\n     * 通知与切入点表达式相关联，\n     * 并在切入点匹配的方法执行之前、之后或前后运行。\n     * 切入点表达式可以是对指定切入点的简单引用，也可以是在适当位置声明的切入点表达式。\n     */\n    @Before(\"com.yao.aop.UserAspect.pintCut()\")\n    public void beforeAdvice(){\n        System.out.println(\"before\");\n    }\n}\n```\n\n\n\n\n## 连接点joinPoint的意义\n1. execution：用于匹配方法执行 join points连接点，最小粒度方法，在aop中主要使用。\n   > execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)\n   > 这里问号表示当前项可以有也可以没有，其中各项的语义如下\n   > **modifiers-pattern**：方法的可见性，如public，protected；\n   > **ret-type-pattern**：方法的返回值类型，如int，void等；\n   > **declaring-type-pattern**：方法所在类的全路径名，如com.spring.Aspect；\n   > **name-pattern**：方法名类型，如buisinessService()；\n   > **param-pattern**：方法的参数类型，如java.lang.String；\n   > **throws-pattern**：方法抛出的异常类型，如java.lang.Exception；\n   \n   example:\n   ```java\n       @Pointcut(\"execution(* com.chenss.dao.*.*(..))\")//匹配com.chenss.dao包下的任意接口和类的任意方法\n       @Pointcut(\"execution(public * com.chenss.dao.*.*(..))\")//匹配com.chenss.dao包下的任意接口和类的public方法\n       @Pointcut(\"execution(public * com.chenss.dao.*.*())\")//匹配com.chenss.dao包下的任意接口和类的public 无方法参数的方法\n       @Pointcut(\"execution(* com.chenss.dao.*.*(java.lang.String, ..))\")//匹配com.chenss.dao包下的任意接口和类的第一个参数为String类型的方法\n       @Pointcut(\"execution(* com.chenss.dao.*.*(java.lang.String))\")//匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法\n       @Pointcut(\"execution(* com.chenss.dao.*.*(java.lang.String))\")//匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法\n       @Pointcut(\"execution(public * *(..))\")//匹配任意的public方法\n       @Pointcut(\"execution(* te*(..))\")//匹配任意的以te开头的方法\n       @Pointcut(\"execution(* com.chenss.dao.IndexDao.*(..))\")//匹配com.chenss.dao.IndexDao接口中任意的方法\n       @Pointcut(\"execution(* com.chenss.dao..*.*(..))\")//匹配com.chenss.dao包及其子包中任意的方法\n   ```\n   由于Spring切面粒度最小是达到方法级别，而execution表达式可以用于明确指定方法返回类型，类名，方法名和参数名等与方法相关的信息，并且在Spring中，大部分需要使用AOP的业务场景也只需要达到方法级别即可，因而execution表达式的使用是最为广泛的\n2. within:表达式的最小粒度为类\n   ```java\n       @Pointcut(\"within(com.chenss.dao.*)\")//匹配com.chenss.dao包中的任意方法\n       @Pointcut(\"within(com.chenss.dao..*)\")//匹配com.chenss.dao包及其子包中的任意方法\n   ```\n   within与execution相比，粒度更大，仅能实现到包和接口、类级别。而execution可以精确到方法的返回值，参数个数、修饰符、参数类型等\n3. args:表达式的作用是匹配指定参数类型和指定参数数量的方法,与包名和类名无关\n   ```java\n       @Pointcut(\"args(java.io.Serializable)\")//匹配运行时传递的参数类型为指定类型的、且参数个数和顺序匹配\n       @Pointcut(\"@args(com.chenss.anno.Chenss)\")//接受一个参数，并且传递的参数的运行时类型具有@Classified\n   ```\n   args同execution不同的地方在于,args匹配的是运行时传递给方法的参数类型,execution(* *(java.io.Serializable))匹配的是方法在声明时指定的方法参数类型。\n4. this:JDK代理时，指向接口和代理类proxy，cglib代理时 指向接口和子类(不使用proxy)\n5. target:指向接口和子类\n   ```java\n        /**\n         * 此处需要注意的是，如果配置设置proxyTargetClass=false，或默认为false，则是用JDK代理，否则使用的是CGLIB代理\n         * JDK代理的实现方式是基于接口实现，代理类继承Proxy，实现接口。\n         * 而CGLIB继承被代理的类来实现。\n         * 所以使用target会保证目标不变，关联对象不会受到这个设置的影响。\n         * 但是使用this对象时，会根据该选项的设置，判断是否能找到对象。\n         */\n        @Pointcut(\"target(com.chenss.dao.IndexDaoImpl)\")//目标对象，也就是被代理的对象。限制目标对象为com.chenss.dao.IndexDaoImpl类\n        @Pointcut(\"this(com.chenss.dao.IndexDaoImpl)\")//当前对象，也就是代理对象，代理对象时通过代理目标对象的方式获取新的对象，与原值并非一个\n        @Pointcut(\"@target(com.chenss.anno.Chenss)\")//具有@Chenss的目标对象中的任意方法\n        @Pointcut(\"@within(com.chenss.anno.Chenss)\")//等同于@targ\n   ```\n   \n   \n\n\n","slug":"Java-SpringAOP","published":1,"updated":"2020-03-13T08:17:01.541Z","layout":"post","photos":[],"link":"","_id":"ck8fb4abc001pk2o5vizlbue7","content":"<h1 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h1><p>与OOP对比，面向切面，传统的OOP开发中的代码逻辑是自上而下的，而这些过程会产生一些横切性问题，这些横切性的问题和我们的主业务逻辑关系不大，这些横切性问题不会影响到主逻辑实现的，但是会散落到代码的各个部分，难以维护。AOP是处理一些横切性问题，AOP的编程思想就是把这些问题和主业务逻辑分开，达到与主业务逻辑解耦的目的。使代码的重用性和开发效率更高。</p>\n<h2 id=\"AOP的应用场景\"><a href=\"#AOP的应用场景\" class=\"headerlink\" title=\"AOP的应用场景\"></a>AOP的应用场景</h2><p>日志记录、权限验证、效率检查、事务管理、exception</p>\n<h2 id=\"springAop的概念\"><a href=\"#springAop的概念\" class=\"headerlink\" title=\"springAop的概念\"></a>springAop的概念</h2><ul>\n<li>切面(Aspect)：切面是通知和切点的结合，通知和切点共同定义了切面的全部内容</li>\n<li>连接点(Join point)：目标对象中的方法。</li>\n<li>通知(Advice)：定义了切面是做什么以及何时使用。</li>\n<li>切点(Pointcut)：表示连接点的集合。（PointCut是JoinPoint的谓语，这是一个动作，主要是告诉通知连接点在哪里，切点表达式决定 JoinPoint 的数量）</li>\n<li>目标对象(Target object)：目标对象 原始对象</li>\n<li>aop代理(AOP proxy)：代理对象  包含了原始对象的代码和增加后的代码的那个对象</li>\n<li>织入(Weaving)：把代理逻辑加入到目标对象上的过程</li>\n</ul>\n<h2 id=\"advice通知类型\"><a href=\"#advice通知类型\" class=\"headerlink\" title=\"advice通知类型\"></a>advice通知类型</h2><ul>\n<li><strong>Before</strong> 连接点执行之前，但是无法阻止连接点的正常执行，除非该段执行抛出异常</li>\n<li><strong>After</strong>  连接点正常执行之后，执行过程中正常执行返回退出，非异常退出</li>\n<li><strong>After throwing</strong>  执行抛出异常的时候</li>\n<li><strong>After (finally)</strong>  无论连接点是正常退出还是异常退出，都会执行</li>\n<li><strong>Around advice</strong> 围绕连接点执行，例如方法调用。这是最有用的切面方式。around通知可以在方法调用之前和之后执行自定义行为。它还负责选择是继续加入点还是通过返回自己的返回值或抛出异常来快速建议的方法执行。</li>\n</ul>\n<h2 id=\"springAop支持AspectJ\"><a href=\"#springAop支持AspectJ\" class=\"headerlink\" title=\"springAop支持AspectJ\"></a>springAop支持AspectJ</h2><h3 id=\"启用-AspectJ支持\"><a href=\"#启用-AspectJ支持\" class=\"headerlink\" title=\"启用@AspectJ支持\"></a>启用@AspectJ支持</h3><ol>\n<li><p>使用Java @Configuration启用@AspectJ支持，添加@EnableAspectJAutoProxy注释</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用XML配置启用@AspectJ支持</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:aspectj-autoproxy/&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"声明一个Aspect\"><a href=\"#声明一个Aspect\" class=\"headerlink\" title=\"声明一个Aspect\"></a>声明一个Aspect</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserAspect</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"声明明一个pointCut\"><a href=\"#声明明一个pointCut\" class=\"headerlink\" title=\"声明明一个pointCut\"></a>声明明一个pointCut</h3><p>切入点表达式由@Pointcut注释表示。切入点声明由两部分组成:一个签名包含名称和任何参数，以及一个切入点表达式，该表达式确定我们对哪个方法执行感兴趣。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* transfer(..))\"</span>)<span class=\"comment\">// 切入点表达式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">anyOldTransfer</span><span class=\"params\">()</span> </span>&#123;&#125;<span class=\"comment\">// 切入点签名</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"声明一个Advice通知\"><a href=\"#声明一个Advice通知\" class=\"headerlink\" title=\"声明一个Advice通知\"></a>声明一个Advice通知</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 申明Aspect，并且交给spring容器管理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserAspect</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 申明切入点，匹配UserDao所有方法调用</span></span><br><span class=\"line\"><span class=\"comment\">     * execution匹配方法执行连接点</span></span><br><span class=\"line\"><span class=\"comment\">     * within:将匹配限制为特定类型中的连接点</span></span><br><span class=\"line\"><span class=\"comment\">     * args：参数</span></span><br><span class=\"line\"><span class=\"comment\">     * target：目标对象</span></span><br><span class=\"line\"><span class=\"comment\">     * this：代理对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.yao.dao.UserDao.*(..))\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pintCut</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"point cut\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 申明before通知,在pintCut切入点前执行</span></span><br><span class=\"line\"><span class=\"comment\">     * 通知与切入点表达式相关联，</span></span><br><span class=\"line\"><span class=\"comment\">     * 并在切入点匹配的方法执行之前、之后或前后运行。</span></span><br><span class=\"line\"><span class=\"comment\">     * 切入点表达式可以是对指定切入点的简单引用，也可以是在适当位置声明的切入点表达式。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(<span class=\"string\">\"com.yao.aop.UserAspect.pintCut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">beforeAdvice</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"before\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"连接点joinPoint的意义\"><a href=\"#连接点joinPoint的意义\" class=\"headerlink\" title=\"连接点joinPoint的意义\"></a>连接点joinPoint的意义</h2><ol>\n<li><p>execution：用于匹配方法执行 join points连接点，最小粒度方法，在aop中主要使用。</p>\n<blockquote>\n<p>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)<br>这里问号表示当前项可以有也可以没有，其中各项的语义如下<br><strong>modifiers-pattern</strong>：方法的可见性，如public，protected；<br><strong>ret-type-pattern</strong>：方法的返回值类型，如int，void等；<br><strong>declaring-type-pattern</strong>：方法所在类的全路径名，如com.spring.Aspect；<br><strong>name-pattern</strong>：方法名类型，如buisinessService()；<br><strong>param-pattern</strong>：方法的参数类型，如java.lang.String；<br><strong>throws-pattern</strong>：方法抛出的异常类型，如java.lang.Exception；</p>\n</blockquote>\n<p>example:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.chenss.dao.*.*(..))\"</span>)<span class=\"comment\">//匹配com.chenss.dao包下的任意接口和类的任意方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(public * com.chenss.dao.*.*(..))\"</span>)<span class=\"comment\">//匹配com.chenss.dao包下的任意接口和类的public方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(public * com.chenss.dao.*.*())\"</span>)<span class=\"comment\">//匹配com.chenss.dao包下的任意接口和类的public 无方法参数的方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.chenss.dao.*.*(java.lang.String, ..))\"</span>)<span class=\"comment\">//匹配com.chenss.dao包下的任意接口和类的第一个参数为String类型的方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.chenss.dao.*.*(java.lang.String))\"</span>)<span class=\"comment\">//匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.chenss.dao.*.*(java.lang.String))\"</span>)<span class=\"comment\">//匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(public * *(..))\"</span>)<span class=\"comment\">//匹配任意的public方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* te*(..))\"</span>)<span class=\"comment\">//匹配任意的以te开头的方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.chenss.dao.IndexDao.*(..))\"</span>)<span class=\"comment\">//匹配com.chenss.dao.IndexDao接口中任意的方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.chenss.dao..*.*(..))\"</span>)<span class=\"comment\">//匹配com.chenss.dao包及其子包中任意的方法</span></span><br></pre></td></tr></table></figure>\n\n<p>由于Spring切面粒度最小是达到方法级别，而execution表达式可以用于明确指定方法返回类型，类名，方法名和参数名等与方法相关的信息，并且在Spring中，大部分需要使用AOP的业务场景也只需要达到方法级别即可，因而execution表达式的使用是最为广泛的</p>\n</li>\n<li><p>within:表达式的最小粒度为类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"within(com.chenss.dao.*)\"</span>)<span class=\"comment\">//匹配com.chenss.dao包中的任意方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"within(com.chenss.dao..*)\"</span>)<span class=\"comment\">//匹配com.chenss.dao包及其子包中的任意方法</span></span><br></pre></td></tr></table></figure>\n\n<p>within与execution相比，粒度更大，仅能实现到包和接口、类级别。而execution可以精确到方法的返回值，参数个数、修饰符、参数类型等</p>\n</li>\n<li><p>args:表达式的作用是匹配指定参数类型和指定参数数量的方法,与包名和类名无关</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"args(java.io.Serializable)\"</span>)<span class=\"comment\">//匹配运行时传递的参数类型为指定类型的、且参数个数和顺序匹配</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"@args(com.chenss.anno.Chenss)\"</span>)<span class=\"comment\">//接受一个参数，并且传递的参数的运行时类型具有@Classified</span></span><br></pre></td></tr></table></figure>\n\n<p>args同execution不同的地方在于,args匹配的是运行时传递给方法的参数类型,execution(* *(java.io.Serializable))匹配的是方法在声明时指定的方法参数类型。</p>\n</li>\n<li><p>this:JDK代理时，指向接口和代理类proxy，cglib代理时 指向接口和子类(不使用proxy)</p>\n</li>\n<li><p>target:指向接口和子类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 此处需要注意的是，如果配置设置proxyTargetClass=false，或默认为false，则是用JDK代理，否则使用的是CGLIB代理</span></span><br><span class=\"line\"><span class=\"comment\"> * JDK代理的实现方式是基于接口实现，代理类继承Proxy，实现接口。</span></span><br><span class=\"line\"><span class=\"comment\"> * 而CGLIB继承被代理的类来实现。</span></span><br><span class=\"line\"><span class=\"comment\"> * 所以使用target会保证目标不变，关联对象不会受到这个设置的影响。</span></span><br><span class=\"line\"><span class=\"comment\"> * 但是使用this对象时，会根据该选项的设置，判断是否能找到对象。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"target(com.chenss.dao.IndexDaoImpl)\"</span>)<span class=\"comment\">//目标对象，也就是被代理的对象。限制目标对象为com.chenss.dao.IndexDaoImpl类</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"this(com.chenss.dao.IndexDaoImpl)\"</span>)<span class=\"comment\">//当前对象，也就是代理对象，代理对象时通过代理目标对象的方式获取新的对象，与原值并非一个</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"@target(com.chenss.anno.Chenss)\"</span>)<span class=\"comment\">//具有@Chenss的目标对象中的任意方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"@within(com.chenss.anno.Chenss)\"</span>)<span class=\"comment\">//等同于@targ</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h1><p>与OOP对比，面向切面，传统的OOP开发中的代码逻辑是自上而下的，而这些过程会产生一些横切性问题，这些横切性的问题和我们的主业务逻辑关系不大，这些横切性问题不会影响到主逻辑实现的，但是会散落到代码的各个部分，难以维护。AOP是处理一些横切性问题，AOP的编程思想就是把这些问题和主业务逻辑分开，达到与主业务逻辑解耦的目的。使代码的重用性和开发效率更高。</p>\n<h2 id=\"AOP的应用场景\"><a href=\"#AOP的应用场景\" class=\"headerlink\" title=\"AOP的应用场景\"></a>AOP的应用场景</h2><p>日志记录、权限验证、效率检查、事务管理、exception</p>\n<h2 id=\"springAop的概念\"><a href=\"#springAop的概念\" class=\"headerlink\" title=\"springAop的概念\"></a>springAop的概念</h2><ul>\n<li>切面(Aspect)：切面是通知和切点的结合，通知和切点共同定义了切面的全部内容</li>\n<li>连接点(Join point)：目标对象中的方法。</li>\n<li>通知(Advice)：定义了切面是做什么以及何时使用。</li>\n<li>切点(Pointcut)：表示连接点的集合。（PointCut是JoinPoint的谓语，这是一个动作，主要是告诉通知连接点在哪里，切点表达式决定 JoinPoint 的数量）</li>\n<li>目标对象(Target object)：目标对象 原始对象</li>\n<li>aop代理(AOP proxy)：代理对象  包含了原始对象的代码和增加后的代码的那个对象</li>\n<li>织入(Weaving)：把代理逻辑加入到目标对象上的过程</li>\n</ul>\n<h2 id=\"advice通知类型\"><a href=\"#advice通知类型\" class=\"headerlink\" title=\"advice通知类型\"></a>advice通知类型</h2><ul>\n<li><strong>Before</strong> 连接点执行之前，但是无法阻止连接点的正常执行，除非该段执行抛出异常</li>\n<li><strong>After</strong>  连接点正常执行之后，执行过程中正常执行返回退出，非异常退出</li>\n<li><strong>After throwing</strong>  执行抛出异常的时候</li>\n<li><strong>After (finally)</strong>  无论连接点是正常退出还是异常退出，都会执行</li>\n<li><strong>Around advice</strong> 围绕连接点执行，例如方法调用。这是最有用的切面方式。around通知可以在方法调用之前和之后执行自定义行为。它还负责选择是继续加入点还是通过返回自己的返回值或抛出异常来快速建议的方法执行。</li>\n</ul>\n<h2 id=\"springAop支持AspectJ\"><a href=\"#springAop支持AspectJ\" class=\"headerlink\" title=\"springAop支持AspectJ\"></a>springAop支持AspectJ</h2><h3 id=\"启用-AspectJ支持\"><a href=\"#启用-AspectJ支持\" class=\"headerlink\" title=\"启用@AspectJ支持\"></a>启用@AspectJ支持</h3><ol>\n<li><p>使用Java @Configuration启用@AspectJ支持，添加@EnableAspectJAutoProxy注释</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用XML配置启用@AspectJ支持</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:aspectj-autoproxy/&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"声明一个Aspect\"><a href=\"#声明一个Aspect\" class=\"headerlink\" title=\"声明一个Aspect\"></a>声明一个Aspect</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserAspect</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"声明明一个pointCut\"><a href=\"#声明明一个pointCut\" class=\"headerlink\" title=\"声明明一个pointCut\"></a>声明明一个pointCut</h3><p>切入点表达式由@Pointcut注释表示。切入点声明由两部分组成:一个签名包含名称和任何参数，以及一个切入点表达式，该表达式确定我们对哪个方法执行感兴趣。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* transfer(..))\"</span>)<span class=\"comment\">// 切入点表达式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">anyOldTransfer</span><span class=\"params\">()</span> </span>&#123;&#125;<span class=\"comment\">// 切入点签名</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"声明一个Advice通知\"><a href=\"#声明一个Advice通知\" class=\"headerlink\" title=\"声明一个Advice通知\"></a>声明一个Advice通知</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 申明Aspect，并且交给spring容器管理</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserAspect</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 申明切入点，匹配UserDao所有方法调用</span></span><br><span class=\"line\"><span class=\"comment\">     * execution匹配方法执行连接点</span></span><br><span class=\"line\"><span class=\"comment\">     * within:将匹配限制为特定类型中的连接点</span></span><br><span class=\"line\"><span class=\"comment\">     * args：参数</span></span><br><span class=\"line\"><span class=\"comment\">     * target：目标对象</span></span><br><span class=\"line\"><span class=\"comment\">     * this：代理对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.yao.dao.UserDao.*(..))\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pintCut</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"point cut\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 申明before通知,在pintCut切入点前执行</span></span><br><span class=\"line\"><span class=\"comment\">     * 通知与切入点表达式相关联，</span></span><br><span class=\"line\"><span class=\"comment\">     * 并在切入点匹配的方法执行之前、之后或前后运行。</span></span><br><span class=\"line\"><span class=\"comment\">     * 切入点表达式可以是对指定切入点的简单引用，也可以是在适当位置声明的切入点表达式。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(<span class=\"string\">\"com.yao.aop.UserAspect.pintCut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">beforeAdvice</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"before\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"连接点joinPoint的意义\"><a href=\"#连接点joinPoint的意义\" class=\"headerlink\" title=\"连接点joinPoint的意义\"></a>连接点joinPoint的意义</h2><ol>\n<li><p>execution：用于匹配方法执行 join points连接点，最小粒度方法，在aop中主要使用。</p>\n<blockquote>\n<p>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)<br>这里问号表示当前项可以有也可以没有，其中各项的语义如下<br><strong>modifiers-pattern</strong>：方法的可见性，如public，protected；<br><strong>ret-type-pattern</strong>：方法的返回值类型，如int，void等；<br><strong>declaring-type-pattern</strong>：方法所在类的全路径名，如com.spring.Aspect；<br><strong>name-pattern</strong>：方法名类型，如buisinessService()；<br><strong>param-pattern</strong>：方法的参数类型，如java.lang.String；<br><strong>throws-pattern</strong>：方法抛出的异常类型，如java.lang.Exception；</p>\n</blockquote>\n<p>example:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.chenss.dao.*.*(..))\"</span>)<span class=\"comment\">//匹配com.chenss.dao包下的任意接口和类的任意方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(public * com.chenss.dao.*.*(..))\"</span>)<span class=\"comment\">//匹配com.chenss.dao包下的任意接口和类的public方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(public * com.chenss.dao.*.*())\"</span>)<span class=\"comment\">//匹配com.chenss.dao包下的任意接口和类的public 无方法参数的方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.chenss.dao.*.*(java.lang.String, ..))\"</span>)<span class=\"comment\">//匹配com.chenss.dao包下的任意接口和类的第一个参数为String类型的方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.chenss.dao.*.*(java.lang.String))\"</span>)<span class=\"comment\">//匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.chenss.dao.*.*(java.lang.String))\"</span>)<span class=\"comment\">//匹配com.chenss.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(public * *(..))\"</span>)<span class=\"comment\">//匹配任意的public方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* te*(..))\"</span>)<span class=\"comment\">//匹配任意的以te开头的方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.chenss.dao.IndexDao.*(..))\"</span>)<span class=\"comment\">//匹配com.chenss.dao.IndexDao接口中任意的方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.chenss.dao..*.*(..))\"</span>)<span class=\"comment\">//匹配com.chenss.dao包及其子包中任意的方法</span></span><br></pre></td></tr></table></figure>\n\n<p>由于Spring切面粒度最小是达到方法级别，而execution表达式可以用于明确指定方法返回类型，类名，方法名和参数名等与方法相关的信息，并且在Spring中，大部分需要使用AOP的业务场景也只需要达到方法级别即可，因而execution表达式的使用是最为广泛的</p>\n</li>\n<li><p>within:表达式的最小粒度为类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"within(com.chenss.dao.*)\"</span>)<span class=\"comment\">//匹配com.chenss.dao包中的任意方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"within(com.chenss.dao..*)\"</span>)<span class=\"comment\">//匹配com.chenss.dao包及其子包中的任意方法</span></span><br></pre></td></tr></table></figure>\n\n<p>within与execution相比，粒度更大，仅能实现到包和接口、类级别。而execution可以精确到方法的返回值，参数个数、修饰符、参数类型等</p>\n</li>\n<li><p>args:表达式的作用是匹配指定参数类型和指定参数数量的方法,与包名和类名无关</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"args(java.io.Serializable)\"</span>)<span class=\"comment\">//匹配运行时传递的参数类型为指定类型的、且参数个数和顺序匹配</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"@args(com.chenss.anno.Chenss)\"</span>)<span class=\"comment\">//接受一个参数，并且传递的参数的运行时类型具有@Classified</span></span><br></pre></td></tr></table></figure>\n\n<p>args同execution不同的地方在于,args匹配的是运行时传递给方法的参数类型,execution(* *(java.io.Serializable))匹配的是方法在声明时指定的方法参数类型。</p>\n</li>\n<li><p>this:JDK代理时，指向接口和代理类proxy，cglib代理时 指向接口和子类(不使用proxy)</p>\n</li>\n<li><p>target:指向接口和子类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 此处需要注意的是，如果配置设置proxyTargetClass=false，或默认为false，则是用JDK代理，否则使用的是CGLIB代理</span></span><br><span class=\"line\"><span class=\"comment\"> * JDK代理的实现方式是基于接口实现，代理类继承Proxy，实现接口。</span></span><br><span class=\"line\"><span class=\"comment\"> * 而CGLIB继承被代理的类来实现。</span></span><br><span class=\"line\"><span class=\"comment\"> * 所以使用target会保证目标不变，关联对象不会受到这个设置的影响。</span></span><br><span class=\"line\"><span class=\"comment\"> * 但是使用this对象时，会根据该选项的设置，判断是否能找到对象。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"target(com.chenss.dao.IndexDaoImpl)\"</span>)<span class=\"comment\">//目标对象，也就是被代理的对象。限制目标对象为com.chenss.dao.IndexDaoImpl类</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"this(com.chenss.dao.IndexDaoImpl)\"</span>)<span class=\"comment\">//当前对象，也就是代理对象，代理对象时通过代理目标对象的方式获取新的对象，与原值并非一个</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"@target(com.chenss.anno.Chenss)\"</span>)<span class=\"comment\">//具有@Chenss的目标对象中的任意方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"@within(com.chenss.anno.Chenss)\"</span>)<span class=\"comment\">//等同于@targ</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n</li>\n</ol>\n"},{"title":"JAVA-Synchronized","date":"2020-01-19T07:17:00.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"# 概念\n利用锁的机制来实现同步的。\n锁机制有如下两种特性：\n**互斥性**：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的**原子性**。\n**可见性**：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。\n\n# 用法\n## 同步方法\n### 同步非静态方法\n```java\nPublic synchronized void methodName(){\n\n}\n```\n### 同步静态方法\n```java\nPublic synchronized static void methodName(){\n\n}\n```\n## 同步代码块\n### 获取对象锁\n```java\nsynchronized(this|object) {}\n```\n用来修饰非静态方法，\n在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，通常会被称为“内置锁”或“对象锁”。类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰\n### 获取类锁\n```java\nsynchronized(类.class) {}\n```\n用来修饰静态方法\n在 Java 中，针对每个类也有一个锁，可以称为“类锁”，类锁实际上是通过对象锁实现的，即类的 Class 对象锁。每个类只有一个 Class 对象，所以每个类只有一个类锁。\n\n## monitor \nMonitor其实是一种同步工具，也可以说是一种同步机制，它通常被描述为一个对象,也常被翻译为“监视器\\管程”,每个对象都会有一个 monitor\n* 某一线程占有一个对象的时候，先看该对象的 monitor 的计数器是不是0，如果是0表示这个对象还没有线程占有，这个时候线程占有这个对象，并且对这个对象的monitor+1；如果不为0，表示这个对象已经被其他线程占有，这个线程等待。当线程释放占有权的时候，monitor-1；\n* 同一线程可以对同一对象进行多次加锁，+1，+1，体现了重入性\n\n# 原理分析\n## 线程堆栈分析(互斥)\n### Jconsole\nJConsole 是一个内置 Java 性能分析器\nMac下位置：/Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/bin/jconsol\n\n测试代码：\n```java\npublic class SynchronizedDemo01 {\n\tpublic void test(){\n\t\tsynchronized (SynchronizedDemo01.class){\n\t\t\ttry {\n\t\t\t\tTimeUnit.MINUTES.sleep(2);\n\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \"is running\");\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSynchronizedDemo01 demo01 = new SynchronizedDemo01();\n\t\tfor (int i = 0 ; i < 5 ; i ++){\n\t\t\tnew Thread(demo01::test).start();\n\t\t}\n\t}\n}\n```\n\n![](Java-Synchronized/1.png)\n![](Java-Synchronized/2.png)\n![](Java-Synchronized/3.png)\n![](Java-Synchronized/4.png)\n![](Java-Synchronized/5.png)\n\n## JVM指令分析\n### Javap \nJavap -V  反编译\n#### 对代码块加锁\n![](Java-Synchronized/6.png)\n以上是代码块的加锁monitorenter和monitorExit配合使用\n#### 对方法加锁\n![](Java-Synchronized/7.png)\n通过ACC_SYNCHRONIZED实现\n\n# Java虚拟机对synchronized的优化\n## 对象头\n一个对象实例包含：对象头、实例变量、填充数据\n![实力对象](Java-Synchronized/8.png)\n对象头结构：\n![对象头](Java-Synchronized/9.png)\nMark Word 结构：\n![对象头](Java-Synchronized/10.png)\n## 偏向锁\n* 作用：偏向锁是为了消除无竞争情况下的同步原语，进一步提升程序性能。\n* 与轻量级锁的区别：轻量级锁是在无竞争的情况下使用CAS操作来代替互斥量的使用，从而实现同步；而偏向锁是在无竞争的情况下完全取消同步。\n* 与轻量级锁的相同点：它们都是乐观锁，都认为同步期间不会有其他线程竞争锁。\n* 原理：当线程请求到锁对象后，将锁对象的状态标志位改为01，即偏向模式。然后使用CAS操作将线程的ID记录在锁对象的Mark Word中。以后该线程可以直接进入同步块，连CAS操作都不需要。但是，一旦有第二条线程需要竞争锁，那么偏向模式立即结束，进入轻量级锁的状态。\n* 优点：偏向锁可以提高有同步但没有竞争的程序性能。但是如果锁对象时常被多条线程竞争，那偏向锁就是多余的。\n* 偏向锁可以通过虚拟机的参数来控制它是否开启。\n\n## 轻量级锁\n* 本质：使用CAS取代互斥同步\n* 背景：『轻量级锁』是相对于『重量级锁』而言的，而重量级锁就是传统的锁\n* 轻量级锁与重量级锁的比较：\n    * 重量级锁是一种悲观锁，它认为总是有多条线程要竞争锁，所以它每次处理共享数据时，不管当前系统中是否真的有线程在竞争锁，它都会使用互斥同步来保证线程的安全；\n    * 而轻量级锁是一种乐观锁，它认为锁存在竞争的概率比较小，所以它不使用互斥同步，而是使用CAS操作来获得锁，这样能减少互斥同步所使用的『互斥量』带来的性能开销。\n* 前提：轻量级锁比重量级锁性能更高的前提是，在轻量级锁被占用的整个同步周期内，**不存在其他线程的竞争**。若在该过程中一旦有其他线程竞争，那么就会膨胀成重量级锁，从而除了使用互斥量以外，还额外发生了CAS操作，因此更慢！\n* 实现原理：\n    * Mark Word中有个标志位用来表示当前对象所处的状态。\n    * 当线程请求锁时，若该锁对象的Mark Word中标志位为01（未锁定状态），则在该线程的栈帧中创建一块名为『锁记录』的空间，然后将锁对象的Mark Word拷贝至该空间；最后通过CAS操作将锁对象的Mark Word指向该锁记录；\n    * 若CAS操作成功，则轻量级锁的上锁过程成功；\n    * 若CAS操作失败，再判断当前线程是否已经持有了该轻量级锁；若已经持有，则直接进入同步块；若尚未持有，则表示该锁已经被其他线程占用，此时轻量级锁就要膨胀成重量级锁。\n\n## 重量级锁\n* 重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现，所以重量级锁又称互斥锁，也称为阻塞同步、悲观锁\n* 当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从**用户态转换到内核态**，线程开销很大。\n\n## 自旋锁\n* 背景：互斥同步对性能最大的影响是阻塞，挂起和恢复线程都需要转入内核态中完成；并且通常情况下，共享数据的锁定状态只持续很短的一段时间，为了这很短的一段时间进行上下文切换并不值得。\n* 原理：当一条线程需要请求一把已经被占用的锁时，并不会进入阻塞状态，而是继续持有CPU执行权等待一段时间，该过程称为『自旋』。\n* 优点：由于自旋等待锁的过程线程并不会引起上下文切换，因此比较高效；\n* 缺点：自旋等待过程线程一直占用CPU执行权但不处理任何任务，因此若该过程过长，那就会造成CPU资源的浪费。\n* 自适应自旋：自适应自旋可以根据以往自旋等待时间的经验，计算出一个较为合理的本次自旋等待时间。\n\n## 锁消除\n编译器会清除一些使用了同步，但同步块中没有涉及共享数据的锁，从而减少多余的同步。\n  \n## 锁粗化\n若有一系列操作，反复地对同一把锁进行上锁和解锁操作，编译器会扩大这部分代码的同步块的边界，从而只使用一次上锁和解锁操作。\n\n","source":"_posts/Java-Synchronized.md","raw":"---\ntitle: JAVA-Synchronized\ndate: 2020-01-19 15:17:00\ntags:\n    - JAVA\n    - 并发\n    - 学习笔记\ncategories: JAVA\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n# 概念\n利用锁的机制来实现同步的。\n锁机制有如下两种特性：\n**互斥性**：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的**原子性**。\n**可见性**：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。\n\n# 用法\n## 同步方法\n### 同步非静态方法\n```java\nPublic synchronized void methodName(){\n\n}\n```\n### 同步静态方法\n```java\nPublic synchronized static void methodName(){\n\n}\n```\n## 同步代码块\n### 获取对象锁\n```java\nsynchronized(this|object) {}\n```\n用来修饰非静态方法，\n在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，通常会被称为“内置锁”或“对象锁”。类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰\n### 获取类锁\n```java\nsynchronized(类.class) {}\n```\n用来修饰静态方法\n在 Java 中，针对每个类也有一个锁，可以称为“类锁”，类锁实际上是通过对象锁实现的，即类的 Class 对象锁。每个类只有一个 Class 对象，所以每个类只有一个类锁。\n\n## monitor \nMonitor其实是一种同步工具，也可以说是一种同步机制，它通常被描述为一个对象,也常被翻译为“监视器\\管程”,每个对象都会有一个 monitor\n* 某一线程占有一个对象的时候，先看该对象的 monitor 的计数器是不是0，如果是0表示这个对象还没有线程占有，这个时候线程占有这个对象，并且对这个对象的monitor+1；如果不为0，表示这个对象已经被其他线程占有，这个线程等待。当线程释放占有权的时候，monitor-1；\n* 同一线程可以对同一对象进行多次加锁，+1，+1，体现了重入性\n\n# 原理分析\n## 线程堆栈分析(互斥)\n### Jconsole\nJConsole 是一个内置 Java 性能分析器\nMac下位置：/Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/bin/jconsol\n\n测试代码：\n```java\npublic class SynchronizedDemo01 {\n\tpublic void test(){\n\t\tsynchronized (SynchronizedDemo01.class){\n\t\t\ttry {\n\t\t\t\tTimeUnit.MINUTES.sleep(2);\n\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \"is running\");\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSynchronizedDemo01 demo01 = new SynchronizedDemo01();\n\t\tfor (int i = 0 ; i < 5 ; i ++){\n\t\t\tnew Thread(demo01::test).start();\n\t\t}\n\t}\n}\n```\n\n![](Java-Synchronized/1.png)\n![](Java-Synchronized/2.png)\n![](Java-Synchronized/3.png)\n![](Java-Synchronized/4.png)\n![](Java-Synchronized/5.png)\n\n## JVM指令分析\n### Javap \nJavap -V  反编译\n#### 对代码块加锁\n![](Java-Synchronized/6.png)\n以上是代码块的加锁monitorenter和monitorExit配合使用\n#### 对方法加锁\n![](Java-Synchronized/7.png)\n通过ACC_SYNCHRONIZED实现\n\n# Java虚拟机对synchronized的优化\n## 对象头\n一个对象实例包含：对象头、实例变量、填充数据\n![实力对象](Java-Synchronized/8.png)\n对象头结构：\n![对象头](Java-Synchronized/9.png)\nMark Word 结构：\n![对象头](Java-Synchronized/10.png)\n## 偏向锁\n* 作用：偏向锁是为了消除无竞争情况下的同步原语，进一步提升程序性能。\n* 与轻量级锁的区别：轻量级锁是在无竞争的情况下使用CAS操作来代替互斥量的使用，从而实现同步；而偏向锁是在无竞争的情况下完全取消同步。\n* 与轻量级锁的相同点：它们都是乐观锁，都认为同步期间不会有其他线程竞争锁。\n* 原理：当线程请求到锁对象后，将锁对象的状态标志位改为01，即偏向模式。然后使用CAS操作将线程的ID记录在锁对象的Mark Word中。以后该线程可以直接进入同步块，连CAS操作都不需要。但是，一旦有第二条线程需要竞争锁，那么偏向模式立即结束，进入轻量级锁的状态。\n* 优点：偏向锁可以提高有同步但没有竞争的程序性能。但是如果锁对象时常被多条线程竞争，那偏向锁就是多余的。\n* 偏向锁可以通过虚拟机的参数来控制它是否开启。\n\n## 轻量级锁\n* 本质：使用CAS取代互斥同步\n* 背景：『轻量级锁』是相对于『重量级锁』而言的，而重量级锁就是传统的锁\n* 轻量级锁与重量级锁的比较：\n    * 重量级锁是一种悲观锁，它认为总是有多条线程要竞争锁，所以它每次处理共享数据时，不管当前系统中是否真的有线程在竞争锁，它都会使用互斥同步来保证线程的安全；\n    * 而轻量级锁是一种乐观锁，它认为锁存在竞争的概率比较小，所以它不使用互斥同步，而是使用CAS操作来获得锁，这样能减少互斥同步所使用的『互斥量』带来的性能开销。\n* 前提：轻量级锁比重量级锁性能更高的前提是，在轻量级锁被占用的整个同步周期内，**不存在其他线程的竞争**。若在该过程中一旦有其他线程竞争，那么就会膨胀成重量级锁，从而除了使用互斥量以外，还额外发生了CAS操作，因此更慢！\n* 实现原理：\n    * Mark Word中有个标志位用来表示当前对象所处的状态。\n    * 当线程请求锁时，若该锁对象的Mark Word中标志位为01（未锁定状态），则在该线程的栈帧中创建一块名为『锁记录』的空间，然后将锁对象的Mark Word拷贝至该空间；最后通过CAS操作将锁对象的Mark Word指向该锁记录；\n    * 若CAS操作成功，则轻量级锁的上锁过程成功；\n    * 若CAS操作失败，再判断当前线程是否已经持有了该轻量级锁；若已经持有，则直接进入同步块；若尚未持有，则表示该锁已经被其他线程占用，此时轻量级锁就要膨胀成重量级锁。\n\n## 重量级锁\n* 重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现，所以重量级锁又称互斥锁，也称为阻塞同步、悲观锁\n* 当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从**用户态转换到内核态**，线程开销很大。\n\n## 自旋锁\n* 背景：互斥同步对性能最大的影响是阻塞，挂起和恢复线程都需要转入内核态中完成；并且通常情况下，共享数据的锁定状态只持续很短的一段时间，为了这很短的一段时间进行上下文切换并不值得。\n* 原理：当一条线程需要请求一把已经被占用的锁时，并不会进入阻塞状态，而是继续持有CPU执行权等待一段时间，该过程称为『自旋』。\n* 优点：由于自旋等待锁的过程线程并不会引起上下文切换，因此比较高效；\n* 缺点：自旋等待过程线程一直占用CPU执行权但不处理任何任务，因此若该过程过长，那就会造成CPU资源的浪费。\n* 自适应自旋：自适应自旋可以根据以往自旋等待时间的经验，计算出一个较为合理的本次自旋等待时间。\n\n## 锁消除\n编译器会清除一些使用了同步，但同步块中没有涉及共享数据的锁，从而减少多余的同步。\n  \n## 锁粗化\n若有一系列操作，反复地对同一把锁进行上锁和解锁操作，编译器会扩大这部分代码的同步块的边界，从而只使用一次上锁和解锁操作。\n\n","slug":"Java-Synchronized","published":1,"updated":"2020-03-06T12:44:31.776Z","layout":"post","photos":[],"link":"","_id":"ck8fb4abm001sk2o5dtcyl3bf","content":"<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><p>利用锁的机制来实现同步的。<br>锁机制有如下两种特性：<br><strong>互斥性</strong>：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的<strong>原子性</strong>。<br><strong>可见性</strong>：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。</p>\n<h1 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h1><h2 id=\"同步方法\"><a href=\"#同步方法\" class=\"headerlink\" title=\"同步方法\"></a>同步方法</h2><h3 id=\"同步非静态方法\"><a href=\"#同步非静态方法\" class=\"headerlink\" title=\"同步非静态方法\"></a>同步非静态方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Public <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">methodName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"同步静态方法\"><a href=\"#同步静态方法\" class=\"headerlink\" title=\"同步静态方法\"></a>同步静态方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Public <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">methodName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"同步代码块\"><a href=\"#同步代码块\" class=\"headerlink\" title=\"同步代码块\"></a>同步代码块</h2><h3 id=\"获取对象锁\"><a href=\"#获取对象锁\" class=\"headerlink\" title=\"获取对象锁\"></a>获取对象锁</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>|object) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用来修饰非静态方法，<br>在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，通常会被称为“内置锁”或“对象锁”。类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰</p>\n<h3 id=\"获取类锁\"><a href=\"#获取类锁\" class=\"headerlink\" title=\"获取类锁\"></a>获取类锁</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(类.class) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用来修饰静态方法<br>在 Java 中，针对每个类也有一个锁，可以称为“类锁”，类锁实际上是通过对象锁实现的，即类的 Class 对象锁。每个类只有一个 Class 对象，所以每个类只有一个类锁。</p>\n<h2 id=\"monitor\"><a href=\"#monitor\" class=\"headerlink\" title=\"monitor\"></a>monitor</h2><p>Monitor其实是一种同步工具，也可以说是一种同步机制，它通常被描述为一个对象,也常被翻译为“监视器\\管程”,每个对象都会有一个 monitor</p>\n<ul>\n<li>某一线程占有一个对象的时候，先看该对象的 monitor 的计数器是不是0，如果是0表示这个对象还没有线程占有，这个时候线程占有这个对象，并且对这个对象的monitor+1；如果不为0，表示这个对象已经被其他线程占有，这个线程等待。当线程释放占有权的时候，monitor-1；</li>\n<li>同一线程可以对同一对象进行多次加锁，+1，+1，体现了重入性</li>\n</ul>\n<h1 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h1><h2 id=\"线程堆栈分析-互斥\"><a href=\"#线程堆栈分析-互斥\" class=\"headerlink\" title=\"线程堆栈分析(互斥)\"></a>线程堆栈分析(互斥)</h2><h3 id=\"Jconsole\"><a href=\"#Jconsole\" class=\"headerlink\" title=\"Jconsole\"></a>Jconsole</h3><p>JConsole 是一个内置 Java 性能分析器<br>Mac下位置：/Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/bin/jconsol</p>\n<p>测试代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SynchronizedDemo01</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (SynchronizedDemo01.class)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\tTimeUnit.MINUTES.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t\t\tSystem.out.println(Thread.currentThread().getName() + <span class=\"string\">\"is running\"</span>);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tSynchronizedDemo01 demo01 = <span class=\"keyword\">new</span> SynchronizedDemo01();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">5</span> ; i ++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">new</span> Thread(demo01::test).start();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/JAVA/Java-Synchronized/1.png\" alt=\"\"><br><img src=\"/JAVA/Java-Synchronized/2.png\" alt=\"\"><br><img src=\"/JAVA/Java-Synchronized/3.png\" alt=\"\"><br><img src=\"/JAVA/Java-Synchronized/4.png\" alt=\"\"><br><img src=\"/JAVA/Java-Synchronized/5.png\" alt=\"\"></p>\n<h2 id=\"JVM指令分析\"><a href=\"#JVM指令分析\" class=\"headerlink\" title=\"JVM指令分析\"></a>JVM指令分析</h2><h3 id=\"Javap\"><a href=\"#Javap\" class=\"headerlink\" title=\"Javap\"></a>Javap</h3><p>Javap -V  反编译</p>\n<h4 id=\"对代码块加锁\"><a href=\"#对代码块加锁\" class=\"headerlink\" title=\"对代码块加锁\"></a>对代码块加锁</h4><p><img src=\"/JAVA/Java-Synchronized/6.png\" alt=\"\"><br>以上是代码块的加锁monitorenter和monitorExit配合使用</p>\n<h4 id=\"对方法加锁\"><a href=\"#对方法加锁\" class=\"headerlink\" title=\"对方法加锁\"></a>对方法加锁</h4><p><img src=\"/JAVA/Java-Synchronized/7.png\" alt=\"\"><br>通过ACC_SYNCHRONIZED实现</p>\n<h1 id=\"Java虚拟机对synchronized的优化\"><a href=\"#Java虚拟机对synchronized的优化\" class=\"headerlink\" title=\"Java虚拟机对synchronized的优化\"></a>Java虚拟机对synchronized的优化</h1><h2 id=\"对象头\"><a href=\"#对象头\" class=\"headerlink\" title=\"对象头\"></a>对象头</h2><p>一个对象实例包含：对象头、实例变量、填充数据<br><img src=\"/JAVA/Java-Synchronized/8.png\" alt=\"实力对象\"><br>对象头结构：<br><img src=\"/JAVA/Java-Synchronized/9.png\" alt=\"对象头\"><br>Mark Word 结构：<br><img src=\"/JAVA/Java-Synchronized/10.png\" alt=\"对象头\"></p>\n<h2 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h2><ul>\n<li>作用：偏向锁是为了消除无竞争情况下的同步原语，进一步提升程序性能。</li>\n<li>与轻量级锁的区别：轻量级锁是在无竞争的情况下使用CAS操作来代替互斥量的使用，从而实现同步；而偏向锁是在无竞争的情况下完全取消同步。</li>\n<li>与轻量级锁的相同点：它们都是乐观锁，都认为同步期间不会有其他线程竞争锁。</li>\n<li>原理：当线程请求到锁对象后，将锁对象的状态标志位改为01，即偏向模式。然后使用CAS操作将线程的ID记录在锁对象的Mark Word中。以后该线程可以直接进入同步块，连CAS操作都不需要。但是，一旦有第二条线程需要竞争锁，那么偏向模式立即结束，进入轻量级锁的状态。</li>\n<li>优点：偏向锁可以提高有同步但没有竞争的程序性能。但是如果锁对象时常被多条线程竞争，那偏向锁就是多余的。</li>\n<li>偏向锁可以通过虚拟机的参数来控制它是否开启。</li>\n</ul>\n<h2 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h2><ul>\n<li>本质：使用CAS取代互斥同步</li>\n<li>背景：『轻量级锁』是相对于『重量级锁』而言的，而重量级锁就是传统的锁</li>\n<li>轻量级锁与重量级锁的比较：<ul>\n<li>重量级锁是一种悲观锁，它认为总是有多条线程要竞争锁，所以它每次处理共享数据时，不管当前系统中是否真的有线程在竞争锁，它都会使用互斥同步来保证线程的安全；</li>\n<li>而轻量级锁是一种乐观锁，它认为锁存在竞争的概率比较小，所以它不使用互斥同步，而是使用CAS操作来获得锁，这样能减少互斥同步所使用的『互斥量』带来的性能开销。</li>\n</ul>\n</li>\n<li>前提：轻量级锁比重量级锁性能更高的前提是，在轻量级锁被占用的整个同步周期内，<strong>不存在其他线程的竞争</strong>。若在该过程中一旦有其他线程竞争，那么就会膨胀成重量级锁，从而除了使用互斥量以外，还额外发生了CAS操作，因此更慢！</li>\n<li>实现原理：<ul>\n<li>Mark Word中有个标志位用来表示当前对象所处的状态。</li>\n<li>当线程请求锁时，若该锁对象的Mark Word中标志位为01（未锁定状态），则在该线程的栈帧中创建一块名为『锁记录』的空间，然后将锁对象的Mark Word拷贝至该空间；最后通过CAS操作将锁对象的Mark Word指向该锁记录；</li>\n<li>若CAS操作成功，则轻量级锁的上锁过程成功；</li>\n<li>若CAS操作失败，再判断当前线程是否已经持有了该轻量级锁；若已经持有，则直接进入同步块；若尚未持有，则表示该锁已经被其他线程占用，此时轻量级锁就要膨胀成重量级锁。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a>重量级锁</h2><ul>\n<li>重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现，所以重量级锁又称互斥锁，也称为阻塞同步、悲观锁</li>\n<li>当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从<strong>用户态转换到内核态</strong>，线程开销很大。</li>\n</ul>\n<h2 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h2><ul>\n<li>背景：互斥同步对性能最大的影响是阻塞，挂起和恢复线程都需要转入内核态中完成；并且通常情况下，共享数据的锁定状态只持续很短的一段时间，为了这很短的一段时间进行上下文切换并不值得。</li>\n<li>原理：当一条线程需要请求一把已经被占用的锁时，并不会进入阻塞状态，而是继续持有CPU执行权等待一段时间，该过程称为『自旋』。</li>\n<li>优点：由于自旋等待锁的过程线程并不会引起上下文切换，因此比较高效；</li>\n<li>缺点：自旋等待过程线程一直占用CPU执行权但不处理任何任务，因此若该过程过长，那就会造成CPU资源的浪费。</li>\n<li>自适应自旋：自适应自旋可以根据以往自旋等待时间的经验，计算出一个较为合理的本次自旋等待时间。</li>\n</ul>\n<h2 id=\"锁消除\"><a href=\"#锁消除\" class=\"headerlink\" title=\"锁消除\"></a>锁消除</h2><p>编译器会清除一些使用了同步，但同步块中没有涉及共享数据的锁，从而减少多余的同步。</p>\n<h2 id=\"锁粗化\"><a href=\"#锁粗化\" class=\"headerlink\" title=\"锁粗化\"></a>锁粗化</h2><p>若有一系列操作，反复地对同一把锁进行上锁和解锁操作，编译器会扩大这部分代码的同步块的边界，从而只使用一次上锁和解锁操作。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h1><p>利用锁的机制来实现同步的。<br>锁机制有如下两种特性：<br><strong>互斥性</strong>：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的<strong>原子性</strong>。<br><strong>可见性</strong>：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。</p>\n<h1 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h1><h2 id=\"同步方法\"><a href=\"#同步方法\" class=\"headerlink\" title=\"同步方法\"></a>同步方法</h2><h3 id=\"同步非静态方法\"><a href=\"#同步非静态方法\" class=\"headerlink\" title=\"同步非静态方法\"></a>同步非静态方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Public <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">methodName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"同步静态方法\"><a href=\"#同步静态方法\" class=\"headerlink\" title=\"同步静态方法\"></a>同步静态方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Public <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">methodName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"同步代码块\"><a href=\"#同步代码块\" class=\"headerlink\" title=\"同步代码块\"></a>同步代码块</h2><h3 id=\"获取对象锁\"><a href=\"#获取对象锁\" class=\"headerlink\" title=\"获取对象锁\"></a>获取对象锁</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>|object) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用来修饰非静态方法，<br>在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，通常会被称为“内置锁”或“对象锁”。类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰</p>\n<h3 id=\"获取类锁\"><a href=\"#获取类锁\" class=\"headerlink\" title=\"获取类锁\"></a>获取类锁</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(类.class) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用来修饰静态方法<br>在 Java 中，针对每个类也有一个锁，可以称为“类锁”，类锁实际上是通过对象锁实现的，即类的 Class 对象锁。每个类只有一个 Class 对象，所以每个类只有一个类锁。</p>\n<h2 id=\"monitor\"><a href=\"#monitor\" class=\"headerlink\" title=\"monitor\"></a>monitor</h2><p>Monitor其实是一种同步工具，也可以说是一种同步机制，它通常被描述为一个对象,也常被翻译为“监视器\\管程”,每个对象都会有一个 monitor</p>\n<ul>\n<li>某一线程占有一个对象的时候，先看该对象的 monitor 的计数器是不是0，如果是0表示这个对象还没有线程占有，这个时候线程占有这个对象，并且对这个对象的monitor+1；如果不为0，表示这个对象已经被其他线程占有，这个线程等待。当线程释放占有权的时候，monitor-1；</li>\n<li>同一线程可以对同一对象进行多次加锁，+1，+1，体现了重入性</li>\n</ul>\n<h1 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h1><h2 id=\"线程堆栈分析-互斥\"><a href=\"#线程堆栈分析-互斥\" class=\"headerlink\" title=\"线程堆栈分析(互斥)\"></a>线程堆栈分析(互斥)</h2><h3 id=\"Jconsole\"><a href=\"#Jconsole\" class=\"headerlink\" title=\"Jconsole\"></a>Jconsole</h3><p>JConsole 是一个内置 Java 性能分析器<br>Mac下位置：/Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/bin/jconsol</p>\n<p>测试代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SynchronizedDemo01</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">synchronized</span> (SynchronizedDemo01.class)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\tTimeUnit.MINUTES.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t\t\tSystem.out.println(Thread.currentThread().getName() + <span class=\"string\">\"is running\"</span>);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tSynchronizedDemo01 demo01 = <span class=\"keyword\">new</span> SynchronizedDemo01();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">5</span> ; i ++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">new</span> Thread(demo01::test).start();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/JAVA/Java-Synchronized/1.png\" alt=\"\"><br><img src=\"/JAVA/Java-Synchronized/2.png\" alt=\"\"><br><img src=\"/JAVA/Java-Synchronized/3.png\" alt=\"\"><br><img src=\"/JAVA/Java-Synchronized/4.png\" alt=\"\"><br><img src=\"/JAVA/Java-Synchronized/5.png\" alt=\"\"></p>\n<h2 id=\"JVM指令分析\"><a href=\"#JVM指令分析\" class=\"headerlink\" title=\"JVM指令分析\"></a>JVM指令分析</h2><h3 id=\"Javap\"><a href=\"#Javap\" class=\"headerlink\" title=\"Javap\"></a>Javap</h3><p>Javap -V  反编译</p>\n<h4 id=\"对代码块加锁\"><a href=\"#对代码块加锁\" class=\"headerlink\" title=\"对代码块加锁\"></a>对代码块加锁</h4><p><img src=\"/JAVA/Java-Synchronized/6.png\" alt=\"\"><br>以上是代码块的加锁monitorenter和monitorExit配合使用</p>\n<h4 id=\"对方法加锁\"><a href=\"#对方法加锁\" class=\"headerlink\" title=\"对方法加锁\"></a>对方法加锁</h4><p><img src=\"/JAVA/Java-Synchronized/7.png\" alt=\"\"><br>通过ACC_SYNCHRONIZED实现</p>\n<h1 id=\"Java虚拟机对synchronized的优化\"><a href=\"#Java虚拟机对synchronized的优化\" class=\"headerlink\" title=\"Java虚拟机对synchronized的优化\"></a>Java虚拟机对synchronized的优化</h1><h2 id=\"对象头\"><a href=\"#对象头\" class=\"headerlink\" title=\"对象头\"></a>对象头</h2><p>一个对象实例包含：对象头、实例变量、填充数据<br><img src=\"/JAVA/Java-Synchronized/8.png\" alt=\"实力对象\"><br>对象头结构：<br><img src=\"/JAVA/Java-Synchronized/9.png\" alt=\"对象头\"><br>Mark Word 结构：<br><img src=\"/JAVA/Java-Synchronized/10.png\" alt=\"对象头\"></p>\n<h2 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h2><ul>\n<li>作用：偏向锁是为了消除无竞争情况下的同步原语，进一步提升程序性能。</li>\n<li>与轻量级锁的区别：轻量级锁是在无竞争的情况下使用CAS操作来代替互斥量的使用，从而实现同步；而偏向锁是在无竞争的情况下完全取消同步。</li>\n<li>与轻量级锁的相同点：它们都是乐观锁，都认为同步期间不会有其他线程竞争锁。</li>\n<li>原理：当线程请求到锁对象后，将锁对象的状态标志位改为01，即偏向模式。然后使用CAS操作将线程的ID记录在锁对象的Mark Word中。以后该线程可以直接进入同步块，连CAS操作都不需要。但是，一旦有第二条线程需要竞争锁，那么偏向模式立即结束，进入轻量级锁的状态。</li>\n<li>优点：偏向锁可以提高有同步但没有竞争的程序性能。但是如果锁对象时常被多条线程竞争，那偏向锁就是多余的。</li>\n<li>偏向锁可以通过虚拟机的参数来控制它是否开启。</li>\n</ul>\n<h2 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h2><ul>\n<li>本质：使用CAS取代互斥同步</li>\n<li>背景：『轻量级锁』是相对于『重量级锁』而言的，而重量级锁就是传统的锁</li>\n<li>轻量级锁与重量级锁的比较：<ul>\n<li>重量级锁是一种悲观锁，它认为总是有多条线程要竞争锁，所以它每次处理共享数据时，不管当前系统中是否真的有线程在竞争锁，它都会使用互斥同步来保证线程的安全；</li>\n<li>而轻量级锁是一种乐观锁，它认为锁存在竞争的概率比较小，所以它不使用互斥同步，而是使用CAS操作来获得锁，这样能减少互斥同步所使用的『互斥量』带来的性能开销。</li>\n</ul>\n</li>\n<li>前提：轻量级锁比重量级锁性能更高的前提是，在轻量级锁被占用的整个同步周期内，<strong>不存在其他线程的竞争</strong>。若在该过程中一旦有其他线程竞争，那么就会膨胀成重量级锁，从而除了使用互斥量以外，还额外发生了CAS操作，因此更慢！</li>\n<li>实现原理：<ul>\n<li>Mark Word中有个标志位用来表示当前对象所处的状态。</li>\n<li>当线程请求锁时，若该锁对象的Mark Word中标志位为01（未锁定状态），则在该线程的栈帧中创建一块名为『锁记录』的空间，然后将锁对象的Mark Word拷贝至该空间；最后通过CAS操作将锁对象的Mark Word指向该锁记录；</li>\n<li>若CAS操作成功，则轻量级锁的上锁过程成功；</li>\n<li>若CAS操作失败，再判断当前线程是否已经持有了该轻量级锁；若已经持有，则直接进入同步块；若尚未持有，则表示该锁已经被其他线程占用，此时轻量级锁就要膨胀成重量级锁。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a>重量级锁</h2><ul>\n<li>重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现，所以重量级锁又称互斥锁，也称为阻塞同步、悲观锁</li>\n<li>当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从<strong>用户态转换到内核态</strong>，线程开销很大。</li>\n</ul>\n<h2 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h2><ul>\n<li>背景：互斥同步对性能最大的影响是阻塞，挂起和恢复线程都需要转入内核态中完成；并且通常情况下，共享数据的锁定状态只持续很短的一段时间，为了这很短的一段时间进行上下文切换并不值得。</li>\n<li>原理：当一条线程需要请求一把已经被占用的锁时，并不会进入阻塞状态，而是继续持有CPU执行权等待一段时间，该过程称为『自旋』。</li>\n<li>优点：由于自旋等待锁的过程线程并不会引起上下文切换，因此比较高效；</li>\n<li>缺点：自旋等待过程线程一直占用CPU执行权但不处理任何任务，因此若该过程过长，那就会造成CPU资源的浪费。</li>\n<li>自适应自旋：自适应自旋可以根据以往自旋等待时间的经验，计算出一个较为合理的本次自旋等待时间。</li>\n</ul>\n<h2 id=\"锁消除\"><a href=\"#锁消除\" class=\"headerlink\" title=\"锁消除\"></a>锁消除</h2><p>编译器会清除一些使用了同步，但同步块中没有涉及共享数据的锁，从而减少多余的同步。</p>\n<h2 id=\"锁粗化\"><a href=\"#锁粗化\" class=\"headerlink\" title=\"锁粗化\"></a>锁粗化</h2><p>若有一系列操作，反复地对同一把锁进行上锁和解锁操作，编译器会扩大这部分代码的同步块的边界，从而只使用一次上锁和解锁操作。</p>\n"},{"title":"JAVA-Volatile","date":"2020-02-27T11:36:00.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"## Volatile关键字\njava编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。\n## 机器硬件CPU与JMM\n{% post_link Java-MemoryModel 点击这里查看这篇文章 %}\n\n## Volatile关键字的作用\nvolatile作用：让其他线程能够马上感知到某一线程多某个变量的修改\n* 保证可见性:对共享变量的修改，其他的线程马上能感知到\n* 保证有序性:禁止重排序（编译阶段、指令优化阶段）volatile之前的代码不能调整到他的后面，volatile之后的代码不能调整到他的前面\n* **不能保证原子性**：\n    举个例子：   \n     ```java\n             public class Test {\n                 public volatile int inc = 0;\n             \n                 public void increase() {\n                     inc++;\n                 }\n             \n                 public static void main(String[] args) {\n                     final Test test = new Test();\n                     for(int i=0;i<10;i++){\n                         new Thread(){\n                             public void run() {\n                                 for(int j=0;j<1000;j++)\n                                     test.increase();\n                             };\n                         }.start();\n                     }\n             \n                     while(Thread.activeCount()>1)  //保证前面的线程都执行完\n                         Thread.yield();\n                     System.out.println(test.inc);\n                 }\n             }\n     ```\n    线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。\n\n## Volatile实现原理\n<table>\n        <tr>\n            <th>Java代码</th>\n            <th>instance = new Singleton();//instance是volatile变量</th>\n        </tr> \n        <tr>\n            <th>汇编代码</th>\n            <th>0x01a3de1d: movb $0x0,0x1104800(%esi);<br>0x01a3de24: lock  addl $0x0,(%esp);</th>\n        </tr> \n</table> \n\n有volatile变量修饰的共享变量进行写操作的时候会多第二行汇编代码，通过查IA-32架构软件开发者手册可知，`lock`前缀的指令在多核处理器下会引发了两件事情。\n* 将当前处理器缓存行的数据会写回到系统内存。\n* 这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。\n\n## Volatile的使用场景\n* 状态标志（开关模式）\n    ```java\n    public class ShutDowsnDemmo extends Thread{\n        private volatile boolean started=false;\n    \n        @Override\n        public void run() {\n            while(started){\n                dowork();\n            }\n        }\n        public void shutdown(){\n            started=false;\n        }\n    }\n    ```\n* 双重检查锁定（double-checked-locking）\n* 需要利用顺序性\n\n## volatile与synchronized的区别\n1. 使用上的区别:\n    Volatile只能修饰变量，synchronized只能修饰方法和语句块\n2. 对原子性的保证:\n    Volatile不能保证原子性，synchronized可以保证原子性\n3. 对可见性的保证:\n    都可以保证可见性，但实现原理不同;Volatile对变量加了lock，synchronized使用monitorEnter和monitorexit\n4. 对有序性的保证:\n    Volatile能保证有序，synchronized可以保证有序性，但是代价（重量级）并发退化到串行\n5. 其他:\n    Volatile不会引起阻塞，synchronized引起阻塞\n\n\n\n\n\n\n\n    ","source":"_posts/Java-Volatile.md","raw":"title: JAVA-Volatile\ndate: 2020-02-27 19:36:00\ntags:\n    - JAVA\n    - 并发\n    - 学习笔记\ncategories: JAVA\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n## Volatile关键字\njava编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。\n## 机器硬件CPU与JMM\n{% post_link Java-MemoryModel 点击这里查看这篇文章 %}\n\n## Volatile关键字的作用\nvolatile作用：让其他线程能够马上感知到某一线程多某个变量的修改\n* 保证可见性:对共享变量的修改，其他的线程马上能感知到\n* 保证有序性:禁止重排序（编译阶段、指令优化阶段）volatile之前的代码不能调整到他的后面，volatile之后的代码不能调整到他的前面\n* **不能保证原子性**：\n    举个例子：   \n     ```java\n             public class Test {\n                 public volatile int inc = 0;\n             \n                 public void increase() {\n                     inc++;\n                 }\n             \n                 public static void main(String[] args) {\n                     final Test test = new Test();\n                     for(int i=0;i<10;i++){\n                         new Thread(){\n                             public void run() {\n                                 for(int j=0;j<1000;j++)\n                                     test.increase();\n                             };\n                         }.start();\n                     }\n             \n                     while(Thread.activeCount()>1)  //保证前面的线程都执行完\n                         Thread.yield();\n                     System.out.println(test.inc);\n                 }\n             }\n     ```\n    线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。\n\n## Volatile实现原理\n<table>\n        <tr>\n            <th>Java代码</th>\n            <th>instance = new Singleton();//instance是volatile变量</th>\n        </tr> \n        <tr>\n            <th>汇编代码</th>\n            <th>0x01a3de1d: movb $0x0,0x1104800(%esi);<br>0x01a3de24: lock  addl $0x0,(%esp);</th>\n        </tr> \n</table> \n\n有volatile变量修饰的共享变量进行写操作的时候会多第二行汇编代码，通过查IA-32架构软件开发者手册可知，`lock`前缀的指令在多核处理器下会引发了两件事情。\n* 将当前处理器缓存行的数据会写回到系统内存。\n* 这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。\n\n## Volatile的使用场景\n* 状态标志（开关模式）\n    ```java\n    public class ShutDowsnDemmo extends Thread{\n        private volatile boolean started=false;\n    \n        @Override\n        public void run() {\n            while(started){\n                dowork();\n            }\n        }\n        public void shutdown(){\n            started=false;\n        }\n    }\n    ```\n* 双重检查锁定（double-checked-locking）\n* 需要利用顺序性\n\n## volatile与synchronized的区别\n1. 使用上的区别:\n    Volatile只能修饰变量，synchronized只能修饰方法和语句块\n2. 对原子性的保证:\n    Volatile不能保证原子性，synchronized可以保证原子性\n3. 对可见性的保证:\n    都可以保证可见性，但实现原理不同;Volatile对变量加了lock，synchronized使用monitorEnter和monitorexit\n4. 对有序性的保证:\n    Volatile能保证有序，synchronized可以保证有序性，但是代价（重量级）并发退化到串行\n5. 其他:\n    Volatile不会引起阻塞，synchronized引起阻塞\n\n\n\n\n\n\n\n    ","slug":"Java-Volatile","published":1,"updated":"2020-03-14T14:20:13.326Z","layout":"post","photos":[],"link":"","_id":"ck8fb4aby001xk2o5ztg0plf2","content":"<h2 id=\"Volatile关键字\"><a href=\"#Volatile关键字\" class=\"headerlink\" title=\"Volatile关键字\"></a>Volatile关键字</h2><p>java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p>\n<h2 id=\"机器硬件CPU与JMM\"><a href=\"#机器硬件CPU与JMM\" class=\"headerlink\" title=\"机器硬件CPU与JMM\"></a>机器硬件CPU与JMM</h2><a href=\"/JAVA/Java-MemoryModel/\" title=\"点击这里查看这篇文章\">点击这里查看这篇文章</a>\n\n<h2 id=\"Volatile关键字的作用\"><a href=\"#Volatile关键字的作用\" class=\"headerlink\" title=\"Volatile关键字的作用\"></a>Volatile关键字的作用</h2><p>volatile作用：让其他线程能够马上感知到某一线程多某个变量的修改</p>\n<ul>\n<li><p>保证可见性:对共享变量的修改，其他的线程马上能感知到</p>\n</li>\n<li><p>保证有序性:禁止重排序（编译阶段、指令优化阶段）volatile之前的代码不能调整到他的后面，volatile之后的代码不能调整到他的前面</p>\n</li>\n<li><p><strong>不能保证原子性</strong>：<br>  举个例子：   </p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> inc = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">increase</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        inc++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Test test = <span class=\"keyword\">new</span> Test();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">1000</span>;j++)</span><br><span class=\"line\">                        test.increase();</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125;.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(Thread.activeCount()&gt;<span class=\"number\">1</span>)  <span class=\"comment\">//保证前面的线程都执行完</span></span><br><span class=\"line\">            Thread.yield();</span><br><span class=\"line\">        System.out.println(test.inc);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>\n</li>\n</ul>\n<h2 id=\"Volatile实现原理\"><a href=\"#Volatile实现原理\" class=\"headerlink\" title=\"Volatile实现原理\"></a>Volatile实现原理</h2><table>\n        <tr>\n            <th>Java代码</th>\n            <th>instance = new Singleton();//instance是volatile变量</th>\n        </tr> \n        <tr>\n            <th>汇编代码</th>\n            <th>0x01a3de1d: movb $0x0,0x1104800(%esi);<br>0x01a3de24: lock  addl $0x0,(%esp);</th>\n        </tr> \n</table> \n\n<p>有volatile变量修饰的共享变量进行写操作的时候会多第二行汇编代码，通过查IA-32架构软件开发者手册可知，<code>lock</code>前缀的指令在多核处理器下会引发了两件事情。</p>\n<ul>\n<li>将当前处理器缓存行的数据会写回到系统内存。</li>\n<li>这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。</li>\n</ul>\n<h2 id=\"Volatile的使用场景\"><a href=\"#Volatile的使用场景\" class=\"headerlink\" title=\"Volatile的使用场景\"></a>Volatile的使用场景</h2><ul>\n<li><p>状态标志（开关模式）</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShutDowsnDemmo</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> started=<span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(started)&#123;</span><br><span class=\"line\">            dowork();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        started=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>双重检查锁定（double-checked-locking）</p>\n</li>\n<li><p>需要利用顺序性</p>\n</li>\n</ul>\n<h2 id=\"volatile与synchronized的区别\"><a href=\"#volatile与synchronized的区别\" class=\"headerlink\" title=\"volatile与synchronized的区别\"></a>volatile与synchronized的区别</h2><ol>\n<li>使用上的区别:<br> Volatile只能修饰变量，synchronized只能修饰方法和语句块</li>\n<li>对原子性的保证:<br> Volatile不能保证原子性，synchronized可以保证原子性</li>\n<li>对可见性的保证:<br> 都可以保证可见性，但实现原理不同;Volatile对变量加了lock，synchronized使用monitorEnter和monitorexit</li>\n<li>对有序性的保证:<br> Volatile能保证有序，synchronized可以保证有序性，但是代价（重量级）并发退化到串行</li>\n<li>其他:<br> Volatile不会引起阻塞，synchronized引起阻塞</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Volatile关键字\"><a href=\"#Volatile关键字\" class=\"headerlink\" title=\"Volatile关键字\"></a>Volatile关键字</h2><p>java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p>\n<h2 id=\"机器硬件CPU与JMM\"><a href=\"#机器硬件CPU与JMM\" class=\"headerlink\" title=\"机器硬件CPU与JMM\"></a>机器硬件CPU与JMM</h2><a href=\"/JAVA/Java-MemoryModel/\" title=\"点击这里查看这篇文章\">点击这里查看这篇文章</a>\n\n<h2 id=\"Volatile关键字的作用\"><a href=\"#Volatile关键字的作用\" class=\"headerlink\" title=\"Volatile关键字的作用\"></a>Volatile关键字的作用</h2><p>volatile作用：让其他线程能够马上感知到某一线程多某个变量的修改</p>\n<ul>\n<li><p>保证可见性:对共享变量的修改，其他的线程马上能感知到</p>\n</li>\n<li><p>保证有序性:禁止重排序（编译阶段、指令优化阶段）volatile之前的代码不能调整到他的后面，volatile之后的代码不能调整到他的前面</p>\n</li>\n<li><p><strong>不能保证原子性</strong>：<br>  举个例子：   </p>\n   <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> inc = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">increase</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        inc++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Test test = <span class=\"keyword\">new</span> Test();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">1000</span>;j++)</span><br><span class=\"line\">                        test.increase();</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125;.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(Thread.activeCount()&gt;<span class=\"number\">1</span>)  <span class=\"comment\">//保证前面的线程都执行完</span></span><br><span class=\"line\">            Thread.yield();</span><br><span class=\"line\">        System.out.println(test.inc);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>\n</li>\n</ul>\n<h2 id=\"Volatile实现原理\"><a href=\"#Volatile实现原理\" class=\"headerlink\" title=\"Volatile实现原理\"></a>Volatile实现原理</h2><table>\n        <tr>\n            <th>Java代码</th>\n            <th>instance = new Singleton();//instance是volatile变量</th>\n        </tr> \n        <tr>\n            <th>汇编代码</th>\n            <th>0x01a3de1d: movb $0x0,0x1104800(%esi);<br>0x01a3de24: lock  addl $0x0,(%esp);</th>\n        </tr> \n</table> \n\n<p>有volatile变量修饰的共享变量进行写操作的时候会多第二行汇编代码，通过查IA-32架构软件开发者手册可知，<code>lock</code>前缀的指令在多核处理器下会引发了两件事情。</p>\n<ul>\n<li>将当前处理器缓存行的数据会写回到系统内存。</li>\n<li>这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。</li>\n</ul>\n<h2 id=\"Volatile的使用场景\"><a href=\"#Volatile的使用场景\" class=\"headerlink\" title=\"Volatile的使用场景\"></a>Volatile的使用场景</h2><ul>\n<li><p>状态标志（开关模式）</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShutDowsnDemmo</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> started=<span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(started)&#123;</span><br><span class=\"line\">            dowork();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        started=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>双重检查锁定（double-checked-locking）</p>\n</li>\n<li><p>需要利用顺序性</p>\n</li>\n</ul>\n<h2 id=\"volatile与synchronized的区别\"><a href=\"#volatile与synchronized的区别\" class=\"headerlink\" title=\"volatile与synchronized的区别\"></a>volatile与synchronized的区别</h2><ol>\n<li>使用上的区别:<br> Volatile只能修饰变量，synchronized只能修饰方法和语句块</li>\n<li>对原子性的保证:<br> Volatile不能保证原子性，synchronized可以保证原子性</li>\n<li>对可见性的保证:<br> 都可以保证可见性，但实现原理不同;Volatile对变量加了lock，synchronized使用monitorEnter和monitorexit</li>\n<li>对有序性的保证:<br> Volatile能保证有序，synchronized可以保证有序性，但是代价（重量级）并发退化到串行</li>\n<li>其他:<br> Volatile不会引起阻塞，synchronized引起阻塞</li>\n</ol>\n"},{"title":"JAVA-线程池","date":"2019-10-21T09:23:04.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"# 线程\n\n#### 概念\n操作系统调度的最小单元是线程，也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程， 这些线程都拥有各自的计数器、 堆栈和局部变量等属性， 并且能够访问共享的内存变量。 处理器在这些线程上高速切换， 让使用者感觉到这些线程在同时执行。\n<!-- more -->\n#### 线程的创建\n\n* 通过继承Thread类来创建一个线程\n* 实现Runnable接口并重写run()方法，new Thread(runnable).start()，线程启动时就会自动调用该对象的run方法\n* 实现Callable接口并实现call()方法，使用FutureTask类包装Callable对象，使用FutureTask对象作为Thread对象的targer创建并启动线程；也可以使用线程池启动\n       Runnable 和 Callable 的区别\n        1. Runnable规定方法是run方法，Callable规定方法是call方法\n        2. Runnable任务执行后无返回值，Callable任务执行后可返回值\n        3. run方法无法抛出异常，call方法可以抛出异常\n        4. 运行Callable任务可以拿到一个Future对象，Future表示异步计算结果，他提供了检查计算是否完成的方法，以等待计算完成并获取结果。计算完成后用get()方法获取结果，如果线程没有执行完，get()方法会阻塞当前线程执行。如果线程出现异常，get()方法会抛出异常。\n* 线程池：Executors类提供了方便的工厂方法来创建不同类型的 executor services。无论Runnable还是Callable都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行\n      1. public static ExecutorService newCachedThreadPool() 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程，但是在之前构造的线程可用时将重用它们。\n      2. public static ExecutorService newFixedThreadPool(int nThreads)  创建一个定长线程池，可控制线程最大并发数，以共享的无界队列方式来运行线程，超出的线程会在队列中等待。\n      3. public static ExecutorService newSingleThreadExecutor() 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，以无界队列方式来运行线程，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n      4. public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 创建一个周期线程池，支持定时及周期性任务执行。\n      5. public static ExecutorService newWorkStealingPool() 创建持有足够线程的线程池来支持给定的并行级别，并通过使用多个队列，减少竞争，它需要穿一个并行级别的参数，如果不传，则被设定为默认的CPU数量，这个线程池实际上是ForkJoinPool的扩展，适合使用在很耗时的任务中，能够合理的使用CPU进行并行操作。\n\n#### 线程的管理\n* ForkJoinPool 的每个工作线程都维护了一个工作队列(WorkQueue)，这是一个双端队列，里面存放的对象是任务(ForkJoinTask)\n  * 每个工作线程在运行中产生新的任务(通常是因为调用了fork())，会放入工作队列的队尾，并且工作线程在处理自己的工作队列时，使用的是LIFO方式，也就是每次从队尾取任务执行。\n  * 每个工作线程在处理自己的工作队列时，会尝试窃取一个任务(或是来自刚刚提交到pool的任务，或是来自其他的工作队列)，窃取的任务位于其他线程工作队列的队首，也就是使用FIFO方式。\n  * 在遇到join()时如果join的任务尚未完成，则会先处理其他任务，并等待其完成。\n* ExecutorCompletionService 内部维护了一个阻塞队列(BlockingQueue), 只有完成的任务才被加入到队列中。如果队列中的数据为空时, 调用take()就会阻塞直到有完成的任务加入队列，基于FutureTask实现。\n\n# 线程池原理\n\n## ThreadPoolExecutor\n\n```java\n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.acc = System.getSecurityManager() == null ?\n                null :\n                AccessController.getContext();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n```\n\n\n* corePoolSize 核心线程数量，当有新任务在exectue()方法提交时，会执行以下判断：\n        1. 如果运行的线程少于 corePoolSize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的；\n        2. 如果线程池中的线程数量大于等于 corePoolSize 且小于 maximumPoolSize，则只有当workQueue满时才创建新的线程去处理任务；\n        3. 如果设置的corePoolSize 和 maximumPoolSize相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取任务并处理；\n        4. 如果运行的线程数量大于等于maximumPoolSize，这时如果workQueue已经满了，则通过handler所指定的策略来处理任务；\n        5. 所以，任务提交时，判断的顺序为 corePoolSize –> workQueue –> maximumPoolSize\n* maximumPoolSize 最大线程数量；\n* keepAliveTime 线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime；\n* TimeUnit 线程保持活动的时间单位\n* BlockingQueue<Runnable> workQueue 保存等待执行的任务的阻塞队列，当提交一个新的任务到线程池以后, 线程池会根据当前线程池中正在运行着的线程的数量来决定对该任务的处理方式，主要有以下几种处理方式:\n  * **直接切换**：这种方式常用的队列是SynchronousQueue\n  * **使用无界队列**：一般使用基于链表的阻塞队列LinkedBlockingQueue。如果使用这种方式，那么线程池中能够创建的最大线程数就是corePoolSize，而maximumPoolSize就不会起作用了。当线程池中所有的核心线程都是RUNNING状态时，这时一个新的任务提交就会放入等待队列中。\n  * **使用有界队列**：一般使用ArrayBlockingQueue。使用该方式可以将线程池的最大线程数量限制为maximumPoolSize，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。\n* threadFactory 它是ThreadFactory类型的变量，用来创建新线程。默认使用Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称。\n* handler 它是RejectedExecutionHandler类型的变量，表示线程池的饱和的**拒绝策略**。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。线程池提供了4种策略：\n  * AbortPolicy：直接抛出异常，这是默认策略；\n  * CallerRunsPolicy：用调用者所在的线程来执行任务；\n  * DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；\n  * DiscardPolicy：直接丢弃任务；\n\n## 线程池状态\n```java\n    private static final int COUNT_BITS = Integer.SIZE - 3;\n    private static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n    // runState is stored in the high-order bits\n    private static final int RUNNING    = -1 << COUNT_BITS;\n    private static final int SHUTDOWN   =  0 << COUNT_BITS;\n    private static final int STOP       =  1 << COUNT_BITS;\n    private static final int TIDYING    =  2 << COUNT_BITS;\n    private static final int TERMINATED =  3 << COUNT_BITS;\n```\n* COUNT_BITS: 线程的最大位数29位\n* CAPACITY：线程的最大容量\n* RUNNING：运行状态，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0\n* SHUTDOWN：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 \n* STOP：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。\n* TIDYING：当所有的任务已终止，任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。\n* TERMINATED：终止状态，当执行 terminated() 后会更新为这个状态。\n![](Java-ThreadPool/01.png)\n\n## 核心源码\n\n### 线程池执行源码\n\n#### execute\n```java\n    public void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n        \n        // clt记录着runState和workerCount\n        int c = ctl.get();\n        \n        // workerCountOf方法取出低29位的值，表示当前活动的线程数；\n        // 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中，并把任务添加到该线程中；\n        if (workerCountOf(c) < corePoolSize) {\n            \n            // addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；\n            // 如果为true，根据corePoolSize来判断；\n            // 如果为false，则根据maximumPoolSize来判断\n            if (addWorker(command, true))\n                return;\n            \n            // 如果添加失败，则重新获取ctl值\n            c = ctl.get();\n        }\n        \n        // 如果当前线程池是运行状态 并且 任务能够成功添加到工作队列\n        if (isRunning(c) && workQueue.offer(command)) {\n            \n            // 重新获取ctl值\n            int recheck = ctl.get();\n            \n            // 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，\n            // 这时需要移除该command\n            // 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回\n            if (! isRunning(recheck) && remove(command))\n                reject(command);\n            \n            // 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法\n            // 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；\n            // 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；\n            // 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n        }\n        // 如果执行到这里，有两种情况：\n        // 1.线程池已经不是RUNNING状态；\n        // 2.线程池是RUNNING状态，但workerCount >= corePoolSize并且workQueue已满;\n        // 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；\n        // 如果失败则拒绝该任务 \n        else if (!addWorker(command, false))\n            reject(command);\n    }\n\n```\n\nrunState和workCount变量怎么存储在一个int中？参考：https://blog.csdn.net/weixin_34396902/article/details/94527424\n\n#### addWorker\n\n```java\n    private boolean addWorker(Runnable firstTask, boolean core) {\n        // 循环CAS操作，将线程池中的线程数+1\n        retry:\n        for (;;) {\n            \n            // clt记录着runState和workerCount\n            int c = ctl.get();\n            \n            // 获取运行状态\n            int rs = runStateOf(c);\n\n            // 如果rs >= SHUTDOWN，则表示此时不再接收新任务；\n            // 接着判断以下3个条件，只要有1个不满足，则返回false：\n            // 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务\n            // 2. firsTask为空\n            // 3. 阻塞队列不为空\n            //\n            // rs == SHUTDOWN的情况\n            // 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；\n            // 如果firstTask为空，并且workQueue也为空，因为队列中已经没有任务了，不需要再添加线程了，则返回false，\n            if (rs >= SHUTDOWN &&\n                ! (rs == SHUTDOWN &&\n                   firstTask == null &&\n                   ! workQueue.isEmpty()))\n                return false;\n\n            for (;;) {\n                // 获取线程数\n                int wc = workerCountOf(c);\n                \n                // 如果wc超过CAPACITY(最大线程数线程数),也就是ctl的低29位的最大值（二进制是29个1），返回false；\n                // core是addWorker方法的第二个参数,如果为true表示根据corePoolSize来比较，如果为false则根据maximumPoolSize来比较;\n                if (wc >= CAPACITY ||\n                    wc >= (core ? corePoolSize : maximumPoolSize))\n                    return false;\n                \n                // CAS操作尝试增加workerCount，修改clt的值+1，如果成功，则跳出第一个for循环\n                if (compareAndIncrementWorkerCount(c))\n                    break retry;\n                \n                // 如果增加workerCount失败，则重新获取ctl的值\n                c = ctl.get();  \n                // 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行\n                if (runStateOf(c) != rs)\n                    continue retry;\n            }\n        }\n\n        // 新建线程，并加入到线程池workers中。\n        boolean workerStarted = false;\n        boolean workerAdded = false;\n        Worker w = null;\n        try {\n            // 根据firstTask来创建Worker对象\n            w = new Worker(firstTask);\n            \n            // 每一个Worker对象都会创建一个线程\n            final Thread t = w.thread;\n            \n            \n            if (t != null) {\n                // 对workers操作要通过加锁来实现\n                final ReentrantLock mainLock = this.mainLock;\n                mainLock.lock();\n                try {\n                    // 获取运行状态\n                    int rs = runStateOf(ctl.get());\n                    \n                    // rs < SHUTDOWN表示是RUNNING状态；\n                    // 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。\n                    // 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务\n                    if (rs < SHUTDOWN ||\n                        (rs == SHUTDOWN && firstTask == null)) {\n                        // 判断添加的任务状态,如果已经开始丢出异常\n                        if (t.isAlive()) \n                            throw new IllegalThreadStateException();\n                        \n                        // 将新建的线程加入到线程池中，workers是一个hashSet\n                        workers.add(w);\n                        int s = workers.size();\n                        \n                        // largestPoolSize记录着线程池中出现过的最大线程数量\n                        if (s > largestPoolSize)\n                            largestPoolSize = s;\n                        //标记任务添加\n                        workerAdded = true;\n                    }\n                } finally {\n                    mainLock.unlock();\n                }\n                if (workerAdded) {\n                    // 启动线程\n                    t.start();\n                    // 标记线程启动\n                    workerStarted = true;\n                }\n            }\n        } finally {\n            // 线程添加线程池失败或者线程start失败，则需要调用addWorkerFailed函数\n            // 如果添加成功则需要移除线程，并恢复复clt的值\n            if (! workerStarted)\n                addWorkerFailed(w);\n        }\n        return workerStarted;\n    }\n\n```\nt.start()这个语句，启动时会调用Worker类中的run方法，Worker本身实现了Runnable接口，所以一个Worker类型的对象也是一个线程。\n\n#### Worker类\n\n```java\n    private final class Worker extends AbstractQueuedSynchronizer implements Runnable\n    {\n\n        private static final long serialVersionUID = 6138294804551838833L;\n\n        /** 线程池中正真运行的线程。通过我们指定的线程工厂创建而来 **/\n        final Thread thread;\n        /** 线程包装的任务。thread 在run时主要调用了该任务的run方法 */\n        Runnable firstTask;\n        /** 记录当前线程完成的任务数 */\n        volatile long completedTasks;\n\n        /**\n         * Creates with given first task and thread from ThreadFactory.\n         * @param firstTask the first task (null if none)\n         */\n        Worker(Runnable firstTask) {\n            setState(-1); // 在调用runWorker()前，禁止interrupt中断，在interruptIfStarted()方法中会判断 getState()>=0\n            this.firstTask = firstTask;\n            // 利用我们指定的线程工厂创建一个线程\n            this.thread = getThreadFactory().newThread(this);\n        }\n\n        /** Delegates main run loop to outer runWorker  */\n        public void run() {\n            runWorker(this);\n        }\n\n        // Lock methods\n        //\n        // The value 0 represents the unlocked state.\n        // The value 1 represents the locked state.\n\n        protected boolean isHeldExclusively() {\n            return getState() != 0;\n        }\n\n        /**\n        * 尝试获取锁\n        */\n        protected boolean tryAcquire(int unused) {\n            //尝试一次将state从0设置为1，即“锁定”状态，\n            if (compareAndSetState(0, 1)) {\n                //设置exclusiveOwnerThread=当前线程\n                setExclusiveOwnerThread(Thread.currentThread());\n                return true;\n            }\n            return false;\n        }\n\n        /**\n        * 尝试释放锁\n        */\n        protected boolean tryRelease(int unused) {\n            setExclusiveOwnerThread(null);\n            setState(0);\n            return true;\n        }\n\n        public void lock()        { acquire(1); }\n        public boolean tryLock()  { return tryAcquire(1); }\n        public void unlock()      { release(1); }\n        public boolean isLocked() { return isHeldExclusively(); }\n\n\n        /**\n        * 中断（如果运行）\n        * shutdownNow时会循环对worker线程执行\n        * 且不需要获取worker锁，即使在worker运行时也可以中断\n        */\n        void interruptIfStarted() {\n            Thread t;\n            // 如果state>=0、t!=null、且t没有被中断\n            // new Worker()时state==-1，说明不能中断\n            if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {\n                try {\n                    t.interrupt();\n                } catch (SecurityException ignore) {\n                }\n            }\n        }\n    }\n```\n\nWorker类投机取巧的继承了AbstractQueuedSynchronizer来简化在执行任务时的获取、释放锁,这样防止了中断在运行中的任务，只会唤醒(中断)在等待从workQueue中获取任务的线程.\n不直接执行execute(command)提交的command，而要在外面包一层Worker主要是为了使用用AQS锁控制中断，当运行时上锁，就不能中断，TreadPoolExecutor的shutdown()方法中断前都要获取worker锁，只有在等待从workQueue中获取任务getTask()时才能中断。\n\n#### runWorker 方法\n\n在Worker类中的run方法调用了runWorker方法来执行任务.\n\n```java\n\n    final void runWorker(Worker w) {\n        Thread wt = Thread.currentThread();\n        \n        // 获取第一个任务\n        Runnable task = w.firstTask;\n        w.firstTask = null;\n        w.unlock(); // 允许中断\n        \n         // 是否因为异常退出循环\n        boolean completedAbruptly = true;\n        try {\n            \n            // 如果task为空，则通过getTask来获取任务\n            while (task != null || (task = getTask()) != null) {\n                w.lock();\n                // If pool is stopping, ensure thread is interrupted;\n                // if not, ensure thread is not interrupted.  This\n                // requires a recheck in second case to deal with\n                // shutdownNow race while clearing interrupt\n                // 线程池处于stop状态或者当前线程被中断时，线程池状态是stop状态\n                // 但是当前线程没有中断，则发出中断请求\n                if ((runStateAtLeast(ctl.get(), STOP) ||\n                     (Thread.interrupted() &&\n                      runStateAtLeast(ctl.get(), STOP))) &&\n                    !wt.isInterrupted())\n                    wt.interrupt();\n                try {\n                    //开始执行任务前的Hook，类似回调函数\n                    beforeExecute(wt, task);\n                    Throwable thrown = null;\n                    try {\n                        //执行任务\n                        task.run();\n                    } catch (RuntimeException x) {\n                        thrown = x; throw x;\n                    } catch (Error x) {\n                        thrown = x; throw x;\n                    } catch (Throwable x) {\n                        thrown = x; throw new Error(x);\n                    } finally {\n                        //任务执行后的Hook，类似回调函数\n                        afterExecute(task, thrown);\n                    }\n                } finally {\n                    //执行完毕后task重置，completedTasks计数器++，解锁\n                    task = null;\n                    w.completedTasks++;\n                    w.unlock();\n                }\n            }\n            //标记正常退出\n            completedAbruptly = false;\n        } finally {\n            //线程空闲达到我们设定的值时，Worker退出销毁。\n            processWorkerExit(w, completedAbruptly);\n        }\n    }\n\n```\n#### getTask 方法\n\nrunWorker函数中最重要的是getTask()，不断的从阻塞队列中取任务交给线程执行，并且负责线程回收\n\n```java\n    private Runnable getTask() {\n        // 表示上次从阻塞队列中取任务时是否超时\n        boolean timedOut = false; // Did the last poll() time out?\n\n        for (;;) {\n            int c = ctl.get();\n            int rs = runStateOf(c);\n\n            // 如果线程池处于shutdown状态，\n            // 并且队列为空，或者线程池处于stop或者terminate状态，\n            // 在线程池数量-1，返回null，回收线程\n            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n                decrementWorkerCount();\n                return null;\n            }\n\n            // 获取线程数\n            int wc = workerCountOf(c);\n\n            // timed变量用于判断是否需要进行超时控制。\n            // allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；\n            // wc > corePoolSize，表示当前线程池中的线程数量大于核心线程数量；\n            // 对于超过核心线程数量的这些线程，需要进行超时控制\n            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\n            // 如果线程数目大于最大线程数目 或 当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时\n            // 并且 线程数目大于1 或 工作队列为空\n            // 尝试将workerCount减1；\n            if ((wc > maximumPoolSize || (timed && timedOut))\n                && (wc > 1 || workQueue.isEmpty())) {\n                if (compareAndDecrementWorkerCount(c))\n                    return null;\n                continue;\n            }\n\n            try {\n                //**保证核心线程不被销毁**\n                // 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null；\n                // 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。\n                Runnable r = timed ?\n                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                    workQueue.take();\n                if (r != null)\n                    return r;\n                \n                // 如果 r == null，说明已经超时，timedOut设置为true，进入下一个循环\n                timedOut = true;\n            } catch (InterruptedException retry) {\n                // 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试\n                timedOut = false;\n            }\n        }\n    }\n```\n### FutureTask源码\n\n```java\n\npublic class FutureTask<V> implements RunnableFuture<V> {\n\n    /**\n     * state字段用来保存FutureTask内部的任务执行状态，一共有7中状态，每种状态及其对应的值如下\n     * NEW:表示是个新的任务或者还没被执行完的任务。这是初始状态。\n     * COMPLETING:任务已经执行完成或者执行任务的时候发生异常，但是任务执行结果或者异常原因还没有保存到outcome字段(outcome字段用来保存任务执行结果，如果发生异常，则用来保存异常原因)的时候，状态会从NEW变更到COMPLETING。但是这个状态会时间会比较短，属于中间状态。\n     * NORMAL:任务已经执行完成并且任务执行结果已经保存到outcome字段，状态会从COMPLETING转换到NORMAL。这是一个最终态。\n     * EXCEPTIONAL:任务执行发生异常并且异常原因已经保存到outcome字段中后，状态会从COMPLETING转换到EXCEPTIONAL。这是一个最终态。\n     * CANCELLED:任务还没开始执行或者已经开始执行但是还没有执行完成的时候，用户调用了cancel(false)方法取消任务且不中断任务执行线程，这个时候状态会从NEW转化为CANCELLED状态。这是一个最终态。\n     * INTERRUPTING: 任务还没开始执行或者已经执行但是还没有执行完成的时候，用户调用了cancel(true)方法取消任务并且要中断任务执行线程但是还没有中断任务执行线程之前，状态会从NEW转化为INTERRUPTING。这是一个中间状态。\n     * INTERRUPTED:调用interrupt()中断任务执行线程之后状态会从INTERRUPTING转换到INTERRUPTED。这是一个最终态。\n     * \n     * NEW -> COMPLETING -> NORMAL 正常执行并返回\n     * NEW -> COMPLETING -> EXCEPTIONAL 执行过程中出现了异常\n     * NEW -> CANCELLED 执行前被取消\n     * NEW -> INTERRUPTING -> INTERRUPTED 取消时被中断\n     */\n    private volatile int state;\n    private static final int NEW          = 0;\n    private static final int COMPLETING   = 1;//大于这个值就是完成状态\n    private static final int NORMAL       = 2;\n    private static final int EXCEPTIONAL  = 3;\n    private static final int CANCELLED    = 4;\n    private static final int INTERRUPTING = 5;\n    private static final int INTERRUPTED  = 6;\n\n    /** The underlying callable; nulled out after running */\n    private Callable<V> callable;\n    /** The result to return or exception to throw from get() */\n    private Object outcome; // non-volatile, protected by state reads/writes\n    /** 执行callable的线程 **/\n    private volatile Thread runner;\n    /** 使用Treiber算法实现的无阻塞的Stack，用于存放等待的线程 */\n    private volatile WaitNode waiters;\n\n    @SuppressWarnings(\"unchecked\")\n    private V report(int s) throws ExecutionException {\n        // 拿到返回结果\n        Object x = outcome;\n        // 判断状态\n        if (s == NORMAL)\n            // 状态正常，就返回结果值\n            return (V)x;\n        // 判断异常，就抛出异常。\n        if (s >= CANCELLED)\n            throw new CancellationException();\n        throw new ExecutionException((Throwable)x);\n    }\n\n    /**\n     * 构造方法\n     */\n    public FutureTask(Callable<V> callable) {\n        if (callable == null)\n            throw new NullPointerException();\n        this.callable = callable;\n        this.state = NEW;       // ensure visibility of callable\n    }\n\n    /**\n     * 这个构造方法会把传入的Runnable封装成一个Callable对象保存在callable字段中，同时如果任务执行成功的话就会返回传入的result。\n     * 这种情况下如果不需要返回值的话可以传入一个null。\n     */\n    public FutureTask(Runnable runnable, V result) {\n        this.callable = Executors.callable(runnable, result);\n        this.state = NEW;       // ensure visibility of callable\n    }\n\n    //判断任务是否被取消\n    public boolean isCancelled() {\n        return state >= CANCELLED;\n    }\n    //判断任务是否完成\n    public boolean isDone() {\n        return state != NEW;\n    }\n\n    public boolean cancel(boolean mayInterruptIfRunning) {\n        // 1. 任务是new状态 并且 根据mayInterruptIfRunning把状态从NEW转化到INTERRUPTING或CANCELLED \n        // 不符合上述状态，返回false\n        if (!(state == NEW &&\n              UNSAFE.compareAndSwapInt(this, stateOffset, NEW,\n                  mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))\n            return false;\n        try {    \n        // 2. 如果需要中断任务执行线程\n            if (mayInterruptIfRunning) {\n                try {\n                    // runner保存着当前执行任务的线程\n                    Thread t = runner;\n                    if (t != null)\n                        //中断任务执行线程\n                        t.interrupt();\n                } finally { // final state\n                    // 修改状态为INTERRUPTED\n                    UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);\n                }\n            }\n        } finally {\n            finishCompletion();\n        }\n        return true;\n    }\n\n\n    public V get() throws InterruptedException, ExecutionException {\n        int s = state;\n        // 判断任务当前的state <= COMPLETING是否成立。\n        if (s <= COMPLETING)\n            // 如果成立，表明任务还没有结束(这里的结束包括任务正常执行完毕，任务执行异常，任务被取消)\n            // 调用awaitDone()进行阻塞等待。\n            s = awaitDone(false, 0L);\n        // 任务已经结束，调用report()返回结果。\n        return report(s);\n    }\n\n\n    public V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException {\n        if (unit == null)\n            throw new NullPointerException();\n        int s = state;\n        // 如果awaitDone()超时返回之后任务还没结束，则抛出异常\n        if (s <= COMPLETING &&\n            (s = awaitDone(true, unit.toNanos(timeout))) <= COMPLETING)\n            throw new TimeoutException();\n        return report(s);\n    }\n\n\n    protected void done() { }\n\n\n    protected void set(V v) {\n        // 尝试CAS操作，把当前的状态从NEW变更为COMPLETING(中间状态)状态。\n        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n            // 把任务执行结果保存在outcome字段中。\n            outcome = v;\n            // CAS的把当前任务状态从COMPLETING变更为NORMAL\n            UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state\n            finishCompletion();\n        }\n    }\n\n\n    protected void setException(Throwable t) {\n        // 尝试CAS操作，把当前的状态从NEW变更为COMPLETING(中间状态)状态。\n        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n            // 把异常原因保存在outcome字段中，outcome字段用来保存任务执行结果或者异常原因。\n            outcome = t;\n            // CAS的把当前任务状态从COMPLETING变更为EXCEPTIONAL。\n            UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state\n            finishCompletion();\n        }\n    }\n\n\n    public void run() {\n        // 状态如果不是NEW，说明任务或者已经执行过，或者已经被取消，直接返回\n        // 状态如果是NEW，则尝试把当前执行线程保存在runner字段(runnerOffset)中，如果赋值失败则直接返回\n        if (state != NEW ||\n            !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                         null, Thread.currentThread()))\n            return;\n        try {\n            Callable<V> c = callable;\n            // 只有初始状态才会执行\n            if (c != null && state == NEW) {\n                V result;\n                boolean ran;\n                try {\n                    // 执行任务  计算逻辑\n                    result = c.call();\n                    ran = true;\n                } catch (Throwable ex) {\n                    result = null;\n                    ran = false;\n                    // 保存异常\n                    setException(ex);\n                }\n                if (ran)\n                    // 任务执行成功，保存返回结果\n                    set(result);\n            }\n        } finally {\n            // 无论是否执行成功，把runner设置为null\n            runner = null;\n            // state must be re-read after nulling runner to prevent\n            // leaked interrupts\n            int s = state;\n            // 如果任务被中断，执行中断处理\n            if (s >= INTERRUPTING)\n                handlePossibleCancellationInterrupt(s);\n        }\n    }\n\n    /**\n     * 与run方法类似，区别在于这个方法不会设置任务的执行结果值\n     *\n     * @return {@code true} if successfully run and reset\n     */\n    protected boolean runAndReset() {\n        if (state != NEW ||\n            !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                         null, Thread.currentThread()))\n            return false;\n        boolean ran = false;\n        int s = state;\n        try {\n            Callable<V> c = callable;\n            if (c != null && s == NEW) {\n                try {\n                    // 不获取和设置返回值\n                    c.call(); // don't set result\n                    ran = true;\n                } catch (Throwable ex) {\n                    setException(ex);\n                }\n            }\n        } finally {\n\n            runner = null;\n            s = state;\n            if (s >= INTERRUPTING)\n                handlePossibleCancellationInterrupt(s);\n        }\n        // 是否正确的执行并复位\n        return ran && s == NEW;\n    }\n\n\n    private void handlePossibleCancellationInterrupt(int s) {\n        if (s == INTERRUPTING)\n            while (state == INTERRUPTING)\n                Thread.yield(); // wait out pending interrupt\n\n        // 确保cancel(true)产生的中断发生在run或runAndReset方法执行的过程中。\n        //这里会循环的调用Thread.yield()来确保状态在cancel方法中被设置为INTERRUPTED。\n    }\n\n    /**\n     * Simple linked list nodes to record waiting threads in a Treiber\n     * stack.  See other classes such as Phaser and SynchronousQueue\n     * for more detailed explanation.\n     */\n    static final class WaitNode {\n        volatile Thread thread;\n        volatile WaitNode next;\n        WaitNode() { thread = Thread.currentThread(); }\n    }\n\n    /**\n     * Removes and signals all waiting threads, invokes done(), and\n     * nulls out callable.\n     */\n    private void finishCompletion() {\n        // assert state > COMPLETING;\n        // 执行该方法时state必须大于COMPLETING\n        // 依次遍历waiters链表\n        for (WaitNode q; (q = waiters) != null;) {\n            // 设置栈顶节点为null\n            if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {\n                for (;;) {\n                    Thread t = q.thread;\n                    if (t != null) {\n                        q.thread = null;\n                        // 唤醒等待线程\n                        LockSupport.unpark(t);\n                    }\n                    WaitNode next = q.next;\n                    // 如果next为空，说明栈空了，跳出循环\n                    if (next == null)\n                        break;\n                    // 方便gc回收\n                    q.next = null; \n                    // 重新设置栈顶node\n                    q = next;\n                }\n                break;\n            }\n        }\n        // 空方法，留给子类扩展\n        done();\n\n        callable = null;        // to reduce footprint\n    }\n\n    /**\n     * Awaits completion or aborts on interrupt or timeout.\n     *\n     * @param timed true if use timed waits\n     * @param nanos time to wait, if timed\n     * @return state upon completion\n     */\n    private int awaitDone(boolean timed, long nanos)\n        throws InterruptedException {\n        // 计算等待截止时间\n        final long deadline = timed ? System.nanoTime() + nanos : 0L;\n        WaitNode q = null;\n        boolean queued = false;\n        for (;;) {\n            // 1. 判断阻塞线程是否被中断\n            if (Thread.interrupted()) {\n                // 被中断则在等待队列中删除该节点\n                removeWaiter(q);\n                // 抛出InterruptedException异常\n                throw new InterruptedException();\n            }\n\n            int s = state;\n            // 2. 获取当前状态，如果状态大于COMPLETING\n            if (s > COMPLETING) {\n                // 说明任务已经结束(要么正常结束，要么异常结束，要么被取消)\n                if (q != null)\n                    // 把thread显示置空\n                    q.thread = null;\n                // 返回结果\n                return s;\n            }\n            // 3. 如果状态处于中间状态COMPLETING\n            // 表示任务已经结束但是任务执行线程还没来得及给outcome赋值\n            else if (s == COMPLETING) // cannot time out yet\n                Thread.yield();// 让出执行权让其他线程优先执行\n            // 4. 如果等待节点为空，则构造一个等待节点\n            else if (q == null)\n                q = new WaitNode();\n            // 5. 如果还没有入队列，则把当前节点加入waiters首节点并替换原来waiters\n            else if (!queued)\n                queued = UNSAFE.compareAndSwapObject(this, waitersOffset,\n                                                     q.next = waiters, q);\n            else if (timed) {\n                // 如果需要等待特定时间，则先计算要等待的时间\n                // 如果已经超时，则删除对应节点并返回对应的状态\n                nanos = deadline - System.nanoTime();\n                if (nanos <= 0L) {\n                    removeWaiter(q);\n                    return state;\n                }\n                // 6. 阻塞等待特定时间\n                LockSupport.parkNanos(this, nanos);\n            }\n            // 6. 阻塞等待直到被其他线程唤醒\n            else\n                LockSupport.park(this);\n        }\n    }\n\n\n    private void removeWaiter(WaitNode node) {\n        if (node != null) {\n            // 将thread设置为null是因为下面要根据thread是否为null判断是否要把node移出\n            node.thread = null;\n            // 这里自旋保证删除成功\n            retry:\n            for (;;) {          // restart on removeWaiter race\n                for (WaitNode pred = null, q = waiters, s; q != null; q = s) {\n                    s = q.next;\n                    // q.thread != null说明该q节点不需要移除\n                    if (q.thread != null)\n                        pred = q;\n                    // 如果q.thread == null，且pred != null，需要删除q节点\n                    else if (pred != null) {\n                        // 删除q节点\n                        pred.next = s;\n                         // pred.thread == null时说明在并发情况下被其他线程修改了；\n                         // 返回第一个for循环重试\n                        if (pred.thread == null) // check for race\n                            continue retry;\n                    }\n                     // 如果q.thread != null且pred == null，说明q是栈顶节点\n                     // 设置栈顶元素为s节点，如果失败则返回重试\n                    else if (!UNSAFE.compareAndSwapObject(this, waitersOffset,\n                                                          q, s))\n                        continue retry;\n                }\n                break;\n            }\n        }\n    }\n\n    // Unsafe mechanics\n    private static final sun.misc.Unsafe UNSAFE;\n    private static final long stateOffset;\n    private static final long runnerOffset;\n    private static final long waitersOffset;\n    static {\n        try {\n            UNSAFE = sun.misc.Unsafe.getUnsafe();\n            Class<?> k = FutureTask.class;\n            stateOffset = UNSAFE.objectFieldOffset\n                (k.getDeclaredField(\"state\"));\n            runnerOffset = UNSAFE.objectFieldOffset\n                (k.getDeclaredField(\"runner\"));\n            waitersOffset = UNSAFE.objectFieldOffset\n                (k.getDeclaredField(\"waiters\"));\n        } catch (Exception e) {\n            throw new Error(e);\n        }\n    }\n\n}\n\n```\n## 线程池中的线程初始化\n\n　　默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：\n* prestartCoreThread()：初始化一个核心线程；\n* prestartAllCoreThreads()：初始化所有核心线程\n\n## 线程池的关闭\nThreadPoolExecutor提供了两个方法，用于线程池的关闭\n* shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务\n* shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务\n\n## 线程池大小\n1. 粗略\n    1. 如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1\n    2. 如果是IO密集型任务，参考值可以设置为2*NCPU\n2. 精确：（(线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目\n3. 最佳：压测\n\n## 任务缓存队列\n\n**workQueue**，它用来存放等待执行的任务。BlockingQueue 是个接口，你需要使用它的实现之一来使用BlockingQueue，java.util.concurrent包下具有以下 BlockingQueue 接口的实现类：\n* ArrayBlockingQueue：ArrayBlockingQueue 是一个有界的阻塞队列，其内部实现是将对象放到一个数组里。有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了(译者注：因为它是基于数组实现的，也就具有数组的特性：一旦初始化，大小就无法修改)。\n* LinkedBlockingQueue：LinkedBlockingQueue 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。\n* DelayQueue：DelayQueue 对元素进行持有直到一个特定的延迟到期。注入其中的元素必须实现 java.util.concurrent.Delayed 接口。\n* PriorityBlockingQueue：PriorityBlockingQueue 是一个无界的并发队列。它使用了和类 java.util.PriorityQueue 一样的排序规则。你无法向这个队列中插入 null 值。所有插入到 PriorityBlockingQueue 的元素必须实现 java.lang.Comparable 接口。因此该队列中元素的排序就取决于你自己的 Comparable 实现。\n* SynchronousQueue：SynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。\n\n\n## 线程池总结\n1. 线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。\n2. 当调用 execute() 方法添加一个任务时，线程池会做如下判断：\n     1. 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；\n     2. 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；\n     3. 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；\n     4. 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。\n     5. 当一个线程完成任务时，它会从队列中取下一个任务来执行。\n     6. 当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。\n\n","source":"_posts/Java-ThreadPool.md","raw":"---\ntitle: JAVA-线程池\ndate: 2019-10-21 17:23:04\ntags:\n    - JAVA\n    - 线程池\n    - 学习笔记\ncategories: JAVA\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n# 线程\n\n#### 概念\n操作系统调度的最小单元是线程，也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程， 这些线程都拥有各自的计数器、 堆栈和局部变量等属性， 并且能够访问共享的内存变量。 处理器在这些线程上高速切换， 让使用者感觉到这些线程在同时执行。\n<!-- more -->\n#### 线程的创建\n\n* 通过继承Thread类来创建一个线程\n* 实现Runnable接口并重写run()方法，new Thread(runnable).start()，线程启动时就会自动调用该对象的run方法\n* 实现Callable接口并实现call()方法，使用FutureTask类包装Callable对象，使用FutureTask对象作为Thread对象的targer创建并启动线程；也可以使用线程池启动\n       Runnable 和 Callable 的区别\n        1. Runnable规定方法是run方法，Callable规定方法是call方法\n        2. Runnable任务执行后无返回值，Callable任务执行后可返回值\n        3. run方法无法抛出异常，call方法可以抛出异常\n        4. 运行Callable任务可以拿到一个Future对象，Future表示异步计算结果，他提供了检查计算是否完成的方法，以等待计算完成并获取结果。计算完成后用get()方法获取结果，如果线程没有执行完，get()方法会阻塞当前线程执行。如果线程出现异常，get()方法会抛出异常。\n* 线程池：Executors类提供了方便的工厂方法来创建不同类型的 executor services。无论Runnable还是Callable都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行\n      1. public static ExecutorService newCachedThreadPool() 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程，但是在之前构造的线程可用时将重用它们。\n      2. public static ExecutorService newFixedThreadPool(int nThreads)  创建一个定长线程池，可控制线程最大并发数，以共享的无界队列方式来运行线程，超出的线程会在队列中等待。\n      3. public static ExecutorService newSingleThreadExecutor() 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，以无界队列方式来运行线程，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n      4. public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 创建一个周期线程池，支持定时及周期性任务执行。\n      5. public static ExecutorService newWorkStealingPool() 创建持有足够线程的线程池来支持给定的并行级别，并通过使用多个队列，减少竞争，它需要穿一个并行级别的参数，如果不传，则被设定为默认的CPU数量，这个线程池实际上是ForkJoinPool的扩展，适合使用在很耗时的任务中，能够合理的使用CPU进行并行操作。\n\n#### 线程的管理\n* ForkJoinPool 的每个工作线程都维护了一个工作队列(WorkQueue)，这是一个双端队列，里面存放的对象是任务(ForkJoinTask)\n  * 每个工作线程在运行中产生新的任务(通常是因为调用了fork())，会放入工作队列的队尾，并且工作线程在处理自己的工作队列时，使用的是LIFO方式，也就是每次从队尾取任务执行。\n  * 每个工作线程在处理自己的工作队列时，会尝试窃取一个任务(或是来自刚刚提交到pool的任务，或是来自其他的工作队列)，窃取的任务位于其他线程工作队列的队首，也就是使用FIFO方式。\n  * 在遇到join()时如果join的任务尚未完成，则会先处理其他任务，并等待其完成。\n* ExecutorCompletionService 内部维护了一个阻塞队列(BlockingQueue), 只有完成的任务才被加入到队列中。如果队列中的数据为空时, 调用take()就会阻塞直到有完成的任务加入队列，基于FutureTask实现。\n\n# 线程池原理\n\n## ThreadPoolExecutor\n\n```java\n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.acc = System.getSecurityManager() == null ?\n                null :\n                AccessController.getContext();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n```\n\n\n* corePoolSize 核心线程数量，当有新任务在exectue()方法提交时，会执行以下判断：\n        1. 如果运行的线程少于 corePoolSize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的；\n        2. 如果线程池中的线程数量大于等于 corePoolSize 且小于 maximumPoolSize，则只有当workQueue满时才创建新的线程去处理任务；\n        3. 如果设置的corePoolSize 和 maximumPoolSize相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取任务并处理；\n        4. 如果运行的线程数量大于等于maximumPoolSize，这时如果workQueue已经满了，则通过handler所指定的策略来处理任务；\n        5. 所以，任务提交时，判断的顺序为 corePoolSize –> workQueue –> maximumPoolSize\n* maximumPoolSize 最大线程数量；\n* keepAliveTime 线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime；\n* TimeUnit 线程保持活动的时间单位\n* BlockingQueue<Runnable> workQueue 保存等待执行的任务的阻塞队列，当提交一个新的任务到线程池以后, 线程池会根据当前线程池中正在运行着的线程的数量来决定对该任务的处理方式，主要有以下几种处理方式:\n  * **直接切换**：这种方式常用的队列是SynchronousQueue\n  * **使用无界队列**：一般使用基于链表的阻塞队列LinkedBlockingQueue。如果使用这种方式，那么线程池中能够创建的最大线程数就是corePoolSize，而maximumPoolSize就不会起作用了。当线程池中所有的核心线程都是RUNNING状态时，这时一个新的任务提交就会放入等待队列中。\n  * **使用有界队列**：一般使用ArrayBlockingQueue。使用该方式可以将线程池的最大线程数量限制为maximumPoolSize，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。\n* threadFactory 它是ThreadFactory类型的变量，用来创建新线程。默认使用Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称。\n* handler 它是RejectedExecutionHandler类型的变量，表示线程池的饱和的**拒绝策略**。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。线程池提供了4种策略：\n  * AbortPolicy：直接抛出异常，这是默认策略；\n  * CallerRunsPolicy：用调用者所在的线程来执行任务；\n  * DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；\n  * DiscardPolicy：直接丢弃任务；\n\n## 线程池状态\n```java\n    private static final int COUNT_BITS = Integer.SIZE - 3;\n    private static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n    // runState is stored in the high-order bits\n    private static final int RUNNING    = -1 << COUNT_BITS;\n    private static final int SHUTDOWN   =  0 << COUNT_BITS;\n    private static final int STOP       =  1 << COUNT_BITS;\n    private static final int TIDYING    =  2 << COUNT_BITS;\n    private static final int TERMINATED =  3 << COUNT_BITS;\n```\n* COUNT_BITS: 线程的最大位数29位\n* CAPACITY：线程的最大容量\n* RUNNING：运行状态，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0\n* SHUTDOWN：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 \n* STOP：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。\n* TIDYING：当所有的任务已终止，任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。\n* TERMINATED：终止状态，当执行 terminated() 后会更新为这个状态。\n![](Java-ThreadPool/01.png)\n\n## 核心源码\n\n### 线程池执行源码\n\n#### execute\n```java\n    public void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n        \n        // clt记录着runState和workerCount\n        int c = ctl.get();\n        \n        // workerCountOf方法取出低29位的值，表示当前活动的线程数；\n        // 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中，并把任务添加到该线程中；\n        if (workerCountOf(c) < corePoolSize) {\n            \n            // addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；\n            // 如果为true，根据corePoolSize来判断；\n            // 如果为false，则根据maximumPoolSize来判断\n            if (addWorker(command, true))\n                return;\n            \n            // 如果添加失败，则重新获取ctl值\n            c = ctl.get();\n        }\n        \n        // 如果当前线程池是运行状态 并且 任务能够成功添加到工作队列\n        if (isRunning(c) && workQueue.offer(command)) {\n            \n            // 重新获取ctl值\n            int recheck = ctl.get();\n            \n            // 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，\n            // 这时需要移除该command\n            // 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回\n            if (! isRunning(recheck) && remove(command))\n                reject(command);\n            \n            // 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法\n            // 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；\n            // 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；\n            // 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n        }\n        // 如果执行到这里，有两种情况：\n        // 1.线程池已经不是RUNNING状态；\n        // 2.线程池是RUNNING状态，但workerCount >= corePoolSize并且workQueue已满;\n        // 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；\n        // 如果失败则拒绝该任务 \n        else if (!addWorker(command, false))\n            reject(command);\n    }\n\n```\n\nrunState和workCount变量怎么存储在一个int中？参考：https://blog.csdn.net/weixin_34396902/article/details/94527424\n\n#### addWorker\n\n```java\n    private boolean addWorker(Runnable firstTask, boolean core) {\n        // 循环CAS操作，将线程池中的线程数+1\n        retry:\n        for (;;) {\n            \n            // clt记录着runState和workerCount\n            int c = ctl.get();\n            \n            // 获取运行状态\n            int rs = runStateOf(c);\n\n            // 如果rs >= SHUTDOWN，则表示此时不再接收新任务；\n            // 接着判断以下3个条件，只要有1个不满足，则返回false：\n            // 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务\n            // 2. firsTask为空\n            // 3. 阻塞队列不为空\n            //\n            // rs == SHUTDOWN的情况\n            // 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；\n            // 如果firstTask为空，并且workQueue也为空，因为队列中已经没有任务了，不需要再添加线程了，则返回false，\n            if (rs >= SHUTDOWN &&\n                ! (rs == SHUTDOWN &&\n                   firstTask == null &&\n                   ! workQueue.isEmpty()))\n                return false;\n\n            for (;;) {\n                // 获取线程数\n                int wc = workerCountOf(c);\n                \n                // 如果wc超过CAPACITY(最大线程数线程数),也就是ctl的低29位的最大值（二进制是29个1），返回false；\n                // core是addWorker方法的第二个参数,如果为true表示根据corePoolSize来比较，如果为false则根据maximumPoolSize来比较;\n                if (wc >= CAPACITY ||\n                    wc >= (core ? corePoolSize : maximumPoolSize))\n                    return false;\n                \n                // CAS操作尝试增加workerCount，修改clt的值+1，如果成功，则跳出第一个for循环\n                if (compareAndIncrementWorkerCount(c))\n                    break retry;\n                \n                // 如果增加workerCount失败，则重新获取ctl的值\n                c = ctl.get();  \n                // 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行\n                if (runStateOf(c) != rs)\n                    continue retry;\n            }\n        }\n\n        // 新建线程，并加入到线程池workers中。\n        boolean workerStarted = false;\n        boolean workerAdded = false;\n        Worker w = null;\n        try {\n            // 根据firstTask来创建Worker对象\n            w = new Worker(firstTask);\n            \n            // 每一个Worker对象都会创建一个线程\n            final Thread t = w.thread;\n            \n            \n            if (t != null) {\n                // 对workers操作要通过加锁来实现\n                final ReentrantLock mainLock = this.mainLock;\n                mainLock.lock();\n                try {\n                    // 获取运行状态\n                    int rs = runStateOf(ctl.get());\n                    \n                    // rs < SHUTDOWN表示是RUNNING状态；\n                    // 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。\n                    // 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务\n                    if (rs < SHUTDOWN ||\n                        (rs == SHUTDOWN && firstTask == null)) {\n                        // 判断添加的任务状态,如果已经开始丢出异常\n                        if (t.isAlive()) \n                            throw new IllegalThreadStateException();\n                        \n                        // 将新建的线程加入到线程池中，workers是一个hashSet\n                        workers.add(w);\n                        int s = workers.size();\n                        \n                        // largestPoolSize记录着线程池中出现过的最大线程数量\n                        if (s > largestPoolSize)\n                            largestPoolSize = s;\n                        //标记任务添加\n                        workerAdded = true;\n                    }\n                } finally {\n                    mainLock.unlock();\n                }\n                if (workerAdded) {\n                    // 启动线程\n                    t.start();\n                    // 标记线程启动\n                    workerStarted = true;\n                }\n            }\n        } finally {\n            // 线程添加线程池失败或者线程start失败，则需要调用addWorkerFailed函数\n            // 如果添加成功则需要移除线程，并恢复复clt的值\n            if (! workerStarted)\n                addWorkerFailed(w);\n        }\n        return workerStarted;\n    }\n\n```\nt.start()这个语句，启动时会调用Worker类中的run方法，Worker本身实现了Runnable接口，所以一个Worker类型的对象也是一个线程。\n\n#### Worker类\n\n```java\n    private final class Worker extends AbstractQueuedSynchronizer implements Runnable\n    {\n\n        private static final long serialVersionUID = 6138294804551838833L;\n\n        /** 线程池中正真运行的线程。通过我们指定的线程工厂创建而来 **/\n        final Thread thread;\n        /** 线程包装的任务。thread 在run时主要调用了该任务的run方法 */\n        Runnable firstTask;\n        /** 记录当前线程完成的任务数 */\n        volatile long completedTasks;\n\n        /**\n         * Creates with given first task and thread from ThreadFactory.\n         * @param firstTask the first task (null if none)\n         */\n        Worker(Runnable firstTask) {\n            setState(-1); // 在调用runWorker()前，禁止interrupt中断，在interruptIfStarted()方法中会判断 getState()>=0\n            this.firstTask = firstTask;\n            // 利用我们指定的线程工厂创建一个线程\n            this.thread = getThreadFactory().newThread(this);\n        }\n\n        /** Delegates main run loop to outer runWorker  */\n        public void run() {\n            runWorker(this);\n        }\n\n        // Lock methods\n        //\n        // The value 0 represents the unlocked state.\n        // The value 1 represents the locked state.\n\n        protected boolean isHeldExclusively() {\n            return getState() != 0;\n        }\n\n        /**\n        * 尝试获取锁\n        */\n        protected boolean tryAcquire(int unused) {\n            //尝试一次将state从0设置为1，即“锁定”状态，\n            if (compareAndSetState(0, 1)) {\n                //设置exclusiveOwnerThread=当前线程\n                setExclusiveOwnerThread(Thread.currentThread());\n                return true;\n            }\n            return false;\n        }\n\n        /**\n        * 尝试释放锁\n        */\n        protected boolean tryRelease(int unused) {\n            setExclusiveOwnerThread(null);\n            setState(0);\n            return true;\n        }\n\n        public void lock()        { acquire(1); }\n        public boolean tryLock()  { return tryAcquire(1); }\n        public void unlock()      { release(1); }\n        public boolean isLocked() { return isHeldExclusively(); }\n\n\n        /**\n        * 中断（如果运行）\n        * shutdownNow时会循环对worker线程执行\n        * 且不需要获取worker锁，即使在worker运行时也可以中断\n        */\n        void interruptIfStarted() {\n            Thread t;\n            // 如果state>=0、t!=null、且t没有被中断\n            // new Worker()时state==-1，说明不能中断\n            if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {\n                try {\n                    t.interrupt();\n                } catch (SecurityException ignore) {\n                }\n            }\n        }\n    }\n```\n\nWorker类投机取巧的继承了AbstractQueuedSynchronizer来简化在执行任务时的获取、释放锁,这样防止了中断在运行中的任务，只会唤醒(中断)在等待从workQueue中获取任务的线程.\n不直接执行execute(command)提交的command，而要在外面包一层Worker主要是为了使用用AQS锁控制中断，当运行时上锁，就不能中断，TreadPoolExecutor的shutdown()方法中断前都要获取worker锁，只有在等待从workQueue中获取任务getTask()时才能中断。\n\n#### runWorker 方法\n\n在Worker类中的run方法调用了runWorker方法来执行任务.\n\n```java\n\n    final void runWorker(Worker w) {\n        Thread wt = Thread.currentThread();\n        \n        // 获取第一个任务\n        Runnable task = w.firstTask;\n        w.firstTask = null;\n        w.unlock(); // 允许中断\n        \n         // 是否因为异常退出循环\n        boolean completedAbruptly = true;\n        try {\n            \n            // 如果task为空，则通过getTask来获取任务\n            while (task != null || (task = getTask()) != null) {\n                w.lock();\n                // If pool is stopping, ensure thread is interrupted;\n                // if not, ensure thread is not interrupted.  This\n                // requires a recheck in second case to deal with\n                // shutdownNow race while clearing interrupt\n                // 线程池处于stop状态或者当前线程被中断时，线程池状态是stop状态\n                // 但是当前线程没有中断，则发出中断请求\n                if ((runStateAtLeast(ctl.get(), STOP) ||\n                     (Thread.interrupted() &&\n                      runStateAtLeast(ctl.get(), STOP))) &&\n                    !wt.isInterrupted())\n                    wt.interrupt();\n                try {\n                    //开始执行任务前的Hook，类似回调函数\n                    beforeExecute(wt, task);\n                    Throwable thrown = null;\n                    try {\n                        //执行任务\n                        task.run();\n                    } catch (RuntimeException x) {\n                        thrown = x; throw x;\n                    } catch (Error x) {\n                        thrown = x; throw x;\n                    } catch (Throwable x) {\n                        thrown = x; throw new Error(x);\n                    } finally {\n                        //任务执行后的Hook，类似回调函数\n                        afterExecute(task, thrown);\n                    }\n                } finally {\n                    //执行完毕后task重置，completedTasks计数器++，解锁\n                    task = null;\n                    w.completedTasks++;\n                    w.unlock();\n                }\n            }\n            //标记正常退出\n            completedAbruptly = false;\n        } finally {\n            //线程空闲达到我们设定的值时，Worker退出销毁。\n            processWorkerExit(w, completedAbruptly);\n        }\n    }\n\n```\n#### getTask 方法\n\nrunWorker函数中最重要的是getTask()，不断的从阻塞队列中取任务交给线程执行，并且负责线程回收\n\n```java\n    private Runnable getTask() {\n        // 表示上次从阻塞队列中取任务时是否超时\n        boolean timedOut = false; // Did the last poll() time out?\n\n        for (;;) {\n            int c = ctl.get();\n            int rs = runStateOf(c);\n\n            // 如果线程池处于shutdown状态，\n            // 并且队列为空，或者线程池处于stop或者terminate状态，\n            // 在线程池数量-1，返回null，回收线程\n            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n                decrementWorkerCount();\n                return null;\n            }\n\n            // 获取线程数\n            int wc = workerCountOf(c);\n\n            // timed变量用于判断是否需要进行超时控制。\n            // allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；\n            // wc > corePoolSize，表示当前线程池中的线程数量大于核心线程数量；\n            // 对于超过核心线程数量的这些线程，需要进行超时控制\n            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\n            // 如果线程数目大于最大线程数目 或 当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时\n            // 并且 线程数目大于1 或 工作队列为空\n            // 尝试将workerCount减1；\n            if ((wc > maximumPoolSize || (timed && timedOut))\n                && (wc > 1 || workQueue.isEmpty())) {\n                if (compareAndDecrementWorkerCount(c))\n                    return null;\n                continue;\n            }\n\n            try {\n                //**保证核心线程不被销毁**\n                // 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null；\n                // 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。\n                Runnable r = timed ?\n                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                    workQueue.take();\n                if (r != null)\n                    return r;\n                \n                // 如果 r == null，说明已经超时，timedOut设置为true，进入下一个循环\n                timedOut = true;\n            } catch (InterruptedException retry) {\n                // 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试\n                timedOut = false;\n            }\n        }\n    }\n```\n### FutureTask源码\n\n```java\n\npublic class FutureTask<V> implements RunnableFuture<V> {\n\n    /**\n     * state字段用来保存FutureTask内部的任务执行状态，一共有7中状态，每种状态及其对应的值如下\n     * NEW:表示是个新的任务或者还没被执行完的任务。这是初始状态。\n     * COMPLETING:任务已经执行完成或者执行任务的时候发生异常，但是任务执行结果或者异常原因还没有保存到outcome字段(outcome字段用来保存任务执行结果，如果发生异常，则用来保存异常原因)的时候，状态会从NEW变更到COMPLETING。但是这个状态会时间会比较短，属于中间状态。\n     * NORMAL:任务已经执行完成并且任务执行结果已经保存到outcome字段，状态会从COMPLETING转换到NORMAL。这是一个最终态。\n     * EXCEPTIONAL:任务执行发生异常并且异常原因已经保存到outcome字段中后，状态会从COMPLETING转换到EXCEPTIONAL。这是一个最终态。\n     * CANCELLED:任务还没开始执行或者已经开始执行但是还没有执行完成的时候，用户调用了cancel(false)方法取消任务且不中断任务执行线程，这个时候状态会从NEW转化为CANCELLED状态。这是一个最终态。\n     * INTERRUPTING: 任务还没开始执行或者已经执行但是还没有执行完成的时候，用户调用了cancel(true)方法取消任务并且要中断任务执行线程但是还没有中断任务执行线程之前，状态会从NEW转化为INTERRUPTING。这是一个中间状态。\n     * INTERRUPTED:调用interrupt()中断任务执行线程之后状态会从INTERRUPTING转换到INTERRUPTED。这是一个最终态。\n     * \n     * NEW -> COMPLETING -> NORMAL 正常执行并返回\n     * NEW -> COMPLETING -> EXCEPTIONAL 执行过程中出现了异常\n     * NEW -> CANCELLED 执行前被取消\n     * NEW -> INTERRUPTING -> INTERRUPTED 取消时被中断\n     */\n    private volatile int state;\n    private static final int NEW          = 0;\n    private static final int COMPLETING   = 1;//大于这个值就是完成状态\n    private static final int NORMAL       = 2;\n    private static final int EXCEPTIONAL  = 3;\n    private static final int CANCELLED    = 4;\n    private static final int INTERRUPTING = 5;\n    private static final int INTERRUPTED  = 6;\n\n    /** The underlying callable; nulled out after running */\n    private Callable<V> callable;\n    /** The result to return or exception to throw from get() */\n    private Object outcome; // non-volatile, protected by state reads/writes\n    /** 执行callable的线程 **/\n    private volatile Thread runner;\n    /** 使用Treiber算法实现的无阻塞的Stack，用于存放等待的线程 */\n    private volatile WaitNode waiters;\n\n    @SuppressWarnings(\"unchecked\")\n    private V report(int s) throws ExecutionException {\n        // 拿到返回结果\n        Object x = outcome;\n        // 判断状态\n        if (s == NORMAL)\n            // 状态正常，就返回结果值\n            return (V)x;\n        // 判断异常，就抛出异常。\n        if (s >= CANCELLED)\n            throw new CancellationException();\n        throw new ExecutionException((Throwable)x);\n    }\n\n    /**\n     * 构造方法\n     */\n    public FutureTask(Callable<V> callable) {\n        if (callable == null)\n            throw new NullPointerException();\n        this.callable = callable;\n        this.state = NEW;       // ensure visibility of callable\n    }\n\n    /**\n     * 这个构造方法会把传入的Runnable封装成一个Callable对象保存在callable字段中，同时如果任务执行成功的话就会返回传入的result。\n     * 这种情况下如果不需要返回值的话可以传入一个null。\n     */\n    public FutureTask(Runnable runnable, V result) {\n        this.callable = Executors.callable(runnable, result);\n        this.state = NEW;       // ensure visibility of callable\n    }\n\n    //判断任务是否被取消\n    public boolean isCancelled() {\n        return state >= CANCELLED;\n    }\n    //判断任务是否完成\n    public boolean isDone() {\n        return state != NEW;\n    }\n\n    public boolean cancel(boolean mayInterruptIfRunning) {\n        // 1. 任务是new状态 并且 根据mayInterruptIfRunning把状态从NEW转化到INTERRUPTING或CANCELLED \n        // 不符合上述状态，返回false\n        if (!(state == NEW &&\n              UNSAFE.compareAndSwapInt(this, stateOffset, NEW,\n                  mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))\n            return false;\n        try {    \n        // 2. 如果需要中断任务执行线程\n            if (mayInterruptIfRunning) {\n                try {\n                    // runner保存着当前执行任务的线程\n                    Thread t = runner;\n                    if (t != null)\n                        //中断任务执行线程\n                        t.interrupt();\n                } finally { // final state\n                    // 修改状态为INTERRUPTED\n                    UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);\n                }\n            }\n        } finally {\n            finishCompletion();\n        }\n        return true;\n    }\n\n\n    public V get() throws InterruptedException, ExecutionException {\n        int s = state;\n        // 判断任务当前的state <= COMPLETING是否成立。\n        if (s <= COMPLETING)\n            // 如果成立，表明任务还没有结束(这里的结束包括任务正常执行完毕，任务执行异常，任务被取消)\n            // 调用awaitDone()进行阻塞等待。\n            s = awaitDone(false, 0L);\n        // 任务已经结束，调用report()返回结果。\n        return report(s);\n    }\n\n\n    public V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException {\n        if (unit == null)\n            throw new NullPointerException();\n        int s = state;\n        // 如果awaitDone()超时返回之后任务还没结束，则抛出异常\n        if (s <= COMPLETING &&\n            (s = awaitDone(true, unit.toNanos(timeout))) <= COMPLETING)\n            throw new TimeoutException();\n        return report(s);\n    }\n\n\n    protected void done() { }\n\n\n    protected void set(V v) {\n        // 尝试CAS操作，把当前的状态从NEW变更为COMPLETING(中间状态)状态。\n        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n            // 把任务执行结果保存在outcome字段中。\n            outcome = v;\n            // CAS的把当前任务状态从COMPLETING变更为NORMAL\n            UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state\n            finishCompletion();\n        }\n    }\n\n\n    protected void setException(Throwable t) {\n        // 尝试CAS操作，把当前的状态从NEW变更为COMPLETING(中间状态)状态。\n        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n            // 把异常原因保存在outcome字段中，outcome字段用来保存任务执行结果或者异常原因。\n            outcome = t;\n            // CAS的把当前任务状态从COMPLETING变更为EXCEPTIONAL。\n            UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state\n            finishCompletion();\n        }\n    }\n\n\n    public void run() {\n        // 状态如果不是NEW，说明任务或者已经执行过，或者已经被取消，直接返回\n        // 状态如果是NEW，则尝试把当前执行线程保存在runner字段(runnerOffset)中，如果赋值失败则直接返回\n        if (state != NEW ||\n            !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                         null, Thread.currentThread()))\n            return;\n        try {\n            Callable<V> c = callable;\n            // 只有初始状态才会执行\n            if (c != null && state == NEW) {\n                V result;\n                boolean ran;\n                try {\n                    // 执行任务  计算逻辑\n                    result = c.call();\n                    ran = true;\n                } catch (Throwable ex) {\n                    result = null;\n                    ran = false;\n                    // 保存异常\n                    setException(ex);\n                }\n                if (ran)\n                    // 任务执行成功，保存返回结果\n                    set(result);\n            }\n        } finally {\n            // 无论是否执行成功，把runner设置为null\n            runner = null;\n            // state must be re-read after nulling runner to prevent\n            // leaked interrupts\n            int s = state;\n            // 如果任务被中断，执行中断处理\n            if (s >= INTERRUPTING)\n                handlePossibleCancellationInterrupt(s);\n        }\n    }\n\n    /**\n     * 与run方法类似，区别在于这个方法不会设置任务的执行结果值\n     *\n     * @return {@code true} if successfully run and reset\n     */\n    protected boolean runAndReset() {\n        if (state != NEW ||\n            !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                         null, Thread.currentThread()))\n            return false;\n        boolean ran = false;\n        int s = state;\n        try {\n            Callable<V> c = callable;\n            if (c != null && s == NEW) {\n                try {\n                    // 不获取和设置返回值\n                    c.call(); // don't set result\n                    ran = true;\n                } catch (Throwable ex) {\n                    setException(ex);\n                }\n            }\n        } finally {\n\n            runner = null;\n            s = state;\n            if (s >= INTERRUPTING)\n                handlePossibleCancellationInterrupt(s);\n        }\n        // 是否正确的执行并复位\n        return ran && s == NEW;\n    }\n\n\n    private void handlePossibleCancellationInterrupt(int s) {\n        if (s == INTERRUPTING)\n            while (state == INTERRUPTING)\n                Thread.yield(); // wait out pending interrupt\n\n        // 确保cancel(true)产生的中断发生在run或runAndReset方法执行的过程中。\n        //这里会循环的调用Thread.yield()来确保状态在cancel方法中被设置为INTERRUPTED。\n    }\n\n    /**\n     * Simple linked list nodes to record waiting threads in a Treiber\n     * stack.  See other classes such as Phaser and SynchronousQueue\n     * for more detailed explanation.\n     */\n    static final class WaitNode {\n        volatile Thread thread;\n        volatile WaitNode next;\n        WaitNode() { thread = Thread.currentThread(); }\n    }\n\n    /**\n     * Removes and signals all waiting threads, invokes done(), and\n     * nulls out callable.\n     */\n    private void finishCompletion() {\n        // assert state > COMPLETING;\n        // 执行该方法时state必须大于COMPLETING\n        // 依次遍历waiters链表\n        for (WaitNode q; (q = waiters) != null;) {\n            // 设置栈顶节点为null\n            if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {\n                for (;;) {\n                    Thread t = q.thread;\n                    if (t != null) {\n                        q.thread = null;\n                        // 唤醒等待线程\n                        LockSupport.unpark(t);\n                    }\n                    WaitNode next = q.next;\n                    // 如果next为空，说明栈空了，跳出循环\n                    if (next == null)\n                        break;\n                    // 方便gc回收\n                    q.next = null; \n                    // 重新设置栈顶node\n                    q = next;\n                }\n                break;\n            }\n        }\n        // 空方法，留给子类扩展\n        done();\n\n        callable = null;        // to reduce footprint\n    }\n\n    /**\n     * Awaits completion or aborts on interrupt or timeout.\n     *\n     * @param timed true if use timed waits\n     * @param nanos time to wait, if timed\n     * @return state upon completion\n     */\n    private int awaitDone(boolean timed, long nanos)\n        throws InterruptedException {\n        // 计算等待截止时间\n        final long deadline = timed ? System.nanoTime() + nanos : 0L;\n        WaitNode q = null;\n        boolean queued = false;\n        for (;;) {\n            // 1. 判断阻塞线程是否被中断\n            if (Thread.interrupted()) {\n                // 被中断则在等待队列中删除该节点\n                removeWaiter(q);\n                // 抛出InterruptedException异常\n                throw new InterruptedException();\n            }\n\n            int s = state;\n            // 2. 获取当前状态，如果状态大于COMPLETING\n            if (s > COMPLETING) {\n                // 说明任务已经结束(要么正常结束，要么异常结束，要么被取消)\n                if (q != null)\n                    // 把thread显示置空\n                    q.thread = null;\n                // 返回结果\n                return s;\n            }\n            // 3. 如果状态处于中间状态COMPLETING\n            // 表示任务已经结束但是任务执行线程还没来得及给outcome赋值\n            else if (s == COMPLETING) // cannot time out yet\n                Thread.yield();// 让出执行权让其他线程优先执行\n            // 4. 如果等待节点为空，则构造一个等待节点\n            else if (q == null)\n                q = new WaitNode();\n            // 5. 如果还没有入队列，则把当前节点加入waiters首节点并替换原来waiters\n            else if (!queued)\n                queued = UNSAFE.compareAndSwapObject(this, waitersOffset,\n                                                     q.next = waiters, q);\n            else if (timed) {\n                // 如果需要等待特定时间，则先计算要等待的时间\n                // 如果已经超时，则删除对应节点并返回对应的状态\n                nanos = deadline - System.nanoTime();\n                if (nanos <= 0L) {\n                    removeWaiter(q);\n                    return state;\n                }\n                // 6. 阻塞等待特定时间\n                LockSupport.parkNanos(this, nanos);\n            }\n            // 6. 阻塞等待直到被其他线程唤醒\n            else\n                LockSupport.park(this);\n        }\n    }\n\n\n    private void removeWaiter(WaitNode node) {\n        if (node != null) {\n            // 将thread设置为null是因为下面要根据thread是否为null判断是否要把node移出\n            node.thread = null;\n            // 这里自旋保证删除成功\n            retry:\n            for (;;) {          // restart on removeWaiter race\n                for (WaitNode pred = null, q = waiters, s; q != null; q = s) {\n                    s = q.next;\n                    // q.thread != null说明该q节点不需要移除\n                    if (q.thread != null)\n                        pred = q;\n                    // 如果q.thread == null，且pred != null，需要删除q节点\n                    else if (pred != null) {\n                        // 删除q节点\n                        pred.next = s;\n                         // pred.thread == null时说明在并发情况下被其他线程修改了；\n                         // 返回第一个for循环重试\n                        if (pred.thread == null) // check for race\n                            continue retry;\n                    }\n                     // 如果q.thread != null且pred == null，说明q是栈顶节点\n                     // 设置栈顶元素为s节点，如果失败则返回重试\n                    else if (!UNSAFE.compareAndSwapObject(this, waitersOffset,\n                                                          q, s))\n                        continue retry;\n                }\n                break;\n            }\n        }\n    }\n\n    // Unsafe mechanics\n    private static final sun.misc.Unsafe UNSAFE;\n    private static final long stateOffset;\n    private static final long runnerOffset;\n    private static final long waitersOffset;\n    static {\n        try {\n            UNSAFE = sun.misc.Unsafe.getUnsafe();\n            Class<?> k = FutureTask.class;\n            stateOffset = UNSAFE.objectFieldOffset\n                (k.getDeclaredField(\"state\"));\n            runnerOffset = UNSAFE.objectFieldOffset\n                (k.getDeclaredField(\"runner\"));\n            waitersOffset = UNSAFE.objectFieldOffset\n                (k.getDeclaredField(\"waiters\"));\n        } catch (Exception e) {\n            throw new Error(e);\n        }\n    }\n\n}\n\n```\n## 线程池中的线程初始化\n\n　　默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：\n* prestartCoreThread()：初始化一个核心线程；\n* prestartAllCoreThreads()：初始化所有核心线程\n\n## 线程池的关闭\nThreadPoolExecutor提供了两个方法，用于线程池的关闭\n* shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务\n* shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务\n\n## 线程池大小\n1. 粗略\n    1. 如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1\n    2. 如果是IO密集型任务，参考值可以设置为2*NCPU\n2. 精确：（(线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目\n3. 最佳：压测\n\n## 任务缓存队列\n\n**workQueue**，它用来存放等待执行的任务。BlockingQueue 是个接口，你需要使用它的实现之一来使用BlockingQueue，java.util.concurrent包下具有以下 BlockingQueue 接口的实现类：\n* ArrayBlockingQueue：ArrayBlockingQueue 是一个有界的阻塞队列，其内部实现是将对象放到一个数组里。有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了(译者注：因为它是基于数组实现的，也就具有数组的特性：一旦初始化，大小就无法修改)。\n* LinkedBlockingQueue：LinkedBlockingQueue 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。\n* DelayQueue：DelayQueue 对元素进行持有直到一个特定的延迟到期。注入其中的元素必须实现 java.util.concurrent.Delayed 接口。\n* PriorityBlockingQueue：PriorityBlockingQueue 是一个无界的并发队列。它使用了和类 java.util.PriorityQueue 一样的排序规则。你无法向这个队列中插入 null 值。所有插入到 PriorityBlockingQueue 的元素必须实现 java.lang.Comparable 接口。因此该队列中元素的排序就取决于你自己的 Comparable 实现。\n* SynchronousQueue：SynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。\n\n\n## 线程池总结\n1. 线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。\n2. 当调用 execute() 方法添加一个任务时，线程池会做如下判断：\n     1. 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；\n     2. 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；\n     3. 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；\n     4. 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。\n     5. 当一个线程完成任务时，它会从队列中取下一个任务来执行。\n     6. 当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。\n\n","slug":"Java-ThreadPool","published":1,"updated":"2020-03-06T12:52:54.595Z","layout":"post","photos":[],"link":"","_id":"ck8fb4ac50020k2o5q71z9gm2","content":"<h1 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h1><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>操作系统调度的最小单元是线程，也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程， 这些线程都拥有各自的计数器、 堆栈和局部变量等属性， 并且能够访问共享的内存变量。 处理器在这些线程上高速切换， 让使用者感觉到这些线程在同时执行。</p>\n<a id=\"more\"></a>\n<h4 id=\"线程的创建\"><a href=\"#线程的创建\" class=\"headerlink\" title=\"线程的创建\"></a>线程的创建</h4><ul>\n<li>通过继承Thread类来创建一个线程</li>\n<li>实现Runnable接口并重写run()方法，new Thread(runnable).start()，线程启动时就会自动调用该对象的run方法</li>\n<li>实现Callable接口并实现call()方法，使用FutureTask类包装Callable对象，使用FutureTask对象作为Thread对象的targer创建并启动线程；也可以使用线程池启动<pre><code>Runnable 和 Callable 的区别\n 1. Runnable规定方法是run方法，Callable规定方法是call方法\n 2. Runnable任务执行后无返回值，Callable任务执行后可返回值\n 3. run方法无法抛出异常，call方法可以抛出异常\n 4. 运行Callable任务可以拿到一个Future对象，Future表示异步计算结果，他提供了检查计算是否完成的方法，以等待计算完成并获取结果。计算完成后用get()方法获取结果，如果线程没有执行完，get()方法会阻塞当前线程执行。如果线程出现异常，get()方法会抛出异常。</code></pre></li>\n<li>线程池：Executors类提供了方便的工厂方法来创建不同类型的 executor services。无论Runnable还是Callable都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行<pre><code>1. public static ExecutorService newCachedThreadPool() 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程，但是在之前构造的线程可用时将重用它们。\n2. public static ExecutorService newFixedThreadPool(int nThreads)  创建一个定长线程池，可控制线程最大并发数，以共享的无界队列方式来运行线程，超出的线程会在队列中等待。\n3. public static ExecutorService newSingleThreadExecutor() 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，以无界队列方式来运行线程，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n4. public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 创建一个周期线程池，支持定时及周期性任务执行。\n5. public static ExecutorService newWorkStealingPool() 创建持有足够线程的线程池来支持给定的并行级别，并通过使用多个队列，减少竞争，它需要穿一个并行级别的参数，如果不传，则被设定为默认的CPU数量，这个线程池实际上是ForkJoinPool的扩展，适合使用在很耗时的任务中，能够合理的使用CPU进行并行操作。</code></pre></li>\n</ul>\n<h4 id=\"线程的管理\"><a href=\"#线程的管理\" class=\"headerlink\" title=\"线程的管理\"></a>线程的管理</h4><ul>\n<li>ForkJoinPool 的每个工作线程都维护了一个工作队列(WorkQueue)，这是一个双端队列，里面存放的对象是任务(ForkJoinTask)<ul>\n<li>每个工作线程在运行中产生新的任务(通常是因为调用了fork())，会放入工作队列的队尾，并且工作线程在处理自己的工作队列时，使用的是LIFO方式，也就是每次从队尾取任务执行。</li>\n<li>每个工作线程在处理自己的工作队列时，会尝试窃取一个任务(或是来自刚刚提交到pool的任务，或是来自其他的工作队列)，窃取的任务位于其他线程工作队列的队首，也就是使用FIFO方式。</li>\n<li>在遇到join()时如果join的任务尚未完成，则会先处理其他任务，并等待其完成。</li>\n</ul>\n</li>\n<li>ExecutorCompletionService 内部维护了一个阻塞队列(BlockingQueue), 只有完成的任务才被加入到队列中。如果队列中的数据为空时, 调用take()就会阻塞直到有完成的任务加入队列，基于FutureTask实现。</li>\n</ul>\n<h1 id=\"线程池原理\"><a href=\"#线程池原理\" class=\"headerlink\" title=\"线程池原理\"></a>线程池原理</h1><h2 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (corePoolSize &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt;= <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt; corePoolSize ||</span><br><span class=\"line\">        keepAliveTime &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workQueue == <span class=\"keyword\">null</span> || threadFactory == <span class=\"keyword\">null</span> || handler == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.acc = System.getSecurityManager() == <span class=\"keyword\">null</span> ?</span><br><span class=\"line\">            <span class=\"keyword\">null</span> :</span><br><span class=\"line\">            AccessController.getContext();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.workQueue = workQueue;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threadFactory = threadFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>corePoolSize 核心线程数量，当有新任务在exectue()方法提交时，会执行以下判断：<pre><code>1. 如果运行的线程少于 corePoolSize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的；\n2. 如果线程池中的线程数量大于等于 corePoolSize 且小于 maximumPoolSize，则只有当workQueue满时才创建新的线程去处理任务；\n3. 如果设置的corePoolSize 和 maximumPoolSize相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取任务并处理；\n4. 如果运行的线程数量大于等于maximumPoolSize，这时如果workQueue已经满了，则通过handler所指定的策略来处理任务；\n5. 所以，任务提交时，判断的顺序为 corePoolSize –&gt; workQueue –&gt; maximumPoolSize</code></pre></li>\n<li>maximumPoolSize 最大线程数量；</li>\n<li>keepAliveTime 线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime；</li>\n<li>TimeUnit 线程保持活动的时间单位</li>\n<li>BlockingQueue<runnable> workQueue 保存等待执行的任务的阻塞队列，当提交一个新的任务到线程池以后, 线程池会根据当前线程池中正在运行着的线程的数量来决定对该任务的处理方式，主要有以下几种处理方式:<ul>\n<li><strong>直接切换</strong>：这种方式常用的队列是SynchronousQueue</li>\n<li><strong>使用无界队列</strong>：一般使用基于链表的阻塞队列LinkedBlockingQueue。如果使用这种方式，那么线程池中能够创建的最大线程数就是corePoolSize，而maximumPoolSize就不会起作用了。当线程池中所有的核心线程都是RUNNING状态时，这时一个新的任务提交就会放入等待队列中。</li>\n<li><strong>使用有界队列</strong>：一般使用ArrayBlockingQueue。使用该方式可以将线程池的最大线程数量限制为maximumPoolSize，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。</li>\n</ul>\n</runnable></li>\n<li>threadFactory 它是ThreadFactory类型的变量，用来创建新线程。默认使用Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称。</li>\n<li>handler 它是RejectedExecutionHandler类型的变量，表示线程池的饱和的<strong>拒绝策略</strong>。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。线程池提供了4种策略：<ul>\n<li>AbortPolicy：直接抛出异常，这是默认策略；</li>\n<li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li>\n<li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>\n<li>DiscardPolicy：直接丢弃任务；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"线程池状态\"><a href=\"#线程池状态\" class=\"headerlink\" title=\"线程池状态\"></a>线程池状态</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> COUNT_BITS = Integer.SIZE - <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CAPACITY   = (<span class=\"number\">1</span> &lt;&lt; COUNT_BITS) - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// runState is stored in the high-order bits</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RUNNING    = -<span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHUTDOWN   =  <span class=\"number\">0</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> STOP       =  <span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TIDYING    =  <span class=\"number\">2</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TERMINATED =  <span class=\"number\">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>COUNT_BITS: 线程的最大位数29位</li>\n<li>CAPACITY：线程的最大容量</li>\n<li>RUNNING：运行状态，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0</li>\n<li>SHUTDOWN：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 </li>\n<li>STOP：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。</li>\n<li>TIDYING：当所有的任务已终止，任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。</li>\n<li>TERMINATED：终止状态，当执行 terminated() 后会更新为这个状态。<br><img src=\"/JAVA/Java-ThreadPool/01.png\" alt=\"\"></li>\n</ul>\n<h2 id=\"核心源码\"><a href=\"#核心源码\" class=\"headerlink\" title=\"核心源码\"></a>核心源码</h2><h3 id=\"线程池执行源码\"><a href=\"#线程池执行源码\" class=\"headerlink\" title=\"线程池执行源码\"></a>线程池执行源码</h3><h4 id=\"execute\"><a href=\"#execute\" class=\"headerlink\" title=\"execute\"></a>execute</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// clt记录着runState和workerCount</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// workerCountOf方法取出低29位的值，表示当前活动的线程数；</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中，并把任务添加到该线程中；</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果为true，根据corePoolSize来判断；</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果为false，则根据maximumPoolSize来判断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 如果添加失败，则重新获取ctl值</span></span><br><span class=\"line\">        c = ctl.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果当前线程池是运行状态 并且 任务能够成功添加到工作队列</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 重新获取ctl值</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，</span></span><br><span class=\"line\">        <span class=\"comment\">// 这时需要移除该command</span></span><br><span class=\"line\">        <span class=\"comment\">// 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">            reject(command);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；</span></span><br><span class=\"line\">        <span class=\"comment\">// 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果执行到这里，有两种情况：</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.线程池已经不是RUNNING状态；</span></span><br><span class=\"line\">    <span class=\"comment\">// 2.线程池是RUNNING状态，但workerCount &gt;= corePoolSize并且workQueue已满;</span></span><br><span class=\"line\">    <span class=\"comment\">// 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果失败则拒绝该任务 </span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">        reject(command);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>runState和workCount变量怎么存储在一个int中？参考：<a href=\"https://blog.csdn.net/weixin_34396902/article/details/94527424\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_34396902/article/details/94527424</a></p>\n<h4 id=\"addWorker\"><a href=\"#addWorker\" class=\"headerlink\" title=\"addWorker\"></a>addWorker</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 循环CAS操作，将线程池中的线程数+1</span></span><br><span class=\"line\">    retry:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// clt记录着runState和workerCount</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取运行状态</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果rs &gt;= SHUTDOWN，则表示此时不再接收新任务；</span></span><br><span class=\"line\">        <span class=\"comment\">// 接着判断以下3个条件，只要有1个不满足，则返回false：</span></span><br><span class=\"line\">        <span class=\"comment\">// 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务</span></span><br><span class=\"line\">        <span class=\"comment\">// 2. firsTask为空</span></span><br><span class=\"line\">        <span class=\"comment\">// 3. 阻塞队列不为空</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"comment\">// rs == SHUTDOWN的情况</span></span><br><span class=\"line\">        <span class=\"comment\">// 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果firstTask为空，并且workQueue也为空，因为队列中已经没有任务了，不需要再添加线程了，则返回false，</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class=\"line\">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class=\"line\">               firstTask == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">               ! workQueue.isEmpty()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取线程数</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 如果wc超过CAPACITY(最大线程数线程数),也就是ctl的低29位的最大值（二进制是29个1），返回false；</span></span><br><span class=\"line\">            <span class=\"comment\">// core是addWorker方法的第二个参数,如果为true表示根据corePoolSize来比较，如果为false则根据maximumPoolSize来比较;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wc &gt;= CAPACITY ||</span><br><span class=\"line\">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// CAS操作尝试增加workerCount，修改clt的值+1，如果成功，则跳出第一个for循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 如果增加workerCount失败，则重新获取ctl的值</span></span><br><span class=\"line\">            c = ctl.get();  </span><br><span class=\"line\">            <span class=\"comment\">// 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 新建线程，并加入到线程池workers中。</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据firstTask来创建Worker对象</span></span><br><span class=\"line\">        w = <span class=\"keyword\">new</span> Worker(firstTask);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 每一个Worker对象都会创建一个线程</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 对workers操作要通过加锁来实现</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">            mainLock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取运行状态</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> rs = runStateOf(ctl.get());</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// rs &lt; SHUTDOWN表示是RUNNING状态；</span></span><br><span class=\"line\">                <span class=\"comment\">// 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。</span></span><br><span class=\"line\">                <span class=\"comment\">// 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||</span><br><span class=\"line\">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 判断添加的任务状态,如果已经开始丢出异常</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (t.isAlive()) </span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"comment\">// 将新建的线程加入到线程池中，workers是一个hashSet</span></span><br><span class=\"line\">                    workers.add(w);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"comment\">// largestPoolSize记录着线程池中出现过的最大线程数量</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                        largestPoolSize = s;</span><br><span class=\"line\">                    <span class=\"comment\">//标记任务添加</span></span><br><span class=\"line\">                    workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                mainLock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">                t.start();</span><br><span class=\"line\">                <span class=\"comment\">// 标记线程启动</span></span><br><span class=\"line\">                workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 线程添加线程池失败或者线程start失败，则需要调用addWorkerFailed函数</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果添加成功则需要移除线程，并恢复复clt的值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">            addWorkerFailed(w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> workerStarted;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>t.start()这个语句，启动时会调用Worker类中的run方法，Worker本身实现了Runnable接口，所以一个Worker类型的对象也是一个线程。</p>\n<h4 id=\"Worker类\"><a href=\"#Worker类\" class=\"headerlink\" title=\"Worker类\"></a>Worker类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Worker</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">6138294804551838833L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** 线程池中正真运行的线程。通过我们指定的线程工厂创建而来 **/</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread thread;</span><br><span class=\"line\">    <span class=\"comment\">/** 线程包装的任务。thread 在run时主要调用了该任务的run方法 */</span></span><br><span class=\"line\">    Runnable firstTask;</span><br><span class=\"line\">    <span class=\"comment\">/** 记录当前线程完成的任务数 */</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> completedTasks;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> firstTask the first task (null if none)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Worker(Runnable firstTask) &#123;</span><br><span class=\"line\">        setState(-<span class=\"number\">1</span>); <span class=\"comment\">// 在调用runWorker()前，禁止interrupt中断，在interruptIfStarted()方法中会判断 getState()&gt;=0</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.firstTask = firstTask;</span><br><span class=\"line\">        <span class=\"comment\">// 利用我们指定的线程工厂创建一个线程</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.thread = getThreadFactory().newThread(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Delegates main run loop to outer runWorker  */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        runWorker(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Lock methods</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// The value 0 represents the unlocked state.</span></span><br><span class=\"line\">    <span class=\"comment\">// The value 1 represents the locked state.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHeldExclusively</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getState() != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 尝试获取锁</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> unused)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//尝试一次将state从0设置为1，即“锁定”状态，</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//设置exclusiveOwnerThread=当前线程</span></span><br><span class=\"line\">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 尝试释放锁</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> unused)</span> </span>&#123;</span><br><span class=\"line\">        setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        setState(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span>        </span>&#123; acquire(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">()</span>  </span>&#123; <span class=\"keyword\">return</span> tryAcquire(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span>      </span>&#123; release(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isLocked</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> isHeldExclusively(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 中断（如果运行）</span></span><br><span class=\"line\"><span class=\"comment\">    * shutdownNow时会循环对worker线程执行</span></span><br><span class=\"line\"><span class=\"comment\">    * 且不需要获取worker锁，即使在worker运行时也可以中断</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">interruptIfStarted</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread t;</span><br><span class=\"line\">        <span class=\"comment\">// 如果state&gt;=0、t!=null、且t没有被中断</span></span><br><span class=\"line\">        <span class=\"comment\">// new Worker()时state==-1，说明不能中断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getState() &gt;= <span class=\"number\">0</span> &amp;&amp; (t = thread) != <span class=\"keyword\">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                t.interrupt();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (SecurityException ignore) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Worker类投机取巧的继承了AbstractQueuedSynchronizer来简化在执行任务时的获取、释放锁,这样防止了中断在运行中的任务，只会唤醒(中断)在等待从workQueue中获取任务的线程.<br>不直接执行execute(command)提交的command，而要在外面包一层Worker主要是为了使用用AQS锁控制中断，当运行时上锁，就不能中断，TreadPoolExecutor的shutdown()方法中断前都要获取worker锁，只有在等待从workQueue中获取任务getTask()时才能中断。</p>\n<h4 id=\"runWorker-方法\"><a href=\"#runWorker-方法\" class=\"headerlink\" title=\"runWorker 方法\"></a>runWorker 方法</h4><p>在Worker类中的run方法调用了runWorker方法来执行任务.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">    Thread wt = Thread.currentThread();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 获取第一个任务</span></span><br><span class=\"line\">    Runnable task = w.firstTask;</span><br><span class=\"line\">    w.firstTask = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    w.unlock(); <span class=\"comment\">// 允许中断</span></span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"comment\">// 是否因为异常退出循环</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 如果task为空，则通过getTask来获取任务</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            w.lock();</span><br><span class=\"line\">            <span class=\"comment\">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class=\"line\">            <span class=\"comment\">// if not, ensure thread is not interrupted.  This</span></span><br><span class=\"line\">            <span class=\"comment\">// requires a recheck in second case to deal with</span></span><br><span class=\"line\">            <span class=\"comment\">// shutdownNow race while clearing interrupt</span></span><br><span class=\"line\">            <span class=\"comment\">// 线程池处于stop状态或者当前线程被中断时，线程池状态是stop状态</span></span><br><span class=\"line\">            <span class=\"comment\">// 但是当前线程没有中断，则发出中断请求</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class=\"line\">                 (Thread.interrupted() &amp;&amp;</span><br><span class=\"line\">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class=\"line\">                !wt.isInterrupted())</span><br><span class=\"line\">                wt.interrupt();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//开始执行任务前的Hook，类似回调函数</span></span><br><span class=\"line\">                beforeExecute(wt, task);</span><br><span class=\"line\">                Throwable thrown = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//执行任务</span></span><br><span class=\"line\">                    task.run();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Error x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(x);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//任务执行后的Hook，类似回调函数</span></span><br><span class=\"line\">                    afterExecute(task, thrown);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//执行完毕后task重置，completedTasks计数器++，解锁</span></span><br><span class=\"line\">                task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                w.completedTasks++;</span><br><span class=\"line\">                w.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//标记正常退出</span></span><br><span class=\"line\">        completedAbruptly = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//线程空闲达到我们设定的值时，Worker退出销毁。</span></span><br><span class=\"line\">        processWorkerExit(w, completedAbruptly);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"getTask-方法\"><a href=\"#getTask-方法\" class=\"headerlink\" title=\"getTask 方法\"></a>getTask 方法</h4><p>runWorker函数中最重要的是getTask()，不断的从阻塞队列中取任务交给线程执行，并且负责线程回收</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 表示上次从阻塞队列中取任务时是否超时</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> timedOut = <span class=\"keyword\">false</span>; <span class=\"comment\">// Did the last poll() time out?</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果线程池处于shutdown状态，</span></span><br><span class=\"line\">        <span class=\"comment\">// 并且队列为空，或者线程池处于stop或者terminate状态，</span></span><br><span class=\"line\">        <span class=\"comment\">// 在线程池数量-1，返回null，回收线程</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">            decrementWorkerCount();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取线程数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// timed变量用于判断是否需要进行超时控制。</span></span><br><span class=\"line\">        <span class=\"comment\">// allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；</span></span><br><span class=\"line\">        <span class=\"comment\">// wc &gt; corePoolSize，表示当前线程池中的线程数量大于核心线程数量；</span></span><br><span class=\"line\">        <span class=\"comment\">// 对于超过核心线程数量的这些线程，需要进行超时控制</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果线程数目大于最大线程数目 或 当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时</span></span><br><span class=\"line\">        <span class=\"comment\">// 并且 线程数目大于1 或 工作队列为空</span></span><br><span class=\"line\">        <span class=\"comment\">// 尝试将workerCount减1；</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class=\"line\">            &amp;&amp; (wc &gt; <span class=\"number\">1</span> || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//**保证核心线程不被销毁**</span></span><br><span class=\"line\">            <span class=\"comment\">// 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null；</span></span><br><span class=\"line\">            <span class=\"comment\">// 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。</span></span><br><span class=\"line\">            Runnable r = timed ?</span><br><span class=\"line\">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class=\"line\">                workQueue.take();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 如果 r == null，说明已经超时，timedOut设置为true，进入下一个循环</span></span><br><span class=\"line\">            timedOut = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException retry) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试</span></span><br><span class=\"line\">            timedOut = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"FutureTask源码\"><a href=\"#FutureTask源码\" class=\"headerlink\" title=\"FutureTask源码\"></a>FutureTask源码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FutureTask</span>&lt;<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">RunnableFuture</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * state字段用来保存FutureTask内部的任务执行状态，一共有7中状态，每种状态及其对应的值如下</span></span><br><span class=\"line\"><span class=\"comment\">     * NEW:表示是个新的任务或者还没被执行完的任务。这是初始状态。</span></span><br><span class=\"line\"><span class=\"comment\">     * COMPLETING:任务已经执行完成或者执行任务的时候发生异常，但是任务执行结果或者异常原因还没有保存到outcome字段(outcome字段用来保存任务执行结果，如果发生异常，则用来保存异常原因)的时候，状态会从NEW变更到COMPLETING。但是这个状态会时间会比较短，属于中间状态。</span></span><br><span class=\"line\"><span class=\"comment\">     * NORMAL:任务已经执行完成并且任务执行结果已经保存到outcome字段，状态会从COMPLETING转换到NORMAL。这是一个最终态。</span></span><br><span class=\"line\"><span class=\"comment\">     * EXCEPTIONAL:任务执行发生异常并且异常原因已经保存到outcome字段中后，状态会从COMPLETING转换到EXCEPTIONAL。这是一个最终态。</span></span><br><span class=\"line\"><span class=\"comment\">     * CANCELLED:任务还没开始执行或者已经开始执行但是还没有执行完成的时候，用户调用了cancel(false)方法取消任务且不中断任务执行线程，这个时候状态会从NEW转化为CANCELLED状态。这是一个最终态。</span></span><br><span class=\"line\"><span class=\"comment\">     * INTERRUPTING: 任务还没开始执行或者已经执行但是还没有执行完成的时候，用户调用了cancel(true)方法取消任务并且要中断任务执行线程但是还没有中断任务执行线程之前，状态会从NEW转化为INTERRUPTING。这是一个中间状态。</span></span><br><span class=\"line\"><span class=\"comment\">     * INTERRUPTED:调用interrupt()中断任务执行线程之后状态会从INTERRUPTING转换到INTERRUPTED。这是一个最终态。</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * NEW -&gt; COMPLETING -&gt; NORMAL 正常执行并返回</span></span><br><span class=\"line\"><span class=\"comment\">     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL 执行过程中出现了异常</span></span><br><span class=\"line\"><span class=\"comment\">     * NEW -&gt; CANCELLED 执行前被取消</span></span><br><span class=\"line\"><span class=\"comment\">     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED 取消时被中断</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> state;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> NEW          = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> COMPLETING   = <span class=\"number\">1</span>;<span class=\"comment\">//大于这个值就是完成状态</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> NORMAL       = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> EXCEPTIONAL  = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CANCELLED    = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INTERRUPTING = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INTERRUPTED  = <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** The underlying callable; nulled out after running */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Callable&lt;V&gt; callable;</span><br><span class=\"line\">    <span class=\"comment\">/** The result to return or exception to throw from get() */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object outcome; <span class=\"comment\">// non-volatile, protected by state reads/writes</span></span><br><span class=\"line\">    <span class=\"comment\">/** 执行callable的线程 **/</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> Thread runner;</span><br><span class=\"line\">    <span class=\"comment\">/** 使用Treiber算法实现的无阻塞的Stack，用于存放等待的线程 */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> WaitNode waiters;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> V <span class=\"title\">report</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> <span class=\"keyword\">throws</span> ExecutionException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 拿到返回结果</span></span><br><span class=\"line\">        Object x = outcome;</span><br><span class=\"line\">        <span class=\"comment\">// 判断状态</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == NORMAL)</span><br><span class=\"line\">            <span class=\"comment\">// 状态正常，就返回结果值</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (V)x;</span><br><span class=\"line\">        <span class=\"comment\">// 判断异常，就抛出异常。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s &gt;= CANCELLED)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CancellationException();</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ExecutionException((Throwable)x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FutureTask</span><span class=\"params\">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callable == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.callable = callable;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = NEW;       <span class=\"comment\">// ensure visibility of callable</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个构造方法会把传入的Runnable封装成一个Callable对象保存在callable字段中，同时如果任务执行成功的话就会返回传入的result。</span></span><br><span class=\"line\"><span class=\"comment\">     * 这种情况下如果不需要返回值的话可以传入一个null。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FutureTask</span><span class=\"params\">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.callable = Executors.callable(runnable, result);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = NEW;       <span class=\"comment\">// ensure visibility of callable</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//判断任务是否被取消</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isCancelled</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state &gt;= CANCELLED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//判断任务是否完成</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isDone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state != NEW;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"keyword\">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 任务是new状态 并且 根据mayInterruptIfRunning把状态从NEW转化到INTERRUPTING或CANCELLED </span></span><br><span class=\"line\">        <span class=\"comment\">// 不符合上述状态，返回false</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(state == NEW &amp;&amp;</span><br><span class=\"line\">              UNSAFE.compareAndSwapInt(<span class=\"keyword\">this</span>, stateOffset, NEW,</span><br><span class=\"line\">                  mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;    </span><br><span class=\"line\">        <span class=\"comment\">// 2. 如果需要中断任务执行线程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mayInterruptIfRunning) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// runner保存着当前执行任务的线程</span></span><br><span class=\"line\">                    Thread t = runner;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        <span class=\"comment\">//中断任务执行线程</span></span><br><span class=\"line\">                        t.interrupt();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123; <span class=\"comment\">// final state</span></span><br><span class=\"line\">                    <span class=\"comment\">// 修改状态为INTERRUPTED</span></span><br><span class=\"line\">                    UNSAFE.putOrderedInt(<span class=\"keyword\">this</span>, stateOffset, INTERRUPTED);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            finishCompletion();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">        <span class=\"comment\">// 判断任务当前的state &lt;= COMPLETING是否成立。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s &lt;= COMPLETING)</span><br><span class=\"line\">            <span class=\"comment\">// 如果成立，表明任务还没有结束(这里的结束包括任务正常执行完毕，任务执行异常，任务被取消)</span></span><br><span class=\"line\">            <span class=\"comment\">// 调用awaitDone()进行阻塞等待。</span></span><br><span class=\"line\">            s = awaitDone(<span class=\"keyword\">false</span>, <span class=\"number\">0L</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 任务已经结束，调用report()返回结果。</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> report(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (unit == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">        <span class=\"comment\">// 如果awaitDone()超时返回之后任务还没结束，则抛出异常</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class=\"line\">            (s = awaitDone(<span class=\"keyword\">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> TimeoutException();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> report(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(V v)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 尝试CAS操作，把当前的状态从NEW变更为COMPLETING(中间状态)状态。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (UNSAFE.compareAndSwapInt(<span class=\"keyword\">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 把任务执行结果保存在outcome字段中。</span></span><br><span class=\"line\">            outcome = v;</span><br><span class=\"line\">            <span class=\"comment\">// CAS的把当前任务状态从COMPLETING变更为NORMAL</span></span><br><span class=\"line\">            UNSAFE.putOrderedInt(<span class=\"keyword\">this</span>, stateOffset, NORMAL); <span class=\"comment\">// final state</span></span><br><span class=\"line\">            finishCompletion();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setException</span><span class=\"params\">(Throwable t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 尝试CAS操作，把当前的状态从NEW变更为COMPLETING(中间状态)状态。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (UNSAFE.compareAndSwapInt(<span class=\"keyword\">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 把异常原因保存在outcome字段中，outcome字段用来保存任务执行结果或者异常原因。</span></span><br><span class=\"line\">            outcome = t;</span><br><span class=\"line\">            <span class=\"comment\">// CAS的把当前任务状态从COMPLETING变更为EXCEPTIONAL。</span></span><br><span class=\"line\">            UNSAFE.putOrderedInt(<span class=\"keyword\">this</span>, stateOffset, EXCEPTIONAL); <span class=\"comment\">// final state</span></span><br><span class=\"line\">            finishCompletion();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 状态如果不是NEW，说明任务或者已经执行过，或者已经被取消，直接返回</span></span><br><span class=\"line\">        <span class=\"comment\">// 状态如果是NEW，则尝试把当前执行线程保存在runner字段(runnerOffset)中，如果赋值失败则直接返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state != NEW ||</span><br><span class=\"line\">            !UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, runnerOffset,</span><br><span class=\"line\">                                         <span class=\"keyword\">null</span>, Thread.currentThread()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Callable&lt;V&gt; c = callable;</span><br><span class=\"line\">            <span class=\"comment\">// 只有初始状态才会执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c != <span class=\"keyword\">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class=\"line\">                V result;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> ran;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 执行任务  计算逻辑</span></span><br><span class=\"line\">                    result = c.call();</span><br><span class=\"line\">                    ran = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                    result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    ran = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// 保存异常</span></span><br><span class=\"line\">                    setException(ex);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ran)</span><br><span class=\"line\">                    <span class=\"comment\">// 任务执行成功，保存返回结果</span></span><br><span class=\"line\">                    set(result);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 无论是否执行成功，把runner设置为null</span></span><br><span class=\"line\">            runner = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">// state must be re-read after nulling runner to prevent</span></span><br><span class=\"line\">            <span class=\"comment\">// leaked interrupts</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">            <span class=\"comment\">// 如果任务被中断，执行中断处理</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s &gt;= INTERRUPTING)</span><br><span class=\"line\">                handlePossibleCancellationInterrupt(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 与run方法类似，区别在于这个方法不会设置任务的执行结果值</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> true&#125; if successfully run and reset</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">runAndReset</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state != NEW ||</span><br><span class=\"line\">            !UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, runnerOffset,</span><br><span class=\"line\">                                         <span class=\"keyword\">null</span>, Thread.currentThread()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> ran = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Callable&lt;V&gt; c = callable;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c != <span class=\"keyword\">null</span> &amp;&amp; s == NEW) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 不获取和设置返回值</span></span><br><span class=\"line\">                    c.call(); <span class=\"comment\">// don't set result</span></span><br><span class=\"line\">                    ran = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                    setException(ex);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            runner = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            s = state;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s &gt;= INTERRUPTING)</span><br><span class=\"line\">                handlePossibleCancellationInterrupt(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 是否正确的执行并复位</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ran &amp;&amp; s == NEW;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handlePossibleCancellationInterrupt</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == INTERRUPTING)</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (state == INTERRUPTING)</span><br><span class=\"line\">                Thread.yield(); <span class=\"comment\">// wait out pending interrupt</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 确保cancel(true)产生的中断发生在run或runAndReset方法执行的过程中。</span></span><br><span class=\"line\">        <span class=\"comment\">//这里会循环的调用Thread.yield()来确保状态在cancel方法中被设置为INTERRUPTED。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Simple linked list nodes to record waiting threads in a Treiber</span></span><br><span class=\"line\"><span class=\"comment\">     * stack.  See other classes such as Phaser and SynchronousQueue</span></span><br><span class=\"line\"><span class=\"comment\">     * for more detailed explanation.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WaitNode</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">volatile</span> Thread thread;</span><br><span class=\"line\">        <span class=\"keyword\">volatile</span> WaitNode next;</span><br><span class=\"line\">        WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Removes and signals all waiting threads, invokes done(), and</span></span><br><span class=\"line\"><span class=\"comment\">     * nulls out callable.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">finishCompletion</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// assert state &gt; COMPLETING;</span></span><br><span class=\"line\">        <span class=\"comment\">// 执行该方法时state必须大于COMPLETING</span></span><br><span class=\"line\">        <span class=\"comment\">// 依次遍历waiters链表</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (WaitNode q; (q = waiters) != <span class=\"keyword\">null</span>;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 设置栈顶节点为null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, waitersOffset, q, <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                    Thread t = q.thread;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        q.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        <span class=\"comment\">// 唤醒等待线程</span></span><br><span class=\"line\">                        LockSupport.unpark(t);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    WaitNode next = q.next;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果next为空，说明栈空了，跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// 方便gc回收</span></span><br><span class=\"line\">                    q.next = <span class=\"keyword\">null</span>; </span><br><span class=\"line\">                    <span class=\"comment\">// 重新设置栈顶node</span></span><br><span class=\"line\">                    q = next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 空方法，留给子类扩展</span></span><br><span class=\"line\">        done();</span><br><span class=\"line\"></span><br><span class=\"line\">        callable = <span class=\"keyword\">null</span>;        <span class=\"comment\">// to reduce footprint</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Awaits completion or aborts on interrupt or timeout.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timed true if use timed waits</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> nanos time to wait, if timed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> state upon completion</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">awaitDone</span><span class=\"params\">(<span class=\"keyword\">boolean</span> timed, <span class=\"keyword\">long</span> nanos)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计算等待截止时间</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> deadline = timed ? System.nanoTime() + nanos : <span class=\"number\">0L</span>;</span><br><span class=\"line\">        WaitNode q = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> queued = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 1. 判断阻塞线程是否被中断</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Thread.interrupted()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 被中断则在等待队列中删除该节点</span></span><br><span class=\"line\">                removeWaiter(q);</span><br><span class=\"line\">                <span class=\"comment\">// 抛出InterruptedException异常</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">            <span class=\"comment\">// 2. 获取当前状态，如果状态大于COMPLETING</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s &gt; COMPLETING) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 说明任务已经结束(要么正常结束，要么异常结束，要么被取消)</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (q != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"comment\">// 把thread显示置空</span></span><br><span class=\"line\">                    q.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 返回结果</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 3. 如果状态处于中间状态COMPLETING</span></span><br><span class=\"line\">            <span class=\"comment\">// 表示任务已经结束但是任务执行线程还没来得及给outcome赋值</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s == COMPLETING) <span class=\"comment\">// cannot time out yet</span></span><br><span class=\"line\">                Thread.yield();<span class=\"comment\">// 让出执行权让其他线程优先执行</span></span><br><span class=\"line\">            <span class=\"comment\">// 4. 如果等待节点为空，则构造一个等待节点</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (q == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                q = <span class=\"keyword\">new</span> WaitNode();</span><br><span class=\"line\">            <span class=\"comment\">// 5. 如果还没有入队列，则把当前节点加入waiters首节点并替换原来waiters</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!queued)</span><br><span class=\"line\">                queued = UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, waitersOffset,</span><br><span class=\"line\">                                                     q.next = waiters, q);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (timed) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果需要等待特定时间，则先计算要等待的时间</span></span><br><span class=\"line\">                <span class=\"comment\">// 如果已经超时，则删除对应节点并返回对应的状态</span></span><br><span class=\"line\">                nanos = deadline - System.nanoTime();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nanos &lt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">                    removeWaiter(q);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 6. 阻塞等待特定时间</span></span><br><span class=\"line\">                LockSupport.parkNanos(<span class=\"keyword\">this</span>, nanos);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 6. 阻塞等待直到被其他线程唤醒</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">removeWaiter</span><span class=\"params\">(WaitNode node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将thread设置为null是因为下面要根据thread是否为null判断是否要把node移出</span></span><br><span class=\"line\">            node.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 这里自旋保证删除成功</span></span><br><span class=\"line\">            retry:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;          <span class=\"comment\">// restart on removeWaiter race</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (WaitNode pred = <span class=\"keyword\">null</span>, q = waiters, s; q != <span class=\"keyword\">null</span>; q = s) &#123;</span><br><span class=\"line\">                    s = q.next;</span><br><span class=\"line\">                    <span class=\"comment\">// q.thread != null说明该q节点不需要移除</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (q.thread != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        pred = q;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果q.thread == null，且pred != null，需要删除q节点</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 删除q节点</span></span><br><span class=\"line\">                        pred.next = s;</span><br><span class=\"line\">                         <span class=\"comment\">// pred.thread == null时说明在并发情况下被其他线程修改了；</span></span><br><span class=\"line\">                         <span class=\"comment\">// 返回第一个for循环重试</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (pred.thread == <span class=\"keyword\">null</span>) <span class=\"comment\">// check for race</span></span><br><span class=\"line\">                            <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                     <span class=\"comment\">// 如果q.thread != null且pred == null，说明q是栈顶节点</span></span><br><span class=\"line\">                     <span class=\"comment\">// 设置栈顶元素为s节点，如果失败则返回重试</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, waitersOffset,</span><br><span class=\"line\">                                                          q, s))</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Unsafe mechanics</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> stateOffset;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> runnerOffset;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> waitersOffset;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class=\"line\">            Class&lt;?&gt; k = FutureTask.class;</span><br><span class=\"line\">            stateOffset = UNSAFE.objectFieldOffset</span><br><span class=\"line\">                (k.getDeclaredField(<span class=\"string\">\"state\"</span>));</span><br><span class=\"line\">            runnerOffset = UNSAFE.objectFieldOffset</span><br><span class=\"line\">                (k.getDeclaredField(<span class=\"string\">\"runner\"</span>));</span><br><span class=\"line\">            waitersOffset = UNSAFE.objectFieldOffset</span><br><span class=\"line\">                (k.getDeclaredField(<span class=\"string\">\"waiters\"</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"线程池中的线程初始化\"><a href=\"#线程池中的线程初始化\" class=\"headerlink\" title=\"线程池中的线程初始化\"></a>线程池中的线程初始化</h2><p>　　默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：</p>\n<ul>\n<li>prestartCoreThread()：初始化一个核心线程；</li>\n<li>prestartAllCoreThreads()：初始化所有核心线程</li>\n</ul>\n<h2 id=\"线程池的关闭\"><a href=\"#线程池的关闭\" class=\"headerlink\" title=\"线程池的关闭\"></a>线程池的关闭</h2><p>ThreadPoolExecutor提供了两个方法，用于线程池的关闭</p>\n<ul>\n<li>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li>\n<li>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</li>\n</ul>\n<h2 id=\"线程池大小\"><a href=\"#线程池大小\" class=\"headerlink\" title=\"线程池大小\"></a>线程池大小</h2><ol>\n<li>粗略<ol>\n<li>如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1</li>\n<li>如果是IO密集型任务，参考值可以设置为2*NCPU</li>\n</ol>\n</li>\n<li>精确：（(线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目</li>\n<li>最佳：压测</li>\n</ol>\n<h2 id=\"任务缓存队列\"><a href=\"#任务缓存队列\" class=\"headerlink\" title=\"任务缓存队列\"></a>任务缓存队列</h2><p><strong>workQueue</strong>，它用来存放等待执行的任务。BlockingQueue 是个接口，你需要使用它的实现之一来使用BlockingQueue，java.util.concurrent包下具有以下 BlockingQueue 接口的实现类：</p>\n<ul>\n<li>ArrayBlockingQueue：ArrayBlockingQueue 是一个有界的阻塞队列，其内部实现是将对象放到一个数组里。有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了(译者注：因为它是基于数组实现的，也就具有数组的特性：一旦初始化，大小就无法修改)。</li>\n<li>LinkedBlockingQueue：LinkedBlockingQueue 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。</li>\n<li>DelayQueue：DelayQueue 对元素进行持有直到一个特定的延迟到期。注入其中的元素必须实现 java.util.concurrent.Delayed 接口。</li>\n<li>PriorityBlockingQueue：PriorityBlockingQueue 是一个无界的并发队列。它使用了和类 java.util.PriorityQueue 一样的排序规则。你无法向这个队列中插入 null 值。所有插入到 PriorityBlockingQueue 的元素必须实现 java.lang.Comparable 接口。因此该队列中元素的排序就取决于你自己的 Comparable 实现。</li>\n<li>SynchronousQueue：SynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。</li>\n</ul>\n<h2 id=\"线程池总结\"><a href=\"#线程池总结\" class=\"headerlink\" title=\"线程池总结\"></a>线程池总结</h2><ol>\n<li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</li>\n<li>当调用 execute() 方法添加一个任务时，线程池会做如下判断：<ol>\n<li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li>\n<li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li>\n<li>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li>\n<li>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。</li>\n<li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li>\n<li>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h1><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>操作系统调度的最小单元是线程，也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程， 这些线程都拥有各自的计数器、 堆栈和局部变量等属性， 并且能够访问共享的内存变量。 处理器在这些线程上高速切换， 让使用者感觉到这些线程在同时执行。</p>","more":"<h4 id=\"线程的创建\"><a href=\"#线程的创建\" class=\"headerlink\" title=\"线程的创建\"></a>线程的创建</h4><ul>\n<li>通过继承Thread类来创建一个线程</li>\n<li>实现Runnable接口并重写run()方法，new Thread(runnable).start()，线程启动时就会自动调用该对象的run方法</li>\n<li>实现Callable接口并实现call()方法，使用FutureTask类包装Callable对象，使用FutureTask对象作为Thread对象的targer创建并启动线程；也可以使用线程池启动<pre><code>Runnable 和 Callable 的区别\n 1. Runnable规定方法是run方法，Callable规定方法是call方法\n 2. Runnable任务执行后无返回值，Callable任务执行后可返回值\n 3. run方法无法抛出异常，call方法可以抛出异常\n 4. 运行Callable任务可以拿到一个Future对象，Future表示异步计算结果，他提供了检查计算是否完成的方法，以等待计算完成并获取结果。计算完成后用get()方法获取结果，如果线程没有执行完，get()方法会阻塞当前线程执行。如果线程出现异常，get()方法会抛出异常。</code></pre></li>\n<li>线程池：Executors类提供了方便的工厂方法来创建不同类型的 executor services。无论Runnable还是Callable都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行<pre><code>1. public static ExecutorService newCachedThreadPool() 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程，但是在之前构造的线程可用时将重用它们。\n2. public static ExecutorService newFixedThreadPool(int nThreads)  创建一个定长线程池，可控制线程最大并发数，以共享的无界队列方式来运行线程，超出的线程会在队列中等待。\n3. public static ExecutorService newSingleThreadExecutor() 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，以无界队列方式来运行线程，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n4. public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 创建一个周期线程池，支持定时及周期性任务执行。\n5. public static ExecutorService newWorkStealingPool() 创建持有足够线程的线程池来支持给定的并行级别，并通过使用多个队列，减少竞争，它需要穿一个并行级别的参数，如果不传，则被设定为默认的CPU数量，这个线程池实际上是ForkJoinPool的扩展，适合使用在很耗时的任务中，能够合理的使用CPU进行并行操作。</code></pre></li>\n</ul>\n<h4 id=\"线程的管理\"><a href=\"#线程的管理\" class=\"headerlink\" title=\"线程的管理\"></a>线程的管理</h4><ul>\n<li>ForkJoinPool 的每个工作线程都维护了一个工作队列(WorkQueue)，这是一个双端队列，里面存放的对象是任务(ForkJoinTask)<ul>\n<li>每个工作线程在运行中产生新的任务(通常是因为调用了fork())，会放入工作队列的队尾，并且工作线程在处理自己的工作队列时，使用的是LIFO方式，也就是每次从队尾取任务执行。</li>\n<li>每个工作线程在处理自己的工作队列时，会尝试窃取一个任务(或是来自刚刚提交到pool的任务，或是来自其他的工作队列)，窃取的任务位于其他线程工作队列的队首，也就是使用FIFO方式。</li>\n<li>在遇到join()时如果join的任务尚未完成，则会先处理其他任务，并等待其完成。</li>\n</ul>\n</li>\n<li>ExecutorCompletionService 内部维护了一个阻塞队列(BlockingQueue), 只有完成的任务才被加入到队列中。如果队列中的数据为空时, 调用take()就会阻塞直到有完成的任务加入队列，基于FutureTask实现。</li>\n</ul>\n<h1 id=\"线程池原理\"><a href=\"#线程池原理\" class=\"headerlink\" title=\"线程池原理\"></a>线程池原理</h1><h2 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (corePoolSize &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt;= <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt; corePoolSize ||</span><br><span class=\"line\">        keepAliveTime &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workQueue == <span class=\"keyword\">null</span> || threadFactory == <span class=\"keyword\">null</span> || handler == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.acc = System.getSecurityManager() == <span class=\"keyword\">null</span> ?</span><br><span class=\"line\">            <span class=\"keyword\">null</span> :</span><br><span class=\"line\">            AccessController.getContext();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.workQueue = workQueue;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threadFactory = threadFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>corePoolSize 核心线程数量，当有新任务在exectue()方法提交时，会执行以下判断：<pre><code>1. 如果运行的线程少于 corePoolSize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的；\n2. 如果线程池中的线程数量大于等于 corePoolSize 且小于 maximumPoolSize，则只有当workQueue满时才创建新的线程去处理任务；\n3. 如果设置的corePoolSize 和 maximumPoolSize相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取任务并处理；\n4. 如果运行的线程数量大于等于maximumPoolSize，这时如果workQueue已经满了，则通过handler所指定的策略来处理任务；\n5. 所以，任务提交时，判断的顺序为 corePoolSize –&gt; workQueue –&gt; maximumPoolSize</code></pre></li>\n<li>maximumPoolSize 最大线程数量；</li>\n<li>keepAliveTime 线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime；</li>\n<li>TimeUnit 线程保持活动的时间单位</li>\n<li>BlockingQueue<runnable> workQueue 保存等待执行的任务的阻塞队列，当提交一个新的任务到线程池以后, 线程池会根据当前线程池中正在运行着的线程的数量来决定对该任务的处理方式，主要有以下几种处理方式:<ul>\n<li><strong>直接切换</strong>：这种方式常用的队列是SynchronousQueue</li>\n<li><strong>使用无界队列</strong>：一般使用基于链表的阻塞队列LinkedBlockingQueue。如果使用这种方式，那么线程池中能够创建的最大线程数就是corePoolSize，而maximumPoolSize就不会起作用了。当线程池中所有的核心线程都是RUNNING状态时，这时一个新的任务提交就会放入等待队列中。</li>\n<li><strong>使用有界队列</strong>：一般使用ArrayBlockingQueue。使用该方式可以将线程池的最大线程数量限制为maximumPoolSize，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。</li>\n</ul>\n</runnable></li>\n<li>threadFactory 它是ThreadFactory类型的变量，用来创建新线程。默认使用Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称。</li>\n<li>handler 它是RejectedExecutionHandler类型的变量，表示线程池的饱和的<strong>拒绝策略</strong>。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。线程池提供了4种策略：<ul>\n<li>AbortPolicy：直接抛出异常，这是默认策略；</li>\n<li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li>\n<li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>\n<li>DiscardPolicy：直接丢弃任务；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"线程池状态\"><a href=\"#线程池状态\" class=\"headerlink\" title=\"线程池状态\"></a>线程池状态</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> COUNT_BITS = Integer.SIZE - <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CAPACITY   = (<span class=\"number\">1</span> &lt;&lt; COUNT_BITS) - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// runState is stored in the high-order bits</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RUNNING    = -<span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHUTDOWN   =  <span class=\"number\">0</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> STOP       =  <span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TIDYING    =  <span class=\"number\">2</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TERMINATED =  <span class=\"number\">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>COUNT_BITS: 线程的最大位数29位</li>\n<li>CAPACITY：线程的最大容量</li>\n<li>RUNNING：运行状态，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0</li>\n<li>SHUTDOWN：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 </li>\n<li>STOP：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。</li>\n<li>TIDYING：当所有的任务已终止，任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。</li>\n<li>TERMINATED：终止状态，当执行 terminated() 后会更新为这个状态。<br><img src=\"/JAVA/Java-ThreadPool/01.png\" alt=\"\"></li>\n</ul>\n<h2 id=\"核心源码\"><a href=\"#核心源码\" class=\"headerlink\" title=\"核心源码\"></a>核心源码</h2><h3 id=\"线程池执行源码\"><a href=\"#线程池执行源码\" class=\"headerlink\" title=\"线程池执行源码\"></a>线程池执行源码</h3><h4 id=\"execute\"><a href=\"#execute\" class=\"headerlink\" title=\"execute\"></a>execute</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// clt记录着runState和workerCount</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// workerCountOf方法取出低29位的值，表示当前活动的线程数；</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中，并把任务添加到该线程中；</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果为true，根据corePoolSize来判断；</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果为false，则根据maximumPoolSize来判断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 如果添加失败，则重新获取ctl值</span></span><br><span class=\"line\">        c = ctl.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果当前线程池是运行状态 并且 任务能够成功添加到工作队列</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 重新获取ctl值</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，</span></span><br><span class=\"line\">        <span class=\"comment\">// 这时需要移除该command</span></span><br><span class=\"line\">        <span class=\"comment\">// 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">            reject(command);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；</span></span><br><span class=\"line\">        <span class=\"comment\">// 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果执行到这里，有两种情况：</span></span><br><span class=\"line\">    <span class=\"comment\">// 1.线程池已经不是RUNNING状态；</span></span><br><span class=\"line\">    <span class=\"comment\">// 2.线程池是RUNNING状态，但workerCount &gt;= corePoolSize并且workQueue已满;</span></span><br><span class=\"line\">    <span class=\"comment\">// 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果失败则拒绝该任务 </span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">        reject(command);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>runState和workCount变量怎么存储在一个int中？参考：<a href=\"https://blog.csdn.net/weixin_34396902/article/details/94527424\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/weixin_34396902/article/details/94527424</a></p>\n<h4 id=\"addWorker\"><a href=\"#addWorker\" class=\"headerlink\" title=\"addWorker\"></a>addWorker</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 循环CAS操作，将线程池中的线程数+1</span></span><br><span class=\"line\">    retry:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// clt记录着runState和workerCount</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取运行状态</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果rs &gt;= SHUTDOWN，则表示此时不再接收新任务；</span></span><br><span class=\"line\">        <span class=\"comment\">// 接着判断以下3个条件，只要有1个不满足，则返回false：</span></span><br><span class=\"line\">        <span class=\"comment\">// 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务</span></span><br><span class=\"line\">        <span class=\"comment\">// 2. firsTask为空</span></span><br><span class=\"line\">        <span class=\"comment\">// 3. 阻塞队列不为空</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"comment\">// rs == SHUTDOWN的情况</span></span><br><span class=\"line\">        <span class=\"comment\">// 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果firstTask为空，并且workQueue也为空，因为队列中已经没有任务了，不需要再添加线程了，则返回false，</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class=\"line\">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class=\"line\">               firstTask == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">               ! workQueue.isEmpty()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取线程数</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 如果wc超过CAPACITY(最大线程数线程数),也就是ctl的低29位的最大值（二进制是29个1），返回false；</span></span><br><span class=\"line\">            <span class=\"comment\">// core是addWorker方法的第二个参数,如果为true表示根据corePoolSize来比较，如果为false则根据maximumPoolSize来比较;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wc &gt;= CAPACITY ||</span><br><span class=\"line\">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// CAS操作尝试增加workerCount，修改clt的值+1，如果成功，则跳出第一个for循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 如果增加workerCount失败，则重新获取ctl的值</span></span><br><span class=\"line\">            c = ctl.get();  </span><br><span class=\"line\">            <span class=\"comment\">// 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 新建线程，并加入到线程池workers中。</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据firstTask来创建Worker对象</span></span><br><span class=\"line\">        w = <span class=\"keyword\">new</span> Worker(firstTask);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 每一个Worker对象都会创建一个线程</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 对workers操作要通过加锁来实现</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">            mainLock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取运行状态</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> rs = runStateOf(ctl.get());</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// rs &lt; SHUTDOWN表示是RUNNING状态；</span></span><br><span class=\"line\">                <span class=\"comment\">// 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。</span></span><br><span class=\"line\">                <span class=\"comment\">// 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||</span><br><span class=\"line\">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 判断添加的任务状态,如果已经开始丢出异常</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (t.isAlive()) </span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"comment\">// 将新建的线程加入到线程池中，workers是一个hashSet</span></span><br><span class=\"line\">                    workers.add(w);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"comment\">// largestPoolSize记录着线程池中出现过的最大线程数量</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                        largestPoolSize = s;</span><br><span class=\"line\">                    <span class=\"comment\">//标记任务添加</span></span><br><span class=\"line\">                    workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                mainLock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">                t.start();</span><br><span class=\"line\">                <span class=\"comment\">// 标记线程启动</span></span><br><span class=\"line\">                workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 线程添加线程池失败或者线程start失败，则需要调用addWorkerFailed函数</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果添加成功则需要移除线程，并恢复复clt的值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">            addWorkerFailed(w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> workerStarted;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>t.start()这个语句，启动时会调用Worker类中的run方法，Worker本身实现了Runnable接口，所以一个Worker类型的对象也是一个线程。</p>\n<h4 id=\"Worker类\"><a href=\"#Worker类\" class=\"headerlink\" title=\"Worker类\"></a>Worker类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Worker</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">6138294804551838833L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** 线程池中正真运行的线程。通过我们指定的线程工厂创建而来 **/</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread thread;</span><br><span class=\"line\">    <span class=\"comment\">/** 线程包装的任务。thread 在run时主要调用了该任务的run方法 */</span></span><br><span class=\"line\">    Runnable firstTask;</span><br><span class=\"line\">    <span class=\"comment\">/** 记录当前线程完成的任务数 */</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> completedTasks;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> firstTask the first task (null if none)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Worker(Runnable firstTask) &#123;</span><br><span class=\"line\">        setState(-<span class=\"number\">1</span>); <span class=\"comment\">// 在调用runWorker()前，禁止interrupt中断，在interruptIfStarted()方法中会判断 getState()&gt;=0</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.firstTask = firstTask;</span><br><span class=\"line\">        <span class=\"comment\">// 利用我们指定的线程工厂创建一个线程</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.thread = getThreadFactory().newThread(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Delegates main run loop to outer runWorker  */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        runWorker(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Lock methods</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// The value 0 represents the unlocked state.</span></span><br><span class=\"line\">    <span class=\"comment\">// The value 1 represents the locked state.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHeldExclusively</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getState() != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 尝试获取锁</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> unused)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//尝试一次将state从0设置为1，即“锁定”状态，</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//设置exclusiveOwnerThread=当前线程</span></span><br><span class=\"line\">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 尝试释放锁</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> unused)</span> </span>&#123;</span><br><span class=\"line\">        setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        setState(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span>        </span>&#123; acquire(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">()</span>  </span>&#123; <span class=\"keyword\">return</span> tryAcquire(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span>      </span>&#123; release(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isLocked</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> isHeldExclusively(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 中断（如果运行）</span></span><br><span class=\"line\"><span class=\"comment\">    * shutdownNow时会循环对worker线程执行</span></span><br><span class=\"line\"><span class=\"comment\">    * 且不需要获取worker锁，即使在worker运行时也可以中断</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">interruptIfStarted</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread t;</span><br><span class=\"line\">        <span class=\"comment\">// 如果state&gt;=0、t!=null、且t没有被中断</span></span><br><span class=\"line\">        <span class=\"comment\">// new Worker()时state==-1，说明不能中断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getState() &gt;= <span class=\"number\">0</span> &amp;&amp; (t = thread) != <span class=\"keyword\">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                t.interrupt();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (SecurityException ignore) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Worker类投机取巧的继承了AbstractQueuedSynchronizer来简化在执行任务时的获取、释放锁,这样防止了中断在运行中的任务，只会唤醒(中断)在等待从workQueue中获取任务的线程.<br>不直接执行execute(command)提交的command，而要在外面包一层Worker主要是为了使用用AQS锁控制中断，当运行时上锁，就不能中断，TreadPoolExecutor的shutdown()方法中断前都要获取worker锁，只有在等待从workQueue中获取任务getTask()时才能中断。</p>\n<h4 id=\"runWorker-方法\"><a href=\"#runWorker-方法\" class=\"headerlink\" title=\"runWorker 方法\"></a>runWorker 方法</h4><p>在Worker类中的run方法调用了runWorker方法来执行任务.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">    Thread wt = Thread.currentThread();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 获取第一个任务</span></span><br><span class=\"line\">    Runnable task = w.firstTask;</span><br><span class=\"line\">    w.firstTask = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    w.unlock(); <span class=\"comment\">// 允许中断</span></span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"comment\">// 是否因为异常退出循环</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 如果task为空，则通过getTask来获取任务</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            w.lock();</span><br><span class=\"line\">            <span class=\"comment\">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class=\"line\">            <span class=\"comment\">// if not, ensure thread is not interrupted.  This</span></span><br><span class=\"line\">            <span class=\"comment\">// requires a recheck in second case to deal with</span></span><br><span class=\"line\">            <span class=\"comment\">// shutdownNow race while clearing interrupt</span></span><br><span class=\"line\">            <span class=\"comment\">// 线程池处于stop状态或者当前线程被中断时，线程池状态是stop状态</span></span><br><span class=\"line\">            <span class=\"comment\">// 但是当前线程没有中断，则发出中断请求</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class=\"line\">                 (Thread.interrupted() &amp;&amp;</span><br><span class=\"line\">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class=\"line\">                !wt.isInterrupted())</span><br><span class=\"line\">                wt.interrupt();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//开始执行任务前的Hook，类似回调函数</span></span><br><span class=\"line\">                beforeExecute(wt, task);</span><br><span class=\"line\">                Throwable thrown = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//执行任务</span></span><br><span class=\"line\">                    task.run();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Error x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(x);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//任务执行后的Hook，类似回调函数</span></span><br><span class=\"line\">                    afterExecute(task, thrown);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//执行完毕后task重置，completedTasks计数器++，解锁</span></span><br><span class=\"line\">                task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                w.completedTasks++;</span><br><span class=\"line\">                w.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//标记正常退出</span></span><br><span class=\"line\">        completedAbruptly = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//线程空闲达到我们设定的值时，Worker退出销毁。</span></span><br><span class=\"line\">        processWorkerExit(w, completedAbruptly);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"getTask-方法\"><a href=\"#getTask-方法\" class=\"headerlink\" title=\"getTask 方法\"></a>getTask 方法</h4><p>runWorker函数中最重要的是getTask()，不断的从阻塞队列中取任务交给线程执行，并且负责线程回收</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 表示上次从阻塞队列中取任务时是否超时</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> timedOut = <span class=\"keyword\">false</span>; <span class=\"comment\">// Did the last poll() time out?</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果线程池处于shutdown状态，</span></span><br><span class=\"line\">        <span class=\"comment\">// 并且队列为空，或者线程池处于stop或者terminate状态，</span></span><br><span class=\"line\">        <span class=\"comment\">// 在线程池数量-1，返回null，回收线程</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">            decrementWorkerCount();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取线程数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// timed变量用于判断是否需要进行超时控制。</span></span><br><span class=\"line\">        <span class=\"comment\">// allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；</span></span><br><span class=\"line\">        <span class=\"comment\">// wc &gt; corePoolSize，表示当前线程池中的线程数量大于核心线程数量；</span></span><br><span class=\"line\">        <span class=\"comment\">// 对于超过核心线程数量的这些线程，需要进行超时控制</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果线程数目大于最大线程数目 或 当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时</span></span><br><span class=\"line\">        <span class=\"comment\">// 并且 线程数目大于1 或 工作队列为空</span></span><br><span class=\"line\">        <span class=\"comment\">// 尝试将workerCount减1；</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class=\"line\">            &amp;&amp; (wc &gt; <span class=\"number\">1</span> || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//**保证核心线程不被销毁**</span></span><br><span class=\"line\">            <span class=\"comment\">// 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null；</span></span><br><span class=\"line\">            <span class=\"comment\">// 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。</span></span><br><span class=\"line\">            Runnable r = timed ?</span><br><span class=\"line\">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class=\"line\">                workQueue.take();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 如果 r == null，说明已经超时，timedOut设置为true，进入下一个循环</span></span><br><span class=\"line\">            timedOut = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException retry) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试</span></span><br><span class=\"line\">            timedOut = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"FutureTask源码\"><a href=\"#FutureTask源码\" class=\"headerlink\" title=\"FutureTask源码\"></a>FutureTask源码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FutureTask</span>&lt;<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">RunnableFuture</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * state字段用来保存FutureTask内部的任务执行状态，一共有7中状态，每种状态及其对应的值如下</span></span><br><span class=\"line\"><span class=\"comment\">     * NEW:表示是个新的任务或者还没被执行完的任务。这是初始状态。</span></span><br><span class=\"line\"><span class=\"comment\">     * COMPLETING:任务已经执行完成或者执行任务的时候发生异常，但是任务执行结果或者异常原因还没有保存到outcome字段(outcome字段用来保存任务执行结果，如果发生异常，则用来保存异常原因)的时候，状态会从NEW变更到COMPLETING。但是这个状态会时间会比较短，属于中间状态。</span></span><br><span class=\"line\"><span class=\"comment\">     * NORMAL:任务已经执行完成并且任务执行结果已经保存到outcome字段，状态会从COMPLETING转换到NORMAL。这是一个最终态。</span></span><br><span class=\"line\"><span class=\"comment\">     * EXCEPTIONAL:任务执行发生异常并且异常原因已经保存到outcome字段中后，状态会从COMPLETING转换到EXCEPTIONAL。这是一个最终态。</span></span><br><span class=\"line\"><span class=\"comment\">     * CANCELLED:任务还没开始执行或者已经开始执行但是还没有执行完成的时候，用户调用了cancel(false)方法取消任务且不中断任务执行线程，这个时候状态会从NEW转化为CANCELLED状态。这是一个最终态。</span></span><br><span class=\"line\"><span class=\"comment\">     * INTERRUPTING: 任务还没开始执行或者已经执行但是还没有执行完成的时候，用户调用了cancel(true)方法取消任务并且要中断任务执行线程但是还没有中断任务执行线程之前，状态会从NEW转化为INTERRUPTING。这是一个中间状态。</span></span><br><span class=\"line\"><span class=\"comment\">     * INTERRUPTED:调用interrupt()中断任务执行线程之后状态会从INTERRUPTING转换到INTERRUPTED。这是一个最终态。</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * NEW -&gt; COMPLETING -&gt; NORMAL 正常执行并返回</span></span><br><span class=\"line\"><span class=\"comment\">     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL 执行过程中出现了异常</span></span><br><span class=\"line\"><span class=\"comment\">     * NEW -&gt; CANCELLED 执行前被取消</span></span><br><span class=\"line\"><span class=\"comment\">     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED 取消时被中断</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> state;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> NEW          = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> COMPLETING   = <span class=\"number\">1</span>;<span class=\"comment\">//大于这个值就是完成状态</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> NORMAL       = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> EXCEPTIONAL  = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CANCELLED    = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INTERRUPTING = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INTERRUPTED  = <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** The underlying callable; nulled out after running */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Callable&lt;V&gt; callable;</span><br><span class=\"line\">    <span class=\"comment\">/** The result to return or exception to throw from get() */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object outcome; <span class=\"comment\">// non-volatile, protected by state reads/writes</span></span><br><span class=\"line\">    <span class=\"comment\">/** 执行callable的线程 **/</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> Thread runner;</span><br><span class=\"line\">    <span class=\"comment\">/** 使用Treiber算法实现的无阻塞的Stack，用于存放等待的线程 */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> WaitNode waiters;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> V <span class=\"title\">report</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> <span class=\"keyword\">throws</span> ExecutionException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 拿到返回结果</span></span><br><span class=\"line\">        Object x = outcome;</span><br><span class=\"line\">        <span class=\"comment\">// 判断状态</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == NORMAL)</span><br><span class=\"line\">            <span class=\"comment\">// 状态正常，就返回结果值</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (V)x;</span><br><span class=\"line\">        <span class=\"comment\">// 判断异常，就抛出异常。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s &gt;= CANCELLED)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CancellationException();</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ExecutionException((Throwable)x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 构造方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FutureTask</span><span class=\"params\">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (callable == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.callable = callable;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = NEW;       <span class=\"comment\">// ensure visibility of callable</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个构造方法会把传入的Runnable封装成一个Callable对象保存在callable字段中，同时如果任务执行成功的话就会返回传入的result。</span></span><br><span class=\"line\"><span class=\"comment\">     * 这种情况下如果不需要返回值的话可以传入一个null。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FutureTask</span><span class=\"params\">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.callable = Executors.callable(runnable, result);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = NEW;       <span class=\"comment\">// ensure visibility of callable</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//判断任务是否被取消</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isCancelled</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state &gt;= CANCELLED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//判断任务是否完成</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isDone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state != NEW;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"keyword\">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 任务是new状态 并且 根据mayInterruptIfRunning把状态从NEW转化到INTERRUPTING或CANCELLED </span></span><br><span class=\"line\">        <span class=\"comment\">// 不符合上述状态，返回false</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(state == NEW &amp;&amp;</span><br><span class=\"line\">              UNSAFE.compareAndSwapInt(<span class=\"keyword\">this</span>, stateOffset, NEW,</span><br><span class=\"line\">                  mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;    </span><br><span class=\"line\">        <span class=\"comment\">// 2. 如果需要中断任务执行线程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mayInterruptIfRunning) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// runner保存着当前执行任务的线程</span></span><br><span class=\"line\">                    Thread t = runner;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        <span class=\"comment\">//中断任务执行线程</span></span><br><span class=\"line\">                        t.interrupt();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123; <span class=\"comment\">// final state</span></span><br><span class=\"line\">                    <span class=\"comment\">// 修改状态为INTERRUPTED</span></span><br><span class=\"line\">                    UNSAFE.putOrderedInt(<span class=\"keyword\">this</span>, stateOffset, INTERRUPTED);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            finishCompletion();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">        <span class=\"comment\">// 判断任务当前的state &lt;= COMPLETING是否成立。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s &lt;= COMPLETING)</span><br><span class=\"line\">            <span class=\"comment\">// 如果成立，表明任务还没有结束(这里的结束包括任务正常执行完毕，任务执行异常，任务被取消)</span></span><br><span class=\"line\">            <span class=\"comment\">// 调用awaitDone()进行阻塞等待。</span></span><br><span class=\"line\">            s = awaitDone(<span class=\"keyword\">false</span>, <span class=\"number\">0L</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 任务已经结束，调用report()返回结果。</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> report(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (unit == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">        <span class=\"comment\">// 如果awaitDone()超时返回之后任务还没结束，则抛出异常</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class=\"line\">            (s = awaitDone(<span class=\"keyword\">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> TimeoutException();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> report(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(V v)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 尝试CAS操作，把当前的状态从NEW变更为COMPLETING(中间状态)状态。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (UNSAFE.compareAndSwapInt(<span class=\"keyword\">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 把任务执行结果保存在outcome字段中。</span></span><br><span class=\"line\">            outcome = v;</span><br><span class=\"line\">            <span class=\"comment\">// CAS的把当前任务状态从COMPLETING变更为NORMAL</span></span><br><span class=\"line\">            UNSAFE.putOrderedInt(<span class=\"keyword\">this</span>, stateOffset, NORMAL); <span class=\"comment\">// final state</span></span><br><span class=\"line\">            finishCompletion();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setException</span><span class=\"params\">(Throwable t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 尝试CAS操作，把当前的状态从NEW变更为COMPLETING(中间状态)状态。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (UNSAFE.compareAndSwapInt(<span class=\"keyword\">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 把异常原因保存在outcome字段中，outcome字段用来保存任务执行结果或者异常原因。</span></span><br><span class=\"line\">            outcome = t;</span><br><span class=\"line\">            <span class=\"comment\">// CAS的把当前任务状态从COMPLETING变更为EXCEPTIONAL。</span></span><br><span class=\"line\">            UNSAFE.putOrderedInt(<span class=\"keyword\">this</span>, stateOffset, EXCEPTIONAL); <span class=\"comment\">// final state</span></span><br><span class=\"line\">            finishCompletion();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 状态如果不是NEW，说明任务或者已经执行过，或者已经被取消，直接返回</span></span><br><span class=\"line\">        <span class=\"comment\">// 状态如果是NEW，则尝试把当前执行线程保存在runner字段(runnerOffset)中，如果赋值失败则直接返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state != NEW ||</span><br><span class=\"line\">            !UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, runnerOffset,</span><br><span class=\"line\">                                         <span class=\"keyword\">null</span>, Thread.currentThread()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Callable&lt;V&gt; c = callable;</span><br><span class=\"line\">            <span class=\"comment\">// 只有初始状态才会执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c != <span class=\"keyword\">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class=\"line\">                V result;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> ran;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 执行任务  计算逻辑</span></span><br><span class=\"line\">                    result = c.call();</span><br><span class=\"line\">                    ran = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                    result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    ran = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// 保存异常</span></span><br><span class=\"line\">                    setException(ex);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ran)</span><br><span class=\"line\">                    <span class=\"comment\">// 任务执行成功，保存返回结果</span></span><br><span class=\"line\">                    set(result);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 无论是否执行成功，把runner设置为null</span></span><br><span class=\"line\">            runner = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">// state must be re-read after nulling runner to prevent</span></span><br><span class=\"line\">            <span class=\"comment\">// leaked interrupts</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">            <span class=\"comment\">// 如果任务被中断，执行中断处理</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s &gt;= INTERRUPTING)</span><br><span class=\"line\">                handlePossibleCancellationInterrupt(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 与run方法类似，区别在于这个方法不会设置任务的执行结果值</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> true&#125; if successfully run and reset</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">runAndReset</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state != NEW ||</span><br><span class=\"line\">            !UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, runnerOffset,</span><br><span class=\"line\">                                         <span class=\"keyword\">null</span>, Thread.currentThread()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> ran = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Callable&lt;V&gt; c = callable;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c != <span class=\"keyword\">null</span> &amp;&amp; s == NEW) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 不获取和设置返回值</span></span><br><span class=\"line\">                    c.call(); <span class=\"comment\">// don't set result</span></span><br><span class=\"line\">                    ran = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                    setException(ex);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            runner = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            s = state;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s &gt;= INTERRUPTING)</span><br><span class=\"line\">                handlePossibleCancellationInterrupt(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 是否正确的执行并复位</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ran &amp;&amp; s == NEW;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handlePossibleCancellationInterrupt</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == INTERRUPTING)</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (state == INTERRUPTING)</span><br><span class=\"line\">                Thread.yield(); <span class=\"comment\">// wait out pending interrupt</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 确保cancel(true)产生的中断发生在run或runAndReset方法执行的过程中。</span></span><br><span class=\"line\">        <span class=\"comment\">//这里会循环的调用Thread.yield()来确保状态在cancel方法中被设置为INTERRUPTED。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Simple linked list nodes to record waiting threads in a Treiber</span></span><br><span class=\"line\"><span class=\"comment\">     * stack.  See other classes such as Phaser and SynchronousQueue</span></span><br><span class=\"line\"><span class=\"comment\">     * for more detailed explanation.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WaitNode</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">volatile</span> Thread thread;</span><br><span class=\"line\">        <span class=\"keyword\">volatile</span> WaitNode next;</span><br><span class=\"line\">        WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Removes and signals all waiting threads, invokes done(), and</span></span><br><span class=\"line\"><span class=\"comment\">     * nulls out callable.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">finishCompletion</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// assert state &gt; COMPLETING;</span></span><br><span class=\"line\">        <span class=\"comment\">// 执行该方法时state必须大于COMPLETING</span></span><br><span class=\"line\">        <span class=\"comment\">// 依次遍历waiters链表</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (WaitNode q; (q = waiters) != <span class=\"keyword\">null</span>;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 设置栈顶节点为null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, waitersOffset, q, <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                    Thread t = q.thread;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        q.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        <span class=\"comment\">// 唤醒等待线程</span></span><br><span class=\"line\">                        LockSupport.unpark(t);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    WaitNode next = q.next;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果next为空，说明栈空了，跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// 方便gc回收</span></span><br><span class=\"line\">                    q.next = <span class=\"keyword\">null</span>; </span><br><span class=\"line\">                    <span class=\"comment\">// 重新设置栈顶node</span></span><br><span class=\"line\">                    q = next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 空方法，留给子类扩展</span></span><br><span class=\"line\">        done();</span><br><span class=\"line\"></span><br><span class=\"line\">        callable = <span class=\"keyword\">null</span>;        <span class=\"comment\">// to reduce footprint</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Awaits completion or aborts on interrupt or timeout.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> timed true if use timed waits</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> nanos time to wait, if timed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> state upon completion</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">awaitDone</span><span class=\"params\">(<span class=\"keyword\">boolean</span> timed, <span class=\"keyword\">long</span> nanos)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计算等待截止时间</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> deadline = timed ? System.nanoTime() + nanos : <span class=\"number\">0L</span>;</span><br><span class=\"line\">        WaitNode q = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> queued = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 1. 判断阻塞线程是否被中断</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Thread.interrupted()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 被中断则在等待队列中删除该节点</span></span><br><span class=\"line\">                removeWaiter(q);</span><br><span class=\"line\">                <span class=\"comment\">// 抛出InterruptedException异常</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">            <span class=\"comment\">// 2. 获取当前状态，如果状态大于COMPLETING</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s &gt; COMPLETING) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 说明任务已经结束(要么正常结束，要么异常结束，要么被取消)</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (q != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"comment\">// 把thread显示置空</span></span><br><span class=\"line\">                    q.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 返回结果</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 3. 如果状态处于中间状态COMPLETING</span></span><br><span class=\"line\">            <span class=\"comment\">// 表示任务已经结束但是任务执行线程还没来得及给outcome赋值</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s == COMPLETING) <span class=\"comment\">// cannot time out yet</span></span><br><span class=\"line\">                Thread.yield();<span class=\"comment\">// 让出执行权让其他线程优先执行</span></span><br><span class=\"line\">            <span class=\"comment\">// 4. 如果等待节点为空，则构造一个等待节点</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (q == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                q = <span class=\"keyword\">new</span> WaitNode();</span><br><span class=\"line\">            <span class=\"comment\">// 5. 如果还没有入队列，则把当前节点加入waiters首节点并替换原来waiters</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!queued)</span><br><span class=\"line\">                queued = UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, waitersOffset,</span><br><span class=\"line\">                                                     q.next = waiters, q);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (timed) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果需要等待特定时间，则先计算要等待的时间</span></span><br><span class=\"line\">                <span class=\"comment\">// 如果已经超时，则删除对应节点并返回对应的状态</span></span><br><span class=\"line\">                nanos = deadline - System.nanoTime();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nanos &lt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">                    removeWaiter(q);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 6. 阻塞等待特定时间</span></span><br><span class=\"line\">                LockSupport.parkNanos(<span class=\"keyword\">this</span>, nanos);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 6. 阻塞等待直到被其他线程唤醒</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">removeWaiter</span><span class=\"params\">(WaitNode node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将thread设置为null是因为下面要根据thread是否为null判断是否要把node移出</span></span><br><span class=\"line\">            node.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 这里自旋保证删除成功</span></span><br><span class=\"line\">            retry:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;          <span class=\"comment\">// restart on removeWaiter race</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (WaitNode pred = <span class=\"keyword\">null</span>, q = waiters, s; q != <span class=\"keyword\">null</span>; q = s) &#123;</span><br><span class=\"line\">                    s = q.next;</span><br><span class=\"line\">                    <span class=\"comment\">// q.thread != null说明该q节点不需要移除</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (q.thread != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        pred = q;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果q.thread == null，且pred != null，需要删除q节点</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 删除q节点</span></span><br><span class=\"line\">                        pred.next = s;</span><br><span class=\"line\">                         <span class=\"comment\">// pred.thread == null时说明在并发情况下被其他线程修改了；</span></span><br><span class=\"line\">                         <span class=\"comment\">// 返回第一个for循环重试</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (pred.thread == <span class=\"keyword\">null</span>) <span class=\"comment\">// check for race</span></span><br><span class=\"line\">                            <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                     <span class=\"comment\">// 如果q.thread != null且pred == null，说明q是栈顶节点</span></span><br><span class=\"line\">                     <span class=\"comment\">// 设置栈顶元素为s节点，如果失败则返回重试</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!UNSAFE.compareAndSwapObject(<span class=\"keyword\">this</span>, waitersOffset,</span><br><span class=\"line\">                                                          q, s))</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Unsafe mechanics</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> stateOffset;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> runnerOffset;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> waitersOffset;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class=\"line\">            Class&lt;?&gt; k = FutureTask.class;</span><br><span class=\"line\">            stateOffset = UNSAFE.objectFieldOffset</span><br><span class=\"line\">                (k.getDeclaredField(<span class=\"string\">\"state\"</span>));</span><br><span class=\"line\">            runnerOffset = UNSAFE.objectFieldOffset</span><br><span class=\"line\">                (k.getDeclaredField(<span class=\"string\">\"runner\"</span>));</span><br><span class=\"line\">            waitersOffset = UNSAFE.objectFieldOffset</span><br><span class=\"line\">                (k.getDeclaredField(<span class=\"string\">\"waiters\"</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"线程池中的线程初始化\"><a href=\"#线程池中的线程初始化\" class=\"headerlink\" title=\"线程池中的线程初始化\"></a>线程池中的线程初始化</h2><p>　　默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：</p>\n<ul>\n<li>prestartCoreThread()：初始化一个核心线程；</li>\n<li>prestartAllCoreThreads()：初始化所有核心线程</li>\n</ul>\n<h2 id=\"线程池的关闭\"><a href=\"#线程池的关闭\" class=\"headerlink\" title=\"线程池的关闭\"></a>线程池的关闭</h2><p>ThreadPoolExecutor提供了两个方法，用于线程池的关闭</p>\n<ul>\n<li>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li>\n<li>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</li>\n</ul>\n<h2 id=\"线程池大小\"><a href=\"#线程池大小\" class=\"headerlink\" title=\"线程池大小\"></a>线程池大小</h2><ol>\n<li>粗略<ol>\n<li>如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1</li>\n<li>如果是IO密集型任务，参考值可以设置为2*NCPU</li>\n</ol>\n</li>\n<li>精确：（(线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目</li>\n<li>最佳：压测</li>\n</ol>\n<h2 id=\"任务缓存队列\"><a href=\"#任务缓存队列\" class=\"headerlink\" title=\"任务缓存队列\"></a>任务缓存队列</h2><p><strong>workQueue</strong>，它用来存放等待执行的任务。BlockingQueue 是个接口，你需要使用它的实现之一来使用BlockingQueue，java.util.concurrent包下具有以下 BlockingQueue 接口的实现类：</p>\n<ul>\n<li>ArrayBlockingQueue：ArrayBlockingQueue 是一个有界的阻塞队列，其内部实现是将对象放到一个数组里。有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了(译者注：因为它是基于数组实现的，也就具有数组的特性：一旦初始化，大小就无法修改)。</li>\n<li>LinkedBlockingQueue：LinkedBlockingQueue 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。</li>\n<li>DelayQueue：DelayQueue 对元素进行持有直到一个特定的延迟到期。注入其中的元素必须实现 java.util.concurrent.Delayed 接口。</li>\n<li>PriorityBlockingQueue：PriorityBlockingQueue 是一个无界的并发队列。它使用了和类 java.util.PriorityQueue 一样的排序规则。你无法向这个队列中插入 null 值。所有插入到 PriorityBlockingQueue 的元素必须实现 java.lang.Comparable 接口。因此该队列中元素的排序就取决于你自己的 Comparable 实现。</li>\n<li>SynchronousQueue：SynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。</li>\n</ul>\n<h2 id=\"线程池总结\"><a href=\"#线程池总结\" class=\"headerlink\" title=\"线程池总结\"></a>线程池总结</h2><ol>\n<li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</li>\n<li>当调用 execute() 方法添加一个任务时，线程池会做如下判断：<ol>\n<li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li>\n<li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li>\n<li>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li>\n<li>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。</li>\n<li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li>\n<li>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li>\n</ol>\n</li>\n</ol>"},{"title":"Kafka背景及架构介绍","date":"2019-05-25T03:38:04.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"## Kafka创建背景\nkafka最初是LinkedIn的一个内部基础设施系统。最初开发的起因是，LinkedIn虽然有了数据库和其他系统可以用来存储数据，但是缺乏一个可以帮助处理持续数据流的组件。它的设计目的是提供一个高性能的消息系统，可以处理多种类型数据，并能够实时提供纯洁且结构化的用户活动数据和系统度量指标。\n<!-- more -->\n## Kafka简介\nKafka是由LinkedIn开发，使用Scala编写的一个分布式的消息系统，具有高性能、持久化、多副本备份、横向扩展能力。生产者往队列里写消息，消费者从队列里取消息进行业务逻辑。一般在架构设计中起到解耦、削峰、异步处理的作用。\n\nkafka对外使用topic的概念，生产者往topic里写消息，消费者从读消息。为了做到水平扩展，一个topic实际是由多个partition组成的，遇到瓶颈时，可以通过增加partition的数量来进行横向扩容。单个parition内是保证消息有序。\n\n每新写一条消息，kafka就是在对应的文件append写，所以性能非常高。\n\n## Kafka架构\n\n### 一、名词解释\n* **Broker**：消息中间件处理节点（服务器），一个节点就是一个broker，一个Kafka集群由一个或多个broker组成\n* **Topic**：Kafka对消息进行归类，发送到集群的每一条消息都要指定一个topic\n* **Partition**：物理上的概念，每个topic包含一个或多个partition，一个partition对应一个文件夹，这个文件夹下存储partition的数据和索引文件，每个partition内部是有序的\n* **Producer**：生产者，负责发布消息到broker\n* **Consumer**：消费者，从broker读取消息\n* **ConsumerGroup**：每个consumer属于一个特定的consumer group，可为每个consumer指定group name，若不指定，则属于默认的group，一条消息可以发送到不同的consumer group，但一个consumer group中只能有一个consumer能消费这条消息\n* **replica**：partition 的副本，保障 partition 的高可用。\n* **leader**：replica 中的一个角色， producer 和 consumer 只跟 leader 交互。\n* **follower**：replica 中的一个角色，从 leader 中复制数据。\n* **controller**：每个集群都有一个broker同时充当了集群控制器角色（自动从集群的活跃成员中选举出来），负责管理工作包括分配分区给broker，监控broker等等\n* **zookeeper**：Kafka 通过 zookeeper 来存储集群的 meta 信息。\n\n### 二、架构图\n#### 总体数据流\n![](Kafka-Background/1.png)\nProducers往Brokers里面的指定Topic中写消息，Consumers从Brokers里面拉去指定Topic的消息，然后进行业务处理。\n\n#### 生产者\n![](Kafka-Background/2.png)\n①首先要构造一个 ProducerRecord 对象，该对象可以声明主题Topic、分区Partition、键 Key以及值 Value，主题和值是必须要声明的，分区和键可以不用指定。\n\n②调用send() 方法进行消息发送。\n\n③因为消息要到网络上进行传输，所以必须进行序列化，序列化器的作用就是把消息的 key 和 value对象序列化成字节数组。\n\n④接下来数据传到分区器，如果之间的 ProducerRecord 对象指定了分区，那么分区器将不再做任何事，直接把指定的分区返回；如果没有，那么分区器会根据 Key 来选择一个分区，选择好分区之后，生产者就知道该往哪个主题和分区发送记录了。\n\n⑤接着这条记录会被添加到一个记录批次里面，这个批次里所有的消息会被发送到相同的主题和分区。会有一个独立的线程来把这些记录批次发送到相应的 Broker 上。\n\n③Broker成功接收到消息，表示发送成功，返回消息的元数据（包括主题和分区信息以及记录在分区里的偏移量）。发送失败，可以选择重试或者直接抛出异常。\n\nkey的作用：可以为消息的附加消息，也可以用来决定消息该被写到哪个主题分区，拥有相同key的消息将会被写到同一分区\n\n#### topic\n![](Kafka-Background/3.jpg)\n从上图可以看出，Topic中数据是顺序不可变序列，采用log追加方式写入，因而kafka中无因随机写入导致性能低下的问题。\n\nTopic的数据可存储在多个partition中，即可存放在不同的服务器上。这可使Topic大小不限于一台server容量。同时，消息存在多个partition上，可以实现Topic上消息的并发访问。\n\n#### partition\n![](Kafka-Background/4.jpg)\n\n每个 Partition 中的消息都是有序的，生产的消息被不断追加到 Partition log 上，其中的每一个消息都被赋予了一个唯一的 offset 值。 因此数据不会因消费而丢失，所以只要consumer指定offset，一个消息可被不同的consumer多次消费。\n\nkafka中只能保证partition中记录是有序的，而不保证topic中不同partition的顺序。\n\n分区的原因：\n\n* 方便在集群中扩展，每个 Partition 可以通过调整以适应它所在的机器，而一个 topic 又可以有多个 Partition 组成，因此整个集群就可以适应任意大小的数据了;\n* 可以提高并发，因为可以以 Partition 为单位读写了。\n\n#### Replication\n同一个 partition 可能会有多个 replication(对应 server.properties 配置中的 default.replication.factor=N)。\n\n没有 replication 的情况下，一旦 broker 宕机，其上所有 patition 的数据都不可被消费，同时 producer 也不能再将数据存于其上的 patition。\n\n引入 replication 之 后，同一个 partition 可能会有多个 replication，而这时需要在这些 replication 之间选出一个 leader，producer 和 consumer 只与这个 leader 交互，其它 replication 作为 follower 从 leader 中复制数据。\n\n### 消费者\n![](Kafka-Background/5.jpeg)\n订阅topic是以一个消费组来订阅的，一个消费组里面可以有多个消费者。\n\n同一个消费组中的两个消费者，不会同时消费一个partition。换句话来说，`就是一个partition，只能被消费组里的一个消费者消费`，但是可以同时被多个消费组消费。\n\n因此，如果消费组内的消费者如果比partition多的话，那么就会有个别消费者一直空闲。\n\n### Kafka Zookeeper 节点\n![](Kafka-Background/6.png)\n\n\n## Kafka常见的应用场景\n#### 1.消息队列\n比起大多数的消息系统来说，Kafka有更好的吞吐量，内置的分区，冗余及容错性，这让Kafka成为了一个很好的大规模消息处理应用的解决方案。 消息系统一般吞吐量相对较低，但是需要更小的端到端延时，并尝尝依赖于Kafka提供的强大的持久性保障。在这个领域，Kafka足以媲美传统消息系统， 如ActiveMQ或RabbitMQ。\n\n#### 2.行为跟踪\n行为跟踪是kafka基于发布订阅模式的扩展应用，当我们跟踪用户浏览页面、搜索及其他行为时，以发布-订阅的模式实时记录到对应的topic里那么这些结果被订阅者拿到后，就可以做进一步的实时处理，或实时监控，或放到hadoop/离线数据仓库里处理。\n\n#### 3.元信息监控\n与行为跟踪相似，作为操作记录的监控模块来使用，即汇集记录一些操作信息，可以理解为运维性质的数据监控吧。\n\n#### 4.日志收集\n日志收集方面，其实开源产品有很多，包括Scribe、Apache Flume。很多人使用Kafka代替日志聚合（log aggregation）。日志聚合一般来说是从服务器上收集日志文件，然后放到一个集中的位置（文件服务器或分布式文件系统）进行处理。然而Kafka忽略掉文件的细节，将其更清晰地抽象成一个个日志或事件的消息流。这就让Kafka处理过程延迟更低，更容易支持多数据源和分布式数据处理。比其他系统Kafka具有更高的扩展性，高效的性能和因为复制导致的更高的耐用性保证，以及更低的端到端延迟。\n\n#### 5.流处理\n保存收集上游的流数据，以提供到下游的Storm或其他流式计算框架进行处理。很多用户会将那些从原始topic来的数据进行阶段性处理，汇总，扩充或者以其他的方式转换到新的topic下再继续后面的处理。例如一个文章推荐的处理流程，可能是先从数据源中抓取文章的内容，然后将其丢入一个叫做“文章”的topic中；后续操作可能是需要对这个内容进行清理，比如回复正常数据或者删除重复数据，最后再将内容匹配的结果返还给用户。这就在一个独立的topic之外，产生了一系列的实时数据处理的流程。Strom和Samza是非常著名的实现这种类型数据转换的框架。\n\n#### 6.持久性日志（commit log）\nKafka可以为一种外部的持久性日志的分布式系统提供服务。这种日志可以在节点之外进行持久性日志的记录，节点间备份数据，并为故障节点数据回复提供一种重新同步的机制。Kafka中提供了日志压缩功能，日志压缩之后整体的日志状态仍然保留，并且通过日志回溯可以实现持久性日志的功能。在这种用法中，Kafka类似于Apache BookKeeper项目。\n\n#### 7.事件源\n将状态转移作为按时间顺序排列的记录序列，这种序列可以按时间回溯整个事件的状态变更，kafka本身的持久性，代表着他可以存储大量的日志，并且这些可以根据这些日志进行汇总和回溯等等。\n\n`实际应用中，适用最多最广泛的自然是MQ的功能。`\n\n## Kafka用作MQ时与常用MQ的对比\n\n**RabbitMQ**——Rabbit Message Queue的简写，但不能仅仅理解其为消息队列，消息代理更合适。 RabbitMQ是一个由Erlang 语言开发的AMQP（高级消息队列协议）的开源实现。 RabbitMQ作为一个消息代理，主要和消息打交道，负责接收并转发消息。\n\n**ZeroMQ**——是一个基于消息队列的多线程网络库，其对套接字类型、连接处理、帧、甚至路由的底层细节进行抽象，提供跨越多种传输协议的套接字。是网络通信中新的一层，`介于应用层和传输层之间`（按照TCP/IP划分），其是一个可伸缩层，可并行运行，分散在分布式系统间。\n\n**RocketMQ**——阿里开源的一款高性能、高吞吐量的分布式消息中间件。\n\n**ActiveMQ**——是一种开源的，实现了JMS1.1规范的，面向消息(MOM)的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信。\n\n\n特性 | Kafka | RabbitMQ | ZeroMQ | RocketMQ | ActiveMQ\n:-: | :-: | :-: | :-: | :-: | :-:\n开发语言 | Scala | Erlang | C | Java | Java\n支持协议 | 自行设计的基于TCP层的协议 | AMQP | TCP、UDP | 自行设计 | OpenWire、STOMP、REST、MQTT、XMPP、AMQP、WS\n消息存储 | 内存、磁盘、数据库。支持大量堆积。 | 内存、磁盘。支持少量堆积。 | 消息发送端的内存或者磁盘中。不支持持久化。 | 磁盘。支持大量堆积。 | 内存、磁盘、数据库。支持少量堆积。\n消息事务 | 支持 | 支持 | 不支持 | 支持 | 支持\n负载均衡\t| 支持 | 支持但支持的不好\t | 去中心化，不支持负载均衡。本身只是一个多线程网络库。 | 支持 | 支持，可以基于zookeeper实现\n集群方式 | 天然的‘‘Leader-Slave’无状态集群，每台服务器既是Master也是Slave。 | 支持简单集群，’复制’模式，对高级集群模式支持不好。 | 去中心化，不支持集群。 | ‘Master-Slave’ 模式，开源版本需手动切换Slave变成Master | 支持简单集群模式，比如’主-备’，对高级集群模式支持不好。\n可用性 | 非常高（分布式） | 高（主从） | 高 | 非常高（分布式） | 高（主从）\n消息重复 | 支持at least once、at most once | 支持at least once、at most once | 只有重传机制，但是没有持久化，消息丢了重传也没有用。既不是at least once、也不是at most once、更不是exactly only once | 支持at least once | 支持at least once\n吞吐量TPS | 极大 | 比较大 | 极大 | 大（发送端不是批量发送） | 比较大\n时效性 | ms以内 | us级 |   | ms级 | ms级\n订阅形式和消息分发 | 基于topic以及按照topic进行正则匹配的发布订阅模式。 | 提供了4种方式：direct, topic ,Headers和fanout。 | 点对点(p2p) | 基于topic/messageTag以及按照消息类型、属性进行正则匹配的发布订阅模式 | 点对点(p2p)、广播（发布-订阅）\n顺序消息 | 支持 | 不支持 | 不支持 | 支持 | 不支持\n消息确认 | 支持 | 支持 | 支持 | 支持 | 支持\n消息回溯\t| 支持指定分区offset位置的回溯 | 不支持 | 不支持 | 支持指定时间点的回溯 | 不支持\n消费失败重试 | 不支持，但可以通过指定分区offset位置实现。 | 不支持，但是可以利用消息确认机制实现。 | 不支持 | 支持 | 不支持\n并发度 | 高 | 极高 | 高 | 高 | 高\n资料文档 | 中。有kafka作者自己写的书，网上资料也有一些。 | 多。有一些不错的书，网上资料多。 | 少。没有专门写zeromq的书，网上的资料多是一些代码的实现和简单介绍。 | 少。没有专门写rocketmq的书，网上的资料良莠不齐，官方文档很简洁，但是对技术细节没有过多的描述。 | 多。没有专门写activemq的书，网上资料多。\n\n### 常用MQ的优缺点\n\n#### Kafka\n##### 优点\n* 性能卓越，单机写入TPS约在百万条/秒，最大的优点，就是吞吐量高。\n* 时效性：ms级\n* 可用性：非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用\n* 消费者采用Pull方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;\n* 有优秀的第三方Kafka Web管理界面Kafka-Manager；\n* 在日志领域比较成熟，被多家公司和多个开源项目使用；\n* 功能支持：功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用\n\n##### 缺点\n* Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长\n* 使用短轮询方式，实时性取决于轮询间隔时间；\n* 消费失败不支持重试；\n* 支持消息顺序，但是一台代理宕机后，就会产生消息乱序；\n* 社区更新较慢；\n\n#### RabbitMQ\n##### 优点\n* 由于erlang语言的特性，mq 性能较好，高并发；\n* 吞吐量到万级，MQ功能比较完备 \n* 健壮、稳定、易用、跨平台、支持多种语言、文档齐全；\n* 开源提供的管理界面非常棒，用起来很好用\n* 社区活跃度高；\n\n##### 缺点\n* erlang开发，很难去看懂源码，基本职能依赖于开源社区的快速维护和修复bug，不利于做二次开发和维护。\n* RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。\n* 需要学习比较复杂的接口和协议，学习和维护成本较高。\n\n#### ZeroMQ\n##### 优点\n* 吞吐量：百万级\n* 扩展性强，其他MQ都已经是成形的产品，已经是一款应用程序了。而ZeroMQ说白了就是一组库函数。\n\n##### 缺点\n* 原生不支持持久化，仅支持相当有限的本地缓存，如需要消息持久化需要自己进行扩展。\n* 在高并发环境下不会出问题，但是有可能会导致本地的缓存区被塞满而导致消息丢失的情况。\n\n#### RocketMQ\n##### 优点\n* 单机吞吐量：十万级\n* 可用性：非常高，分布式架构\n* 消息可靠性：经过参数优化配置，消息可以做到0丢失\n* 功能支持：MQ功能较为完善，还是分布式的，扩展性好\n* 支持10亿级别的消息堆积，不会因为堆积导致性能下降\n* 源码是java，我们可以自己阅读源码，定制自己公司的MQ，可以掌控\n\n##### 缺点\n* 支持的客户端语言不多，目前是java及c++，其中c++不成熟；\n* 社区活跃度一般\n* MQ核心代码未遵循JMS规范，有些系统要迁移需要修改大量代码\n\n#### RocketMQ\n##### 优点\n* 单机吞吐量：万级\n* topic数量都吞吐量的影响：\n* 时效性：ms级\n* 可用性：高，基于主从架构实现高可用性\n* 消息可靠性：有较低的概率丢失数据\n* 功能支持：MQ领域的功能极其完备\n* 遵循JMS规范安装部署方便\n\n##### 缺点\n* 在并发较多时，消费端只能接收一部分，会出现丢失消息情况，需重启消费端才能接收到那部分剩下的消息。\n* 官方社区现在对ActiveMQ 5.x维护越来越少，较少在大规模吞吐的场景中使用。\n\n\n\n\n\n\n","source":"_posts/Kafka-Background.md","raw":"---\ntitle: Kafka背景及架构介绍\ndate: 2019-05-25 11:38:04\ntags:\n    - Kafka\n    - JAVA\n    - 学习笔记\ncategories: Kafka\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n## Kafka创建背景\nkafka最初是LinkedIn的一个内部基础设施系统。最初开发的起因是，LinkedIn虽然有了数据库和其他系统可以用来存储数据，但是缺乏一个可以帮助处理持续数据流的组件。它的设计目的是提供一个高性能的消息系统，可以处理多种类型数据，并能够实时提供纯洁且结构化的用户活动数据和系统度量指标。\n<!-- more -->\n## Kafka简介\nKafka是由LinkedIn开发，使用Scala编写的一个分布式的消息系统，具有高性能、持久化、多副本备份、横向扩展能力。生产者往队列里写消息，消费者从队列里取消息进行业务逻辑。一般在架构设计中起到解耦、削峰、异步处理的作用。\n\nkafka对外使用topic的概念，生产者往topic里写消息，消费者从读消息。为了做到水平扩展，一个topic实际是由多个partition组成的，遇到瓶颈时，可以通过增加partition的数量来进行横向扩容。单个parition内是保证消息有序。\n\n每新写一条消息，kafka就是在对应的文件append写，所以性能非常高。\n\n## Kafka架构\n\n### 一、名词解释\n* **Broker**：消息中间件处理节点（服务器），一个节点就是一个broker，一个Kafka集群由一个或多个broker组成\n* **Topic**：Kafka对消息进行归类，发送到集群的每一条消息都要指定一个topic\n* **Partition**：物理上的概念，每个topic包含一个或多个partition，一个partition对应一个文件夹，这个文件夹下存储partition的数据和索引文件，每个partition内部是有序的\n* **Producer**：生产者，负责发布消息到broker\n* **Consumer**：消费者，从broker读取消息\n* **ConsumerGroup**：每个consumer属于一个特定的consumer group，可为每个consumer指定group name，若不指定，则属于默认的group，一条消息可以发送到不同的consumer group，但一个consumer group中只能有一个consumer能消费这条消息\n* **replica**：partition 的副本，保障 partition 的高可用。\n* **leader**：replica 中的一个角色， producer 和 consumer 只跟 leader 交互。\n* **follower**：replica 中的一个角色，从 leader 中复制数据。\n* **controller**：每个集群都有一个broker同时充当了集群控制器角色（自动从集群的活跃成员中选举出来），负责管理工作包括分配分区给broker，监控broker等等\n* **zookeeper**：Kafka 通过 zookeeper 来存储集群的 meta 信息。\n\n### 二、架构图\n#### 总体数据流\n![](Kafka-Background/1.png)\nProducers往Brokers里面的指定Topic中写消息，Consumers从Brokers里面拉去指定Topic的消息，然后进行业务处理。\n\n#### 生产者\n![](Kafka-Background/2.png)\n①首先要构造一个 ProducerRecord 对象，该对象可以声明主题Topic、分区Partition、键 Key以及值 Value，主题和值是必须要声明的，分区和键可以不用指定。\n\n②调用send() 方法进行消息发送。\n\n③因为消息要到网络上进行传输，所以必须进行序列化，序列化器的作用就是把消息的 key 和 value对象序列化成字节数组。\n\n④接下来数据传到分区器，如果之间的 ProducerRecord 对象指定了分区，那么分区器将不再做任何事，直接把指定的分区返回；如果没有，那么分区器会根据 Key 来选择一个分区，选择好分区之后，生产者就知道该往哪个主题和分区发送记录了。\n\n⑤接着这条记录会被添加到一个记录批次里面，这个批次里所有的消息会被发送到相同的主题和分区。会有一个独立的线程来把这些记录批次发送到相应的 Broker 上。\n\n③Broker成功接收到消息，表示发送成功，返回消息的元数据（包括主题和分区信息以及记录在分区里的偏移量）。发送失败，可以选择重试或者直接抛出异常。\n\nkey的作用：可以为消息的附加消息，也可以用来决定消息该被写到哪个主题分区，拥有相同key的消息将会被写到同一分区\n\n#### topic\n![](Kafka-Background/3.jpg)\n从上图可以看出，Topic中数据是顺序不可变序列，采用log追加方式写入，因而kafka中无因随机写入导致性能低下的问题。\n\nTopic的数据可存储在多个partition中，即可存放在不同的服务器上。这可使Topic大小不限于一台server容量。同时，消息存在多个partition上，可以实现Topic上消息的并发访问。\n\n#### partition\n![](Kafka-Background/4.jpg)\n\n每个 Partition 中的消息都是有序的，生产的消息被不断追加到 Partition log 上，其中的每一个消息都被赋予了一个唯一的 offset 值。 因此数据不会因消费而丢失，所以只要consumer指定offset，一个消息可被不同的consumer多次消费。\n\nkafka中只能保证partition中记录是有序的，而不保证topic中不同partition的顺序。\n\n分区的原因：\n\n* 方便在集群中扩展，每个 Partition 可以通过调整以适应它所在的机器，而一个 topic 又可以有多个 Partition 组成，因此整个集群就可以适应任意大小的数据了;\n* 可以提高并发，因为可以以 Partition 为单位读写了。\n\n#### Replication\n同一个 partition 可能会有多个 replication(对应 server.properties 配置中的 default.replication.factor=N)。\n\n没有 replication 的情况下，一旦 broker 宕机，其上所有 patition 的数据都不可被消费，同时 producer 也不能再将数据存于其上的 patition。\n\n引入 replication 之 后，同一个 partition 可能会有多个 replication，而这时需要在这些 replication 之间选出一个 leader，producer 和 consumer 只与这个 leader 交互，其它 replication 作为 follower 从 leader 中复制数据。\n\n### 消费者\n![](Kafka-Background/5.jpeg)\n订阅topic是以一个消费组来订阅的，一个消费组里面可以有多个消费者。\n\n同一个消费组中的两个消费者，不会同时消费一个partition。换句话来说，`就是一个partition，只能被消费组里的一个消费者消费`，但是可以同时被多个消费组消费。\n\n因此，如果消费组内的消费者如果比partition多的话，那么就会有个别消费者一直空闲。\n\n### Kafka Zookeeper 节点\n![](Kafka-Background/6.png)\n\n\n## Kafka常见的应用场景\n#### 1.消息队列\n比起大多数的消息系统来说，Kafka有更好的吞吐量，内置的分区，冗余及容错性，这让Kafka成为了一个很好的大规模消息处理应用的解决方案。 消息系统一般吞吐量相对较低，但是需要更小的端到端延时，并尝尝依赖于Kafka提供的强大的持久性保障。在这个领域，Kafka足以媲美传统消息系统， 如ActiveMQ或RabbitMQ。\n\n#### 2.行为跟踪\n行为跟踪是kafka基于发布订阅模式的扩展应用，当我们跟踪用户浏览页面、搜索及其他行为时，以发布-订阅的模式实时记录到对应的topic里那么这些结果被订阅者拿到后，就可以做进一步的实时处理，或实时监控，或放到hadoop/离线数据仓库里处理。\n\n#### 3.元信息监控\n与行为跟踪相似，作为操作记录的监控模块来使用，即汇集记录一些操作信息，可以理解为运维性质的数据监控吧。\n\n#### 4.日志收集\n日志收集方面，其实开源产品有很多，包括Scribe、Apache Flume。很多人使用Kafka代替日志聚合（log aggregation）。日志聚合一般来说是从服务器上收集日志文件，然后放到一个集中的位置（文件服务器或分布式文件系统）进行处理。然而Kafka忽略掉文件的细节，将其更清晰地抽象成一个个日志或事件的消息流。这就让Kafka处理过程延迟更低，更容易支持多数据源和分布式数据处理。比其他系统Kafka具有更高的扩展性，高效的性能和因为复制导致的更高的耐用性保证，以及更低的端到端延迟。\n\n#### 5.流处理\n保存收集上游的流数据，以提供到下游的Storm或其他流式计算框架进行处理。很多用户会将那些从原始topic来的数据进行阶段性处理，汇总，扩充或者以其他的方式转换到新的topic下再继续后面的处理。例如一个文章推荐的处理流程，可能是先从数据源中抓取文章的内容，然后将其丢入一个叫做“文章”的topic中；后续操作可能是需要对这个内容进行清理，比如回复正常数据或者删除重复数据，最后再将内容匹配的结果返还给用户。这就在一个独立的topic之外，产生了一系列的实时数据处理的流程。Strom和Samza是非常著名的实现这种类型数据转换的框架。\n\n#### 6.持久性日志（commit log）\nKafka可以为一种外部的持久性日志的分布式系统提供服务。这种日志可以在节点之外进行持久性日志的记录，节点间备份数据，并为故障节点数据回复提供一种重新同步的机制。Kafka中提供了日志压缩功能，日志压缩之后整体的日志状态仍然保留，并且通过日志回溯可以实现持久性日志的功能。在这种用法中，Kafka类似于Apache BookKeeper项目。\n\n#### 7.事件源\n将状态转移作为按时间顺序排列的记录序列，这种序列可以按时间回溯整个事件的状态变更，kafka本身的持久性，代表着他可以存储大量的日志，并且这些可以根据这些日志进行汇总和回溯等等。\n\n`实际应用中，适用最多最广泛的自然是MQ的功能。`\n\n## Kafka用作MQ时与常用MQ的对比\n\n**RabbitMQ**——Rabbit Message Queue的简写，但不能仅仅理解其为消息队列，消息代理更合适。 RabbitMQ是一个由Erlang 语言开发的AMQP（高级消息队列协议）的开源实现。 RabbitMQ作为一个消息代理，主要和消息打交道，负责接收并转发消息。\n\n**ZeroMQ**——是一个基于消息队列的多线程网络库，其对套接字类型、连接处理、帧、甚至路由的底层细节进行抽象，提供跨越多种传输协议的套接字。是网络通信中新的一层，`介于应用层和传输层之间`（按照TCP/IP划分），其是一个可伸缩层，可并行运行，分散在分布式系统间。\n\n**RocketMQ**——阿里开源的一款高性能、高吞吐量的分布式消息中间件。\n\n**ActiveMQ**——是一种开源的，实现了JMS1.1规范的，面向消息(MOM)的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信。\n\n\n特性 | Kafka | RabbitMQ | ZeroMQ | RocketMQ | ActiveMQ\n:-: | :-: | :-: | :-: | :-: | :-:\n开发语言 | Scala | Erlang | C | Java | Java\n支持协议 | 自行设计的基于TCP层的协议 | AMQP | TCP、UDP | 自行设计 | OpenWire、STOMP、REST、MQTT、XMPP、AMQP、WS\n消息存储 | 内存、磁盘、数据库。支持大量堆积。 | 内存、磁盘。支持少量堆积。 | 消息发送端的内存或者磁盘中。不支持持久化。 | 磁盘。支持大量堆积。 | 内存、磁盘、数据库。支持少量堆积。\n消息事务 | 支持 | 支持 | 不支持 | 支持 | 支持\n负载均衡\t| 支持 | 支持但支持的不好\t | 去中心化，不支持负载均衡。本身只是一个多线程网络库。 | 支持 | 支持，可以基于zookeeper实现\n集群方式 | 天然的‘‘Leader-Slave’无状态集群，每台服务器既是Master也是Slave。 | 支持简单集群，’复制’模式，对高级集群模式支持不好。 | 去中心化，不支持集群。 | ‘Master-Slave’ 模式，开源版本需手动切换Slave变成Master | 支持简单集群模式，比如’主-备’，对高级集群模式支持不好。\n可用性 | 非常高（分布式） | 高（主从） | 高 | 非常高（分布式） | 高（主从）\n消息重复 | 支持at least once、at most once | 支持at least once、at most once | 只有重传机制，但是没有持久化，消息丢了重传也没有用。既不是at least once、也不是at most once、更不是exactly only once | 支持at least once | 支持at least once\n吞吐量TPS | 极大 | 比较大 | 极大 | 大（发送端不是批量发送） | 比较大\n时效性 | ms以内 | us级 |   | ms级 | ms级\n订阅形式和消息分发 | 基于topic以及按照topic进行正则匹配的发布订阅模式。 | 提供了4种方式：direct, topic ,Headers和fanout。 | 点对点(p2p) | 基于topic/messageTag以及按照消息类型、属性进行正则匹配的发布订阅模式 | 点对点(p2p)、广播（发布-订阅）\n顺序消息 | 支持 | 不支持 | 不支持 | 支持 | 不支持\n消息确认 | 支持 | 支持 | 支持 | 支持 | 支持\n消息回溯\t| 支持指定分区offset位置的回溯 | 不支持 | 不支持 | 支持指定时间点的回溯 | 不支持\n消费失败重试 | 不支持，但可以通过指定分区offset位置实现。 | 不支持，但是可以利用消息确认机制实现。 | 不支持 | 支持 | 不支持\n并发度 | 高 | 极高 | 高 | 高 | 高\n资料文档 | 中。有kafka作者自己写的书，网上资料也有一些。 | 多。有一些不错的书，网上资料多。 | 少。没有专门写zeromq的书，网上的资料多是一些代码的实现和简单介绍。 | 少。没有专门写rocketmq的书，网上的资料良莠不齐，官方文档很简洁，但是对技术细节没有过多的描述。 | 多。没有专门写activemq的书，网上资料多。\n\n### 常用MQ的优缺点\n\n#### Kafka\n##### 优点\n* 性能卓越，单机写入TPS约在百万条/秒，最大的优点，就是吞吐量高。\n* 时效性：ms级\n* 可用性：非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用\n* 消费者采用Pull方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;\n* 有优秀的第三方Kafka Web管理界面Kafka-Manager；\n* 在日志领域比较成熟，被多家公司和多个开源项目使用；\n* 功能支持：功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用\n\n##### 缺点\n* Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长\n* 使用短轮询方式，实时性取决于轮询间隔时间；\n* 消费失败不支持重试；\n* 支持消息顺序，但是一台代理宕机后，就会产生消息乱序；\n* 社区更新较慢；\n\n#### RabbitMQ\n##### 优点\n* 由于erlang语言的特性，mq 性能较好，高并发；\n* 吞吐量到万级，MQ功能比较完备 \n* 健壮、稳定、易用、跨平台、支持多种语言、文档齐全；\n* 开源提供的管理界面非常棒，用起来很好用\n* 社区活跃度高；\n\n##### 缺点\n* erlang开发，很难去看懂源码，基本职能依赖于开源社区的快速维护和修复bug，不利于做二次开发和维护。\n* RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。\n* 需要学习比较复杂的接口和协议，学习和维护成本较高。\n\n#### ZeroMQ\n##### 优点\n* 吞吐量：百万级\n* 扩展性强，其他MQ都已经是成形的产品，已经是一款应用程序了。而ZeroMQ说白了就是一组库函数。\n\n##### 缺点\n* 原生不支持持久化，仅支持相当有限的本地缓存，如需要消息持久化需要自己进行扩展。\n* 在高并发环境下不会出问题，但是有可能会导致本地的缓存区被塞满而导致消息丢失的情况。\n\n#### RocketMQ\n##### 优点\n* 单机吞吐量：十万级\n* 可用性：非常高，分布式架构\n* 消息可靠性：经过参数优化配置，消息可以做到0丢失\n* 功能支持：MQ功能较为完善，还是分布式的，扩展性好\n* 支持10亿级别的消息堆积，不会因为堆积导致性能下降\n* 源码是java，我们可以自己阅读源码，定制自己公司的MQ，可以掌控\n\n##### 缺点\n* 支持的客户端语言不多，目前是java及c++，其中c++不成熟；\n* 社区活跃度一般\n* MQ核心代码未遵循JMS规范，有些系统要迁移需要修改大量代码\n\n#### RocketMQ\n##### 优点\n* 单机吞吐量：万级\n* topic数量都吞吐量的影响：\n* 时效性：ms级\n* 可用性：高，基于主从架构实现高可用性\n* 消息可靠性：有较低的概率丢失数据\n* 功能支持：MQ领域的功能极其完备\n* 遵循JMS规范安装部署方便\n\n##### 缺点\n* 在并发较多时，消费端只能接收一部分，会出现丢失消息情况，需重启消费端才能接收到那部分剩下的消息。\n* 官方社区现在对ActiveMQ 5.x维护越来越少，较少在大规模吞吐的场景中使用。\n\n\n\n\n\n\n","slug":"Kafka-Background","published":1,"updated":"2019-07-31T13:41:40.990Z","layout":"post","photos":[],"link":"","_id":"ck8fb4acc0024k2o50l4jyrn8","content":"<h2 id=\"Kafka创建背景\"><a href=\"#Kafka创建背景\" class=\"headerlink\" title=\"Kafka创建背景\"></a>Kafka创建背景</h2><p>kafka最初是LinkedIn的一个内部基础设施系统。最初开发的起因是，LinkedIn虽然有了数据库和其他系统可以用来存储数据，但是缺乏一个可以帮助处理持续数据流的组件。它的设计目的是提供一个高性能的消息系统，可以处理多种类型数据，并能够实时提供纯洁且结构化的用户活动数据和系统度量指标。</p>\n<a id=\"more\"></a>\n<h2 id=\"Kafka简介\"><a href=\"#Kafka简介\" class=\"headerlink\" title=\"Kafka简介\"></a>Kafka简介</h2><p>Kafka是由LinkedIn开发，使用Scala编写的一个分布式的消息系统，具有高性能、持久化、多副本备份、横向扩展能力。生产者往队列里写消息，消费者从队列里取消息进行业务逻辑。一般在架构设计中起到解耦、削峰、异步处理的作用。</p>\n<p>kafka对外使用topic的概念，生产者往topic里写消息，消费者从读消息。为了做到水平扩展，一个topic实际是由多个partition组成的，遇到瓶颈时，可以通过增加partition的数量来进行横向扩容。单个parition内是保证消息有序。</p>\n<p>每新写一条消息，kafka就是在对应的文件append写，所以性能非常高。</p>\n<h2 id=\"Kafka架构\"><a href=\"#Kafka架构\" class=\"headerlink\" title=\"Kafka架构\"></a>Kafka架构</h2><h3 id=\"一、名词解释\"><a href=\"#一、名词解释\" class=\"headerlink\" title=\"一、名词解释\"></a>一、名词解释</h3><ul>\n<li><strong>Broker</strong>：消息中间件处理节点（服务器），一个节点就是一个broker，一个Kafka集群由一个或多个broker组成</li>\n<li><strong>Topic</strong>：Kafka对消息进行归类，发送到集群的每一条消息都要指定一个topic</li>\n<li><strong>Partition</strong>：物理上的概念，每个topic包含一个或多个partition，一个partition对应一个文件夹，这个文件夹下存储partition的数据和索引文件，每个partition内部是有序的</li>\n<li><strong>Producer</strong>：生产者，负责发布消息到broker</li>\n<li><strong>Consumer</strong>：消费者，从broker读取消息</li>\n<li><strong>ConsumerGroup</strong>：每个consumer属于一个特定的consumer group，可为每个consumer指定group name，若不指定，则属于默认的group，一条消息可以发送到不同的consumer group，但一个consumer group中只能有一个consumer能消费这条消息</li>\n<li><strong>replica</strong>：partition 的副本，保障 partition 的高可用。</li>\n<li><strong>leader</strong>：replica 中的一个角色， producer 和 consumer 只跟 leader 交互。</li>\n<li><strong>follower</strong>：replica 中的一个角色，从 leader 中复制数据。</li>\n<li><strong>controller</strong>：每个集群都有一个broker同时充当了集群控制器角色（自动从集群的活跃成员中选举出来），负责管理工作包括分配分区给broker，监控broker等等</li>\n<li><strong>zookeeper</strong>：Kafka 通过 zookeeper 来存储集群的 meta 信息。</li>\n</ul>\n<h3 id=\"二、架构图\"><a href=\"#二、架构图\" class=\"headerlink\" title=\"二、架构图\"></a>二、架构图</h3><h4 id=\"总体数据流\"><a href=\"#总体数据流\" class=\"headerlink\" title=\"总体数据流\"></a>总体数据流</h4><p><img src=\"/Kafka/Kafka-Background/1.png\" alt=\"\"><br>Producers往Brokers里面的指定Topic中写消息，Consumers从Brokers里面拉去指定Topic的消息，然后进行业务处理。</p>\n<h4 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h4><p><img src=\"/Kafka/Kafka-Background/2.png\" alt=\"\"><br>①首先要构造一个 ProducerRecord 对象，该对象可以声明主题Topic、分区Partition、键 Key以及值 Value，主题和值是必须要声明的，分区和键可以不用指定。</p>\n<p>②调用send() 方法进行消息发送。</p>\n<p>③因为消息要到网络上进行传输，所以必须进行序列化，序列化器的作用就是把消息的 key 和 value对象序列化成字节数组。</p>\n<p>④接下来数据传到分区器，如果之间的 ProducerRecord 对象指定了分区，那么分区器将不再做任何事，直接把指定的分区返回；如果没有，那么分区器会根据 Key 来选择一个分区，选择好分区之后，生产者就知道该往哪个主题和分区发送记录了。</p>\n<p>⑤接着这条记录会被添加到一个记录批次里面，这个批次里所有的消息会被发送到相同的主题和分区。会有一个独立的线程来把这些记录批次发送到相应的 Broker 上。</p>\n<p>③Broker成功接收到消息，表示发送成功，返回消息的元数据（包括主题和分区信息以及记录在分区里的偏移量）。发送失败，可以选择重试或者直接抛出异常。</p>\n<p>key的作用：可以为消息的附加消息，也可以用来决定消息该被写到哪个主题分区，拥有相同key的消息将会被写到同一分区</p>\n<h4 id=\"topic\"><a href=\"#topic\" class=\"headerlink\" title=\"topic\"></a>topic</h4><p><img src=\"/Kafka/Kafka-Background/3.jpg\" alt=\"\"><br>从上图可以看出，Topic中数据是顺序不可变序列，采用log追加方式写入，因而kafka中无因随机写入导致性能低下的问题。</p>\n<p>Topic的数据可存储在多个partition中，即可存放在不同的服务器上。这可使Topic大小不限于一台server容量。同时，消息存在多个partition上，可以实现Topic上消息的并发访问。</p>\n<h4 id=\"partition\"><a href=\"#partition\" class=\"headerlink\" title=\"partition\"></a>partition</h4><p><img src=\"/Kafka/Kafka-Background/4.jpg\" alt=\"\"></p>\n<p>每个 Partition 中的消息都是有序的，生产的消息被不断追加到 Partition log 上，其中的每一个消息都被赋予了一个唯一的 offset 值。 因此数据不会因消费而丢失，所以只要consumer指定offset，一个消息可被不同的consumer多次消费。</p>\n<p>kafka中只能保证partition中记录是有序的，而不保证topic中不同partition的顺序。</p>\n<p>分区的原因：</p>\n<ul>\n<li>方便在集群中扩展，每个 Partition 可以通过调整以适应它所在的机器，而一个 topic 又可以有多个 Partition 组成，因此整个集群就可以适应任意大小的数据了;</li>\n<li>可以提高并发，因为可以以 Partition 为单位读写了。</li>\n</ul>\n<h4 id=\"Replication\"><a href=\"#Replication\" class=\"headerlink\" title=\"Replication\"></a>Replication</h4><p>同一个 partition 可能会有多个 replication(对应 server.properties 配置中的 default.replication.factor=N)。</p>\n<p>没有 replication 的情况下，一旦 broker 宕机，其上所有 patition 的数据都不可被消费，同时 producer 也不能再将数据存于其上的 patition。</p>\n<p>引入 replication 之 后，同一个 partition 可能会有多个 replication，而这时需要在这些 replication 之间选出一个 leader，producer 和 consumer 只与这个 leader 交互，其它 replication 作为 follower 从 leader 中复制数据。</p>\n<h3 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><p><img src=\"/Kafka/Kafka-Background/5.jpeg\" alt=\"\"><br>订阅topic是以一个消费组来订阅的，一个消费组里面可以有多个消费者。</p>\n<p>同一个消费组中的两个消费者，不会同时消费一个partition。换句话来说，<code>就是一个partition，只能被消费组里的一个消费者消费</code>，但是可以同时被多个消费组消费。</p>\n<p>因此，如果消费组内的消费者如果比partition多的话，那么就会有个别消费者一直空闲。</p>\n<h3 id=\"Kafka-Zookeeper-节点\"><a href=\"#Kafka-Zookeeper-节点\" class=\"headerlink\" title=\"Kafka Zookeeper 节点\"></a>Kafka Zookeeper 节点</h3><p><img src=\"/Kafka/Kafka-Background/6.png\" alt=\"\"></p>\n<h2 id=\"Kafka常见的应用场景\"><a href=\"#Kafka常见的应用场景\" class=\"headerlink\" title=\"Kafka常见的应用场景\"></a>Kafka常见的应用场景</h2><h4 id=\"1-消息队列\"><a href=\"#1-消息队列\" class=\"headerlink\" title=\"1.消息队列\"></a>1.消息队列</h4><p>比起大多数的消息系统来说，Kafka有更好的吞吐量，内置的分区，冗余及容错性，这让Kafka成为了一个很好的大规模消息处理应用的解决方案。 消息系统一般吞吐量相对较低，但是需要更小的端到端延时，并尝尝依赖于Kafka提供的强大的持久性保障。在这个领域，Kafka足以媲美传统消息系统， 如ActiveMQ或RabbitMQ。</p>\n<h4 id=\"2-行为跟踪\"><a href=\"#2-行为跟踪\" class=\"headerlink\" title=\"2.行为跟踪\"></a>2.行为跟踪</h4><p>行为跟踪是kafka基于发布订阅模式的扩展应用，当我们跟踪用户浏览页面、搜索及其他行为时，以发布-订阅的模式实时记录到对应的topic里那么这些结果被订阅者拿到后，就可以做进一步的实时处理，或实时监控，或放到hadoop/离线数据仓库里处理。</p>\n<h4 id=\"3-元信息监控\"><a href=\"#3-元信息监控\" class=\"headerlink\" title=\"3.元信息监控\"></a>3.元信息监控</h4><p>与行为跟踪相似，作为操作记录的监控模块来使用，即汇集记录一些操作信息，可以理解为运维性质的数据监控吧。</p>\n<h4 id=\"4-日志收集\"><a href=\"#4-日志收集\" class=\"headerlink\" title=\"4.日志收集\"></a>4.日志收集</h4><p>日志收集方面，其实开源产品有很多，包括Scribe、Apache Flume。很多人使用Kafka代替日志聚合（log aggregation）。日志聚合一般来说是从服务器上收集日志文件，然后放到一个集中的位置（文件服务器或分布式文件系统）进行处理。然而Kafka忽略掉文件的细节，将其更清晰地抽象成一个个日志或事件的消息流。这就让Kafka处理过程延迟更低，更容易支持多数据源和分布式数据处理。比其他系统Kafka具有更高的扩展性，高效的性能和因为复制导致的更高的耐用性保证，以及更低的端到端延迟。</p>\n<h4 id=\"5-流处理\"><a href=\"#5-流处理\" class=\"headerlink\" title=\"5.流处理\"></a>5.流处理</h4><p>保存收集上游的流数据，以提供到下游的Storm或其他流式计算框架进行处理。很多用户会将那些从原始topic来的数据进行阶段性处理，汇总，扩充或者以其他的方式转换到新的topic下再继续后面的处理。例如一个文章推荐的处理流程，可能是先从数据源中抓取文章的内容，然后将其丢入一个叫做“文章”的topic中；后续操作可能是需要对这个内容进行清理，比如回复正常数据或者删除重复数据，最后再将内容匹配的结果返还给用户。这就在一个独立的topic之外，产生了一系列的实时数据处理的流程。Strom和Samza是非常著名的实现这种类型数据转换的框架。</p>\n<h4 id=\"6-持久性日志（commit-log）\"><a href=\"#6-持久性日志（commit-log）\" class=\"headerlink\" title=\"6.持久性日志（commit log）\"></a>6.持久性日志（commit log）</h4><p>Kafka可以为一种外部的持久性日志的分布式系统提供服务。这种日志可以在节点之外进行持久性日志的记录，节点间备份数据，并为故障节点数据回复提供一种重新同步的机制。Kafka中提供了日志压缩功能，日志压缩之后整体的日志状态仍然保留，并且通过日志回溯可以实现持久性日志的功能。在这种用法中，Kafka类似于Apache BookKeeper项目。</p>\n<h4 id=\"7-事件源\"><a href=\"#7-事件源\" class=\"headerlink\" title=\"7.事件源\"></a>7.事件源</h4><p>将状态转移作为按时间顺序排列的记录序列，这种序列可以按时间回溯整个事件的状态变更，kafka本身的持久性，代表着他可以存储大量的日志，并且这些可以根据这些日志进行汇总和回溯等等。</p>\n<p><code>实际应用中，适用最多最广泛的自然是MQ的功能。</code></p>\n<h2 id=\"Kafka用作MQ时与常用MQ的对比\"><a href=\"#Kafka用作MQ时与常用MQ的对比\" class=\"headerlink\" title=\"Kafka用作MQ时与常用MQ的对比\"></a>Kafka用作MQ时与常用MQ的对比</h2><p><strong>RabbitMQ</strong>——Rabbit Message Queue的简写，但不能仅仅理解其为消息队列，消息代理更合适。 RabbitMQ是一个由Erlang 语言开发的AMQP（高级消息队列协议）的开源实现。 RabbitMQ作为一个消息代理，主要和消息打交道，负责接收并转发消息。</p>\n<p><strong>ZeroMQ</strong>——是一个基于消息队列的多线程网络库，其对套接字类型、连接处理、帧、甚至路由的底层细节进行抽象，提供跨越多种传输协议的套接字。是网络通信中新的一层，<code>介于应用层和传输层之间</code>（按照TCP/IP划分），其是一个可伸缩层，可并行运行，分散在分布式系统间。</p>\n<p><strong>RocketMQ</strong>——阿里开源的一款高性能、高吞吐量的分布式消息中间件。</p>\n<p><strong>ActiveMQ</strong>——是一种开源的，实现了JMS1.1规范的，面向消息(MOM)的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">特性</th>\n<th align=\"center\">Kafka</th>\n<th align=\"center\">RabbitMQ</th>\n<th align=\"center\">ZeroMQ</th>\n<th align=\"center\">RocketMQ</th>\n<th align=\"center\">ActiveMQ</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">开发语言</td>\n<td align=\"center\">Scala</td>\n<td align=\"center\">Erlang</td>\n<td align=\"center\">C</td>\n<td align=\"center\">Java</td>\n<td align=\"center\">Java</td>\n</tr>\n<tr>\n<td align=\"center\">支持协议</td>\n<td align=\"center\">自行设计的基于TCP层的协议</td>\n<td align=\"center\">AMQP</td>\n<td align=\"center\">TCP、UDP</td>\n<td align=\"center\">自行设计</td>\n<td align=\"center\">OpenWire、STOMP、REST、MQTT、XMPP、AMQP、WS</td>\n</tr>\n<tr>\n<td align=\"center\">消息存储</td>\n<td align=\"center\">内存、磁盘、数据库。支持大量堆积。</td>\n<td align=\"center\">内存、磁盘。支持少量堆积。</td>\n<td align=\"center\">消息发送端的内存或者磁盘中。不支持持久化。</td>\n<td align=\"center\">磁盘。支持大量堆积。</td>\n<td align=\"center\">内存、磁盘、数据库。支持少量堆积。</td>\n</tr>\n<tr>\n<td align=\"center\">消息事务</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n</tr>\n<tr>\n<td align=\"center\">负载均衡</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持但支持的不好</td>\n<td align=\"center\">去中心化，不支持负载均衡。本身只是一个多线程网络库。</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持，可以基于zookeeper实现</td>\n</tr>\n<tr>\n<td align=\"center\">集群方式</td>\n<td align=\"center\">天然的‘‘Leader-Slave’无状态集群，每台服务器既是Master也是Slave。</td>\n<td align=\"center\">支持简单集群，’复制’模式，对高级集群模式支持不好。</td>\n<td align=\"center\">去中心化，不支持集群。</td>\n<td align=\"center\">‘Master-Slave’ 模式，开源版本需手动切换Slave变成Master</td>\n<td align=\"center\">支持简单集群模式，比如’主-备’，对高级集群模式支持不好。</td>\n</tr>\n<tr>\n<td align=\"center\">可用性</td>\n<td align=\"center\">非常高（分布式）</td>\n<td align=\"center\">高（主从）</td>\n<td align=\"center\">高</td>\n<td align=\"center\">非常高（分布式）</td>\n<td align=\"center\">高（主从）</td>\n</tr>\n<tr>\n<td align=\"center\">消息重复</td>\n<td align=\"center\">支持at least once、at most once</td>\n<td align=\"center\">支持at least once、at most once</td>\n<td align=\"center\">只有重传机制，但是没有持久化，消息丢了重传也没有用。既不是at least once、也不是at most once、更不是exactly only once</td>\n<td align=\"center\">支持at least once</td>\n<td align=\"center\">支持at least once</td>\n</tr>\n<tr>\n<td align=\"center\">吞吐量TPS</td>\n<td align=\"center\">极大</td>\n<td align=\"center\">比较大</td>\n<td align=\"center\">极大</td>\n<td align=\"center\">大（发送端不是批量发送）</td>\n<td align=\"center\">比较大</td>\n</tr>\n<tr>\n<td align=\"center\">时效性</td>\n<td align=\"center\">ms以内</td>\n<td align=\"center\">us级</td>\n<td align=\"center\"></td>\n<td align=\"center\">ms级</td>\n<td align=\"center\">ms级</td>\n</tr>\n<tr>\n<td align=\"center\">订阅形式和消息分发</td>\n<td align=\"center\">基于topic以及按照topic进行正则匹配的发布订阅模式。</td>\n<td align=\"center\">提供了4种方式：direct, topic ,Headers和fanout。</td>\n<td align=\"center\">点对点(p2p)</td>\n<td align=\"center\">基于topic/messageTag以及按照消息类型、属性进行正则匹配的发布订阅模式</td>\n<td align=\"center\">点对点(p2p)、广播（发布-订阅）</td>\n</tr>\n<tr>\n<td align=\"center\">顺序消息</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">不支持</td>\n</tr>\n<tr>\n<td align=\"center\">消息确认</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n</tr>\n<tr>\n<td align=\"center\">消息回溯</td>\n<td align=\"center\">支持指定分区offset位置的回溯</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">支持指定时间点的回溯</td>\n<td align=\"center\">不支持</td>\n</tr>\n<tr>\n<td align=\"center\">消费失败重试</td>\n<td align=\"center\">不支持，但可以通过指定分区offset位置实现。</td>\n<td align=\"center\">不支持，但是可以利用消息确认机制实现。</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">不支持</td>\n</tr>\n<tr>\n<td align=\"center\">并发度</td>\n<td align=\"center\">高</td>\n<td align=\"center\">极高</td>\n<td align=\"center\">高</td>\n<td align=\"center\">高</td>\n<td align=\"center\">高</td>\n</tr>\n<tr>\n<td align=\"center\">资料文档</td>\n<td align=\"center\">中。有kafka作者自己写的书，网上资料也有一些。</td>\n<td align=\"center\">多。有一些不错的书，网上资料多。</td>\n<td align=\"center\">少。没有专门写zeromq的书，网上的资料多是一些代码的实现和简单介绍。</td>\n<td align=\"center\">少。没有专门写rocketmq的书，网上的资料良莠不齐，官方文档很简洁，但是对技术细节没有过多的描述。</td>\n<td align=\"center\">多。没有专门写activemq的书，网上资料多。</td>\n</tr>\n</tbody></table>\n<h3 id=\"常用MQ的优缺点\"><a href=\"#常用MQ的优缺点\" class=\"headerlink\" title=\"常用MQ的优缺点\"></a>常用MQ的优缺点</h3><h4 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h4><h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>性能卓越，单机写入TPS约在百万条/秒，最大的优点，就是吞吐量高。</li>\n<li>时效性：ms级</li>\n<li>可用性：非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</li>\n<li>消费者采用Pull方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;</li>\n<li>有优秀的第三方Kafka Web管理界面Kafka-Manager；</li>\n<li>在日志领域比较成熟，被多家公司和多个开源项目使用；</li>\n<li>功能支持：功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长</li>\n<li>使用短轮询方式，实时性取决于轮询间隔时间；</li>\n<li>消费失败不支持重试；</li>\n<li>支持消息顺序，但是一台代理宕机后，就会产生消息乱序；</li>\n<li>社区更新较慢；</li>\n</ul>\n<h4 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h4><h5 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>由于erlang语言的特性，mq 性能较好，高并发；</li>\n<li>吞吐量到万级，MQ功能比较完备 </li>\n<li>健壮、稳定、易用、跨平台、支持多种语言、文档齐全；</li>\n<li>开源提供的管理界面非常棒，用起来很好用</li>\n<li>社区活跃度高；</li>\n</ul>\n<h5 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>erlang开发，很难去看懂源码，基本职能依赖于开源社区的快速维护和修复bug，不利于做二次开发和维护。</li>\n<li>RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。</li>\n<li>需要学习比较复杂的接口和协议，学习和维护成本较高。</li>\n</ul>\n<h4 id=\"ZeroMQ\"><a href=\"#ZeroMQ\" class=\"headerlink\" title=\"ZeroMQ\"></a>ZeroMQ</h4><h5 id=\"优点-2\"><a href=\"#优点-2\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>吞吐量：百万级</li>\n<li>扩展性强，其他MQ都已经是成形的产品，已经是一款应用程序了。而ZeroMQ说白了就是一组库函数。</li>\n</ul>\n<h5 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>原生不支持持久化，仅支持相当有限的本地缓存，如需要消息持久化需要自己进行扩展。</li>\n<li>在高并发环境下不会出问题，但是有可能会导致本地的缓存区被塞满而导致消息丢失的情况。</li>\n</ul>\n<h4 id=\"RocketMQ\"><a href=\"#RocketMQ\" class=\"headerlink\" title=\"RocketMQ\"></a>RocketMQ</h4><h5 id=\"优点-3\"><a href=\"#优点-3\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>单机吞吐量：十万级</li>\n<li>可用性：非常高，分布式架构</li>\n<li>消息可靠性：经过参数优化配置，消息可以做到0丢失</li>\n<li>功能支持：MQ功能较为完善，还是分布式的，扩展性好</li>\n<li>支持10亿级别的消息堆积，不会因为堆积导致性能下降</li>\n<li>源码是java，我们可以自己阅读源码，定制自己公司的MQ，可以掌控</li>\n</ul>\n<h5 id=\"缺点-3\"><a href=\"#缺点-3\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>支持的客户端语言不多，目前是java及c++，其中c++不成熟；</li>\n<li>社区活跃度一般</li>\n<li>MQ核心代码未遵循JMS规范，有些系统要迁移需要修改大量代码</li>\n</ul>\n<h4 id=\"RocketMQ-1\"><a href=\"#RocketMQ-1\" class=\"headerlink\" title=\"RocketMQ\"></a>RocketMQ</h4><h5 id=\"优点-4\"><a href=\"#优点-4\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>单机吞吐量：万级</li>\n<li>topic数量都吞吐量的影响：</li>\n<li>时效性：ms级</li>\n<li>可用性：高，基于主从架构实现高可用性</li>\n<li>消息可靠性：有较低的概率丢失数据</li>\n<li>功能支持：MQ领域的功能极其完备</li>\n<li>遵循JMS规范安装部署方便</li>\n</ul>\n<h5 id=\"缺点-4\"><a href=\"#缺点-4\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>在并发较多时，消费端只能接收一部分，会出现丢失消息情况，需重启消费端才能接收到那部分剩下的消息。</li>\n<li>官方社区现在对ActiveMQ 5.x维护越来越少，较少在大规模吞吐的场景中使用。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Kafka创建背景\"><a href=\"#Kafka创建背景\" class=\"headerlink\" title=\"Kafka创建背景\"></a>Kafka创建背景</h2><p>kafka最初是LinkedIn的一个内部基础设施系统。最初开发的起因是，LinkedIn虽然有了数据库和其他系统可以用来存储数据，但是缺乏一个可以帮助处理持续数据流的组件。它的设计目的是提供一个高性能的消息系统，可以处理多种类型数据，并能够实时提供纯洁且结构化的用户活动数据和系统度量指标。</p>","more":"<h2 id=\"Kafka简介\"><a href=\"#Kafka简介\" class=\"headerlink\" title=\"Kafka简介\"></a>Kafka简介</h2><p>Kafka是由LinkedIn开发，使用Scala编写的一个分布式的消息系统，具有高性能、持久化、多副本备份、横向扩展能力。生产者往队列里写消息，消费者从队列里取消息进行业务逻辑。一般在架构设计中起到解耦、削峰、异步处理的作用。</p>\n<p>kafka对外使用topic的概念，生产者往topic里写消息，消费者从读消息。为了做到水平扩展，一个topic实际是由多个partition组成的，遇到瓶颈时，可以通过增加partition的数量来进行横向扩容。单个parition内是保证消息有序。</p>\n<p>每新写一条消息，kafka就是在对应的文件append写，所以性能非常高。</p>\n<h2 id=\"Kafka架构\"><a href=\"#Kafka架构\" class=\"headerlink\" title=\"Kafka架构\"></a>Kafka架构</h2><h3 id=\"一、名词解释\"><a href=\"#一、名词解释\" class=\"headerlink\" title=\"一、名词解释\"></a>一、名词解释</h3><ul>\n<li><strong>Broker</strong>：消息中间件处理节点（服务器），一个节点就是一个broker，一个Kafka集群由一个或多个broker组成</li>\n<li><strong>Topic</strong>：Kafka对消息进行归类，发送到集群的每一条消息都要指定一个topic</li>\n<li><strong>Partition</strong>：物理上的概念，每个topic包含一个或多个partition，一个partition对应一个文件夹，这个文件夹下存储partition的数据和索引文件，每个partition内部是有序的</li>\n<li><strong>Producer</strong>：生产者，负责发布消息到broker</li>\n<li><strong>Consumer</strong>：消费者，从broker读取消息</li>\n<li><strong>ConsumerGroup</strong>：每个consumer属于一个特定的consumer group，可为每个consumer指定group name，若不指定，则属于默认的group，一条消息可以发送到不同的consumer group，但一个consumer group中只能有一个consumer能消费这条消息</li>\n<li><strong>replica</strong>：partition 的副本，保障 partition 的高可用。</li>\n<li><strong>leader</strong>：replica 中的一个角色， producer 和 consumer 只跟 leader 交互。</li>\n<li><strong>follower</strong>：replica 中的一个角色，从 leader 中复制数据。</li>\n<li><strong>controller</strong>：每个集群都有一个broker同时充当了集群控制器角色（自动从集群的活跃成员中选举出来），负责管理工作包括分配分区给broker，监控broker等等</li>\n<li><strong>zookeeper</strong>：Kafka 通过 zookeeper 来存储集群的 meta 信息。</li>\n</ul>\n<h3 id=\"二、架构图\"><a href=\"#二、架构图\" class=\"headerlink\" title=\"二、架构图\"></a>二、架构图</h3><h4 id=\"总体数据流\"><a href=\"#总体数据流\" class=\"headerlink\" title=\"总体数据流\"></a>总体数据流</h4><p><img src=\"/Kafka/Kafka-Background/1.png\" alt=\"\"><br>Producers往Brokers里面的指定Topic中写消息，Consumers从Brokers里面拉去指定Topic的消息，然后进行业务处理。</p>\n<h4 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h4><p><img src=\"/Kafka/Kafka-Background/2.png\" alt=\"\"><br>①首先要构造一个 ProducerRecord 对象，该对象可以声明主题Topic、分区Partition、键 Key以及值 Value，主题和值是必须要声明的，分区和键可以不用指定。</p>\n<p>②调用send() 方法进行消息发送。</p>\n<p>③因为消息要到网络上进行传输，所以必须进行序列化，序列化器的作用就是把消息的 key 和 value对象序列化成字节数组。</p>\n<p>④接下来数据传到分区器，如果之间的 ProducerRecord 对象指定了分区，那么分区器将不再做任何事，直接把指定的分区返回；如果没有，那么分区器会根据 Key 来选择一个分区，选择好分区之后，生产者就知道该往哪个主题和分区发送记录了。</p>\n<p>⑤接着这条记录会被添加到一个记录批次里面，这个批次里所有的消息会被发送到相同的主题和分区。会有一个独立的线程来把这些记录批次发送到相应的 Broker 上。</p>\n<p>③Broker成功接收到消息，表示发送成功，返回消息的元数据（包括主题和分区信息以及记录在分区里的偏移量）。发送失败，可以选择重试或者直接抛出异常。</p>\n<p>key的作用：可以为消息的附加消息，也可以用来决定消息该被写到哪个主题分区，拥有相同key的消息将会被写到同一分区</p>\n<h4 id=\"topic\"><a href=\"#topic\" class=\"headerlink\" title=\"topic\"></a>topic</h4><p><img src=\"/Kafka/Kafka-Background/3.jpg\" alt=\"\"><br>从上图可以看出，Topic中数据是顺序不可变序列，采用log追加方式写入，因而kafka中无因随机写入导致性能低下的问题。</p>\n<p>Topic的数据可存储在多个partition中，即可存放在不同的服务器上。这可使Topic大小不限于一台server容量。同时，消息存在多个partition上，可以实现Topic上消息的并发访问。</p>\n<h4 id=\"partition\"><a href=\"#partition\" class=\"headerlink\" title=\"partition\"></a>partition</h4><p><img src=\"/Kafka/Kafka-Background/4.jpg\" alt=\"\"></p>\n<p>每个 Partition 中的消息都是有序的，生产的消息被不断追加到 Partition log 上，其中的每一个消息都被赋予了一个唯一的 offset 值。 因此数据不会因消费而丢失，所以只要consumer指定offset，一个消息可被不同的consumer多次消费。</p>\n<p>kafka中只能保证partition中记录是有序的，而不保证topic中不同partition的顺序。</p>\n<p>分区的原因：</p>\n<ul>\n<li>方便在集群中扩展，每个 Partition 可以通过调整以适应它所在的机器，而一个 topic 又可以有多个 Partition 组成，因此整个集群就可以适应任意大小的数据了;</li>\n<li>可以提高并发，因为可以以 Partition 为单位读写了。</li>\n</ul>\n<h4 id=\"Replication\"><a href=\"#Replication\" class=\"headerlink\" title=\"Replication\"></a>Replication</h4><p>同一个 partition 可能会有多个 replication(对应 server.properties 配置中的 default.replication.factor=N)。</p>\n<p>没有 replication 的情况下，一旦 broker 宕机，其上所有 patition 的数据都不可被消费，同时 producer 也不能再将数据存于其上的 patition。</p>\n<p>引入 replication 之 后，同一个 partition 可能会有多个 replication，而这时需要在这些 replication 之间选出一个 leader，producer 和 consumer 只与这个 leader 交互，其它 replication 作为 follower 从 leader 中复制数据。</p>\n<h3 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><p><img src=\"/Kafka/Kafka-Background/5.jpeg\" alt=\"\"><br>订阅topic是以一个消费组来订阅的，一个消费组里面可以有多个消费者。</p>\n<p>同一个消费组中的两个消费者，不会同时消费一个partition。换句话来说，<code>就是一个partition，只能被消费组里的一个消费者消费</code>，但是可以同时被多个消费组消费。</p>\n<p>因此，如果消费组内的消费者如果比partition多的话，那么就会有个别消费者一直空闲。</p>\n<h3 id=\"Kafka-Zookeeper-节点\"><a href=\"#Kafka-Zookeeper-节点\" class=\"headerlink\" title=\"Kafka Zookeeper 节点\"></a>Kafka Zookeeper 节点</h3><p><img src=\"/Kafka/Kafka-Background/6.png\" alt=\"\"></p>\n<h2 id=\"Kafka常见的应用场景\"><a href=\"#Kafka常见的应用场景\" class=\"headerlink\" title=\"Kafka常见的应用场景\"></a>Kafka常见的应用场景</h2><h4 id=\"1-消息队列\"><a href=\"#1-消息队列\" class=\"headerlink\" title=\"1.消息队列\"></a>1.消息队列</h4><p>比起大多数的消息系统来说，Kafka有更好的吞吐量，内置的分区，冗余及容错性，这让Kafka成为了一个很好的大规模消息处理应用的解决方案。 消息系统一般吞吐量相对较低，但是需要更小的端到端延时，并尝尝依赖于Kafka提供的强大的持久性保障。在这个领域，Kafka足以媲美传统消息系统， 如ActiveMQ或RabbitMQ。</p>\n<h4 id=\"2-行为跟踪\"><a href=\"#2-行为跟踪\" class=\"headerlink\" title=\"2.行为跟踪\"></a>2.行为跟踪</h4><p>行为跟踪是kafka基于发布订阅模式的扩展应用，当我们跟踪用户浏览页面、搜索及其他行为时，以发布-订阅的模式实时记录到对应的topic里那么这些结果被订阅者拿到后，就可以做进一步的实时处理，或实时监控，或放到hadoop/离线数据仓库里处理。</p>\n<h4 id=\"3-元信息监控\"><a href=\"#3-元信息监控\" class=\"headerlink\" title=\"3.元信息监控\"></a>3.元信息监控</h4><p>与行为跟踪相似，作为操作记录的监控模块来使用，即汇集记录一些操作信息，可以理解为运维性质的数据监控吧。</p>\n<h4 id=\"4-日志收集\"><a href=\"#4-日志收集\" class=\"headerlink\" title=\"4.日志收集\"></a>4.日志收集</h4><p>日志收集方面，其实开源产品有很多，包括Scribe、Apache Flume。很多人使用Kafka代替日志聚合（log aggregation）。日志聚合一般来说是从服务器上收集日志文件，然后放到一个集中的位置（文件服务器或分布式文件系统）进行处理。然而Kafka忽略掉文件的细节，将其更清晰地抽象成一个个日志或事件的消息流。这就让Kafka处理过程延迟更低，更容易支持多数据源和分布式数据处理。比其他系统Kafka具有更高的扩展性，高效的性能和因为复制导致的更高的耐用性保证，以及更低的端到端延迟。</p>\n<h4 id=\"5-流处理\"><a href=\"#5-流处理\" class=\"headerlink\" title=\"5.流处理\"></a>5.流处理</h4><p>保存收集上游的流数据，以提供到下游的Storm或其他流式计算框架进行处理。很多用户会将那些从原始topic来的数据进行阶段性处理，汇总，扩充或者以其他的方式转换到新的topic下再继续后面的处理。例如一个文章推荐的处理流程，可能是先从数据源中抓取文章的内容，然后将其丢入一个叫做“文章”的topic中；后续操作可能是需要对这个内容进行清理，比如回复正常数据或者删除重复数据，最后再将内容匹配的结果返还给用户。这就在一个独立的topic之外，产生了一系列的实时数据处理的流程。Strom和Samza是非常著名的实现这种类型数据转换的框架。</p>\n<h4 id=\"6-持久性日志（commit-log）\"><a href=\"#6-持久性日志（commit-log）\" class=\"headerlink\" title=\"6.持久性日志（commit log）\"></a>6.持久性日志（commit log）</h4><p>Kafka可以为一种外部的持久性日志的分布式系统提供服务。这种日志可以在节点之外进行持久性日志的记录，节点间备份数据，并为故障节点数据回复提供一种重新同步的机制。Kafka中提供了日志压缩功能，日志压缩之后整体的日志状态仍然保留，并且通过日志回溯可以实现持久性日志的功能。在这种用法中，Kafka类似于Apache BookKeeper项目。</p>\n<h4 id=\"7-事件源\"><a href=\"#7-事件源\" class=\"headerlink\" title=\"7.事件源\"></a>7.事件源</h4><p>将状态转移作为按时间顺序排列的记录序列，这种序列可以按时间回溯整个事件的状态变更，kafka本身的持久性，代表着他可以存储大量的日志，并且这些可以根据这些日志进行汇总和回溯等等。</p>\n<p><code>实际应用中，适用最多最广泛的自然是MQ的功能。</code></p>\n<h2 id=\"Kafka用作MQ时与常用MQ的对比\"><a href=\"#Kafka用作MQ时与常用MQ的对比\" class=\"headerlink\" title=\"Kafka用作MQ时与常用MQ的对比\"></a>Kafka用作MQ时与常用MQ的对比</h2><p><strong>RabbitMQ</strong>——Rabbit Message Queue的简写，但不能仅仅理解其为消息队列，消息代理更合适。 RabbitMQ是一个由Erlang 语言开发的AMQP（高级消息队列协议）的开源实现。 RabbitMQ作为一个消息代理，主要和消息打交道，负责接收并转发消息。</p>\n<p><strong>ZeroMQ</strong>——是一个基于消息队列的多线程网络库，其对套接字类型、连接处理、帧、甚至路由的底层细节进行抽象，提供跨越多种传输协议的套接字。是网络通信中新的一层，<code>介于应用层和传输层之间</code>（按照TCP/IP划分），其是一个可伸缩层，可并行运行，分散在分布式系统间。</p>\n<p><strong>RocketMQ</strong>——阿里开源的一款高性能、高吞吐量的分布式消息中间件。</p>\n<p><strong>ActiveMQ</strong>——是一种开源的，实现了JMS1.1规范的，面向消息(MOM)的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">特性</th>\n<th align=\"center\">Kafka</th>\n<th align=\"center\">RabbitMQ</th>\n<th align=\"center\">ZeroMQ</th>\n<th align=\"center\">RocketMQ</th>\n<th align=\"center\">ActiveMQ</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">开发语言</td>\n<td align=\"center\">Scala</td>\n<td align=\"center\">Erlang</td>\n<td align=\"center\">C</td>\n<td align=\"center\">Java</td>\n<td align=\"center\">Java</td>\n</tr>\n<tr>\n<td align=\"center\">支持协议</td>\n<td align=\"center\">自行设计的基于TCP层的协议</td>\n<td align=\"center\">AMQP</td>\n<td align=\"center\">TCP、UDP</td>\n<td align=\"center\">自行设计</td>\n<td align=\"center\">OpenWire、STOMP、REST、MQTT、XMPP、AMQP、WS</td>\n</tr>\n<tr>\n<td align=\"center\">消息存储</td>\n<td align=\"center\">内存、磁盘、数据库。支持大量堆积。</td>\n<td align=\"center\">内存、磁盘。支持少量堆积。</td>\n<td align=\"center\">消息发送端的内存或者磁盘中。不支持持久化。</td>\n<td align=\"center\">磁盘。支持大量堆积。</td>\n<td align=\"center\">内存、磁盘、数据库。支持少量堆积。</td>\n</tr>\n<tr>\n<td align=\"center\">消息事务</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n</tr>\n<tr>\n<td align=\"center\">负载均衡</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持但支持的不好</td>\n<td align=\"center\">去中心化，不支持负载均衡。本身只是一个多线程网络库。</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持，可以基于zookeeper实现</td>\n</tr>\n<tr>\n<td align=\"center\">集群方式</td>\n<td align=\"center\">天然的‘‘Leader-Slave’无状态集群，每台服务器既是Master也是Slave。</td>\n<td align=\"center\">支持简单集群，’复制’模式，对高级集群模式支持不好。</td>\n<td align=\"center\">去中心化，不支持集群。</td>\n<td align=\"center\">‘Master-Slave’ 模式，开源版本需手动切换Slave变成Master</td>\n<td align=\"center\">支持简单集群模式，比如’主-备’，对高级集群模式支持不好。</td>\n</tr>\n<tr>\n<td align=\"center\">可用性</td>\n<td align=\"center\">非常高（分布式）</td>\n<td align=\"center\">高（主从）</td>\n<td align=\"center\">高</td>\n<td align=\"center\">非常高（分布式）</td>\n<td align=\"center\">高（主从）</td>\n</tr>\n<tr>\n<td align=\"center\">消息重复</td>\n<td align=\"center\">支持at least once、at most once</td>\n<td align=\"center\">支持at least once、at most once</td>\n<td align=\"center\">只有重传机制，但是没有持久化，消息丢了重传也没有用。既不是at least once、也不是at most once、更不是exactly only once</td>\n<td align=\"center\">支持at least once</td>\n<td align=\"center\">支持at least once</td>\n</tr>\n<tr>\n<td align=\"center\">吞吐量TPS</td>\n<td align=\"center\">极大</td>\n<td align=\"center\">比较大</td>\n<td align=\"center\">极大</td>\n<td align=\"center\">大（发送端不是批量发送）</td>\n<td align=\"center\">比较大</td>\n</tr>\n<tr>\n<td align=\"center\">时效性</td>\n<td align=\"center\">ms以内</td>\n<td align=\"center\">us级</td>\n<td align=\"center\"></td>\n<td align=\"center\">ms级</td>\n<td align=\"center\">ms级</td>\n</tr>\n<tr>\n<td align=\"center\">订阅形式和消息分发</td>\n<td align=\"center\">基于topic以及按照topic进行正则匹配的发布订阅模式。</td>\n<td align=\"center\">提供了4种方式：direct, topic ,Headers和fanout。</td>\n<td align=\"center\">点对点(p2p)</td>\n<td align=\"center\">基于topic/messageTag以及按照消息类型、属性进行正则匹配的发布订阅模式</td>\n<td align=\"center\">点对点(p2p)、广播（发布-订阅）</td>\n</tr>\n<tr>\n<td align=\"center\">顺序消息</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">不支持</td>\n</tr>\n<tr>\n<td align=\"center\">消息确认</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n</tr>\n<tr>\n<td align=\"center\">消息回溯</td>\n<td align=\"center\">支持指定分区offset位置的回溯</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">支持指定时间点的回溯</td>\n<td align=\"center\">不支持</td>\n</tr>\n<tr>\n<td align=\"center\">消费失败重试</td>\n<td align=\"center\">不支持，但可以通过指定分区offset位置实现。</td>\n<td align=\"center\">不支持，但是可以利用消息确认机制实现。</td>\n<td align=\"center\">不支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">不支持</td>\n</tr>\n<tr>\n<td align=\"center\">并发度</td>\n<td align=\"center\">高</td>\n<td align=\"center\">极高</td>\n<td align=\"center\">高</td>\n<td align=\"center\">高</td>\n<td align=\"center\">高</td>\n</tr>\n<tr>\n<td align=\"center\">资料文档</td>\n<td align=\"center\">中。有kafka作者自己写的书，网上资料也有一些。</td>\n<td align=\"center\">多。有一些不错的书，网上资料多。</td>\n<td align=\"center\">少。没有专门写zeromq的书，网上的资料多是一些代码的实现和简单介绍。</td>\n<td align=\"center\">少。没有专门写rocketmq的书，网上的资料良莠不齐，官方文档很简洁，但是对技术细节没有过多的描述。</td>\n<td align=\"center\">多。没有专门写activemq的书，网上资料多。</td>\n</tr>\n</tbody></table>\n<h3 id=\"常用MQ的优缺点\"><a href=\"#常用MQ的优缺点\" class=\"headerlink\" title=\"常用MQ的优缺点\"></a>常用MQ的优缺点</h3><h4 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h4><h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>性能卓越，单机写入TPS约在百万条/秒，最大的优点，就是吞吐量高。</li>\n<li>时效性：ms级</li>\n<li>可用性：非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</li>\n<li>消费者采用Pull方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;</li>\n<li>有优秀的第三方Kafka Web管理界面Kafka-Manager；</li>\n<li>在日志领域比较成熟，被多家公司和多个开源项目使用；</li>\n<li>功能支持：功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长</li>\n<li>使用短轮询方式，实时性取决于轮询间隔时间；</li>\n<li>消费失败不支持重试；</li>\n<li>支持消息顺序，但是一台代理宕机后，就会产生消息乱序；</li>\n<li>社区更新较慢；</li>\n</ul>\n<h4 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h4><h5 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>由于erlang语言的特性，mq 性能较好，高并发；</li>\n<li>吞吐量到万级，MQ功能比较完备 </li>\n<li>健壮、稳定、易用、跨平台、支持多种语言、文档齐全；</li>\n<li>开源提供的管理界面非常棒，用起来很好用</li>\n<li>社区活跃度高；</li>\n</ul>\n<h5 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>erlang开发，很难去看懂源码，基本职能依赖于开源社区的快速维护和修复bug，不利于做二次开发和维护。</li>\n<li>RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。</li>\n<li>需要学习比较复杂的接口和协议，学习和维护成本较高。</li>\n</ul>\n<h4 id=\"ZeroMQ\"><a href=\"#ZeroMQ\" class=\"headerlink\" title=\"ZeroMQ\"></a>ZeroMQ</h4><h5 id=\"优点-2\"><a href=\"#优点-2\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>吞吐量：百万级</li>\n<li>扩展性强，其他MQ都已经是成形的产品，已经是一款应用程序了。而ZeroMQ说白了就是一组库函数。</li>\n</ul>\n<h5 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>原生不支持持久化，仅支持相当有限的本地缓存，如需要消息持久化需要自己进行扩展。</li>\n<li>在高并发环境下不会出问题，但是有可能会导致本地的缓存区被塞满而导致消息丢失的情况。</li>\n</ul>\n<h4 id=\"RocketMQ\"><a href=\"#RocketMQ\" class=\"headerlink\" title=\"RocketMQ\"></a>RocketMQ</h4><h5 id=\"优点-3\"><a href=\"#优点-3\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>单机吞吐量：十万级</li>\n<li>可用性：非常高，分布式架构</li>\n<li>消息可靠性：经过参数优化配置，消息可以做到0丢失</li>\n<li>功能支持：MQ功能较为完善，还是分布式的，扩展性好</li>\n<li>支持10亿级别的消息堆积，不会因为堆积导致性能下降</li>\n<li>源码是java，我们可以自己阅读源码，定制自己公司的MQ，可以掌控</li>\n</ul>\n<h5 id=\"缺点-3\"><a href=\"#缺点-3\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>支持的客户端语言不多，目前是java及c++，其中c++不成熟；</li>\n<li>社区活跃度一般</li>\n<li>MQ核心代码未遵循JMS规范，有些系统要迁移需要修改大量代码</li>\n</ul>\n<h4 id=\"RocketMQ-1\"><a href=\"#RocketMQ-1\" class=\"headerlink\" title=\"RocketMQ\"></a>RocketMQ</h4><h5 id=\"优点-4\"><a href=\"#优点-4\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>单机吞吐量：万级</li>\n<li>topic数量都吞吐量的影响：</li>\n<li>时效性：ms级</li>\n<li>可用性：高，基于主从架构实现高可用性</li>\n<li>消息可靠性：有较低的概率丢失数据</li>\n<li>功能支持：MQ领域的功能极其完备</li>\n<li>遵循JMS规范安装部署方便</li>\n</ul>\n<h5 id=\"缺点-4\"><a href=\"#缺点-4\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>在并发较多时，消费端只能接收一部分，会出现丢失消息情况，需重启消费端才能接收到那部分剩下的消息。</li>\n<li>官方社区现在对ActiveMQ 5.x维护越来越少，较少在大规模吞吐的场景中使用。</li>\n</ul>"},{"title":"Kafka-生产者","date":"2019-06-10T03:38:04.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"## Kafka生产者\nkafka数据生产流程如图：\n![](Kafka-Producer/cert_override.png)\n<!-- more -->\n1. 创建一个 ProducerRecord 对象,包括目标主题和要发送的内容\n2. 将对象序列化成字节数组\n3. 数据被传给分区：\n    * 是否指定了partition -> 直接到指定分区\n    * 是否指定了key -> 分区器使用该 key 进行 hash 操作，然后对 topic 对应的分区数量进行取模操作并返回一个分区。\n    * 没有指定key -> 则通过先产生随机数，之后在该数上自增的方式产生一个数，并转为正数之后进行取余操作。\n4. 添加到批次，并发送\n5. 服务器收到消息后返回响应\n    * 成功 -> 返回 RecordMetaData对象\n    * 失败 -> 返回错误信息\n","source":"_posts/Kafka-Producer.md","raw":"---\ntitle: Kafka-生产者\ndate: 2019-06-10 11:38:04\ntags:\n    - Kafka\n    - JAVA\n    - 学习笔记\ncategories: Kafka\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n## Kafka生产者\nkafka数据生产流程如图：\n![](Kafka-Producer/cert_override.png)\n<!-- more -->\n1. 创建一个 ProducerRecord 对象,包括目标主题和要发送的内容\n2. 将对象序列化成字节数组\n3. 数据被传给分区：\n    * 是否指定了partition -> 直接到指定分区\n    * 是否指定了key -> 分区器使用该 key 进行 hash 操作，然后对 topic 对应的分区数量进行取模操作并返回一个分区。\n    * 没有指定key -> 则通过先产生随机数，之后在该数上自增的方式产生一个数，并转为正数之后进行取余操作。\n4. 添加到批次，并发送\n5. 服务器收到消息后返回响应\n    * 成功 -> 返回 RecordMetaData对象\n    * 失败 -> 返回错误信息\n","slug":"Kafka-Producer","published":1,"updated":"2019-08-05T14:35:25.650Z","layout":"post","photos":[],"link":"","_id":"ck8fb4ack0028k2o5kbmrh14h","content":"<h2 id=\"Kafka生产者\"><a href=\"#Kafka生产者\" class=\"headerlink\" title=\"Kafka生产者\"></a>Kafka生产者</h2><p>kafka数据生产流程如图：<br><img src=\"/Kafka/Kafka-Producer/cert_override.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<ol>\n<li>创建一个 ProducerRecord 对象,包括目标主题和要发送的内容</li>\n<li>将对象序列化成字节数组</li>\n<li>数据被传给分区：<ul>\n<li>是否指定了partition -&gt; 直接到指定分区</li>\n<li>是否指定了key -&gt; 分区器使用该 key 进行 hash 操作，然后对 topic 对应的分区数量进行取模操作并返回一个分区。</li>\n<li>没有指定key -&gt; 则通过先产生随机数，之后在该数上自增的方式产生一个数，并转为正数之后进行取余操作。</li>\n</ul>\n</li>\n<li>添加到批次，并发送</li>\n<li>服务器收到消息后返回响应<ul>\n<li>成功 -&gt; 返回 RecordMetaData对象</li>\n<li>失败 -&gt; 返回错误信息</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"Kafka生产者\"><a href=\"#Kafka生产者\" class=\"headerlink\" title=\"Kafka生产者\"></a>Kafka生产者</h2><p>kafka数据生产流程如图：<br><img src=\"/Kafka/Kafka-Producer/cert_override.png\" alt=\"\"></p>","more":"<ol>\n<li>创建一个 ProducerRecord 对象,包括目标主题和要发送的内容</li>\n<li>将对象序列化成字节数组</li>\n<li>数据被传给分区：<ul>\n<li>是否指定了partition -&gt; 直接到指定分区</li>\n<li>是否指定了key -&gt; 分区器使用该 key 进行 hash 操作，然后对 topic 对应的分区数量进行取模操作并返回一个分区。</li>\n<li>没有指定key -&gt; 则通过先产生随机数，之后在该数上自增的方式产生一个数，并转为正数之后进行取余操作。</li>\n</ul>\n</li>\n<li>添加到批次，并发送</li>\n<li>服务器收到消息后返回响应<ul>\n<li>成功 -&gt; 返回 RecordMetaData对象</li>\n<li>失败 -&gt; 返回错误信息</li>\n</ul>\n</li>\n</ol>"},{"title":"《Mysql技术内幕》学习笔记-LSN","author":"Guyuqing","copyright":true,"comments":0,"date":"2019-08-17T09:42:00.000Z","_content":"LSN(log sequence number)——日志序列号：递增产生，表示事务写入重做日志的字节总量，占用8个字节。\n# LSN存在什么地方？有什么含义？\n\n```bash\n---\nLOG\n---\nLog sequence number 15151135824   -- redo log buffer 的 lsn，存放在redo log buffer 中称： redo_mem_lsn\nLog flushed up to   15151135824   -- redo log file 的 lsn，存放在redo log 中称： redo_log_lsn\nPages flushed up to 15151135824   -- 最后一个刷到磁盘上的页的最新的 lsn  \nLast checkpoint at  15151135815   -- 共享表空间上的日志记录点，最后一次检查点，及崩溃恢复时指定的起点 , checkpoint 所在的 lsn, 存放在redo log第一个文件的头部，称： cp_lsn\n```\n![log](Mysql-LSN/LOG.png)\n\n# LSN 有什么用？\n主要用于MySQL重启恢复  \n\n# 恢复的算法\n假设： redo_log_lsn = 15000 , cp_lsn=10000 , 这时候MySQL crash了，重启后的恢复流程如下：\n1. cp_lsn = 10000 之前的redo 日志，不需要恢复： 因为checkpoint之前的日志已经可以确保刷新完毕  \n2. 那么 10000 <=  redo_log_LSN <= 15000 的日志需要结合page_lsn判断，哪些需要重做，哪些不需要重做。  \n    * redo_log_LSN 日志里面记录的page 操作，如果redo_log_LSN <= page_lsn   , 这些日志不需要重做，因为page已经是最新的  \n    * redo_log_LSN 日志里面记录的page 操作, 如果redo_log_LSN >= page_lsn   , 这些日志是需要应用到page 里面去的，这一系列操作我们称为恢复. \n","source":"_posts/Mysql-LSN.md","raw":"title: 《Mysql技术内幕》学习笔记-LSN\ntags:\n  - 学习笔记\n  - MySql\ncategories:\n  - Mysql\nauthor: Guyuqing\ncopyright: true\ncomments: false\ndate: 2019-08-17 17:42:00\n---\nLSN(log sequence number)——日志序列号：递增产生，表示事务写入重做日志的字节总量，占用8个字节。\n# LSN存在什么地方？有什么含义？\n\n```bash\n---\nLOG\n---\nLog sequence number 15151135824   -- redo log buffer 的 lsn，存放在redo log buffer 中称： redo_mem_lsn\nLog flushed up to   15151135824   -- redo log file 的 lsn，存放在redo log 中称： redo_log_lsn\nPages flushed up to 15151135824   -- 最后一个刷到磁盘上的页的最新的 lsn  \nLast checkpoint at  15151135815   -- 共享表空间上的日志记录点，最后一次检查点，及崩溃恢复时指定的起点 , checkpoint 所在的 lsn, 存放在redo log第一个文件的头部，称： cp_lsn\n```\n![log](Mysql-LSN/LOG.png)\n\n# LSN 有什么用？\n主要用于MySQL重启恢复  \n\n# 恢复的算法\n假设： redo_log_lsn = 15000 , cp_lsn=10000 , 这时候MySQL crash了，重启后的恢复流程如下：\n1. cp_lsn = 10000 之前的redo 日志，不需要恢复： 因为checkpoint之前的日志已经可以确保刷新完毕  \n2. 那么 10000 <=  redo_log_LSN <= 15000 的日志需要结合page_lsn判断，哪些需要重做，哪些不需要重做。  \n    * redo_log_LSN 日志里面记录的page 操作，如果redo_log_LSN <= page_lsn   , 这些日志不需要重做，因为page已经是最新的  \n    * redo_log_LSN 日志里面记录的page 操作, 如果redo_log_LSN >= page_lsn   , 这些日志是需要应用到page 里面去的，这一系列操作我们称为恢复. \n","slug":"Mysql-LSN","published":1,"updated":"2019-08-31T03:03:59.987Z","layout":"post","photos":[],"link":"","_id":"ck8fb4acs002ck2o5t90ziyb8","content":"<p>LSN(log sequence number)——日志序列号：递增产生，表示事务写入重做日志的字节总量，占用8个字节。</p>\n<h1 id=\"LSN存在什么地方？有什么含义？\"><a href=\"#LSN存在什么地方？有什么含义？\" class=\"headerlink\" title=\"LSN存在什么地方？有什么含义？\"></a>LSN存在什么地方？有什么含义？</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">LOG</span><br><span class=\"line\">---</span><br><span class=\"line\">Log sequence number 15151135824   -- redo <span class=\"built_in\">log</span> buffer 的 lsn，存放在redo <span class=\"built_in\">log</span> buffer 中称： redo_mem_lsn</span><br><span class=\"line\">Log flushed up to   15151135824   -- redo <span class=\"built_in\">log</span> file 的 lsn，存放在redo <span class=\"built_in\">log</span> 中称： redo_log_lsn</span><br><span class=\"line\">Pages flushed up to 15151135824   -- 最后一个刷到磁盘上的页的最新的 lsn  </span><br><span class=\"line\">Last checkpoint at  15151135815   -- 共享表空间上的日志记录点，最后一次检查点，及崩溃恢复时指定的起点 , checkpoint 所在的 lsn, 存放在redo <span class=\"built_in\">log</span>第一个文件的头部，称： cp_lsn</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/Mysql/Mysql-LSN/LOG.png\" alt=\"log\"></p>\n<h1 id=\"LSN-有什么用？\"><a href=\"#LSN-有什么用？\" class=\"headerlink\" title=\"LSN 有什么用？\"></a>LSN 有什么用？</h1><p>主要用于MySQL重启恢复  </p>\n<h1 id=\"恢复的算法\"><a href=\"#恢复的算法\" class=\"headerlink\" title=\"恢复的算法\"></a>恢复的算法</h1><p>假设： redo_log_lsn = 15000 , cp_lsn=10000 , 这时候MySQL crash了，重启后的恢复流程如下：</p>\n<ol>\n<li>cp_lsn = 10000 之前的redo 日志，不需要恢复： 因为checkpoint之前的日志已经可以确保刷新完毕  </li>\n<li>那么 10000 &lt;=  redo_log_LSN &lt;= 15000 的日志需要结合page_lsn判断，哪些需要重做，哪些不需要重做。  <ul>\n<li>redo_log_LSN 日志里面记录的page 操作，如果redo_log_LSN &lt;= page_lsn   , 这些日志不需要重做，因为page已经是最新的  </li>\n<li>redo_log_LSN 日志里面记录的page 操作, 如果redo_log_LSN &gt;= page_lsn   , 这些日志是需要应用到page 里面去的，这一系列操作我们称为恢复. </li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>LSN(log sequence number)——日志序列号：递增产生，表示事务写入重做日志的字节总量，占用8个字节。</p>\n<h1 id=\"LSN存在什么地方？有什么含义？\"><a href=\"#LSN存在什么地方？有什么含义？\" class=\"headerlink\" title=\"LSN存在什么地方？有什么含义？\"></a>LSN存在什么地方？有什么含义？</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">LOG</span><br><span class=\"line\">---</span><br><span class=\"line\">Log sequence number 15151135824   -- redo <span class=\"built_in\">log</span> buffer 的 lsn，存放在redo <span class=\"built_in\">log</span> buffer 中称： redo_mem_lsn</span><br><span class=\"line\">Log flushed up to   15151135824   -- redo <span class=\"built_in\">log</span> file 的 lsn，存放在redo <span class=\"built_in\">log</span> 中称： redo_log_lsn</span><br><span class=\"line\">Pages flushed up to 15151135824   -- 最后一个刷到磁盘上的页的最新的 lsn  </span><br><span class=\"line\">Last checkpoint at  15151135815   -- 共享表空间上的日志记录点，最后一次检查点，及崩溃恢复时指定的起点 , checkpoint 所在的 lsn, 存放在redo <span class=\"built_in\">log</span>第一个文件的头部，称： cp_lsn</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/Mysql/Mysql-LSN/LOG.png\" alt=\"log\"></p>\n<h1 id=\"LSN-有什么用？\"><a href=\"#LSN-有什么用？\" class=\"headerlink\" title=\"LSN 有什么用？\"></a>LSN 有什么用？</h1><p>主要用于MySQL重启恢复  </p>\n<h1 id=\"恢复的算法\"><a href=\"#恢复的算法\" class=\"headerlink\" title=\"恢复的算法\"></a>恢复的算法</h1><p>假设： redo_log_lsn = 15000 , cp_lsn=10000 , 这时候MySQL crash了，重启后的恢复流程如下：</p>\n<ol>\n<li>cp_lsn = 10000 之前的redo 日志，不需要恢复： 因为checkpoint之前的日志已经可以确保刷新完毕  </li>\n<li>那么 10000 &lt;=  redo_log_LSN &lt;= 15000 的日志需要结合page_lsn判断，哪些需要重做，哪些不需要重做。  <ul>\n<li>redo_log_LSN 日志里面记录的page 操作，如果redo_log_LSN &lt;= page_lsn   , 这些日志不需要重做，因为page已经是最新的  </li>\n<li>redo_log_LSN 日志里面记录的page 操作, 如果redo_log_LSN &gt;= page_lsn   , 这些日志是需要应用到page 里面去的，这一系列操作我们称为恢复. </li>\n</ul>\n</li>\n</ol>\n"},{"title":"《Mysql技术内幕》学习笔记-Redo与Undo","author":"Guyuqing","copyright":true,"comments":0,"date":"2019-08-16T11:09:00.000Z","_content":"# redo log\n## redo 概念\n重做日志(redo log)：在InnoDB存储引擎中，大部分情况下 Redo 是`物理日志`，记录的是数据页的物理变化。\n## redo 结构\nRedo log可以简单分为以下两个部分：\n<!-- more -->\n1. 重做日志缓冲 (redo log buffer),是易失的，在内存中\n    * 日志会先写到redo log buffer ，根据制定条件刷新到redo log file\n    * 由log block组成  \n    * 每个log block 512字节，所以不需要 [double write](http://123.56.47.170:8080/2019/07/31/Mysql02/#%E4%B8%A4%E6%AC%A1%E5%86%99)，因为每次刷新都是原子的  \n2. 重做日志文件 (redo log file)，是持久的，保存在磁盘中\t\n\t* redo log的物理文件，一般有2个,大小可配置  \n\n## redo 写入时机\n* 在数据页修改完成之后，在脏页刷出磁盘之前，写入redo日志。注意的是**先修改数据，后写日志**\n* redo日志比数据页先写回磁盘\n* 聚集索引、非聚集索引、undo页面的修改，均需要记录Redo日志。\n\n## redo 的整体流程\n![redo](Mysql-RedoAndUndo/redo-buffer.png)\n\n## redo如何保证事务的持久性？\nInnoDB 通过 **Force Log at Commit** 机制实现事务的持久性，即当事务提交时，先将 redo log buffer 写入到 redo log file 进行持久化，待事务的commit操作完成时才算完成。\n这种做法也被称为 **Write-Ahead Log**(预先日志持久化)，在持久化一个数据页之前，先将内存中相应的日志页持久化。\n\n为了保证每次日志都写入redo log file，在每次将redo buffer写入redo log file之后，默认情况下，InnoDB存储引擎都需要调用一次 fsync操作,因为重做日志打开并没有 O_DIRECT选项，所以重做日志先写入到文件系统缓存。为了确保重做日志写入到磁盘，必须进行一次 fsync操作。fsync操作 将数据提交到硬盘中，强制硬盘同步，将一直阻塞到写入硬盘完成后返回，大量进行fsync操作就有性能瓶颈，因此磁盘的性能也影响了事务提交的性能，也就是数据库的性能。\n(O_DIRECT选项是在Linux系统中的选项，使用该选项后，对文件进行直接IO操作，不经过文件系统缓存，直接写入磁盘)\n\n# undo log\n## undo 概念\nundo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。\n\n## undo 结构\n在InnoDB存储引擎中，undo存储在回滚段(Rollback Segment)中,每个回滚段记录了1024个undo log segment，而在每个undo log segment段中进行undo 页的申请，在5.6以前，Rollback Segment是在共享表空间里的，5.6.3之后，可通过 innodb_undo_tablespace设置undo存储的位置。\n\n## undo 写入时机\n* DML操作修改聚集索引前，记录undo日志\n* 非聚集索引记录的修改，**不**记录undo日志\n\n## undo 的整体流程\n![undo](Mysql-RedoAndUndo/undo-Segment.png)\nundo log 采用顺序IO写入磁盘共享表空间。\n\n## undo 类型\n* insert undo log：在insert 操作中产生的undo log，因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。\n* update undo log：在delete 和update操作产生的undo log，该undo log可能需要提供MVCC机制，因此不能再事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。\n\n<div style='display: none'>\n## DML的相关物理实现算法\n* 主键索引\n```text\n1. 对于delete   --需要undo绑定该记录才能进行回滚，所以只能打上标记，delete mark  \n2. 对于update  --原记录可以物理删除，因为可以在新插入进来的地方进行undo绑定  \n\t* 如果不能原地更新： delete(注意：这里是直接delete,而不是delete mark)  + insert \n\t* 如果可以原地更新，那么直接update就好    \n ```\n* 非聚集索\n```text\n1. 对于delete  --不能直接被物理删除，因为二级索引没有undo，只能通过打标记，然后回滚。否则如果被物理删除，则无法回滚\n\tdelete mark    \n2. 对于update  --不能直接被物理删除，因为二级索引没有undo，只能通过打标记，然后回滚。否则如果被物理删除，则无法回滚\n\tdelete mark + insert\n```\n</div>\n\n# redo & undo\n## undo log 是否是 redo log 的逆过程？\nundo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。\nredo log是物理日志，记录的是数据页的物理变化，显然undo log不是redo log的逆过程。\n\n## 事务实现过程\n事务B要将字段A的值由原来的1修改为3，要将B的值由原来的2修改为4，redo日志记录的是：\n```text\n假设有A、B两个数据，值分别为1,2.\n1. 事务B开始\n2. 记录A=1到undo log\n3. 修改A=3\n4. 记录A=3到 redo log\n5. 记录B=2到 undo log\n6. 修改B=4\n7. 记录B=4到redo log\n8. 将redo log写入磁盘\n9. 事务提交，将数据写入磁盘\n10.事物B结束\n\n```\n在insert/update/delete操作中，redo和undo分别记录的内容都不一样，量也不一样。在InnoDB内存中，一般的顺序如下：\n1. 写undo的redo\n2. 写undo\n3. 修改数据页\n4. 写Redo\n\n如果上面事务B回滚（当做新的事务C），则redo记录的是：\n```text\n1. 事务C开始\n2. 记录A=1到undo log\n3. 修改A=3\n4. 记录A=3到 redo log\n5. 记录B=2到 undo log\n6. 修改B=4\n7. 记录B=4到redo log\n   <!--回滚-->\n8. 修改B=2\n9. 记录B=2到redo log\n10.修改A=1\n11.记录A=1到redo log\n12.将redo log写入磁盘\n13.事务提交，将数据写入磁盘\n14.事物C结束\n```\n\n恢复策略：恢复时，先根据redo重做所有事务（包括未提交和回滚了的），再根据undo回滚未提交的事务。\n当系统发生宕机时，如果一个事务的 redo log 已经全部刷入磁盘，那么该事务一定可以恢复；如果一个事务的 redo log 没有全部刷入磁盘，那么就通过 undo log 将这个事务恢复到执行之前。\n\n如上，如果事务B异常未提交事务就宕机，恢复时，先根据redo日志将数据恢复为A=3&B=4，然后根据undo记录的A=1&B=2将数据恢复如初。\n\n<div style='display: none'>\n# 参考：\n* https://keithlan.github.io/2017/06/12/innodb_locks_redo/\n* https://juejin.im/post/5c3c5c0451882525487c498d\n* https://t.hao0.me/mysql/2016/11/05/mysql-innodb-05-tablespaces.html\n</div>","source":"_posts/Mysql-RedoAndUndo.md","raw":"title: 《Mysql技术内幕》学习笔记-Redo与Undo\ntags:\n  - 学习笔记\n  - MySql\ncategories:\n  - Mysql\nauthor: Guyuqing\ncopyright: true\ncomments: false\ndate: 2019-08-16 19:09:00\n---\n# redo log\n## redo 概念\n重做日志(redo log)：在InnoDB存储引擎中，大部分情况下 Redo 是`物理日志`，记录的是数据页的物理变化。\n## redo 结构\nRedo log可以简单分为以下两个部分：\n<!-- more -->\n1. 重做日志缓冲 (redo log buffer),是易失的，在内存中\n    * 日志会先写到redo log buffer ，根据制定条件刷新到redo log file\n    * 由log block组成  \n    * 每个log block 512字节，所以不需要 [double write](http://123.56.47.170:8080/2019/07/31/Mysql02/#%E4%B8%A4%E6%AC%A1%E5%86%99)，因为每次刷新都是原子的  \n2. 重做日志文件 (redo log file)，是持久的，保存在磁盘中\t\n\t* redo log的物理文件，一般有2个,大小可配置  \n\n## redo 写入时机\n* 在数据页修改完成之后，在脏页刷出磁盘之前，写入redo日志。注意的是**先修改数据，后写日志**\n* redo日志比数据页先写回磁盘\n* 聚集索引、非聚集索引、undo页面的修改，均需要记录Redo日志。\n\n## redo 的整体流程\n![redo](Mysql-RedoAndUndo/redo-buffer.png)\n\n## redo如何保证事务的持久性？\nInnoDB 通过 **Force Log at Commit** 机制实现事务的持久性，即当事务提交时，先将 redo log buffer 写入到 redo log file 进行持久化，待事务的commit操作完成时才算完成。\n这种做法也被称为 **Write-Ahead Log**(预先日志持久化)，在持久化一个数据页之前，先将内存中相应的日志页持久化。\n\n为了保证每次日志都写入redo log file，在每次将redo buffer写入redo log file之后，默认情况下，InnoDB存储引擎都需要调用一次 fsync操作,因为重做日志打开并没有 O_DIRECT选项，所以重做日志先写入到文件系统缓存。为了确保重做日志写入到磁盘，必须进行一次 fsync操作。fsync操作 将数据提交到硬盘中，强制硬盘同步，将一直阻塞到写入硬盘完成后返回，大量进行fsync操作就有性能瓶颈，因此磁盘的性能也影响了事务提交的性能，也就是数据库的性能。\n(O_DIRECT选项是在Linux系统中的选项，使用该选项后，对文件进行直接IO操作，不经过文件系统缓存，直接写入磁盘)\n\n# undo log\n## undo 概念\nundo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。\n\n## undo 结构\n在InnoDB存储引擎中，undo存储在回滚段(Rollback Segment)中,每个回滚段记录了1024个undo log segment，而在每个undo log segment段中进行undo 页的申请，在5.6以前，Rollback Segment是在共享表空间里的，5.6.3之后，可通过 innodb_undo_tablespace设置undo存储的位置。\n\n## undo 写入时机\n* DML操作修改聚集索引前，记录undo日志\n* 非聚集索引记录的修改，**不**记录undo日志\n\n## undo 的整体流程\n![undo](Mysql-RedoAndUndo/undo-Segment.png)\nundo log 采用顺序IO写入磁盘共享表空间。\n\n## undo 类型\n* insert undo log：在insert 操作中产生的undo log，因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。\n* update undo log：在delete 和update操作产生的undo log，该undo log可能需要提供MVCC机制，因此不能再事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。\n\n<div style='display: none'>\n## DML的相关物理实现算法\n* 主键索引\n```text\n1. 对于delete   --需要undo绑定该记录才能进行回滚，所以只能打上标记，delete mark  \n2. 对于update  --原记录可以物理删除，因为可以在新插入进来的地方进行undo绑定  \n\t* 如果不能原地更新： delete(注意：这里是直接delete,而不是delete mark)  + insert \n\t* 如果可以原地更新，那么直接update就好    \n ```\n* 非聚集索\n```text\n1. 对于delete  --不能直接被物理删除，因为二级索引没有undo，只能通过打标记，然后回滚。否则如果被物理删除，则无法回滚\n\tdelete mark    \n2. 对于update  --不能直接被物理删除，因为二级索引没有undo，只能通过打标记，然后回滚。否则如果被物理删除，则无法回滚\n\tdelete mark + insert\n```\n</div>\n\n# redo & undo\n## undo log 是否是 redo log 的逆过程？\nundo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。\nredo log是物理日志，记录的是数据页的物理变化，显然undo log不是redo log的逆过程。\n\n## 事务实现过程\n事务B要将字段A的值由原来的1修改为3，要将B的值由原来的2修改为4，redo日志记录的是：\n```text\n假设有A、B两个数据，值分别为1,2.\n1. 事务B开始\n2. 记录A=1到undo log\n3. 修改A=3\n4. 记录A=3到 redo log\n5. 记录B=2到 undo log\n6. 修改B=4\n7. 记录B=4到redo log\n8. 将redo log写入磁盘\n9. 事务提交，将数据写入磁盘\n10.事物B结束\n\n```\n在insert/update/delete操作中，redo和undo分别记录的内容都不一样，量也不一样。在InnoDB内存中，一般的顺序如下：\n1. 写undo的redo\n2. 写undo\n3. 修改数据页\n4. 写Redo\n\n如果上面事务B回滚（当做新的事务C），则redo记录的是：\n```text\n1. 事务C开始\n2. 记录A=1到undo log\n3. 修改A=3\n4. 记录A=3到 redo log\n5. 记录B=2到 undo log\n6. 修改B=4\n7. 记录B=4到redo log\n   <!--回滚-->\n8. 修改B=2\n9. 记录B=2到redo log\n10.修改A=1\n11.记录A=1到redo log\n12.将redo log写入磁盘\n13.事务提交，将数据写入磁盘\n14.事物C结束\n```\n\n恢复策略：恢复时，先根据redo重做所有事务（包括未提交和回滚了的），再根据undo回滚未提交的事务。\n当系统发生宕机时，如果一个事务的 redo log 已经全部刷入磁盘，那么该事务一定可以恢复；如果一个事务的 redo log 没有全部刷入磁盘，那么就通过 undo log 将这个事务恢复到执行之前。\n\n如上，如果事务B异常未提交事务就宕机，恢复时，先根据redo日志将数据恢复为A=3&B=4，然后根据undo记录的A=1&B=2将数据恢复如初。\n\n<div style='display: none'>\n# 参考：\n* https://keithlan.github.io/2017/06/12/innodb_locks_redo/\n* https://juejin.im/post/5c3c5c0451882525487c498d\n* https://t.hao0.me/mysql/2016/11/05/mysql-innodb-05-tablespaces.html\n</div>","slug":"Mysql-RedoAndUndo","published":1,"updated":"2019-08-31T03:03:59.994Z","layout":"post","photos":[],"link":"","_id":"ck8fb4ad1002gk2o5xp846y8p","content":"<h1 id=\"redo-log\"><a href=\"#redo-log\" class=\"headerlink\" title=\"redo log\"></a>redo log</h1><h2 id=\"redo-概念\"><a href=\"#redo-概念\" class=\"headerlink\" title=\"redo 概念\"></a>redo 概念</h2><p>重做日志(redo log)：在InnoDB存储引擎中，大部分情况下 Redo 是<code>物理日志</code>，记录的是数据页的物理变化。</p>\n<h2 id=\"redo-结构\"><a href=\"#redo-结构\" class=\"headerlink\" title=\"redo 结构\"></a>redo 结构</h2><p>Redo log可以简单分为以下两个部分：</p>\n<a id=\"more\"></a>\n<ol>\n<li>重做日志缓冲 (redo log buffer),是易失的，在内存中<ul>\n<li>日志会先写到redo log buffer ，根据制定条件刷新到redo log file</li>\n<li>由log block组成  </li>\n<li>每个log block 512字节，所以不需要 <a href=\"http://123.56.47.170:8080/2019/07/31/Mysql02/#%E4%B8%A4%E6%AC%A1%E5%86%99\" target=\"_blank\" rel=\"noopener\">double write</a>，因为每次刷新都是原子的  </li>\n</ul>\n</li>\n<li>重做日志文件 (redo log file)，是持久的，保存在磁盘中    <ul>\n<li>redo log的物理文件，一般有2个,大小可配置  </li>\n</ul>\n</li>\n</ol>\n<h2 id=\"redo-写入时机\"><a href=\"#redo-写入时机\" class=\"headerlink\" title=\"redo 写入时机\"></a>redo 写入时机</h2><ul>\n<li>在数据页修改完成之后，在脏页刷出磁盘之前，写入redo日志。注意的是<strong>先修改数据，后写日志</strong></li>\n<li>redo日志比数据页先写回磁盘</li>\n<li>聚集索引、非聚集索引、undo页面的修改，均需要记录Redo日志。</li>\n</ul>\n<h2 id=\"redo-的整体流程\"><a href=\"#redo-的整体流程\" class=\"headerlink\" title=\"redo 的整体流程\"></a>redo 的整体流程</h2><p><img src=\"/Mysql/Mysql-RedoAndUndo/redo-buffer.png\" alt=\"redo\"></p>\n<h2 id=\"redo如何保证事务的持久性？\"><a href=\"#redo如何保证事务的持久性？\" class=\"headerlink\" title=\"redo如何保证事务的持久性？\"></a>redo如何保证事务的持久性？</h2><p>InnoDB 通过 <strong>Force Log at Commit</strong> 机制实现事务的持久性，即当事务提交时，先将 redo log buffer 写入到 redo log file 进行持久化，待事务的commit操作完成时才算完成。<br>这种做法也被称为 <strong>Write-Ahead Log</strong>(预先日志持久化)，在持久化一个数据页之前，先将内存中相应的日志页持久化。</p>\n<p>为了保证每次日志都写入redo log file，在每次将redo buffer写入redo log file之后，默认情况下，InnoDB存储引擎都需要调用一次 fsync操作,因为重做日志打开并没有 O_DIRECT选项，所以重做日志先写入到文件系统缓存。为了确保重做日志写入到磁盘，必须进行一次 fsync操作。fsync操作 将数据提交到硬盘中，强制硬盘同步，将一直阻塞到写入硬盘完成后返回，大量进行fsync操作就有性能瓶颈，因此磁盘的性能也影响了事务提交的性能，也就是数据库的性能。<br>(O_DIRECT选项是在Linux系统中的选项，使用该选项后，对文件进行直接IO操作，不经过文件系统缓存，直接写入磁盘)</p>\n<h1 id=\"undo-log\"><a href=\"#undo-log\" class=\"headerlink\" title=\"undo log\"></a>undo log</h1><h2 id=\"undo-概念\"><a href=\"#undo-概念\" class=\"headerlink\" title=\"undo 概念\"></a>undo 概念</h2><p>undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。</p>\n<h2 id=\"undo-结构\"><a href=\"#undo-结构\" class=\"headerlink\" title=\"undo 结构\"></a>undo 结构</h2><p>在InnoDB存储引擎中，undo存储在回滚段(Rollback Segment)中,每个回滚段记录了1024个undo log segment，而在每个undo log segment段中进行undo 页的申请，在5.6以前，Rollback Segment是在共享表空间里的，5.6.3之后，可通过 innodb_undo_tablespace设置undo存储的位置。</p>\n<h2 id=\"undo-写入时机\"><a href=\"#undo-写入时机\" class=\"headerlink\" title=\"undo 写入时机\"></a>undo 写入时机</h2><ul>\n<li>DML操作修改聚集索引前，记录undo日志</li>\n<li>非聚集索引记录的修改，<strong>不</strong>记录undo日志</li>\n</ul>\n<h2 id=\"undo-的整体流程\"><a href=\"#undo-的整体流程\" class=\"headerlink\" title=\"undo 的整体流程\"></a>undo 的整体流程</h2><p><img src=\"/Mysql/Mysql-RedoAndUndo/undo-Segment.png\" alt=\"undo\"><br>undo log 采用顺序IO写入磁盘共享表空间。</p>\n<h2 id=\"undo-类型\"><a href=\"#undo-类型\" class=\"headerlink\" title=\"undo 类型\"></a>undo 类型</h2><ul>\n<li>insert undo log：在insert 操作中产生的undo log，因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</li>\n<li>update undo log：在delete 和update操作产生的undo log，该undo log可能需要提供MVCC机制，因此不能再事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</li>\n</ul>\n<div style=\"display: none\">\n## DML的相关物理实现算法\n* 主键索引\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 对于delete   --需要undo绑定该记录才能进行回滚，所以只能打上标记，delete mark  </span><br><span class=\"line\">2. 对于update  --原记录可以物理删除，因为可以在新插入进来的地方进行undo绑定  </span><br><span class=\"line\">\t* 如果不能原地更新： delete(注意：这里是直接delete,而不是delete mark)  + insert </span><br><span class=\"line\">\t* 如果可以原地更新，那么直接update就好</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>非聚集索<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 对于delete  --不能直接被物理删除，因为二级索引没有undo，只能通过打标记，然后回滚。否则如果被物理删除，则无法回滚</span><br><span class=\"line\">\tdelete mark    </span><br><span class=\"line\">2. 对于update  --不能直接被物理删除，因为二级索引没有undo，只能通过打标记，然后回滚。否则如果被物理删除，则无法回滚</span><br><span class=\"line\">\tdelete mark + insert</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</div>\n\n<h1 id=\"redo-amp-undo\"><a href=\"#redo-amp-undo\" class=\"headerlink\" title=\"redo &amp; undo\"></a>redo &amp; undo</h1><h2 id=\"undo-log-是否是-redo-log-的逆过程？\"><a href=\"#undo-log-是否是-redo-log-的逆过程？\" class=\"headerlink\" title=\"undo log 是否是 redo log 的逆过程？\"></a>undo log 是否是 redo log 的逆过程？</h2><p>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。<br>redo log是物理日志，记录的是数据页的物理变化，显然undo log不是redo log的逆过程。</p>\n<h2 id=\"事务实现过程\"><a href=\"#事务实现过程\" class=\"headerlink\" title=\"事务实现过程\"></a>事务实现过程</h2><p>事务B要将字段A的值由原来的1修改为3，要将B的值由原来的2修改为4，redo日志记录的是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">假设有A、B两个数据，值分别为1,2.</span><br><span class=\"line\">1. 事务B开始</span><br><span class=\"line\">2. 记录A=1到undo log</span><br><span class=\"line\">3. 修改A=3</span><br><span class=\"line\">4. 记录A=3到 redo log</span><br><span class=\"line\">5. 记录B=2到 undo log</span><br><span class=\"line\">6. 修改B=4</span><br><span class=\"line\">7. 记录B=4到redo log</span><br><span class=\"line\">8. 将redo log写入磁盘</span><br><span class=\"line\">9. 事务提交，将数据写入磁盘</span><br><span class=\"line\">10.事物B结束</span><br></pre></td></tr></table></figure>\n\n<p>在insert/update/delete操作中，redo和undo分别记录的内容都不一样，量也不一样。在InnoDB内存中，一般的顺序如下：</p>\n<ol>\n<li>写undo的redo</li>\n<li>写undo</li>\n<li>修改数据页</li>\n<li>写Redo</li>\n</ol>\n<p>如果上面事务B回滚（当做新的事务C），则redo记录的是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 事务C开始</span><br><span class=\"line\">2. 记录A=1到undo log</span><br><span class=\"line\">3. 修改A=3</span><br><span class=\"line\">4. 记录A=3到 redo log</span><br><span class=\"line\">5. 记录B=2到 undo log</span><br><span class=\"line\">6. 修改B=4</span><br><span class=\"line\">7. 记录B=4到redo log</span><br><span class=\"line\">   &lt;!--回滚--&gt;</span><br><span class=\"line\">8. 修改B=2</span><br><span class=\"line\">9. 记录B=2到redo log</span><br><span class=\"line\">10.修改A=1</span><br><span class=\"line\">11.记录A=1到redo log</span><br><span class=\"line\">12.将redo log写入磁盘</span><br><span class=\"line\">13.事务提交，将数据写入磁盘</span><br><span class=\"line\">14.事物C结束</span><br></pre></td></tr></table></figure>\n\n<p>恢复策略：恢复时，先根据redo重做所有事务（包括未提交和回滚了的），再根据undo回滚未提交的事务。<br>当系统发生宕机时，如果一个事务的 redo log 已经全部刷入磁盘，那么该事务一定可以恢复；如果一个事务的 redo log 没有全部刷入磁盘，那么就通过 undo log 将这个事务恢复到执行之前。</p>\n<p>如上，如果事务B异常未提交事务就宕机，恢复时，先根据redo日志将数据恢复为A=3&amp;B=4，然后根据undo记录的A=1&amp;B=2将数据恢复如初。</p>\n<div style=\"display: none\">\n# 参考：\n* https://keithlan.github.io/2017/06/12/innodb_locks_redo/\n* https://juejin.im/post/5c3c5c0451882525487c498d\n* https://t.hao0.me/mysql/2016/11/05/mysql-innodb-05-tablespaces.html\n</div>","site":{"data":{}},"excerpt":"<h1 id=\"redo-log\"><a href=\"#redo-log\" class=\"headerlink\" title=\"redo log\"></a>redo log</h1><h2 id=\"redo-概念\"><a href=\"#redo-概念\" class=\"headerlink\" title=\"redo 概念\"></a>redo 概念</h2><p>重做日志(redo log)：在InnoDB存储引擎中，大部分情况下 Redo 是<code>物理日志</code>，记录的是数据页的物理变化。</p>\n<h2 id=\"redo-结构\"><a href=\"#redo-结构\" class=\"headerlink\" title=\"redo 结构\"></a>redo 结构</h2><p>Redo log可以简单分为以下两个部分：</p>","more":"<ol>\n<li>重做日志缓冲 (redo log buffer),是易失的，在内存中<ul>\n<li>日志会先写到redo log buffer ，根据制定条件刷新到redo log file</li>\n<li>由log block组成  </li>\n<li>每个log block 512字节，所以不需要 <a href=\"http://123.56.47.170:8080/2019/07/31/Mysql02/#%E4%B8%A4%E6%AC%A1%E5%86%99\" target=\"_blank\" rel=\"noopener\">double write</a>，因为每次刷新都是原子的  </li>\n</ul>\n</li>\n<li>重做日志文件 (redo log file)，是持久的，保存在磁盘中    <ul>\n<li>redo log的物理文件，一般有2个,大小可配置  </li>\n</ul>\n</li>\n</ol>\n<h2 id=\"redo-写入时机\"><a href=\"#redo-写入时机\" class=\"headerlink\" title=\"redo 写入时机\"></a>redo 写入时机</h2><ul>\n<li>在数据页修改完成之后，在脏页刷出磁盘之前，写入redo日志。注意的是<strong>先修改数据，后写日志</strong></li>\n<li>redo日志比数据页先写回磁盘</li>\n<li>聚集索引、非聚集索引、undo页面的修改，均需要记录Redo日志。</li>\n</ul>\n<h2 id=\"redo-的整体流程\"><a href=\"#redo-的整体流程\" class=\"headerlink\" title=\"redo 的整体流程\"></a>redo 的整体流程</h2><p><img src=\"/Mysql/Mysql-RedoAndUndo/redo-buffer.png\" alt=\"redo\"></p>\n<h2 id=\"redo如何保证事务的持久性？\"><a href=\"#redo如何保证事务的持久性？\" class=\"headerlink\" title=\"redo如何保证事务的持久性？\"></a>redo如何保证事务的持久性？</h2><p>InnoDB 通过 <strong>Force Log at Commit</strong> 机制实现事务的持久性，即当事务提交时，先将 redo log buffer 写入到 redo log file 进行持久化，待事务的commit操作完成时才算完成。<br>这种做法也被称为 <strong>Write-Ahead Log</strong>(预先日志持久化)，在持久化一个数据页之前，先将内存中相应的日志页持久化。</p>\n<p>为了保证每次日志都写入redo log file，在每次将redo buffer写入redo log file之后，默认情况下，InnoDB存储引擎都需要调用一次 fsync操作,因为重做日志打开并没有 O_DIRECT选项，所以重做日志先写入到文件系统缓存。为了确保重做日志写入到磁盘，必须进行一次 fsync操作。fsync操作 将数据提交到硬盘中，强制硬盘同步，将一直阻塞到写入硬盘完成后返回，大量进行fsync操作就有性能瓶颈，因此磁盘的性能也影响了事务提交的性能，也就是数据库的性能。<br>(O_DIRECT选项是在Linux系统中的选项，使用该选项后，对文件进行直接IO操作，不经过文件系统缓存，直接写入磁盘)</p>\n<h1 id=\"undo-log\"><a href=\"#undo-log\" class=\"headerlink\" title=\"undo log\"></a>undo log</h1><h2 id=\"undo-概念\"><a href=\"#undo-概念\" class=\"headerlink\" title=\"undo 概念\"></a>undo 概念</h2><p>undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。</p>\n<h2 id=\"undo-结构\"><a href=\"#undo-结构\" class=\"headerlink\" title=\"undo 结构\"></a>undo 结构</h2><p>在InnoDB存储引擎中，undo存储在回滚段(Rollback Segment)中,每个回滚段记录了1024个undo log segment，而在每个undo log segment段中进行undo 页的申请，在5.6以前，Rollback Segment是在共享表空间里的，5.6.3之后，可通过 innodb_undo_tablespace设置undo存储的位置。</p>\n<h2 id=\"undo-写入时机\"><a href=\"#undo-写入时机\" class=\"headerlink\" title=\"undo 写入时机\"></a>undo 写入时机</h2><ul>\n<li>DML操作修改聚集索引前，记录undo日志</li>\n<li>非聚集索引记录的修改，<strong>不</strong>记录undo日志</li>\n</ul>\n<h2 id=\"undo-的整体流程\"><a href=\"#undo-的整体流程\" class=\"headerlink\" title=\"undo 的整体流程\"></a>undo 的整体流程</h2><p><img src=\"/Mysql/Mysql-RedoAndUndo/undo-Segment.png\" alt=\"undo\"><br>undo log 采用顺序IO写入磁盘共享表空间。</p>\n<h2 id=\"undo-类型\"><a href=\"#undo-类型\" class=\"headerlink\" title=\"undo 类型\"></a>undo 类型</h2><ul>\n<li>insert undo log：在insert 操作中产生的undo log，因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</li>\n<li>update undo log：在delete 和update操作产生的undo log，该undo log可能需要提供MVCC机制，因此不能再事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</li>\n</ul>\n<div style=\"display: none\">\n## DML的相关物理实现算法\n* 主键索引\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 对于delete   --需要undo绑定该记录才能进行回滚，所以只能打上标记，delete mark  </span><br><span class=\"line\">2. 对于update  --原记录可以物理删除，因为可以在新插入进来的地方进行undo绑定  </span><br><span class=\"line\">\t* 如果不能原地更新： delete(注意：这里是直接delete,而不是delete mark)  + insert </span><br><span class=\"line\">\t* 如果可以原地更新，那么直接update就好</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>非聚集索<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 对于delete  --不能直接被物理删除，因为二级索引没有undo，只能通过打标记，然后回滚。否则如果被物理删除，则无法回滚</span><br><span class=\"line\">\tdelete mark    </span><br><span class=\"line\">2. 对于update  --不能直接被物理删除，因为二级索引没有undo，只能通过打标记，然后回滚。否则如果被物理删除，则无法回滚</span><br><span class=\"line\">\tdelete mark + insert</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</div>\n\n<h1 id=\"redo-amp-undo\"><a href=\"#redo-amp-undo\" class=\"headerlink\" title=\"redo &amp; undo\"></a>redo &amp; undo</h1><h2 id=\"undo-log-是否是-redo-log-的逆过程？\"><a href=\"#undo-log-是否是-redo-log-的逆过程？\" class=\"headerlink\" title=\"undo log 是否是 redo log 的逆过程？\"></a>undo log 是否是 redo log 的逆过程？</h2><p>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。<br>redo log是物理日志，记录的是数据页的物理变化，显然undo log不是redo log的逆过程。</p>\n<h2 id=\"事务实现过程\"><a href=\"#事务实现过程\" class=\"headerlink\" title=\"事务实现过程\"></a>事务实现过程</h2><p>事务B要将字段A的值由原来的1修改为3，要将B的值由原来的2修改为4，redo日志记录的是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">假设有A、B两个数据，值分别为1,2.</span><br><span class=\"line\">1. 事务B开始</span><br><span class=\"line\">2. 记录A=1到undo log</span><br><span class=\"line\">3. 修改A=3</span><br><span class=\"line\">4. 记录A=3到 redo log</span><br><span class=\"line\">5. 记录B=2到 undo log</span><br><span class=\"line\">6. 修改B=4</span><br><span class=\"line\">7. 记录B=4到redo log</span><br><span class=\"line\">8. 将redo log写入磁盘</span><br><span class=\"line\">9. 事务提交，将数据写入磁盘</span><br><span class=\"line\">10.事物B结束</span><br></pre></td></tr></table></figure>\n\n<p>在insert/update/delete操作中，redo和undo分别记录的内容都不一样，量也不一样。在InnoDB内存中，一般的顺序如下：</p>\n<ol>\n<li>写undo的redo</li>\n<li>写undo</li>\n<li>修改数据页</li>\n<li>写Redo</li>\n</ol>\n<p>如果上面事务B回滚（当做新的事务C），则redo记录的是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 事务C开始</span><br><span class=\"line\">2. 记录A=1到undo log</span><br><span class=\"line\">3. 修改A=3</span><br><span class=\"line\">4. 记录A=3到 redo log</span><br><span class=\"line\">5. 记录B=2到 undo log</span><br><span class=\"line\">6. 修改B=4</span><br><span class=\"line\">7. 记录B=4到redo log</span><br><span class=\"line\">   &lt;!--回滚--&gt;</span><br><span class=\"line\">8. 修改B=2</span><br><span class=\"line\">9. 记录B=2到redo log</span><br><span class=\"line\">10.修改A=1</span><br><span class=\"line\">11.记录A=1到redo log</span><br><span class=\"line\">12.将redo log写入磁盘</span><br><span class=\"line\">13.事务提交，将数据写入磁盘</span><br><span class=\"line\">14.事物C结束</span><br></pre></td></tr></table></figure>\n\n<p>恢复策略：恢复时，先根据redo重做所有事务（包括未提交和回滚了的），再根据undo回滚未提交的事务。<br>当系统发生宕机时，如果一个事务的 redo log 已经全部刷入磁盘，那么该事务一定可以恢复；如果一个事务的 redo log 没有全部刷入磁盘，那么就通过 undo log 将这个事务恢复到执行之前。</p>\n<p>如上，如果事务B异常未提交事务就宕机，恢复时，先根据redo日志将数据恢复为A=3&amp;B=4，然后根据undo记录的A=1&amp;B=2将数据恢复如初。</p>\n<div style=\"display: none\">\n# 参考：\n* https://keithlan.github.io/2017/06/12/innodb_locks_redo/\n* https://juejin.im/post/5c3c5c0451882525487c498d\n* https://t.hao0.me/mysql/2016/11/05/mysql-innodb-05-tablespaces.html\n</div>"},{"title":"Kafka-MacOs安装","date":"2019-06-05T13:38:04.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"### MacOS Docker 安装\n\n安装和镜像加速参考<a href=\"https://www.runoob.com/docker/macos-docker-install.html\">docker安装教程</a>\n\n### Docker 下载Zookeeper 和 kafka 镜像\n```bash\n~ » docker pull zookeeper:latest\n~ » docker pull wurstmeister/kafka:latest\n~ » docker pull sheepkiller/kafka-manager\n```\n<!-- more -->\n### 启动容器\n1、创建网络：由于要涉及到zookeeper和kafka之间的通信，所以我们运用docker内部容器通信机制先新建一个网络。\n```bash\n~ » docker network create app\n\nd481270a05236007178e6ed0ce4b775c9d2aebb6c13bc050bb852bc46ca0b874\n```\n运行 docker network ls查看新建的网络\n```bash\n~ » docker network ls                  \n\nNETWORK ID          NAME                DRIVER              SCOPE\nd481270a0523        app                 bridge              local\n0ab6b1467267        bridge              bridge              local\ncd08298f526b        host                host                local\n86a734066770        none                null                local\n```\n运行docker network inspect app查看网络详细信息\n```bash\n~ » docker network inspect app                        \n[\n    {\n        \"Name\": \"app\",\n        \"Id\": \"d481270a05236007178e6ed0ce4b775c9d2aebb6c13bc050bb852bc46ca0b874\",\n        \"Created\": \"2019-07-19T06:57:10.768655482Z\",\n        \"Scope\": \"local\",\n        \"Driver\": \"bridge\",\n        \"EnableIPv6\": false,\n        \"IPAM\": {\n            \"Driver\": \"default\",\n            \"Options\": {},\n            \"Config\": [\n                {\n                    \"Subnet\": \"172.18.0.0/16\",\n                    \"Gateway\": \"172.18.0.1\"\n                }\n            ]\n        },\n        \"Internal\": false,\n        \"Attachable\": false,\n        \"Ingress\": false,\n        \"ConfigFrom\": {\n            \"Network\": \"\"\n        },\n        \"ConfigOnly\": false,\n        \"Containers\": {},\n        \"Options\": {},\n        \"Labels\": {}\n    }\n]\n```\n可以看到其连接的containers为空，说明还没有容器连接进来\n2、创建Zookeeper容器\n```bash\n~ » docker run --net=app --name zookeeper -p 2181 -t zookeeper\n```\n\n遇到了如下问题\n```bash\ndocker: Error response from daemon: Conflict. The container name \"/zookeeper\" is already in use by container \"26ffbd391e8c6e5e90b8f593e354f80768f179741e1de35640efacc6303fdad0\". You have to remove (or rename) that container to be able to reuse that name.\nSee 'docker run --help'.\n```\ndocker ps -l 查看发现已经创建的zookeeper 可以使用docker rm 删除\n```bash\n~ » docker ps -l                                       \nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES\n26ffbd391e8c        zookeeper           \"/docker-entrypoint.…\"   8 minutes ago       Created                                 zookeeper\n\n~ » docker rm 26ffbd391e8c\n```\n重新执行创建命令\n\n{% note info %}\nrun，创建新容器，并为容器配置一些参数。\n\n-t，在容器内部创建一个tty或者伪终端。\n\n-i，允许主机终端按照容器内部的标准与其交互。\n\n-d，后台运行容器并打印容器名称。\n\n--name，容器名称。\n\n-p，端口映射，参数格式为：主机物理端口:容器内部端口。\n\n最后跟上的就是我们已经下载的镜像\n{% endnote %}\n\n3、创建Kafka容器\n```bash\n~ » docker run --net=app --name kafka -p 9092 \\\n--env HOST_IP=127.0.0.1 \\\n--env KAFKA_ADVERTISED_HOST_NAME=localhost  \\\n--env KAFKA_ADVERTISED_PORT=9092 \\\n--env KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 \\\n--link zookeeper \\\nwurstmeister/kafka:latest\n```\n{% note info %}\n\n-e，配置容器环境变量。\n\n--link，链接到另一个容器，参数格式为：目标容器名称:在本容器内的别名。\n\n这里的环境变量设置，其实是就是对即将创建的Kafka配置文件server.properties进行初始化。\n\n{% endnote %}\n\n4、创建kafka-manager\n```bash\n~ » docker run --net=app \\\n--name kafka-manager \\\n-p 9000:9000 \\\n-e ZK_HOSTS=zookeeper:2181 \\\nsheepkiller/kafka-manager\n```\n访问ip:9000即可\n\n5、测试Kafka\n进入kafka容器\n```bash\n~ » docker exec -it kafka /bin/bash\n```\n发送消息\n```bash\nbash-4.4# kafka-console-producer.sh --broker-list localhost:9092 --topic test\n>hello\n>AAAA\n>BBBB\n>hey\n```\n读取消息(需要打开另一个终端)\n```bash                             \nbash-4.4# kafka-console-consumer.sh \\\n> --bootstrap-server localhost:9092 \\\n> --topic test --from-beginning\nhello\nAAAA\nBBBB\nhey\n```\n测试成功！(＾－＾)V\n\n> 参考https://cloud.tencent.com/developer/news/371290","source":"_posts/Kafka-Install.md","raw":"---\ntitle: Kafka-MacOs安装\ndate: 2019-06-05 21:38:04\ntags:\n    - Kafka\n    - JAVA\n    - 学习笔记\ncategories: Kafka\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n### MacOS Docker 安装\n\n安装和镜像加速参考<a href=\"https://www.runoob.com/docker/macos-docker-install.html\">docker安装教程</a>\n\n### Docker 下载Zookeeper 和 kafka 镜像\n```bash\n~ » docker pull zookeeper:latest\n~ » docker pull wurstmeister/kafka:latest\n~ » docker pull sheepkiller/kafka-manager\n```\n<!-- more -->\n### 启动容器\n1、创建网络：由于要涉及到zookeeper和kafka之间的通信，所以我们运用docker内部容器通信机制先新建一个网络。\n```bash\n~ » docker network create app\n\nd481270a05236007178e6ed0ce4b775c9d2aebb6c13bc050bb852bc46ca0b874\n```\n运行 docker network ls查看新建的网络\n```bash\n~ » docker network ls                  \n\nNETWORK ID          NAME                DRIVER              SCOPE\nd481270a0523        app                 bridge              local\n0ab6b1467267        bridge              bridge              local\ncd08298f526b        host                host                local\n86a734066770        none                null                local\n```\n运行docker network inspect app查看网络详细信息\n```bash\n~ » docker network inspect app                        \n[\n    {\n        \"Name\": \"app\",\n        \"Id\": \"d481270a05236007178e6ed0ce4b775c9d2aebb6c13bc050bb852bc46ca0b874\",\n        \"Created\": \"2019-07-19T06:57:10.768655482Z\",\n        \"Scope\": \"local\",\n        \"Driver\": \"bridge\",\n        \"EnableIPv6\": false,\n        \"IPAM\": {\n            \"Driver\": \"default\",\n            \"Options\": {},\n            \"Config\": [\n                {\n                    \"Subnet\": \"172.18.0.0/16\",\n                    \"Gateway\": \"172.18.0.1\"\n                }\n            ]\n        },\n        \"Internal\": false,\n        \"Attachable\": false,\n        \"Ingress\": false,\n        \"ConfigFrom\": {\n            \"Network\": \"\"\n        },\n        \"ConfigOnly\": false,\n        \"Containers\": {},\n        \"Options\": {},\n        \"Labels\": {}\n    }\n]\n```\n可以看到其连接的containers为空，说明还没有容器连接进来\n2、创建Zookeeper容器\n```bash\n~ » docker run --net=app --name zookeeper -p 2181 -t zookeeper\n```\n\n遇到了如下问题\n```bash\ndocker: Error response from daemon: Conflict. The container name \"/zookeeper\" is already in use by container \"26ffbd391e8c6e5e90b8f593e354f80768f179741e1de35640efacc6303fdad0\". You have to remove (or rename) that container to be able to reuse that name.\nSee 'docker run --help'.\n```\ndocker ps -l 查看发现已经创建的zookeeper 可以使用docker rm 删除\n```bash\n~ » docker ps -l                                       \nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES\n26ffbd391e8c        zookeeper           \"/docker-entrypoint.…\"   8 minutes ago       Created                                 zookeeper\n\n~ » docker rm 26ffbd391e8c\n```\n重新执行创建命令\n\n{% note info %}\nrun，创建新容器，并为容器配置一些参数。\n\n-t，在容器内部创建一个tty或者伪终端。\n\n-i，允许主机终端按照容器内部的标准与其交互。\n\n-d，后台运行容器并打印容器名称。\n\n--name，容器名称。\n\n-p，端口映射，参数格式为：主机物理端口:容器内部端口。\n\n最后跟上的就是我们已经下载的镜像\n{% endnote %}\n\n3、创建Kafka容器\n```bash\n~ » docker run --net=app --name kafka -p 9092 \\\n--env HOST_IP=127.0.0.1 \\\n--env KAFKA_ADVERTISED_HOST_NAME=localhost  \\\n--env KAFKA_ADVERTISED_PORT=9092 \\\n--env KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 \\\n--link zookeeper \\\nwurstmeister/kafka:latest\n```\n{% note info %}\n\n-e，配置容器环境变量。\n\n--link，链接到另一个容器，参数格式为：目标容器名称:在本容器内的别名。\n\n这里的环境变量设置，其实是就是对即将创建的Kafka配置文件server.properties进行初始化。\n\n{% endnote %}\n\n4、创建kafka-manager\n```bash\n~ » docker run --net=app \\\n--name kafka-manager \\\n-p 9000:9000 \\\n-e ZK_HOSTS=zookeeper:2181 \\\nsheepkiller/kafka-manager\n```\n访问ip:9000即可\n\n5、测试Kafka\n进入kafka容器\n```bash\n~ » docker exec -it kafka /bin/bash\n```\n发送消息\n```bash\nbash-4.4# kafka-console-producer.sh --broker-list localhost:9092 --topic test\n>hello\n>AAAA\n>BBBB\n>hey\n```\n读取消息(需要打开另一个终端)\n```bash                             \nbash-4.4# kafka-console-consumer.sh \\\n> --bootstrap-server localhost:9092 \\\n> --topic test --from-beginning\nhello\nAAAA\nBBBB\nhey\n```\n测试成功！(＾－＾)V\n\n> 参考https://cloud.tencent.com/developer/news/371290","slug":"Kafka-Install","published":1,"updated":"2019-08-01T15:10:15.715Z","layout":"post","photos":[],"link":"","_id":"ck8fb4ada002kk2o55tlbepnc","content":"<h3 id=\"MacOS-Docker-安装\"><a href=\"#MacOS-Docker-安装\" class=\"headerlink\" title=\"MacOS Docker 安装\"></a>MacOS Docker 安装</h3><p>安装和镜像加速参考<a href=\"https://www.runoob.com/docker/macos-docker-install.html\" target=\"_blank\" rel=\"noopener\">docker安装教程</a></p>\n<h3 id=\"Docker-下载Zookeeper-和-kafka-镜像\"><a href=\"#Docker-下载Zookeeper-和-kafka-镜像\" class=\"headerlink\" title=\"Docker 下载Zookeeper 和 kafka 镜像\"></a>Docker 下载Zookeeper 和 kafka 镜像</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ » docker pull zookeeper:latest</span><br><span class=\"line\">~ » docker pull wurstmeister/kafka:latest</span><br><span class=\"line\">~ » docker pull sheepkiller/kafka-manager</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n<h3 id=\"启动容器\"><a href=\"#启动容器\" class=\"headerlink\" title=\"启动容器\"></a>启动容器</h3><p>1、创建网络：由于要涉及到zookeeper和kafka之间的通信，所以我们运用docker内部容器通信机制先新建一个网络。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ » docker network create app</span><br><span class=\"line\"></span><br><span class=\"line\">d481270a05236007178e6ed0ce4b775c9d2aebb6c13bc050bb852bc46ca0b874</span><br></pre></td></tr></table></figure>\n\n<p>运行 docker network ls查看新建的网络</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ » docker network ls                  </span><br><span class=\"line\"></span><br><span class=\"line\">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class=\"line\">d481270a0523        app                 bridge              <span class=\"built_in\">local</span></span><br><span class=\"line\">0ab6b1467267        bridge              bridge              <span class=\"built_in\">local</span></span><br><span class=\"line\">cd08298f526b        host                host                <span class=\"built_in\">local</span></span><br><span class=\"line\">86a734066770        none                null                <span class=\"built_in\">local</span></span><br></pre></td></tr></table></figure>\n\n<p>运行docker network inspect app查看网络详细信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ » docker network inspect app                        </span><br><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">\"Name\"</span>: <span class=\"string\">\"app\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Id\"</span>: <span class=\"string\">\"d481270a05236007178e6ed0ce4b775c9d2aebb6c13bc050bb852bc46ca0b874\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Created\"</span>: <span class=\"string\">\"2019-07-19T06:57:10.768655482Z\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Scope\"</span>: <span class=\"string\">\"local\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Driver\"</span>: <span class=\"string\">\"bridge\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"EnableIPv6\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">\"IPAM\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">\"Driver\"</span>: <span class=\"string\">\"default\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"Options\"</span>: &#123;&#125;,</span><br><span class=\"line\">            <span class=\"string\">\"Config\"</span>: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"string\">\"Subnet\"</span>: <span class=\"string\">\"172.18.0.0/16\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"Gateway\"</span>: <span class=\"string\">\"172.18.0.1\"</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">\"Internal\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Attachable\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Ingress\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">\"ConfigFrom\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">\"Network\"</span>: <span class=\"string\">\"\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">\"ConfigOnly\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Containers\"</span>: &#123;&#125;,</span><br><span class=\"line\">        <span class=\"string\">\"Options\"</span>: &#123;&#125;,</span><br><span class=\"line\">        <span class=\"string\">\"Labels\"</span>: &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>可以看到其连接的containers为空，说明还没有容器连接进来<br>2、创建Zookeeper容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ » docker run --net=app --name zookeeper -p 2181 -t zookeeper</span><br></pre></td></tr></table></figure>\n\n<p>遇到了如下问题</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker: Error response from daemon: Conflict. The container name <span class=\"string\">\"/zookeeper\"</span> is already <span class=\"keyword\">in</span> use by container <span class=\"string\">\"26ffbd391e8c6e5e90b8f593e354f80768f179741e1de35640efacc6303fdad0\"</span>. You have to remove (or rename) that container to be able to reuse that name.</span><br><span class=\"line\">See <span class=\"string\">'docker run --help'</span>.</span><br></pre></td></tr></table></figure>\n\n<p>docker ps -l 查看发现已经创建的zookeeper 可以使用docker rm 删除</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ » docker ps -l                                       </span><br><span class=\"line\">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class=\"line\">26ffbd391e8c        zookeeper           <span class=\"string\">\"/docker-entrypoint.…\"</span>   8 minutes ago       Created                                 zookeeper</span><br><span class=\"line\"></span><br><span class=\"line\">~ » docker rm 26ffbd391e8c</span><br></pre></td></tr></table></figure>\n\n<p>重新执行创建命令</p>\n<div class=\"note info\"><p>run，创建新容器，并为容器配置一些参数。</p>\n<p>-t，在容器内部创建一个tty或者伪终端。</p>\n<p>-i，允许主机终端按照容器内部的标准与其交互。</p>\n<p>-d，后台运行容器并打印容器名称。</p>\n<p>–name，容器名称。</p>\n<p>-p，端口映射，参数格式为：主机物理端口:容器内部端口。</p>\n<p>最后跟上的就是我们已经下载的镜像</p></div>\n\n<p>3、创建Kafka容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ » docker run --net=app --name kafka -p 9092 \\</span><br><span class=\"line\">--env HOST_IP=127.0.0.1 \\</span><br><span class=\"line\">--env KAFKA_ADVERTISED_HOST_NAME=localhost  \\</span><br><span class=\"line\">--env KAFKA_ADVERTISED_PORT=9092 \\</span><br><span class=\"line\">--env KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 \\</span><br><span class=\"line\">--link zookeeper \\</span><br><span class=\"line\">wurstmeister/kafka:latest</span><br></pre></td></tr></table></figure>\n\n<div class=\"note info\"><p>-e，配置容器环境变量。</p>\n<p>–link，链接到另一个容器，参数格式为：目标容器名称:在本容器内的别名。</p>\n<p>这里的环境变量设置，其实是就是对即将创建的Kafka配置文件server.properties进行初始化。</p></div>\n\n<p>4、创建kafka-manager</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ » docker run --net=app \\</span><br><span class=\"line\">--name kafka-manager \\</span><br><span class=\"line\">-p 9000:9000 \\</span><br><span class=\"line\">-e ZK_HOSTS=zookeeper:2181 \\</span><br><span class=\"line\">sheepkiller/kafka-manager</span><br></pre></td></tr></table></figure>\n\n<p>访问ip:9000即可</p>\n<p>5、测试Kafka<br>进入kafka容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ » docker <span class=\"built_in\">exec</span> -it kafka /bin/bash</span><br></pre></td></tr></table></figure>\n\n<p>发送消息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash-4.4<span class=\"comment\"># kafka-console-producer.sh --broker-list localhost:9092 --topic test</span></span><br><span class=\"line\">&gt;hello</span><br><span class=\"line\">&gt;AAAA</span><br><span class=\"line\">&gt;BBBB</span><br><span class=\"line\">&gt;hey</span><br></pre></td></tr></table></figure>\n\n<p>读取消息(需要打开另一个终端)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash-4.4<span class=\"comment\"># kafka-console-consumer.sh \\</span></span><br><span class=\"line\">&gt; --bootstrap-server localhost:9092 \\</span><br><span class=\"line\">&gt; --topic <span class=\"built_in\">test</span> --from-beginning</span><br><span class=\"line\">hello</span><br><span class=\"line\">AAAA</span><br><span class=\"line\">BBBB</span><br><span class=\"line\">hey</span><br></pre></td></tr></table></figure>\n\n<p>测试成功！(＾－＾)V</p>\n<blockquote>\n<p>参考<a href=\"https://cloud.tencent.com/developer/news/371290\" target=\"_blank\" rel=\"noopener\">https://cloud.tencent.com/developer/news/371290</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h3 id=\"MacOS-Docker-安装\"><a href=\"#MacOS-Docker-安装\" class=\"headerlink\" title=\"MacOS Docker 安装\"></a>MacOS Docker 安装</h3><p>安装和镜像加速参考<a href=\"https://www.runoob.com/docker/macos-docker-install.html\" target=\"_blank\" rel=\"noopener\">docker安装教程</a></p>\n<h3 id=\"Docker-下载Zookeeper-和-kafka-镜像\"><a href=\"#Docker-下载Zookeeper-和-kafka-镜像\" class=\"headerlink\" title=\"Docker 下载Zookeeper 和 kafka 镜像\"></a>Docker 下载Zookeeper 和 kafka 镜像</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ » docker pull zookeeper:latest</span><br><span class=\"line\">~ » docker pull wurstmeister/kafka:latest</span><br><span class=\"line\">~ » docker pull sheepkiller/kafka-manager</span><br></pre></td></tr></table></figure>","more":"<h3 id=\"启动容器\"><a href=\"#启动容器\" class=\"headerlink\" title=\"启动容器\"></a>启动容器</h3><p>1、创建网络：由于要涉及到zookeeper和kafka之间的通信，所以我们运用docker内部容器通信机制先新建一个网络。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ » docker network create app</span><br><span class=\"line\"></span><br><span class=\"line\">d481270a05236007178e6ed0ce4b775c9d2aebb6c13bc050bb852bc46ca0b874</span><br></pre></td></tr></table></figure>\n\n<p>运行 docker network ls查看新建的网络</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ » docker network ls                  </span><br><span class=\"line\"></span><br><span class=\"line\">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class=\"line\">d481270a0523        app                 bridge              <span class=\"built_in\">local</span></span><br><span class=\"line\">0ab6b1467267        bridge              bridge              <span class=\"built_in\">local</span></span><br><span class=\"line\">cd08298f526b        host                host                <span class=\"built_in\">local</span></span><br><span class=\"line\">86a734066770        none                null                <span class=\"built_in\">local</span></span><br></pre></td></tr></table></figure>\n\n<p>运行docker network inspect app查看网络详细信息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ » docker network inspect app                        </span><br><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">\"Name\"</span>: <span class=\"string\">\"app\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Id\"</span>: <span class=\"string\">\"d481270a05236007178e6ed0ce4b775c9d2aebb6c13bc050bb852bc46ca0b874\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Created\"</span>: <span class=\"string\">\"2019-07-19T06:57:10.768655482Z\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Scope\"</span>: <span class=\"string\">\"local\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Driver\"</span>: <span class=\"string\">\"bridge\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"EnableIPv6\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">\"IPAM\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">\"Driver\"</span>: <span class=\"string\">\"default\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"Options\"</span>: &#123;&#125;,</span><br><span class=\"line\">            <span class=\"string\">\"Config\"</span>: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"string\">\"Subnet\"</span>: <span class=\"string\">\"172.18.0.0/16\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"Gateway\"</span>: <span class=\"string\">\"172.18.0.1\"</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">\"Internal\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Attachable\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Ingress\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">\"ConfigFrom\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">\"Network\"</span>: <span class=\"string\">\"\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">\"ConfigOnly\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Containers\"</span>: &#123;&#125;,</span><br><span class=\"line\">        <span class=\"string\">\"Options\"</span>: &#123;&#125;,</span><br><span class=\"line\">        <span class=\"string\">\"Labels\"</span>: &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>可以看到其连接的containers为空，说明还没有容器连接进来<br>2、创建Zookeeper容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ » docker run --net=app --name zookeeper -p 2181 -t zookeeper</span><br></pre></td></tr></table></figure>\n\n<p>遇到了如下问题</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker: Error response from daemon: Conflict. The container name <span class=\"string\">\"/zookeeper\"</span> is already <span class=\"keyword\">in</span> use by container <span class=\"string\">\"26ffbd391e8c6e5e90b8f593e354f80768f179741e1de35640efacc6303fdad0\"</span>. You have to remove (or rename) that container to be able to reuse that name.</span><br><span class=\"line\">See <span class=\"string\">'docker run --help'</span>.</span><br></pre></td></tr></table></figure>\n\n<p>docker ps -l 查看发现已经创建的zookeeper 可以使用docker rm 删除</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ » docker ps -l                                       </span><br><span class=\"line\">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class=\"line\">26ffbd391e8c        zookeeper           <span class=\"string\">\"/docker-entrypoint.…\"</span>   8 minutes ago       Created                                 zookeeper</span><br><span class=\"line\"></span><br><span class=\"line\">~ » docker rm 26ffbd391e8c</span><br></pre></td></tr></table></figure>\n\n<p>重新执行创建命令</p>\n<div class=\"note info\"><p>run，创建新容器，并为容器配置一些参数。</p>\n<p>-t，在容器内部创建一个tty或者伪终端。</p>\n<p>-i，允许主机终端按照容器内部的标准与其交互。</p>\n<p>-d，后台运行容器并打印容器名称。</p>\n<p>–name，容器名称。</p>\n<p>-p，端口映射，参数格式为：主机物理端口:容器内部端口。</p>\n<p>最后跟上的就是我们已经下载的镜像</p></div>\n\n<p>3、创建Kafka容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ » docker run --net=app --name kafka -p 9092 \\</span><br><span class=\"line\">--env HOST_IP=127.0.0.1 \\</span><br><span class=\"line\">--env KAFKA_ADVERTISED_HOST_NAME=localhost  \\</span><br><span class=\"line\">--env KAFKA_ADVERTISED_PORT=9092 \\</span><br><span class=\"line\">--env KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 \\</span><br><span class=\"line\">--link zookeeper \\</span><br><span class=\"line\">wurstmeister/kafka:latest</span><br></pre></td></tr></table></figure>\n\n<div class=\"note info\"><p>-e，配置容器环境变量。</p>\n<p>–link，链接到另一个容器，参数格式为：目标容器名称:在本容器内的别名。</p>\n<p>这里的环境变量设置，其实是就是对即将创建的Kafka配置文件server.properties进行初始化。</p></div>\n\n<p>4、创建kafka-manager</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ » docker run --net=app \\</span><br><span class=\"line\">--name kafka-manager \\</span><br><span class=\"line\">-p 9000:9000 \\</span><br><span class=\"line\">-e ZK_HOSTS=zookeeper:2181 \\</span><br><span class=\"line\">sheepkiller/kafka-manager</span><br></pre></td></tr></table></figure>\n\n<p>访问ip:9000即可</p>\n<p>5、测试Kafka<br>进入kafka容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ » docker <span class=\"built_in\">exec</span> -it kafka /bin/bash</span><br></pre></td></tr></table></figure>\n\n<p>发送消息</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash-4.4<span class=\"comment\"># kafka-console-producer.sh --broker-list localhost:9092 --topic test</span></span><br><span class=\"line\">&gt;hello</span><br><span class=\"line\">&gt;AAAA</span><br><span class=\"line\">&gt;BBBB</span><br><span class=\"line\">&gt;hey</span><br></pre></td></tr></table></figure>\n\n<p>读取消息(需要打开另一个终端)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash-4.4<span class=\"comment\"># kafka-console-consumer.sh \\</span></span><br><span class=\"line\">&gt; --bootstrap-server localhost:9092 \\</span><br><span class=\"line\">&gt; --topic <span class=\"built_in\">test</span> --from-beginning</span><br><span class=\"line\">hello</span><br><span class=\"line\">AAAA</span><br><span class=\"line\">BBBB</span><br><span class=\"line\">hey</span><br></pre></td></tr></table></figure>\n\n<p>测试成功！(＾－＾)V</p>\n<blockquote>\n<p>参考<a href=\"https://cloud.tencent.com/developer/news/371290\" target=\"_blank\" rel=\"noopener\">https://cloud.tencent.com/developer/news/371290</a></p>\n</blockquote>"},{"title":"《Mysql技术内幕》学习笔记-MySql体系结构和存储引擎","date":"2019-07-29T18:40:04.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"#### 数据库\n> 数据库是文件的集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合。\n> 在MySQL数据库中，数据库文件可以是frm、MYD、MYI、ibd结尾的文件。\n\n<!-- more -->\n#### 数据库实例\n> 数据库实例是`程序`，是位于用户与操作系统之间的一层数据管理软件，用户对数据库数据的任何操作，\n> 包括数据库定义、数据查询、数据维护、数据库运行控制等都是在数据库实例下进行的，应用程序只有通过数据库实例才能和数据库打交道。\n\n#### MySql体系结构\n![mysql体系结构图](Mysql01/01.jpg)\n\n从图中可以发现，MySQL由：连接池组件、管理服务和工具组件、SQL接口组件、查询分析器组件、优化器组件、缓冲（Cache）组件、插件式存储引擎和物理文件组成。\nMySQL数据库区别于其他数据库的最重要的一个特点就是其插件式的`表存储引擎`。\n\n#### MySql存储引擎\nMySql数据库常用存储引擎：InnoDB、MyISAM、NDB、Memory(HEAP)、Archive、BDB(BerkeleyDB)、Federated、Maria等。\n\n|特性|InnoDB|MyISAM|NDB|Memory|Archive|BDB|\n|:---:|:---:|:---:|:---:|:---:|:---:|:---:|\n|存储限制|64TB|No|Yes|Yes|No|No|\n|事务|Yes|||||Yes|\n|锁粒度|Row|Table|Row|Table|Row|Page|\n|MVCC|Yes||Yes||Yes||\n|B树索引|Yes|Yes|Yes|Yes||Yes|\n|哈希索引|Yes||Yes|Yes|||\n|全文索引|5.6支持英文|Yes|||||\n|集群索引|Yes||||||\n|数据缓存|Yes||Yes|Yes|||\n|索引缓存|Yes|Yes|Yes|Yes|||\n|数据压缩||Yes|||Yes||\n|加密传输|Yes|Yes|Yes|Yes|Yes|Yes|\n|批量插入|相对低|高|高|高|非常高|高|\n|内存消耗|高|低|高|中|低|低|\n|存储空间消耗|高|低|低|N/A|非常低|低|\n|外键支持|Yes||||||\n|复制支持|Yes|Yes|Yes|Yes|Yes|Yes|\n|查询缓存|Yes|Yes|Yes|Yes|Yes|Yes|\n|备份恢复|Yes|Yes|Yes|Yes|Yes|Yes|\n|数据字典更新|Yes|Yes|Yes|Yes|Yes|Yes|\n|备份/时间点恢复|Yes|Yes|Yes|Yes|Yes|Yes|\n|集群支持|||Yes|||||\n\n","source":"_posts/Mysql01.md","raw":"---\ntitle: 《Mysql技术内幕》学习笔记-MySql体系结构和存储引擎\ndate: 2019-07-30 02:40:04\ntags:\n    - MySql\n    - 学习笔记\ncategories: Mysql\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n#### 数据库\n> 数据库是文件的集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合。\n> 在MySQL数据库中，数据库文件可以是frm、MYD、MYI、ibd结尾的文件。\n\n<!-- more -->\n#### 数据库实例\n> 数据库实例是`程序`，是位于用户与操作系统之间的一层数据管理软件，用户对数据库数据的任何操作，\n> 包括数据库定义、数据查询、数据维护、数据库运行控制等都是在数据库实例下进行的，应用程序只有通过数据库实例才能和数据库打交道。\n\n#### MySql体系结构\n![mysql体系结构图](Mysql01/01.jpg)\n\n从图中可以发现，MySQL由：连接池组件、管理服务和工具组件、SQL接口组件、查询分析器组件、优化器组件、缓冲（Cache）组件、插件式存储引擎和物理文件组成。\nMySQL数据库区别于其他数据库的最重要的一个特点就是其插件式的`表存储引擎`。\n\n#### MySql存储引擎\nMySql数据库常用存储引擎：InnoDB、MyISAM、NDB、Memory(HEAP)、Archive、BDB(BerkeleyDB)、Federated、Maria等。\n\n|特性|InnoDB|MyISAM|NDB|Memory|Archive|BDB|\n|:---:|:---:|:---:|:---:|:---:|:---:|:---:|\n|存储限制|64TB|No|Yes|Yes|No|No|\n|事务|Yes|||||Yes|\n|锁粒度|Row|Table|Row|Table|Row|Page|\n|MVCC|Yes||Yes||Yes||\n|B树索引|Yes|Yes|Yes|Yes||Yes|\n|哈希索引|Yes||Yes|Yes|||\n|全文索引|5.6支持英文|Yes|||||\n|集群索引|Yes||||||\n|数据缓存|Yes||Yes|Yes|||\n|索引缓存|Yes|Yes|Yes|Yes|||\n|数据压缩||Yes|||Yes||\n|加密传输|Yes|Yes|Yes|Yes|Yes|Yes|\n|批量插入|相对低|高|高|高|非常高|高|\n|内存消耗|高|低|高|中|低|低|\n|存储空间消耗|高|低|低|N/A|非常低|低|\n|外键支持|Yes||||||\n|复制支持|Yes|Yes|Yes|Yes|Yes|Yes|\n|查询缓存|Yes|Yes|Yes|Yes|Yes|Yes|\n|备份恢复|Yes|Yes|Yes|Yes|Yes|Yes|\n|数据字典更新|Yes|Yes|Yes|Yes|Yes|Yes|\n|备份/时间点恢复|Yes|Yes|Yes|Yes|Yes|Yes|\n|集群支持|||Yes|||||\n\n","slug":"Mysql01","published":1,"updated":"2019-08-31T03:03:59.999Z","layout":"post","photos":[],"link":"","_id":"ck8fb4ado002ok2o5ky2m2j0v","content":"<h4 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h4><blockquote>\n<p>数据库是文件的集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合。<br>在MySQL数据库中，数据库文件可以是frm、MYD、MYI、ibd结尾的文件。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h4 id=\"数据库实例\"><a href=\"#数据库实例\" class=\"headerlink\" title=\"数据库实例\"></a>数据库实例</h4><blockquote>\n<p>数据库实例是<code>程序</code>，是位于用户与操作系统之间的一层数据管理软件，用户对数据库数据的任何操作，<br>包括数据库定义、数据查询、数据维护、数据库运行控制等都是在数据库实例下进行的，应用程序只有通过数据库实例才能和数据库打交道。</p>\n</blockquote>\n<h4 id=\"MySql体系结构\"><a href=\"#MySql体系结构\" class=\"headerlink\" title=\"MySql体系结构\"></a>MySql体系结构</h4><p><img src=\"/Mysql/Mysql01/01.jpg\" alt=\"mysql体系结构图\"></p>\n<p>从图中可以发现，MySQL由：连接池组件、管理服务和工具组件、SQL接口组件、查询分析器组件、优化器组件、缓冲（Cache）组件、插件式存储引擎和物理文件组成。<br>MySQL数据库区别于其他数据库的最重要的一个特点就是其插件式的<code>表存储引擎</code>。</p>\n<h4 id=\"MySql存储引擎\"><a href=\"#MySql存储引擎\" class=\"headerlink\" title=\"MySql存储引擎\"></a>MySql存储引擎</h4><p>MySql数据库常用存储引擎：InnoDB、MyISAM、NDB、Memory(HEAP)、Archive、BDB(BerkeleyDB)、Federated、Maria等。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">特性</th>\n<th align=\"center\">InnoDB</th>\n<th align=\"center\">MyISAM</th>\n<th align=\"center\">NDB</th>\n<th align=\"center\">Memory</th>\n<th align=\"center\">Archive</th>\n<th align=\"center\">BDB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">存储限制</td>\n<td align=\"center\">64TB</td>\n<td align=\"center\">No</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">No</td>\n<td align=\"center\">No</td>\n</tr>\n<tr>\n<td align=\"center\">事务</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">Yes</td>\n</tr>\n<tr>\n<td align=\"center\">锁粒度</td>\n<td align=\"center\">Row</td>\n<td align=\"center\">Table</td>\n<td align=\"center\">Row</td>\n<td align=\"center\">Table</td>\n<td align=\"center\">Row</td>\n<td align=\"center\">Page</td>\n</tr>\n<tr>\n<td align=\"center\">MVCC</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">B树索引</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\">Yes</td>\n</tr>\n<tr>\n<td align=\"center\">哈希索引</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">全文索引</td>\n<td align=\"center\">5.6支持英文</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">集群索引</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">数据缓存</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">索引缓存</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">数据压缩</td>\n<td align=\"center\"></td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">加密传输</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n</tr>\n<tr>\n<td align=\"center\">批量插入</td>\n<td align=\"center\">相对低</td>\n<td align=\"center\">高</td>\n<td align=\"center\">高</td>\n<td align=\"center\">高</td>\n<td align=\"center\">非常高</td>\n<td align=\"center\">高</td>\n</tr>\n<tr>\n<td align=\"center\">内存消耗</td>\n<td align=\"center\">高</td>\n<td align=\"center\">低</td>\n<td align=\"center\">高</td>\n<td align=\"center\">中</td>\n<td align=\"center\">低</td>\n<td align=\"center\">低</td>\n</tr>\n<tr>\n<td align=\"center\">存储空间消耗</td>\n<td align=\"center\">高</td>\n<td align=\"center\">低</td>\n<td align=\"center\">低</td>\n<td align=\"center\">N/A</td>\n<td align=\"center\">非常低</td>\n<td align=\"center\">低</td>\n</tr>\n<tr>\n<td align=\"center\">外键支持</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">复制支持</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n</tr>\n<tr>\n<td align=\"center\">查询缓存</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n</tr>\n<tr>\n<td align=\"center\">备份恢复</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n</tr>\n<tr>\n<td align=\"center\">数据字典更新</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n</tr>\n<tr>\n<td align=\"center\">备份/时间点恢复</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n</tr>\n<tr>\n<td align=\"center\">集群支持</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"<h4 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h4><blockquote>\n<p>数据库是文件的集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合。<br>在MySQL数据库中，数据库文件可以是frm、MYD、MYI、ibd结尾的文件。</p>\n</blockquote>","more":"<h4 id=\"数据库实例\"><a href=\"#数据库实例\" class=\"headerlink\" title=\"数据库实例\"></a>数据库实例</h4><blockquote>\n<p>数据库实例是<code>程序</code>，是位于用户与操作系统之间的一层数据管理软件，用户对数据库数据的任何操作，<br>包括数据库定义、数据查询、数据维护、数据库运行控制等都是在数据库实例下进行的，应用程序只有通过数据库实例才能和数据库打交道。</p>\n</blockquote>\n<h4 id=\"MySql体系结构\"><a href=\"#MySql体系结构\" class=\"headerlink\" title=\"MySql体系结构\"></a>MySql体系结构</h4><p><img src=\"/Mysql/Mysql01/01.jpg\" alt=\"mysql体系结构图\"></p>\n<p>从图中可以发现，MySQL由：连接池组件、管理服务和工具组件、SQL接口组件、查询分析器组件、优化器组件、缓冲（Cache）组件、插件式存储引擎和物理文件组成。<br>MySQL数据库区别于其他数据库的最重要的一个特点就是其插件式的<code>表存储引擎</code>。</p>\n<h4 id=\"MySql存储引擎\"><a href=\"#MySql存储引擎\" class=\"headerlink\" title=\"MySql存储引擎\"></a>MySql存储引擎</h4><p>MySql数据库常用存储引擎：InnoDB、MyISAM、NDB、Memory(HEAP)、Archive、BDB(BerkeleyDB)、Federated、Maria等。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">特性</th>\n<th align=\"center\">InnoDB</th>\n<th align=\"center\">MyISAM</th>\n<th align=\"center\">NDB</th>\n<th align=\"center\">Memory</th>\n<th align=\"center\">Archive</th>\n<th align=\"center\">BDB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">存储限制</td>\n<td align=\"center\">64TB</td>\n<td align=\"center\">No</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">No</td>\n<td align=\"center\">No</td>\n</tr>\n<tr>\n<td align=\"center\">事务</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">Yes</td>\n</tr>\n<tr>\n<td align=\"center\">锁粒度</td>\n<td align=\"center\">Row</td>\n<td align=\"center\">Table</td>\n<td align=\"center\">Row</td>\n<td align=\"center\">Table</td>\n<td align=\"center\">Row</td>\n<td align=\"center\">Page</td>\n</tr>\n<tr>\n<td align=\"center\">MVCC</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">B树索引</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\">Yes</td>\n</tr>\n<tr>\n<td align=\"center\">哈希索引</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">全文索引</td>\n<td align=\"center\">5.6支持英文</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">集群索引</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">数据缓存</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">索引缓存</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">数据压缩</td>\n<td align=\"center\"></td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">加密传输</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n</tr>\n<tr>\n<td align=\"center\">批量插入</td>\n<td align=\"center\">相对低</td>\n<td align=\"center\">高</td>\n<td align=\"center\">高</td>\n<td align=\"center\">高</td>\n<td align=\"center\">非常高</td>\n<td align=\"center\">高</td>\n</tr>\n<tr>\n<td align=\"center\">内存消耗</td>\n<td align=\"center\">高</td>\n<td align=\"center\">低</td>\n<td align=\"center\">高</td>\n<td align=\"center\">中</td>\n<td align=\"center\">低</td>\n<td align=\"center\">低</td>\n</tr>\n<tr>\n<td align=\"center\">存储空间消耗</td>\n<td align=\"center\">高</td>\n<td align=\"center\">低</td>\n<td align=\"center\">低</td>\n<td align=\"center\">N/A</td>\n<td align=\"center\">非常低</td>\n<td align=\"center\">低</td>\n</tr>\n<tr>\n<td align=\"center\">外键支持</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">复制支持</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n</tr>\n<tr>\n<td align=\"center\">查询缓存</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n</tr>\n<tr>\n<td align=\"center\">备份恢复</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n</tr>\n<tr>\n<td align=\"center\">数据字典更新</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n</tr>\n<tr>\n<td align=\"center\">备份/时间点恢复</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n<td align=\"center\">Yes</td>\n</tr>\n<tr>\n<td align=\"center\">集群支持</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">Yes</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>"},{"title":"Mysql-存储程序","author":"Guyuqing","copyright":true,"comments":0,"date":"2019-08-28T08:32:00.000Z","_content":"MySQL中的存储程序本质上封装了一些可执行的语句，然后给用户提供一种简单的调用方式来执行这些语句，根据调用方式的不同，我们可以把`存储程序`分为`存储例程`、`触发器`和`事件`这几种类型。其中，`存储例程`又可以被细分为`存储函数`和`存储过程`。\n<!-- more -->\n![存储程序](Mysql-storage/640.png)\n\n# 自定义变量\n\nMySQL中对我们自定义的变量的命名有个要求，那就是变量名称前必须加一个`@符号`。我们自定义变量的值的类型可以是任意MySQL支持的类型，例如我们自定义一个变量<font color='red'>a</font>：\n```sql\nmysql> SET @a = 1;\nQuery OK, 0 rows affected (0.00 sec)\n```\n\n如果我们想查看这个变量的值的话，使用<font color='Orange'>SELECT</font>语句就好了，不过仍然需要在变量名称加一个@符号：\n```sql\nmysql> SELECT @a;\n+------+\n| @a   |\n+------+\n|    1 |\n+------+\n1 row in set (0.00 sec)\n```\n\n同一个变量也可以存储存储不同类型的值，比方说我们再把一个字符串值赋值给变量<font color='red'>a</font>：\n```sql\nmysql> SET @a = '啦';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @a;\n+------+\n| @a   |\n+------+\n| 啦   |\n+------+\n1 row in set (0.00 sec)\n```\n\n除了把一个常量赋值给一个变量以外，我们还可以把一个变量赋值给另一个变量：\n```sql\nmysql> SET @b = @a;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @b;\n+------+\n| @b   |\n+------+\n| 啦   |\n+------+\n1 row in set (0.00 sec)\n```\n\n我们还可以将某个查询的结果赋值给一个变量，前提是这个<font color='red'>查询的结果只有一个值</font>：\n```sql\nmysql> SET @a = (SELECT first_column FROM first_table LIMIT 1);\nQuery OK, 0 rows affected (0.00 sec)\n\n```\n\n还可以用另一种形式的语句来将查询的结果赋值给一个变量：\n```sql\nmysql> SELECT first_column FROM first_table LIMIT 1 INTO @b;\nQuery OK, 1 row affected (0.00 sec)\n\n```\n\n我们查看一下这两个变量的值：\n```sql\nmysql> SELECT @a, @b;\n+------+------+\n| @a   | @b   |\n+------+------+\n|    1 |    1 |\n+------+------+\n1 row in set (0.00 sec)\n```\n如果我们的查询结果是一条记录，该记录中有多个列的值的话，我们想把这几个值分别赋值到不同的变量中，只能使用`INTO`语句了：\n```sql\nmysql> SELECT first_column, second_column FROM first_table LIMIT 1 INTO @a, @b;\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> SELECT @a, @b;                                                           \n+------+------+\n| @a   | @b   |\n+------+------+\n|    1 | aaa  |\n+------+------+\n1 row in set (0.00 sec)\n```\n\n# 复合语句\n\n在MySQL客户端的交互界面处，当我们完成键盘输入并按下回车键时，MySQL客户端会检测我们输入的内容中是否包含`;`、`\\g`或者`\\G`这三个符号之一，如果有的话，会把我们输入的内容发送到服务器。这样一来，如果我们想给服务器发送复合语句（也就是由一条或多条语句组成的语句）的话，就需要把这些语句写到一行中，比如这样：\n```sql\nmysql> SELECT first_column FROM first_table ;SELECT second_column FROM first_table;\n+--------------+\n| first_column |\n+--------------+\n|            1 |\n|            2 |\n|         NULL |\n+--------------+\n3 rows in set (0.00 sec)\n\n+---------------+\n| second_column |\n+---------------+\n| aaa           |\n| NULL          |\n| ccc           |\n+---------------+\n3 rows in set (0.00 sec)\n\n```\n\n我们也可以用`delimiter`命令来自定义MySQL的检测输入结束的符号，如下：\n```sql\nmysql> delimiter $\nmysql> SELECT first_column FROM first_table ;\n    -> SELECT second_column FROM first_table;\n    -> $\n+--------------+\n| first_column |\n+--------------+\n|            1 |\n|            2 |\n|         NULL |\n+--------------+\n3 rows in set (0.00 sec)\n\n+---------------+\n| second_column |\n+---------------+\n| aaa           |\n| NULL          |\n| ccc           |\n+---------------+\n3 rows in set (0.00 sec)\n\n```\n\n`delimiter $`命令意味着修改MySQL客户端检测输入结束的符号为`$`,也可以使用任何符号来作为MySQL客户端检测输入结束的符号，也包括多个字符，如下：\n```sql\nmysql> delimiter 666\nmysql> SELECT first_column FROM first_table;\n    -> SELECT second_column FROM first_table;\n    -> 666\n+--------------+\n| first_column |\n+--------------+\n|            1 |\n|            2 |\n|         NULL |\n+--------------+\n3 rows in set (0.00 sec)\n\n+---------------+\n| second_column |\n+---------------+\n| aaa           |\n| NULL          |\n| ccc           |\n+---------------+\n3 rows in set (0.00 sec)\n```\n\n# 存储函数\n\n## 创建存储函数\n`存储函数`其实就是一种`函数`，只不过在这个函数里可以执行命令语句而已。\nMySQL中定义存储函数的语句如下：\n```sql\nCREATE FUNCTION 存储函数名称([参数列表])\nRETURNS 返回值类型\nBEGIN\n    函数体内容\nEND\n```\n\n举个🌰：\n```sql\nmysql> delimiter $\nmysql> CREATE FUNCTION second_column(a INT)\n    -> RETURNS VARCHAR(100)\n    -> BEGIN\n    -> RETURN (SELECT second_column FROM first_table WHERE first_column = a);\n    -> END $\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> delimiter ;\n```\n\n## 存储函数的调用\n我们自定义的函数和系统内置函数的使用方式是一样的，都是在函数名后加小括号`()`表示函数调用\n```sql\nmysql> SELECT second_column(1);\n+------------------+\n| second_column(1) |\n+------------------+\n| aaa              |\n+------------------+\n1 row in set (0.00 sec)\n```\n\n## 查看存储函数\n查看定义了多少个存储函数:\n```sql\nSHOW FUNCTION STATUS [LIKE 需要匹配的函数名]\n```\n\n查看某个函数的具体定义:\n```sql\nSHOW CREATE FUNCTION 函数名\n```\n\n## 删除存储函数\n删除某个存储函数\n```sql\nDROP FUNCTION 函数名\n```\n\n## 在函数体中定义变量\n\n在函数体中使用变量前必须先声明这个变量，函数体中的变量名`不允许加@`前缀,声明方式如下：\n```sql\nDECLARE 变量名 数据类型 [DEFAULT 默认值];   \n\nmysql> delimiter $\nmysql> CREATE FUNCTION var_demo(a INT)\n    -> RETURNS INT\n    -> BEGIN\n    -> DECLARE b INT;\n    -> SET b = 5;\n    -> RETURN b+a;\n    -> END $\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> delimiter ;\n```\n我们调用一下这个函数：\n```sql\nmysql> SELECT var_demo(2);\n+-------------+\n| var_demo(2) |\n+-------------+\n|           7 |\n+-------------+\n1 row in set (0.00 sec)\n```\n如果不对声明的变量赋值，它的默认值就是NULL，也可以通过`DEFAULT`子句来显式的指定变量的默认值.\n```sql\nmysql> delimiter $\nmysql> CREATE FUNCTION var_default_demo()\n-> RETURNS INT\n-> BEGIN\n->     DECLARE c INT DEFAULT 1;\n->     RETURN c;\n-> END $\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> delimiter ;\n\nmysql> SELECT var_default_demo();\n+--------------------+\n| var_default_demo() |\n+--------------------+\n|                  1 |\n+--------------------+\n1 row in set (0.00 sec)\n\n```\n\n## 参数定义\n\n比如我们上边编写的这个second_column函数：\n\n```sql\nmysql> CREATE FUNCTION second_column(a INT)\n    -> RETURNS VARCHAR(100)\n    -> BEGIN\n    -> RETURN (SELECT second_column FROM first_table WHERE first_column = a);\n    -> END $\n```\n需要注意的是，参数名不要和函数体语句中其他的变量名、命令语句的标识符冲突。并且函数参数不可以指定默认值，我们在调用函数的时候，必须显式的指定所有的参数，参数类型也一定要匹配\n\n\n\n## 判断语句\n\n语法格式如下：\n```sql\nIF 布尔表达式 THEN \n    处理语句\n[ELSEIF 布尔表达式 THEN\n    处理语句]\n[ELSE \n    处理语句]    \nEND IF;\n```\n\n举个🌰：\n```sql\nmysql> delimiter $\nmysql> CREATE FUNCTION condition_demo(i INT)\n    -> RETURNS VARCHAR(10)\n    -> BEGIN\n    -> DECLARE result VARCHAR(10);\n    -> IF i = 1 THEN\n    -> SET result = '结果是1';\n    -> ELSEIF i = 2 THEN\n    ->  SET result = '结果是2';\n    -> ELSEIF i = 3 THEN\n    -> SET result = '结果是3';\n    -> ELSE\n    -> SET result = '非法参数';\n    -> END IF;\n    -> RETURN result;\n    -> END $\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> delimiter;\n\n\nmysql> SELECT condition_demo(2);\n+-------------------+\n| condition_demo(2) |\n+-------------------+\n| 结果是2           |\n+-------------------+\n1 row in set (0.00 sec)\n\n```\n\n## 循环语句\n`while`循环语法格式如下：\n```sql\nWHILE 布尔表达式 DO\n    循环语句\nEND WHILE;\n```\n\n举个🌰：\n```sql\nmysql> delimiter $\nmysql> CREATE FUNCTION sum_all(n INT UNSIGNED)\n    -> RETURNS INT\n    -> BEGIN\n    -> DECLARE result INT DEFAULT 0;\n    -> DECLARE i INT DEFAULT 1;\n    -> WHILE i <= n DO\n    -> SET result = result + i;\n    -> SET i = i + 1;\n    -> END WHILE;\n    -> RETURN result;\n    -> END $\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> delimiter;\n\nmysql> select sum_all(10);\n+-------------+\n| sum_all(10) |\n+-------------+\n|          55 |\n+-------------+\n1 row in set (0.00 sec)\n```\n\n`REPEAT`循环语法格式如下：\n```sql\nREPEAT\n    循环语句\nUNTIL 布尔表达式 END REPEAT;\n```\n举个🌰：\n```sql\nmysql> CREATE FUNCTION sum_repeat(n INT UNSIGNED)\n    -> RETURNS INT\n    -> BEGIN\n    -> DECLARE result INT DEFAULT 0;\n    -> DECLARE i INT DEFAULT 1;\n    -> REPEAT\n    -> -- 循环开始\n    -> SET result = result + i;\n    -> SET i = i + 1;\n    -> UNTIL i > n END REPEAT;\n    -> RETURN result;\n    -> END $\nQuery OK, 0 rows affected (0.02 sec)\n\nmysql> select sum_repeat(5);\n+---------------+\n| sum_repeat(5) |\n+---------------+\n|            15 |\n+---------------+\n1 row in set (0.01 sec)\n```\n\n\n`LOOP`循环语法格式如下：\n```sql\n循环标记:LOOP\n    循环语句\n    LEAVE 循环标记;\nEND LOOP 循环标记;\n```\n举个🌰：\n```sql\nmysql> CREATE FUNCTION sum_loop(n INT UNSIGNED)\n    -> RETURNS INT\n    -> BEGIN\n    -> DECLARE result INT DEFAULT 0;\n    -> DECLARE i INT DEFAULT 1;\n    -> LOOP_NAME:LOOP -- 循环开始\n    -> IF i > n THEN\n    -> LEAVE LOOP_NAME;\n    -> END IF;\n    -> SET result = result + i;\n    -> SET i = i + 1;\n    -> END LOOP LOOP_NAME;\n    -> RETURN result;\n    -> END $\n    \nmysql> select sum_loop(10);\n+--------------+\n| sum_loop(10) |\n+--------------+\n|           55 |\n+--------------+\n1 row in set (0.00 sec)\n```\n\n# 存储过程\n\n存储函数侧重于执行语句并返回一个值，而存储过程更侧重于单纯的去执行语句。\n## 创建存储过程\n```sql\nCREATE PROCEDURE 存储过程名称([参数列表])\nBEGIN\n    需要执行的语句\nEND  \n```\n举个🌰：\n```sql\nmysql> CREATE PROCEDURE insert_first_table(c1 INT,c2 VARCHAR(100))\n    -> BEGIN\n    -> SELECT * FROM first_table;\n    -> INSERT INTO first_table(first_column,second_column) VALUES(c1,c2);\n    -> SELECT * FROM first_table;\n    -> END $\nQuery OK, 0 rows affected (0.02 sec)\n```\n\n## 存储过程的调用\n存储函数执行语句并返回一个值，所以常用在表达式中。\n存储过程偏向于调用那些语句，并不能用在表达式中。\n我们需要显式的使用CALL语句来调用一个存储过程：\n\n```sql\nCALL 存储过程([参数列表]);\n```\n举个🌰：\n```sql\nmysql> CALL insert_first_table(4,'test');\n \n+--------------+---------------+\n| first_column | second_column |\n+--------------+---------------+\n|            1 | aaa           |\n|            2 | NULL          |\n|         NULL | ccc           |\n+--------------+---------------+\n3 rows in set (0.00 sec)\n\n\n+--------------+---------------+\n| first_column | second_column |\n+--------------+---------------+\n|            1 | aaa           |\n|            2 | NULL          |\n|         NULL | ccc           |\n|            4 | test          |\n+--------------+---------------+\n4 rows in set (0.00 sec)\n```\n\n## 查看存储过程\n```sql\n查看当前数据库中创建的存储过程都有哪些的语句：\nSHOW PROCEDURE STATUS [LIKE 需要匹配的函数名]\n\n查看某个存储过程定义的语句：\nSHOW CREATE PROCEDURE 存储过程名称\n```\n\n## 删除存储过程\n删除某个存储过程\n```sql\nDROP PROCEDURE 存储过程名称\n```\n\n## 存储过程参数类型\n<table>\n<tr>\n    <th>参数类型</th>\n    <th>实际参数是否必须是变量</th>\n    <th colspan=\"3\">作用</th>\n</tr>\n<tr>\n    <td style=\"text-align:center\">IN</td>\n    <td style=\"text-align:center\">否</td>\n    <td colspan=\"3\">用于调用者向过程传递数据，如果该参数在过程中被修改，调用者不可见</td>\n</tr>\n<tr>\n    <td style=\"text-align:center\">OUT</td>\n    <td style=\"text-align:center\">是</td>\n    <td colspan=\"3\">用于把过程产生的结果放到此参数中，过程结束后调用者可以通过该参数来获取过程执行的结果</td>\n</tr>\n<tr>\n    <td style=\"text-align:center\">INOUT</td>\n    <td style=\"text-align:center\">是</td>\n    <td colspan=\"3\">综合IN和OUT特点，即可用于调用者向过程传递数据，也可用于存放过程中产生的结果</td>\n</tr>\n</table>  \n\n### IN\n```sql\nmysql> CREATE PROCEDURE test_in(IN num INT)\n    -> BEGIN\n    -> SELECT num;\n    -> SET num = 666;\n    -> END $\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> SET @a = 111;\n\nQuery OK, 0 rows affected (0.01 sec)\n\n\nmysql> CALL test_in(@a);\n+------+\n| num  |\n+------+\n|  111 |\n+------+\n1 row in set (0.00 sec)\n\nQuery OK, 0 rows affected (0.00 sec)\n```\nIN参数类型的变量只能用于读取，对类型的变量赋值是不会被调用者看到的。\n如果我们不写明参数类型的话，该参数的类型默认是IN。\n\n### OUT\n```sql\nmysql> CREATE PROCEDURE test_out(OUT num INT)\n    -> BEGIN\n    -> SELECT num;\n    -> SET num = 666;\n    -> END $\nQuery OK, 0 rows affected (0.01 sec)\n\n\nmysql> CALL test_out(@a);\n+------+\n| num  |\n+------+\n| NULL |\n+------+\n1 row in set (0.00 sec)\n\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @a;\n+------+\n| @a   |\n+------+\n|  666 |\n+------+\n1 row in set (0.00 sec)\n\n```\n\nOUT参数类型的变量只能用于赋值，对类型的变量赋值是会被调用者看到的,因此参数就不允许是常量。\n\n存储过程中向调用者返回多个值，举个例子：\n```sql\nmysql> CREATE PROCEDURE data_out(OUT a INT,OUT b INT)\n    -> BEGIN\n    -> SET a = 100;\n    -> SET b = 200;\n    -> END $\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> CALL data_out(@a,@b);\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> select @a,@b;\n+------+------+\n| @a   | @b   |\n+------+------+\n|  100 |  200 |\n+------+------+\n1 row in set (0.00 sec)\n\n```\n\n### INOUT\n\n这种类型的参数既可以在存储过程中被读取，也可以被赋值后被调用者看到，因此参数就不允许是常量。\n\n## 存储过程和函数的区别\n\n* 存储函数在定义时需要显式用RETURNS语句标明返回的数据类型，而且在函数体中必须使用RETURN语句来显式指定返回的值，存储过程不需要。\n\n* 存储函数的参数类型只能是IN，而存储过程支持IN、OUT、INOUT三种参数类型。\n\n* 存储函数只能返回一个值，而存储过程可以通过设置多个OUT类型的参数来返回多个结果。\n\n* 存储函数执行过程中产生的结果集并不会被显示到客户端，而存储过程执行过程中产生的结果集会被显示到客户端。\n\n* 存储函数的调用直接使用在表达式中，而存储过程只能通过CALL语句来显式调用。\n\n# 游标\n游标（Cursor）是处理数据的一种方法，为了查看或者处理结果集中的数据，游标提供了在结果集中一次一行或者多行前进或向后浏览数据的能力。\n初始状态下它标记查询结果集中的第一条记录,根据这个游标取出它对应记录的信息，随后再移动游标，让它指向别的记录。\n\n## 创建游标\n```sql\nDECLARE 游标名称 CURSOR FOR 查询语句;\n```\n举个🌰：\n```sql\nmysql> CREATE PROCEDURE cursor_demo()\n    -> BEGIN\n    -> DECLARE first_table_cursor CURSOR FOR select * from first_table;\n    -> END $\nQuery OK, 0 rows affected (0.01 sec)\n```\n## 打开和关闭游标\n```sql\nOPEN 游标名称;\n\nCLOSE 游标名称;\n```\n打开游标意味着执行查询语句，让创建好的游标与该查询语句得到的结果集关联起来，关闭游标意味着会释放该游标占用的内存，所以一旦我们使用完了游标，就要把它关闭掉。\n\n## 游标获取记录\n\n```sql\nFETCH 游标名 INTO 变量1, 变量2, ... 变量n\n```\n举个例子：\n```sql\nmysql> CREATE PROCEDURE cursor_demo()\n    -> BEGIN\n    -> DECLARE c1 INT;\n    -> DECLARE c2 VARCHAR(100);\n    -> DECLARE record_count INT;\n    -> DECLARE i INT DEFAULT 0;\n    ->  -- 声明游标\n    -> DECLARE first_table_cursor CURSOR FOR select * from first_table;\n    ->\n    -> -- 统计表行数\n    -> SELECT COUNT(*) FROM first_table INTO record_count;\n    ->\n    -> -- 使用游标遍历\n    -> OPEN first_table_cursor;\n    ->\n    -> WHILE i < record_count DO\n    -> FETCH first_table_cursor INTO c1 , c2;\n    -> SELECT c1,c2;\n    -> SET i = i + 1;\n    -> END WHILE;\n    -> CLOSE first_table_cursor;\n    -> END $\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> CALL cursor_demo();\n+------+------+\n| c1   | c2   |\n+------+------+\n|    1 | aaa  |\n+------+------+\n1 row in set (0.01 sec)\n\n+------+------+\n| c1   | c2   |\n+------+------+\n|    2 | NULL |\n+------+------+\n1 row in set (0.01 sec)\n\n+------+------+\n| c1   | c2   |\n+------+------+\n| NULL | ccc  |\n+------+------+\n1 row in set (0.01 sec)\n\n+------+------+\n| c1   | c2   |\n+------+------+\n|    4 | test |\n+------+------+\n1 row in set (0.01 sec)\n\nQuery OK, 0 rows affected (0.01 sec)\n\n```\ni表示当前游标对应的记录位置。每调用一次 FETCH 语句，游标就移动到下一条记录的位置。\n\n## 遍历结束的执行策略\n\n其实在FETCH语句获取不到记录的时候会触发一个事件，从而我们可以得知所有的记录都被获取过了，然后我们就可以去主动的停止循环。\nMySQL中响应这个事件的语句如下：\n```sql\nDECLARE CONTINUE HANDLER FOR NOT FOUND 语句;  \n```\n举个🌰，再来改写一下cursor_demo存储过程：\n```sql\nmysql> delimiter $\nmysql> CREATE PROCEDURE cursor_demo()\n    -> BEGIN\n    -> -- 声明变量\n    -> DECLARE c1 INT;\n    -> DECLARE c2 VARCHAR(100);\n    -> DECLARE not_done INT DEFAULT 1;\n    ->\n    -> -- 声明游标\n    -> DECLARE first_table_cursor CURSOR FOR select * from first_table;\n    ->\n    -> -- 在游标遍历完记录的时候将变量 not_done 的值设置为 0，并且继续执行后边的语句\n    -> DECLARE CONTINUE HANDLER FOR NOT FOUND SET not_done = 0;\n    ->\n    -> -- 使用游标遍历\n    -> OPEN first_table_cursor;\n    ->\n    -> WHILE not_done = 1 DO\n    ->\n    -> FETCH first_table_cursor INTO c1 , c2;\n    -> SELECT c1,c2;\n    -> END WHILE;\n    -> CLOSE first_table_cursor;\n    -> END $\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql>  CALL cursor_demo();\n+------+------+\n| c1   | c2   |\n+------+------+\n|    1 | aaa  |\n+------+------+\n1 row in set (0.01 sec)\n\n+------+------+\n| c1   | c2   |\n+------+------+\n|    2 | NULL |\n+------+------+\n1 row in set (0.01 sec)\n\n+------+------+\n| c1   | c2   |\n+------+------+\n| NULL | ccc  |\n+------+------+\n1 row in set (0.01 sec)\n\n+------+------+\n| c1   | c2   |\n+------+------+\n|    4 | test |\n+------+------+\n1 row in set (0.01 sec)\n\n+------+------+\n| c1   | c2   |\n+------+------+\n|    4 | test |\n+------+------+\n1 row in set (0.01 sec)\n\nQuery OK, 0 rows affected (0.01 sec)\n\n```\n我们发现结果集中最后一条记录输出两遍怎么办呢，我们可以使用`EXIT`来替代上边的`CONTINUE`：\n`CONTINUE`表示在FETCH语句获取不到记录的时候仍然会执行之后存储过程的语句，也就是会将最后一次关联的记录中的值放入指定的变量\n`EXIT`表示在FETCH语句获取不到记录的时候仍然不会执行之后存储过程的语句\n\n# 触发器\n存储函数与存储过程都是需要我们`手动`调用的，如果想在执行某条语句之前或者之后自动去调用另外一些语句，就需要用到触发器。\n\n## 创建触发器\n触发器的定义：\n```sql\nCREATE TRIGGER 触发器名\n{BEFORE|AFTER}          \n{INSERT|DELETE|UPDATE}\nON 表名\nFOR EACH ROW \nBEGIN\n    触发器内容\nEND\n```\nMySQL中目前只支持对INSERT、DELETE、UPDATE这三种类型的语句设置触发器。\n\n因为触发器会对某个语句影响的所有记录依次调用我们自定义的触发器内容，所以我们需要一种访问该记录中的内容的方式，\nMySQL提供了NEW和OLD两个单词来分别代表新记录和旧记录，它们在不同操作中的含义不同：\n* 对于INSERT语句设置的触发器来说，NEW代表准备插入的记录，不能使用OLD。\n* 对于DELETE语句设置的触发器来说，OLD代表删除前的记录，不能使用NEW。\n* 对于UPDATE语句设置的触发器来说，NEW代表修改后的记录，OLD代表修改前的记录。\n\n举个🌰：\n```sql\nmysql> CREATE TRIGGER test_trigger\n    -> BEFORE INSERT ON first_table\n    -> FOR EACH ROW\n    -> BEGIN\n    -> IF NEW.first_column < 1 THEN\n    ->  SET NEW.first_column = 1;\n    -> ELSEIF NEW.first_column > 10 THEN\n    ->  SET NEW.first_column = 10;\n    -> END IF;\n    -> END $\nQuery OK, 0 rows affected (0.02 sec)\n\nmysql> select * from first_table;\n+--------------+---------------+\n| first_column | second_column |\n+--------------+---------------+\n|            1 | aaa           |\n|            2 | NULL          |\n|         NULL | ccc           |\n|            4 | test          |\n+--------------+---------------+\n4 rows in set (0.00 sec)\n\nmysql> INSERT INTO first_table(first_column,second_column) VALUES(5,'5'),(20,'20');\nQuery OK, 2 rows affected (0.01 sec)\nRecords: 2  Duplicates: 0  Warnings: 0\n\n\nmysql> select * from first_table;\n+--------------+---------------+\n| first_column | second_column |\n+--------------+---------------+\n|            1 | aaa           |\n|            2 | NULL          |\n|         NULL | ccc           |\n|            4 | test          |\n|            5 | 5             |\n|           10 | 20            |\n+--------------+---------------+\n6 rows in set (0.00 sec)\n```\n(20,'20')的插入结果变成了(10,'20')说明触发器生效了。\n\n## 查看触发器\n\n```sql\n查看当前数据库中的所有触发器的语句：\nSHOW TRIGGERS;\n\n查看某个具体的触发器的定义：\nSHOW CREATE TRIGGER 触发器名;\n```\n\n## 删除触发器：\n```sql\nDROP TRIGGER 触发器名;\n```\n\n## 触发器使用注意事项\n1. 触发器内容中不能有输出结果集的语句。\n2. 一个表最多只能定义6个触发器分别是：\n    * BEFORE INSERT触发器\n    * BEFORE DELETE触发器\n    * BEFORE UPDATE触发器\n    * AFTER INSERT触发器\n    * AFTER DELETE触发器\n    * AFTER UPDATE触发器\n3. NEW中的值可以被更改，OLD中的值无法更改。\n4. 如果我们的`BEFORE`触发器内容执行过程中遇到了`ERROR`，那这个触发器对应的具体语句将无法执行；如果具体的操作语句执行过程中遇到了`ERROR`，那与它对应的`AFTER`触发器的内容将无法执行。\n\n# 事件\n\n如果我们想指定某些语句在某个时间点或者每隔一个时间段执行一次的话,就需要创建一个事件。\n\n## 创建事件\n```sql\nCREATE EVENT 事件名\nON SCHEDULE\n{AT 某个确定的时间点 | EVERY 期望的时间间隔 [STARTS datetime][END datetime]}\nDO\nBEGIN\n    具体的语句\nEND\n```\n\n事件支持两种类型的定时执行：\n1. 某个确定的时间点执行\n    ```sql\n    mysql> CREATE EVENT insert_first_table\n        -> ON SCHEDULE\n        -> AT '2019-09-10 11:30:30'\n        -> DO\n        -> BEGIN\n        -> INSERT INTO first_table(first_column,second_column) VALUES(6,'6');\n        -> END $\n    ```\n    除了直接填某个时间常量，也可以填写一些表达式：\n    ```sql\n    mysql> CREATE EVENT insert_first_table\n        -> ON SCHEDULE\n        -> AT DATE_ADD(NOW(), INTERVAL 2 DAY)\n        -> DO\n        -> BEGIN\n        -> INSERT INTO first_table(first_column,second_column) VALUES(6,'6');\n        -> END $\n    ```\n    DATE_ADD(NOW(), INTERVAL 2 DAY)表示该事件将在当前时间的两天后执行。\n\n2. 每隔一段时间执行一次\n    ```sql\n    mysql> CREATE EVENT insert_first_table\n        -> ON SCHEDULE\n        -> EVERY 1 HOUR \n        -> DO\n        -> BEGIN\n        -> INSERT INTO first_table(first_column,second_column) VALUES(6,'6');\n        -> END $\n    ```\n    默认情况下，采用这种每隔一段时间执行一次的方式将从创建事件的事件开始，无限制的执行下去。我们也可以指定该事件开始执行时间和截止时间：\n    ```sql\n    mysql> CREATE EVENT insert_first_table\n        -> ON SCHEDULE\n        -> EVERY 1 HOUR STARTS '2019-09-10 11:30:30' ENDS '2019-09-12 11:30:30'\n        -> DO\n        -> BEGIN\n        -> INSERT INTO first_table(first_column,second_column) VALUES(6,'6');\n        -> END $\n    ```\n    在创建好事件之后我们就不用管了，到了指定时间，MySQL服务器会帮我们自动执行的。\n\n## 查看事件\n```sql\n查看当前数据库中的所有事件的语句：\nSHOW EVENTS;\n\n查看某个具体的事件的定义:\nSHOW CREATE EVENT 事件名;\n```\n\n## 删除事件\n```sql\nDROP EVENT 事件名;\n```\n\n## 事件使用注意事项\n默认情况下，MySQL服务器并不会帮助我们执行事件，除非我们在启动服务器的时候就指定了下边这个选项：\n```sql\nevent_scheduler = ON\n```\n如果在服务器已经启动的情况下，我们可以通过设置`event_scheduler`的系统变量来让MySQL服务器帮助我们执行事件，设置方式如下：\n```sql\nmysql> SET GLOBAL event_scheduler = ON;\nQuery OK, 0 rows affected (0.00 sec)\n```\n\n\n\n# 错误解决\n在MySql中创建自定义函数报错信息如下：\n```sql\nERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)\n```\n解决方法：\n```sql\nmysql> set global log_bin_trust_function_creators=1;\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Mysql-storage.md","raw":"title: Mysql-存储程序\ntags:\n  - MySql\ncategories:\n  - Mysql\nauthor: Guyuqing\ncopyright: true\ncomments: false\ndate: 2019-08-28 16:32:00\n---\nMySQL中的存储程序本质上封装了一些可执行的语句，然后给用户提供一种简单的调用方式来执行这些语句，根据调用方式的不同，我们可以把`存储程序`分为`存储例程`、`触发器`和`事件`这几种类型。其中，`存储例程`又可以被细分为`存储函数`和`存储过程`。\n<!-- more -->\n![存储程序](Mysql-storage/640.png)\n\n# 自定义变量\n\nMySQL中对我们自定义的变量的命名有个要求，那就是变量名称前必须加一个`@符号`。我们自定义变量的值的类型可以是任意MySQL支持的类型，例如我们自定义一个变量<font color='red'>a</font>：\n```sql\nmysql> SET @a = 1;\nQuery OK, 0 rows affected (0.00 sec)\n```\n\n如果我们想查看这个变量的值的话，使用<font color='Orange'>SELECT</font>语句就好了，不过仍然需要在变量名称加一个@符号：\n```sql\nmysql> SELECT @a;\n+------+\n| @a   |\n+------+\n|    1 |\n+------+\n1 row in set (0.00 sec)\n```\n\n同一个变量也可以存储存储不同类型的值，比方说我们再把一个字符串值赋值给变量<font color='red'>a</font>：\n```sql\nmysql> SET @a = '啦';\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @a;\n+------+\n| @a   |\n+------+\n| 啦   |\n+------+\n1 row in set (0.00 sec)\n```\n\n除了把一个常量赋值给一个变量以外，我们还可以把一个变量赋值给另一个变量：\n```sql\nmysql> SET @b = @a;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @b;\n+------+\n| @b   |\n+------+\n| 啦   |\n+------+\n1 row in set (0.00 sec)\n```\n\n我们还可以将某个查询的结果赋值给一个变量，前提是这个<font color='red'>查询的结果只有一个值</font>：\n```sql\nmysql> SET @a = (SELECT first_column FROM first_table LIMIT 1);\nQuery OK, 0 rows affected (0.00 sec)\n\n```\n\n还可以用另一种形式的语句来将查询的结果赋值给一个变量：\n```sql\nmysql> SELECT first_column FROM first_table LIMIT 1 INTO @b;\nQuery OK, 1 row affected (0.00 sec)\n\n```\n\n我们查看一下这两个变量的值：\n```sql\nmysql> SELECT @a, @b;\n+------+------+\n| @a   | @b   |\n+------+------+\n|    1 |    1 |\n+------+------+\n1 row in set (0.00 sec)\n```\n如果我们的查询结果是一条记录，该记录中有多个列的值的话，我们想把这几个值分别赋值到不同的变量中，只能使用`INTO`语句了：\n```sql\nmysql> SELECT first_column, second_column FROM first_table LIMIT 1 INTO @a, @b;\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> SELECT @a, @b;                                                           \n+------+------+\n| @a   | @b   |\n+------+------+\n|    1 | aaa  |\n+------+------+\n1 row in set (0.00 sec)\n```\n\n# 复合语句\n\n在MySQL客户端的交互界面处，当我们完成键盘输入并按下回车键时，MySQL客户端会检测我们输入的内容中是否包含`;`、`\\g`或者`\\G`这三个符号之一，如果有的话，会把我们输入的内容发送到服务器。这样一来，如果我们想给服务器发送复合语句（也就是由一条或多条语句组成的语句）的话，就需要把这些语句写到一行中，比如这样：\n```sql\nmysql> SELECT first_column FROM first_table ;SELECT second_column FROM first_table;\n+--------------+\n| first_column |\n+--------------+\n|            1 |\n|            2 |\n|         NULL |\n+--------------+\n3 rows in set (0.00 sec)\n\n+---------------+\n| second_column |\n+---------------+\n| aaa           |\n| NULL          |\n| ccc           |\n+---------------+\n3 rows in set (0.00 sec)\n\n```\n\n我们也可以用`delimiter`命令来自定义MySQL的检测输入结束的符号，如下：\n```sql\nmysql> delimiter $\nmysql> SELECT first_column FROM first_table ;\n    -> SELECT second_column FROM first_table;\n    -> $\n+--------------+\n| first_column |\n+--------------+\n|            1 |\n|            2 |\n|         NULL |\n+--------------+\n3 rows in set (0.00 sec)\n\n+---------------+\n| second_column |\n+---------------+\n| aaa           |\n| NULL          |\n| ccc           |\n+---------------+\n3 rows in set (0.00 sec)\n\n```\n\n`delimiter $`命令意味着修改MySQL客户端检测输入结束的符号为`$`,也可以使用任何符号来作为MySQL客户端检测输入结束的符号，也包括多个字符，如下：\n```sql\nmysql> delimiter 666\nmysql> SELECT first_column FROM first_table;\n    -> SELECT second_column FROM first_table;\n    -> 666\n+--------------+\n| first_column |\n+--------------+\n|            1 |\n|            2 |\n|         NULL |\n+--------------+\n3 rows in set (0.00 sec)\n\n+---------------+\n| second_column |\n+---------------+\n| aaa           |\n| NULL          |\n| ccc           |\n+---------------+\n3 rows in set (0.00 sec)\n```\n\n# 存储函数\n\n## 创建存储函数\n`存储函数`其实就是一种`函数`，只不过在这个函数里可以执行命令语句而已。\nMySQL中定义存储函数的语句如下：\n```sql\nCREATE FUNCTION 存储函数名称([参数列表])\nRETURNS 返回值类型\nBEGIN\n    函数体内容\nEND\n```\n\n举个🌰：\n```sql\nmysql> delimiter $\nmysql> CREATE FUNCTION second_column(a INT)\n    -> RETURNS VARCHAR(100)\n    -> BEGIN\n    -> RETURN (SELECT second_column FROM first_table WHERE first_column = a);\n    -> END $\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> delimiter ;\n```\n\n## 存储函数的调用\n我们自定义的函数和系统内置函数的使用方式是一样的，都是在函数名后加小括号`()`表示函数调用\n```sql\nmysql> SELECT second_column(1);\n+------------------+\n| second_column(1) |\n+------------------+\n| aaa              |\n+------------------+\n1 row in set (0.00 sec)\n```\n\n## 查看存储函数\n查看定义了多少个存储函数:\n```sql\nSHOW FUNCTION STATUS [LIKE 需要匹配的函数名]\n```\n\n查看某个函数的具体定义:\n```sql\nSHOW CREATE FUNCTION 函数名\n```\n\n## 删除存储函数\n删除某个存储函数\n```sql\nDROP FUNCTION 函数名\n```\n\n## 在函数体中定义变量\n\n在函数体中使用变量前必须先声明这个变量，函数体中的变量名`不允许加@`前缀,声明方式如下：\n```sql\nDECLARE 变量名 数据类型 [DEFAULT 默认值];   \n\nmysql> delimiter $\nmysql> CREATE FUNCTION var_demo(a INT)\n    -> RETURNS INT\n    -> BEGIN\n    -> DECLARE b INT;\n    -> SET b = 5;\n    -> RETURN b+a;\n    -> END $\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> delimiter ;\n```\n我们调用一下这个函数：\n```sql\nmysql> SELECT var_demo(2);\n+-------------+\n| var_demo(2) |\n+-------------+\n|           7 |\n+-------------+\n1 row in set (0.00 sec)\n```\n如果不对声明的变量赋值，它的默认值就是NULL，也可以通过`DEFAULT`子句来显式的指定变量的默认值.\n```sql\nmysql> delimiter $\nmysql> CREATE FUNCTION var_default_demo()\n-> RETURNS INT\n-> BEGIN\n->     DECLARE c INT DEFAULT 1;\n->     RETURN c;\n-> END $\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> delimiter ;\n\nmysql> SELECT var_default_demo();\n+--------------------+\n| var_default_demo() |\n+--------------------+\n|                  1 |\n+--------------------+\n1 row in set (0.00 sec)\n\n```\n\n## 参数定义\n\n比如我们上边编写的这个second_column函数：\n\n```sql\nmysql> CREATE FUNCTION second_column(a INT)\n    -> RETURNS VARCHAR(100)\n    -> BEGIN\n    -> RETURN (SELECT second_column FROM first_table WHERE first_column = a);\n    -> END $\n```\n需要注意的是，参数名不要和函数体语句中其他的变量名、命令语句的标识符冲突。并且函数参数不可以指定默认值，我们在调用函数的时候，必须显式的指定所有的参数，参数类型也一定要匹配\n\n\n\n## 判断语句\n\n语法格式如下：\n```sql\nIF 布尔表达式 THEN \n    处理语句\n[ELSEIF 布尔表达式 THEN\n    处理语句]\n[ELSE \n    处理语句]    \nEND IF;\n```\n\n举个🌰：\n```sql\nmysql> delimiter $\nmysql> CREATE FUNCTION condition_demo(i INT)\n    -> RETURNS VARCHAR(10)\n    -> BEGIN\n    -> DECLARE result VARCHAR(10);\n    -> IF i = 1 THEN\n    -> SET result = '结果是1';\n    -> ELSEIF i = 2 THEN\n    ->  SET result = '结果是2';\n    -> ELSEIF i = 3 THEN\n    -> SET result = '结果是3';\n    -> ELSE\n    -> SET result = '非法参数';\n    -> END IF;\n    -> RETURN result;\n    -> END $\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> delimiter;\n\n\nmysql> SELECT condition_demo(2);\n+-------------------+\n| condition_demo(2) |\n+-------------------+\n| 结果是2           |\n+-------------------+\n1 row in set (0.00 sec)\n\n```\n\n## 循环语句\n`while`循环语法格式如下：\n```sql\nWHILE 布尔表达式 DO\n    循环语句\nEND WHILE;\n```\n\n举个🌰：\n```sql\nmysql> delimiter $\nmysql> CREATE FUNCTION sum_all(n INT UNSIGNED)\n    -> RETURNS INT\n    -> BEGIN\n    -> DECLARE result INT DEFAULT 0;\n    -> DECLARE i INT DEFAULT 1;\n    -> WHILE i <= n DO\n    -> SET result = result + i;\n    -> SET i = i + 1;\n    -> END WHILE;\n    -> RETURN result;\n    -> END $\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> delimiter;\n\nmysql> select sum_all(10);\n+-------------+\n| sum_all(10) |\n+-------------+\n|          55 |\n+-------------+\n1 row in set (0.00 sec)\n```\n\n`REPEAT`循环语法格式如下：\n```sql\nREPEAT\n    循环语句\nUNTIL 布尔表达式 END REPEAT;\n```\n举个🌰：\n```sql\nmysql> CREATE FUNCTION sum_repeat(n INT UNSIGNED)\n    -> RETURNS INT\n    -> BEGIN\n    -> DECLARE result INT DEFAULT 0;\n    -> DECLARE i INT DEFAULT 1;\n    -> REPEAT\n    -> -- 循环开始\n    -> SET result = result + i;\n    -> SET i = i + 1;\n    -> UNTIL i > n END REPEAT;\n    -> RETURN result;\n    -> END $\nQuery OK, 0 rows affected (0.02 sec)\n\nmysql> select sum_repeat(5);\n+---------------+\n| sum_repeat(5) |\n+---------------+\n|            15 |\n+---------------+\n1 row in set (0.01 sec)\n```\n\n\n`LOOP`循环语法格式如下：\n```sql\n循环标记:LOOP\n    循环语句\n    LEAVE 循环标记;\nEND LOOP 循环标记;\n```\n举个🌰：\n```sql\nmysql> CREATE FUNCTION sum_loop(n INT UNSIGNED)\n    -> RETURNS INT\n    -> BEGIN\n    -> DECLARE result INT DEFAULT 0;\n    -> DECLARE i INT DEFAULT 1;\n    -> LOOP_NAME:LOOP -- 循环开始\n    -> IF i > n THEN\n    -> LEAVE LOOP_NAME;\n    -> END IF;\n    -> SET result = result + i;\n    -> SET i = i + 1;\n    -> END LOOP LOOP_NAME;\n    -> RETURN result;\n    -> END $\n    \nmysql> select sum_loop(10);\n+--------------+\n| sum_loop(10) |\n+--------------+\n|           55 |\n+--------------+\n1 row in set (0.00 sec)\n```\n\n# 存储过程\n\n存储函数侧重于执行语句并返回一个值，而存储过程更侧重于单纯的去执行语句。\n## 创建存储过程\n```sql\nCREATE PROCEDURE 存储过程名称([参数列表])\nBEGIN\n    需要执行的语句\nEND  \n```\n举个🌰：\n```sql\nmysql> CREATE PROCEDURE insert_first_table(c1 INT,c2 VARCHAR(100))\n    -> BEGIN\n    -> SELECT * FROM first_table;\n    -> INSERT INTO first_table(first_column,second_column) VALUES(c1,c2);\n    -> SELECT * FROM first_table;\n    -> END $\nQuery OK, 0 rows affected (0.02 sec)\n```\n\n## 存储过程的调用\n存储函数执行语句并返回一个值，所以常用在表达式中。\n存储过程偏向于调用那些语句，并不能用在表达式中。\n我们需要显式的使用CALL语句来调用一个存储过程：\n\n```sql\nCALL 存储过程([参数列表]);\n```\n举个🌰：\n```sql\nmysql> CALL insert_first_table(4,'test');\n \n+--------------+---------------+\n| first_column | second_column |\n+--------------+---------------+\n|            1 | aaa           |\n|            2 | NULL          |\n|         NULL | ccc           |\n+--------------+---------------+\n3 rows in set (0.00 sec)\n\n\n+--------------+---------------+\n| first_column | second_column |\n+--------------+---------------+\n|            1 | aaa           |\n|            2 | NULL          |\n|         NULL | ccc           |\n|            4 | test          |\n+--------------+---------------+\n4 rows in set (0.00 sec)\n```\n\n## 查看存储过程\n```sql\n查看当前数据库中创建的存储过程都有哪些的语句：\nSHOW PROCEDURE STATUS [LIKE 需要匹配的函数名]\n\n查看某个存储过程定义的语句：\nSHOW CREATE PROCEDURE 存储过程名称\n```\n\n## 删除存储过程\n删除某个存储过程\n```sql\nDROP PROCEDURE 存储过程名称\n```\n\n## 存储过程参数类型\n<table>\n<tr>\n    <th>参数类型</th>\n    <th>实际参数是否必须是变量</th>\n    <th colspan=\"3\">作用</th>\n</tr>\n<tr>\n    <td style=\"text-align:center\">IN</td>\n    <td style=\"text-align:center\">否</td>\n    <td colspan=\"3\">用于调用者向过程传递数据，如果该参数在过程中被修改，调用者不可见</td>\n</tr>\n<tr>\n    <td style=\"text-align:center\">OUT</td>\n    <td style=\"text-align:center\">是</td>\n    <td colspan=\"3\">用于把过程产生的结果放到此参数中，过程结束后调用者可以通过该参数来获取过程执行的结果</td>\n</tr>\n<tr>\n    <td style=\"text-align:center\">INOUT</td>\n    <td style=\"text-align:center\">是</td>\n    <td colspan=\"3\">综合IN和OUT特点，即可用于调用者向过程传递数据，也可用于存放过程中产生的结果</td>\n</tr>\n</table>  \n\n### IN\n```sql\nmysql> CREATE PROCEDURE test_in(IN num INT)\n    -> BEGIN\n    -> SELECT num;\n    -> SET num = 666;\n    -> END $\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> SET @a = 111;\n\nQuery OK, 0 rows affected (0.01 sec)\n\n\nmysql> CALL test_in(@a);\n+------+\n| num  |\n+------+\n|  111 |\n+------+\n1 row in set (0.00 sec)\n\nQuery OK, 0 rows affected (0.00 sec)\n```\nIN参数类型的变量只能用于读取，对类型的变量赋值是不会被调用者看到的。\n如果我们不写明参数类型的话，该参数的类型默认是IN。\n\n### OUT\n```sql\nmysql> CREATE PROCEDURE test_out(OUT num INT)\n    -> BEGIN\n    -> SELECT num;\n    -> SET num = 666;\n    -> END $\nQuery OK, 0 rows affected (0.01 sec)\n\n\nmysql> CALL test_out(@a);\n+------+\n| num  |\n+------+\n| NULL |\n+------+\n1 row in set (0.00 sec)\n\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT @a;\n+------+\n| @a   |\n+------+\n|  666 |\n+------+\n1 row in set (0.00 sec)\n\n```\n\nOUT参数类型的变量只能用于赋值，对类型的变量赋值是会被调用者看到的,因此参数就不允许是常量。\n\n存储过程中向调用者返回多个值，举个例子：\n```sql\nmysql> CREATE PROCEDURE data_out(OUT a INT,OUT b INT)\n    -> BEGIN\n    -> SET a = 100;\n    -> SET b = 200;\n    -> END $\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> CALL data_out(@a,@b);\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> select @a,@b;\n+------+------+\n| @a   | @b   |\n+------+------+\n|  100 |  200 |\n+------+------+\n1 row in set (0.00 sec)\n\n```\n\n### INOUT\n\n这种类型的参数既可以在存储过程中被读取，也可以被赋值后被调用者看到，因此参数就不允许是常量。\n\n## 存储过程和函数的区别\n\n* 存储函数在定义时需要显式用RETURNS语句标明返回的数据类型，而且在函数体中必须使用RETURN语句来显式指定返回的值，存储过程不需要。\n\n* 存储函数的参数类型只能是IN，而存储过程支持IN、OUT、INOUT三种参数类型。\n\n* 存储函数只能返回一个值，而存储过程可以通过设置多个OUT类型的参数来返回多个结果。\n\n* 存储函数执行过程中产生的结果集并不会被显示到客户端，而存储过程执行过程中产生的结果集会被显示到客户端。\n\n* 存储函数的调用直接使用在表达式中，而存储过程只能通过CALL语句来显式调用。\n\n# 游标\n游标（Cursor）是处理数据的一种方法，为了查看或者处理结果集中的数据，游标提供了在结果集中一次一行或者多行前进或向后浏览数据的能力。\n初始状态下它标记查询结果集中的第一条记录,根据这个游标取出它对应记录的信息，随后再移动游标，让它指向别的记录。\n\n## 创建游标\n```sql\nDECLARE 游标名称 CURSOR FOR 查询语句;\n```\n举个🌰：\n```sql\nmysql> CREATE PROCEDURE cursor_demo()\n    -> BEGIN\n    -> DECLARE first_table_cursor CURSOR FOR select * from first_table;\n    -> END $\nQuery OK, 0 rows affected (0.01 sec)\n```\n## 打开和关闭游标\n```sql\nOPEN 游标名称;\n\nCLOSE 游标名称;\n```\n打开游标意味着执行查询语句，让创建好的游标与该查询语句得到的结果集关联起来，关闭游标意味着会释放该游标占用的内存，所以一旦我们使用完了游标，就要把它关闭掉。\n\n## 游标获取记录\n\n```sql\nFETCH 游标名 INTO 变量1, 变量2, ... 变量n\n```\n举个例子：\n```sql\nmysql> CREATE PROCEDURE cursor_demo()\n    -> BEGIN\n    -> DECLARE c1 INT;\n    -> DECLARE c2 VARCHAR(100);\n    -> DECLARE record_count INT;\n    -> DECLARE i INT DEFAULT 0;\n    ->  -- 声明游标\n    -> DECLARE first_table_cursor CURSOR FOR select * from first_table;\n    ->\n    -> -- 统计表行数\n    -> SELECT COUNT(*) FROM first_table INTO record_count;\n    ->\n    -> -- 使用游标遍历\n    -> OPEN first_table_cursor;\n    ->\n    -> WHILE i < record_count DO\n    -> FETCH first_table_cursor INTO c1 , c2;\n    -> SELECT c1,c2;\n    -> SET i = i + 1;\n    -> END WHILE;\n    -> CLOSE first_table_cursor;\n    -> END $\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> CALL cursor_demo();\n+------+------+\n| c1   | c2   |\n+------+------+\n|    1 | aaa  |\n+------+------+\n1 row in set (0.01 sec)\n\n+------+------+\n| c1   | c2   |\n+------+------+\n|    2 | NULL |\n+------+------+\n1 row in set (0.01 sec)\n\n+------+------+\n| c1   | c2   |\n+------+------+\n| NULL | ccc  |\n+------+------+\n1 row in set (0.01 sec)\n\n+------+------+\n| c1   | c2   |\n+------+------+\n|    4 | test |\n+------+------+\n1 row in set (0.01 sec)\n\nQuery OK, 0 rows affected (0.01 sec)\n\n```\ni表示当前游标对应的记录位置。每调用一次 FETCH 语句，游标就移动到下一条记录的位置。\n\n## 遍历结束的执行策略\n\n其实在FETCH语句获取不到记录的时候会触发一个事件，从而我们可以得知所有的记录都被获取过了，然后我们就可以去主动的停止循环。\nMySQL中响应这个事件的语句如下：\n```sql\nDECLARE CONTINUE HANDLER FOR NOT FOUND 语句;  \n```\n举个🌰，再来改写一下cursor_demo存储过程：\n```sql\nmysql> delimiter $\nmysql> CREATE PROCEDURE cursor_demo()\n    -> BEGIN\n    -> -- 声明变量\n    -> DECLARE c1 INT;\n    -> DECLARE c2 VARCHAR(100);\n    -> DECLARE not_done INT DEFAULT 1;\n    ->\n    -> -- 声明游标\n    -> DECLARE first_table_cursor CURSOR FOR select * from first_table;\n    ->\n    -> -- 在游标遍历完记录的时候将变量 not_done 的值设置为 0，并且继续执行后边的语句\n    -> DECLARE CONTINUE HANDLER FOR NOT FOUND SET not_done = 0;\n    ->\n    -> -- 使用游标遍历\n    -> OPEN first_table_cursor;\n    ->\n    -> WHILE not_done = 1 DO\n    ->\n    -> FETCH first_table_cursor INTO c1 , c2;\n    -> SELECT c1,c2;\n    -> END WHILE;\n    -> CLOSE first_table_cursor;\n    -> END $\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql>  CALL cursor_demo();\n+------+------+\n| c1   | c2   |\n+------+------+\n|    1 | aaa  |\n+------+------+\n1 row in set (0.01 sec)\n\n+------+------+\n| c1   | c2   |\n+------+------+\n|    2 | NULL |\n+------+------+\n1 row in set (0.01 sec)\n\n+------+------+\n| c1   | c2   |\n+------+------+\n| NULL | ccc  |\n+------+------+\n1 row in set (0.01 sec)\n\n+------+------+\n| c1   | c2   |\n+------+------+\n|    4 | test |\n+------+------+\n1 row in set (0.01 sec)\n\n+------+------+\n| c1   | c2   |\n+------+------+\n|    4 | test |\n+------+------+\n1 row in set (0.01 sec)\n\nQuery OK, 0 rows affected (0.01 sec)\n\n```\n我们发现结果集中最后一条记录输出两遍怎么办呢，我们可以使用`EXIT`来替代上边的`CONTINUE`：\n`CONTINUE`表示在FETCH语句获取不到记录的时候仍然会执行之后存储过程的语句，也就是会将最后一次关联的记录中的值放入指定的变量\n`EXIT`表示在FETCH语句获取不到记录的时候仍然不会执行之后存储过程的语句\n\n# 触发器\n存储函数与存储过程都是需要我们`手动`调用的，如果想在执行某条语句之前或者之后自动去调用另外一些语句，就需要用到触发器。\n\n## 创建触发器\n触发器的定义：\n```sql\nCREATE TRIGGER 触发器名\n{BEFORE|AFTER}          \n{INSERT|DELETE|UPDATE}\nON 表名\nFOR EACH ROW \nBEGIN\n    触发器内容\nEND\n```\nMySQL中目前只支持对INSERT、DELETE、UPDATE这三种类型的语句设置触发器。\n\n因为触发器会对某个语句影响的所有记录依次调用我们自定义的触发器内容，所以我们需要一种访问该记录中的内容的方式，\nMySQL提供了NEW和OLD两个单词来分别代表新记录和旧记录，它们在不同操作中的含义不同：\n* 对于INSERT语句设置的触发器来说，NEW代表准备插入的记录，不能使用OLD。\n* 对于DELETE语句设置的触发器来说，OLD代表删除前的记录，不能使用NEW。\n* 对于UPDATE语句设置的触发器来说，NEW代表修改后的记录，OLD代表修改前的记录。\n\n举个🌰：\n```sql\nmysql> CREATE TRIGGER test_trigger\n    -> BEFORE INSERT ON first_table\n    -> FOR EACH ROW\n    -> BEGIN\n    -> IF NEW.first_column < 1 THEN\n    ->  SET NEW.first_column = 1;\n    -> ELSEIF NEW.first_column > 10 THEN\n    ->  SET NEW.first_column = 10;\n    -> END IF;\n    -> END $\nQuery OK, 0 rows affected (0.02 sec)\n\nmysql> select * from first_table;\n+--------------+---------------+\n| first_column | second_column |\n+--------------+---------------+\n|            1 | aaa           |\n|            2 | NULL          |\n|         NULL | ccc           |\n|            4 | test          |\n+--------------+---------------+\n4 rows in set (0.00 sec)\n\nmysql> INSERT INTO first_table(first_column,second_column) VALUES(5,'5'),(20,'20');\nQuery OK, 2 rows affected (0.01 sec)\nRecords: 2  Duplicates: 0  Warnings: 0\n\n\nmysql> select * from first_table;\n+--------------+---------------+\n| first_column | second_column |\n+--------------+---------------+\n|            1 | aaa           |\n|            2 | NULL          |\n|         NULL | ccc           |\n|            4 | test          |\n|            5 | 5             |\n|           10 | 20            |\n+--------------+---------------+\n6 rows in set (0.00 sec)\n```\n(20,'20')的插入结果变成了(10,'20')说明触发器生效了。\n\n## 查看触发器\n\n```sql\n查看当前数据库中的所有触发器的语句：\nSHOW TRIGGERS;\n\n查看某个具体的触发器的定义：\nSHOW CREATE TRIGGER 触发器名;\n```\n\n## 删除触发器：\n```sql\nDROP TRIGGER 触发器名;\n```\n\n## 触发器使用注意事项\n1. 触发器内容中不能有输出结果集的语句。\n2. 一个表最多只能定义6个触发器分别是：\n    * BEFORE INSERT触发器\n    * BEFORE DELETE触发器\n    * BEFORE UPDATE触发器\n    * AFTER INSERT触发器\n    * AFTER DELETE触发器\n    * AFTER UPDATE触发器\n3. NEW中的值可以被更改，OLD中的值无法更改。\n4. 如果我们的`BEFORE`触发器内容执行过程中遇到了`ERROR`，那这个触发器对应的具体语句将无法执行；如果具体的操作语句执行过程中遇到了`ERROR`，那与它对应的`AFTER`触发器的内容将无法执行。\n\n# 事件\n\n如果我们想指定某些语句在某个时间点或者每隔一个时间段执行一次的话,就需要创建一个事件。\n\n## 创建事件\n```sql\nCREATE EVENT 事件名\nON SCHEDULE\n{AT 某个确定的时间点 | EVERY 期望的时间间隔 [STARTS datetime][END datetime]}\nDO\nBEGIN\n    具体的语句\nEND\n```\n\n事件支持两种类型的定时执行：\n1. 某个确定的时间点执行\n    ```sql\n    mysql> CREATE EVENT insert_first_table\n        -> ON SCHEDULE\n        -> AT '2019-09-10 11:30:30'\n        -> DO\n        -> BEGIN\n        -> INSERT INTO first_table(first_column,second_column) VALUES(6,'6');\n        -> END $\n    ```\n    除了直接填某个时间常量，也可以填写一些表达式：\n    ```sql\n    mysql> CREATE EVENT insert_first_table\n        -> ON SCHEDULE\n        -> AT DATE_ADD(NOW(), INTERVAL 2 DAY)\n        -> DO\n        -> BEGIN\n        -> INSERT INTO first_table(first_column,second_column) VALUES(6,'6');\n        -> END $\n    ```\n    DATE_ADD(NOW(), INTERVAL 2 DAY)表示该事件将在当前时间的两天后执行。\n\n2. 每隔一段时间执行一次\n    ```sql\n    mysql> CREATE EVENT insert_first_table\n        -> ON SCHEDULE\n        -> EVERY 1 HOUR \n        -> DO\n        -> BEGIN\n        -> INSERT INTO first_table(first_column,second_column) VALUES(6,'6');\n        -> END $\n    ```\n    默认情况下，采用这种每隔一段时间执行一次的方式将从创建事件的事件开始，无限制的执行下去。我们也可以指定该事件开始执行时间和截止时间：\n    ```sql\n    mysql> CREATE EVENT insert_first_table\n        -> ON SCHEDULE\n        -> EVERY 1 HOUR STARTS '2019-09-10 11:30:30' ENDS '2019-09-12 11:30:30'\n        -> DO\n        -> BEGIN\n        -> INSERT INTO first_table(first_column,second_column) VALUES(6,'6');\n        -> END $\n    ```\n    在创建好事件之后我们就不用管了，到了指定时间，MySQL服务器会帮我们自动执行的。\n\n## 查看事件\n```sql\n查看当前数据库中的所有事件的语句：\nSHOW EVENTS;\n\n查看某个具体的事件的定义:\nSHOW CREATE EVENT 事件名;\n```\n\n## 删除事件\n```sql\nDROP EVENT 事件名;\n```\n\n## 事件使用注意事项\n默认情况下，MySQL服务器并不会帮助我们执行事件，除非我们在启动服务器的时候就指定了下边这个选项：\n```sql\nevent_scheduler = ON\n```\n如果在服务器已经启动的情况下，我们可以通过设置`event_scheduler`的系统变量来让MySQL服务器帮助我们执行事件，设置方式如下：\n```sql\nmysql> SET GLOBAL event_scheduler = ON;\nQuery OK, 0 rows affected (0.00 sec)\n```\n\n\n\n# 错误解决\n在MySql中创建自定义函数报错信息如下：\n```sql\nERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)\n```\n解决方法：\n```sql\nmysql> set global log_bin_trust_function_creators=1;\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Mysql-storage","published":1,"updated":"2019-09-25T14:29:48.413Z","layout":"post","photos":[],"link":"","_id":"ck8fb4adw002rk2o5i698re3l","content":"<p>MySQL中的存储程序本质上封装了一些可执行的语句，然后给用户提供一种简单的调用方式来执行这些语句，根据调用方式的不同，我们可以把<code>存储程序</code>分为<code>存储例程</code>、<code>触发器</code>和<code>事件</code>这几种类型。其中，<code>存储例程</code>又可以被细分为<code>存储函数</code>和<code>存储过程</code>。</p>\n<a id=\"more\"></a>\n<p><img src=\"/Mysql/Mysql-storage/640.png\" alt=\"存储程序\"></p>\n<h1 id=\"自定义变量\"><a href=\"#自定义变量\" class=\"headerlink\" title=\"自定义变量\"></a>自定义变量</h1><p>MySQL中对我们自定义的变量的命名有个要求，那就是变量名称前必须加一个<code>@符号</code>。我们自定义变量的值的类型可以是任意MySQL支持的类型，例如我们自定义一个变量<font color=\"red\">a</font>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SET @a = 1;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>如果我们想查看这个变量的值的话，使用<font color=\"Orange\">SELECT</font>语句就好了，不过仍然需要在变量名称加一个@符号：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SELECT @a;</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| @a   |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">|    1 |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>同一个变量也可以存储存储不同类型的值，比方说我们再把一个字符串值赋值给变量<font color=\"red\">a</font>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SET @a = '啦';</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; SELECT @a;</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| @a   |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| 啦   |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>除了把一个常量赋值给一个变量以外，我们还可以把一个变量赋值给另一个变量：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SET @b = @a;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; SELECT @b;</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| @b   |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| 啦   |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>我们还可以将某个查询的结果赋值给一个变量，前提是这个<font color=\"red\">查询的结果只有一个值</font>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SET @a = (SELECT first_column FROM first_table LIMIT 1);</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>还可以用另一种形式的语句来将查询的结果赋值给一个变量：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SELECT first_column FROM first_table LIMIT 1 INTO @b;</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>我们查看一下这两个变量的值：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SELECT @a, @b;</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| @a   | @b   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">|    1 |    1 |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>如果我们的查询结果是一条记录，该记录中有多个列的值的话，我们想把这几个值分别赋值到不同的变量中，只能使用<code>INTO</code>语句了：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SELECT first_column, second_column FROM first_table LIMIT 1 INTO @a, @b;</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; SELECT @a, @b;                                                           </span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| @a   | @b   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">|    1 | aaa  |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"复合语句\"><a href=\"#复合语句\" class=\"headerlink\" title=\"复合语句\"></a>复合语句</h1><p>在MySQL客户端的交互界面处，当我们完成键盘输入并按下回车键时，MySQL客户端会检测我们输入的内容中是否包含<code>;</code>、<code>\\g</code>或者<code>\\G</code>这三个符号之一，如果有的话，会把我们输入的内容发送到服务器。这样一来，如果我们想给服务器发送复合语句（也就是由一条或多条语句组成的语句）的话，就需要把这些语句写到一行中，比如这样：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SELECT first_column FROM first_table ;SELECT second_column FROM first_table;</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">| first_column |</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">|            1 |</span><br><span class=\"line\">|            2 |</span><br><span class=\"line\">|         NULL |</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">3 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\">| second_column |</span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\">| aaa           |</span><br><span class=\"line\">| <span class=\"literal\">NULL</span>          |</span><br><span class=\"line\">| ccc           |</span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>我们也可以用<code>delimiter</code>命令来自定义MySQL的检测输入结束的符号，如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; delimiter $</span><br><span class=\"line\">mysql&gt; SELECT first_column FROM first_table ;</span><br><span class=\"line\">    -&gt; SELECT second_column FROM first_table;</span><br><span class=\"line\">    -&gt; $</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">| first_column |</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">|            1 |</span><br><span class=\"line\">|            2 |</span><br><span class=\"line\">|         NULL |</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">3 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\">| second_column |</span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\">| aaa           |</span><br><span class=\"line\">| <span class=\"literal\">NULL</span>          |</span><br><span class=\"line\">| ccc           |</span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p><code>delimiter $</code>命令意味着修改MySQL客户端检测输入结束的符号为<code>$</code>,也可以使用任何符号来作为MySQL客户端检测输入结束的符号，也包括多个字符，如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; delimiter 666</span><br><span class=\"line\">mysql&gt; SELECT first_column FROM first_table;</span><br><span class=\"line\">    -&gt; SELECT second_column FROM first_table;</span><br><span class=\"line\">    -&gt; 666</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">| first_column |</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">|            1 |</span><br><span class=\"line\">|            2 |</span><br><span class=\"line\">|         NULL |</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">3 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\">| second_column |</span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\">| aaa           |</span><br><span class=\"line\">| <span class=\"literal\">NULL</span>          |</span><br><span class=\"line\">| ccc           |</span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"存储函数\"><a href=\"#存储函数\" class=\"headerlink\" title=\"存储函数\"></a>存储函数</h1><h2 id=\"创建存储函数\"><a href=\"#创建存储函数\" class=\"headerlink\" title=\"创建存储函数\"></a>创建存储函数</h2><p><code>存储函数</code>其实就是一种<code>函数</code>，只不过在这个函数里可以执行命令语句而已。<br>MySQL中定义存储函数的语句如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">FUNCTION</span> 存储函数名称([参数列表])</span><br><span class=\"line\"><span class=\"keyword\">RETURNS</span> 返回值类型</span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">    函数体内容</span><br><span class=\"line\"><span class=\"keyword\">END</span></span><br></pre></td></tr></table></figure>\n\n<p>举个🌰：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; delimiter $</span><br><span class=\"line\">mysql&gt; CREATE FUNCTION second_column(a INT)</span><br><span class=\"line\">    -&gt; RETURNS VARCHAR(100)</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; RETURN (SELECT second_column FROM first_table WHERE first_column = a);</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; delimiter ;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"存储函数的调用\"><a href=\"#存储函数的调用\" class=\"headerlink\" title=\"存储函数的调用\"></a>存储函数的调用</h2><p>我们自定义的函数和系统内置函数的使用方式是一样的，都是在函数名后加小括号<code>()</code>表示函数调用</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SELECT second_column(1);</span><br><span class=\"line\">+<span class=\"comment\">------------------+</span></span><br><span class=\"line\">| second_column(1) |</span><br><span class=\"line\">+<span class=\"comment\">------------------+</span></span><br><span class=\"line\">| aaa              |</span><br><span class=\"line\">+<span class=\"comment\">------------------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查看存储函数\"><a href=\"#查看存储函数\" class=\"headerlink\" title=\"查看存储函数\"></a>查看存储函数</h2><p>查看定义了多少个存储函数:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">FUNCTION</span> <span class=\"keyword\">STATUS</span> [<span class=\"keyword\">LIKE</span> 需要匹配的函数名]</span><br></pre></td></tr></table></figure>\n\n<p>查看某个函数的具体定义:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">CREATE</span> <span class=\"keyword\">FUNCTION</span> 函数名</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除存储函数\"><a href=\"#删除存储函数\" class=\"headerlink\" title=\"删除存储函数\"></a>删除存储函数</h2><p>删除某个存储函数</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">FUNCTION</span> 函数名</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在函数体中定义变量\"><a href=\"#在函数体中定义变量\" class=\"headerlink\" title=\"在函数体中定义变量\"></a>在函数体中定义变量</h2><p>在函数体中使用变量前必须先声明这个变量，函数体中的变量名<code>不允许加@</code>前缀,声明方式如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DECLARE</span> 变量名 数据类型 [<span class=\"keyword\">DEFAULT</span> 默认值];   </span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; delimiter $</span><br><span class=\"line\">mysql&gt; CREATE FUNCTION var_demo(a INT)</span><br><span class=\"line\">    -&gt; RETURNS INT</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; DECLARE b INT;</span><br><span class=\"line\">    -&gt; SET b = 5;</span><br><span class=\"line\">    -&gt; RETURN b+a;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; delimiter ;</span><br></pre></td></tr></table></figure>\n\n<p>我们调用一下这个函数：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SELECT var_demo(2);</span><br><span class=\"line\">+<span class=\"comment\">-------------+</span></span><br><span class=\"line\">| var_demo(2) |</span><br><span class=\"line\">+<span class=\"comment\">-------------+</span></span><br><span class=\"line\">|           7 |</span><br><span class=\"line\">+<span class=\"comment\">-------------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>如果不对声明的变量赋值，它的默认值就是NULL，也可以通过<code>DEFAULT</code>子句来显式的指定变量的默认值.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; delimiter $</span><br><span class=\"line\">mysql&gt; CREATE FUNCTION var_default_demo()</span><br><span class=\"line\">-&gt; RETURNS INT</span><br><span class=\"line\">-&gt; BEGIN</span><br><span class=\"line\">-&gt;     DECLARE c INT DEFAULT 1;</span><br><span class=\"line\">-&gt;     RETURN c;</span><br><span class=\"line\">-&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; delimiter ;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; SELECT var_default_demo();</span><br><span class=\"line\">+<span class=\"comment\">--------------------+</span></span><br><span class=\"line\">| var_default_demo() |</span><br><span class=\"line\">+<span class=\"comment\">--------------------+</span></span><br><span class=\"line\">|                  1 |</span><br><span class=\"line\">+<span class=\"comment\">--------------------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参数定义\"><a href=\"#参数定义\" class=\"headerlink\" title=\"参数定义\"></a>参数定义</h2><p>比如我们上边编写的这个second_column函数：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE FUNCTION second_column(a INT)</span><br><span class=\"line\">    -&gt; RETURNS VARCHAR(100)</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; RETURN (SELECT second_column FROM first_table WHERE first_column = a);</span><br><span class=\"line\">    -&gt; END $</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，参数名不要和函数体语句中其他的变量名、命令语句的标识符冲突。并且函数参数不可以指定默认值，我们在调用函数的时候，必须显式的指定所有的参数，参数类型也一定要匹配</p>\n<h2 id=\"判断语句\"><a href=\"#判断语句\" class=\"headerlink\" title=\"判断语句\"></a>判断语句</h2><p>语法格式如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IF 布尔表达式 THEN </span><br><span class=\"line\">    处理语句</span><br><span class=\"line\">[ELSEIF 布尔表达式 THEN</span><br><span class=\"line\">    处理语句]</span><br><span class=\"line\">[ELSE </span><br><span class=\"line\">    处理语句]    </span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">IF</span>;</span><br></pre></td></tr></table></figure>\n\n<p>举个🌰：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; delimiter $</span><br><span class=\"line\">mysql&gt; CREATE FUNCTION condition_demo(i INT)</span><br><span class=\"line\">    -&gt; RETURNS VARCHAR(10)</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; DECLARE result VARCHAR(10);</span><br><span class=\"line\">    -&gt; IF i = 1 THEN</span><br><span class=\"line\">    -&gt; SET result = '结果是1';</span><br><span class=\"line\">    -&gt; ELSEIF i = 2 THEN</span><br><span class=\"line\">    -&gt;  SET result = '结果是2';</span><br><span class=\"line\">    -&gt; ELSEIF i = 3 THEN</span><br><span class=\"line\">    -&gt; SET result = '结果是3';</span><br><span class=\"line\">    -&gt; ELSE</span><br><span class=\"line\">    -&gt; SET result = '非法参数';</span><br><span class=\"line\">    -&gt; END IF;</span><br><span class=\"line\">    -&gt; RETURN result;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; delimiter;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; SELECT condition_demo(2);</span><br><span class=\"line\">+<span class=\"comment\">-------------------+</span></span><br><span class=\"line\">| condition_demo(2) |</span><br><span class=\"line\">+<span class=\"comment\">-------------------+</span></span><br><span class=\"line\">| 结果是2           |</span><br><span class=\"line\">+<span class=\"comment\">-------------------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h2><p><code>while</code>循环语法格式如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WHILE 布尔表达式 <span class=\"keyword\">DO</span></span><br><span class=\"line\">    循环语句</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">WHILE</span>;</span><br></pre></td></tr></table></figure>\n\n<p>举个🌰：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; delimiter $</span><br><span class=\"line\">mysql&gt; CREATE FUNCTION sum_all(n INT UNSIGNED)</span><br><span class=\"line\">    -&gt; RETURNS INT</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; DECLARE result INT DEFAULT 0;</span><br><span class=\"line\">    -&gt; DECLARE i INT DEFAULT 1;</span><br><span class=\"line\">    -&gt; WHILE i &lt;= n DO</span><br><span class=\"line\">    -&gt; SET result = result + i;</span><br><span class=\"line\">    -&gt; SET i = i + 1;</span><br><span class=\"line\">    -&gt; END WHILE;</span><br><span class=\"line\">    -&gt; RETURN result;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; delimiter;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select sum_all(10);</span><br><span class=\"line\">+<span class=\"comment\">-------------+</span></span><br><span class=\"line\">| sum_all(10) |</span><br><span class=\"line\">+<span class=\"comment\">-------------+</span></span><br><span class=\"line\">|          55 |</span><br><span class=\"line\">+<span class=\"comment\">-------------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p><code>REPEAT</code>循环语法格式如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REPEAT</span><br><span class=\"line\">    循环语句</span><br><span class=\"line\">UNTIL 布尔表达式 <span class=\"keyword\">END</span> <span class=\"keyword\">REPEAT</span>;</span><br></pre></td></tr></table></figure>\n\n<p>举个🌰：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE FUNCTION sum_repeat(n INT UNSIGNED)</span><br><span class=\"line\">    -&gt; RETURNS INT</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; DECLARE result INT DEFAULT 0;</span><br><span class=\"line\">    -&gt; DECLARE i INT DEFAULT 1;</span><br><span class=\"line\">    -&gt; REPEAT</span><br><span class=\"line\">    -&gt; -- 循环开始</span><br><span class=\"line\">    -&gt; SET result = result + i;</span><br><span class=\"line\">    -&gt; SET i = i + 1;</span><br><span class=\"line\">    -&gt; UNTIL i &gt; n END REPEAT;</span><br><span class=\"line\">    -&gt; RETURN result;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.02 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select sum_repeat(5);</span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\">| sum_repeat(5) |</span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\">|            15 |</span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p><code>LOOP</code>循环语法格式如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">循环标记:LOOP</span><br><span class=\"line\">    循环语句</span><br><span class=\"line\">    LEAVE 循环标记;</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">LOOP</span> 循环标记;</span><br></pre></td></tr></table></figure>\n\n<p>举个🌰：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE FUNCTION sum_loop(n INT UNSIGNED)</span><br><span class=\"line\">    -&gt; RETURNS INT</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; DECLARE result INT DEFAULT 0;</span><br><span class=\"line\">    -&gt; DECLARE i INT DEFAULT 1;</span><br><span class=\"line\">    -&gt; LOOP_NAME:LOOP -- 循环开始</span><br><span class=\"line\">    -&gt; IF i &gt; n THEN</span><br><span class=\"line\">    -&gt; LEAVE LOOP_NAME;</span><br><span class=\"line\">    -&gt; END IF;</span><br><span class=\"line\">    -&gt; SET result = result + i;</span><br><span class=\"line\">    -&gt; SET i = i + 1;</span><br><span class=\"line\">    -&gt; END LOOP LOOP_NAME;</span><br><span class=\"line\">    -&gt; RETURN result;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">    </span><br><span class=\"line\">mysql&gt; select sum_loop(10);</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">| sum_loop(10) |</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">|           55 |</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"存储过程\"><a href=\"#存储过程\" class=\"headerlink\" title=\"存储过程\"></a>存储过程</h1><p>存储函数侧重于执行语句并返回一个值，而存储过程更侧重于单纯的去执行语句。</p>\n<h2 id=\"创建存储过程\"><a href=\"#创建存储过程\" class=\"headerlink\" title=\"创建存储过程\"></a>创建存储过程</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> 存储过程名称([参数列表])</span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">    需要执行的语句</span><br><span class=\"line\"><span class=\"keyword\">END</span></span><br></pre></td></tr></table></figure>\n\n<p>举个🌰：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE PROCEDURE insert_first_table(c1 INT,c2 VARCHAR(100))</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; SELECT * FROM first_table;</span><br><span class=\"line\">    -&gt; INSERT INTO first_table(first_column,second_column) VALUES(c1,c2);</span><br><span class=\"line\">    -&gt; SELECT * FROM first_table;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"存储过程的调用\"><a href=\"#存储过程的调用\" class=\"headerlink\" title=\"存储过程的调用\"></a>存储过程的调用</h2><p>存储函数执行语句并返回一个值，所以常用在表达式中。<br>存储过程偏向于调用那些语句，并不能用在表达式中。<br>我们需要显式的使用CALL语句来调用一个存储过程：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CALL</span> 存储过程([参数列表]);</span><br></pre></td></tr></table></figure>\n\n<p>举个🌰：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CALL insert_first_table(4,'test');</span><br><span class=\"line\"> </span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">| first_column | second_column |</span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">|            1 | aaa           |</span><br><span class=\"line\">|            2 | NULL          |</span><br><span class=\"line\">|         NULL | ccc           |</span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">3 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">| first_column | second_column |</span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">|            <span class=\"number\">1</span> | aaa           |</span><br><span class=\"line\">|            <span class=\"number\">2</span> | <span class=\"literal\">NULL</span>          |</span><br><span class=\"line\">|         <span class=\"literal\">NULL</span> | ccc           |</span><br><span class=\"line\">|            <span class=\"number\">4</span> | <span class=\"keyword\">test</span>          |</span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查看存储过程\"><a href=\"#查看存储过程\" class=\"headerlink\" title=\"查看存储过程\"></a>查看存储过程</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看当前数据库中创建的存储过程都有哪些的语句：</span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">PROCEDURE</span> <span class=\"keyword\">STATUS</span> [<span class=\"keyword\">LIKE</span> 需要匹配的函数名]</span><br><span class=\"line\"></span><br><span class=\"line\">查看某个存储过程定义的语句：</span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> 存储过程名称</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除存储过程\"><a href=\"#删除存储过程\" class=\"headerlink\" title=\"删除存储过程\"></a>删除存储过程</h2><p>删除某个存储过程</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">PROCEDURE</span> 存储过程名称</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"存储过程参数类型\"><a href=\"#存储过程参数类型\" class=\"headerlink\" title=\"存储过程参数类型\"></a>存储过程参数类型</h2><table>\n<tr>\n    <th>参数类型</th>\n    <th>实际参数是否必须是变量</th>\n    <th colspan=\"3\">作用</th>\n</tr>\n<tr>\n    <td style=\"text-align:center\">IN</td>\n    <td style=\"text-align:center\">否</td>\n    <td colspan=\"3\">用于调用者向过程传递数据，如果该参数在过程中被修改，调用者不可见</td>\n</tr>\n<tr>\n    <td style=\"text-align:center\">OUT</td>\n    <td style=\"text-align:center\">是</td>\n    <td colspan=\"3\">用于把过程产生的结果放到此参数中，过程结束后调用者可以通过该参数来获取过程执行的结果</td>\n</tr>\n<tr>\n    <td style=\"text-align:center\">INOUT</td>\n    <td style=\"text-align:center\">是</td>\n    <td colspan=\"3\">综合IN和OUT特点，即可用于调用者向过程传递数据，也可用于存放过程中产生的结果</td>\n</tr>\n</table>  \n\n<h3 id=\"IN\"><a href=\"#IN\" class=\"headerlink\" title=\"IN\"></a>IN</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE PROCEDURE test_in(IN num INT)</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; SELECT num;</span><br><span class=\"line\">    -&gt; SET num = 666;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; SET @a = 111;</span><br><span class=\"line\"></span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; CALL test_in(@a);</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| num  |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">|  111 |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Query</span> OK, <span class=\"number\">0</span> <span class=\"keyword\">rows</span> affected (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>IN参数类型的变量只能用于读取，对类型的变量赋值是不会被调用者看到的。<br>如果我们不写明参数类型的话，该参数的类型默认是IN。</p>\n<h3 id=\"OUT\"><a href=\"#OUT\" class=\"headerlink\" title=\"OUT\"></a>OUT</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE PROCEDURE test_out(OUT num INT)</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; SELECT num;</span><br><span class=\"line\">    -&gt; SET num = 666;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; CALL test_out(@a);</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| num  |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| NULL |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Query</span> OK, <span class=\"number\">0</span> <span class=\"keyword\">rows</span> affected (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; <span class=\"keyword\">SELECT</span> @a;</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| @a   |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">|  666 |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>OUT参数类型的变量只能用于赋值，对类型的变量赋值是会被调用者看到的,因此参数就不允许是常量。</p>\n<p>存储过程中向调用者返回多个值，举个例子：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE PROCEDURE data_out(OUT a INT,OUT b INT)</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; SET a = 100;</span><br><span class=\"line\">    -&gt; SET b = 200;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; CALL data_out(@a,@b);</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select @a,@b;</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| @a   | @b   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">|  100 |  200 |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"INOUT\"><a href=\"#INOUT\" class=\"headerlink\" title=\"INOUT\"></a>INOUT</h3><p>这种类型的参数既可以在存储过程中被读取，也可以被赋值后被调用者看到，因此参数就不允许是常量。</p>\n<h2 id=\"存储过程和函数的区别\"><a href=\"#存储过程和函数的区别\" class=\"headerlink\" title=\"存储过程和函数的区别\"></a>存储过程和函数的区别</h2><ul>\n<li><p>存储函数在定义时需要显式用RETURNS语句标明返回的数据类型，而且在函数体中必须使用RETURN语句来显式指定返回的值，存储过程不需要。</p>\n</li>\n<li><p>存储函数的参数类型只能是IN，而存储过程支持IN、OUT、INOUT三种参数类型。</p>\n</li>\n<li><p>存储函数只能返回一个值，而存储过程可以通过设置多个OUT类型的参数来返回多个结果。</p>\n</li>\n<li><p>存储函数执行过程中产生的结果集并不会被显示到客户端，而存储过程执行过程中产生的结果集会被显示到客户端。</p>\n</li>\n<li><p>存储函数的调用直接使用在表达式中，而存储过程只能通过CALL语句来显式调用。</p>\n</li>\n</ul>\n<h1 id=\"游标\"><a href=\"#游标\" class=\"headerlink\" title=\"游标\"></a>游标</h1><p>游标（Cursor）是处理数据的一种方法，为了查看或者处理结果集中的数据，游标提供了在结果集中一次一行或者多行前进或向后浏览数据的能力。<br>初始状态下它标记查询结果集中的第一条记录,根据这个游标取出它对应记录的信息，随后再移动游标，让它指向别的记录。</p>\n<h2 id=\"创建游标\"><a href=\"#创建游标\" class=\"headerlink\" title=\"创建游标\"></a>创建游标</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DECLARE</span> 游标名称 <span class=\"keyword\">CURSOR</span> <span class=\"keyword\">FOR</span> 查询语句;</span><br></pre></td></tr></table></figure>\n\n<p>举个🌰：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE PROCEDURE cursor_demo()</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; DECLARE first_table_cursor CURSOR FOR select * from first_table;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"打开和关闭游标\"><a href=\"#打开和关闭游标\" class=\"headerlink\" title=\"打开和关闭游标\"></a>打开和关闭游标</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OPEN 游标名称;</span><br><span class=\"line\"></span><br><span class=\"line\">CLOSE 游标名称;</span><br></pre></td></tr></table></figure>\n\n<p>打开游标意味着执行查询语句，让创建好的游标与该查询语句得到的结果集关联起来，关闭游标意味着会释放该游标占用的内存，所以一旦我们使用完了游标，就要把它关闭掉。</p>\n<h2 id=\"游标获取记录\"><a href=\"#游标获取记录\" class=\"headerlink\" title=\"游标获取记录\"></a>游标获取记录</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FETCH 游标名 INTO 变量1, 变量2, ... 变量n</span><br></pre></td></tr></table></figure>\n\n<p>举个例子：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE PROCEDURE cursor_demo()</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; DECLARE c1 INT;</span><br><span class=\"line\">    -&gt; DECLARE c2 VARCHAR(100);</span><br><span class=\"line\">    -&gt; DECLARE record_count INT;</span><br><span class=\"line\">    -&gt; DECLARE i INT DEFAULT 0;</span><br><span class=\"line\">    -&gt;  -- 声明游标</span><br><span class=\"line\">    -&gt; DECLARE first_table_cursor CURSOR FOR select * from first_table;</span><br><span class=\"line\">    -&gt;</span><br><span class=\"line\">    -&gt; -- 统计表行数</span><br><span class=\"line\">    -&gt; SELECT COUNT(*) FROM first_table INTO record_count;</span><br><span class=\"line\">    -&gt;</span><br><span class=\"line\">    -&gt; -- 使用游标遍历</span><br><span class=\"line\">    -&gt; OPEN first_table_cursor;</span><br><span class=\"line\">    -&gt;</span><br><span class=\"line\">    -&gt; WHILE i &lt; record_count DO</span><br><span class=\"line\">    -&gt; FETCH first_table_cursor INTO c1 , c2;</span><br><span class=\"line\">    -&gt; SELECT c1,c2;</span><br><span class=\"line\">    -&gt; SET i = i + 1;</span><br><span class=\"line\">    -&gt; END WHILE;</span><br><span class=\"line\">    -&gt; CLOSE first_table_cursor;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; CALL cursor_demo();</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| c1   | c2   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">|    1 | aaa  |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| c1   | c2   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">|    <span class=\"number\">2</span> | <span class=\"literal\">NULL</span> |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">row</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| c1   | c2   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| <span class=\"literal\">NULL</span> | ccc  |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">row</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| c1   | c2   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">|    <span class=\"number\">4</span> | <span class=\"keyword\">test</span> |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">row</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Query</span> OK, <span class=\"number\">0</span> <span class=\"keyword\">rows</span> affected (<span class=\"number\">0.01</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>i表示当前游标对应的记录位置。每调用一次 FETCH 语句，游标就移动到下一条记录的位置。</p>\n<h2 id=\"遍历结束的执行策略\"><a href=\"#遍历结束的执行策略\" class=\"headerlink\" title=\"遍历结束的执行策略\"></a>遍历结束的执行策略</h2><p>其实在FETCH语句获取不到记录的时候会触发一个事件，从而我们可以得知所有的记录都被获取过了，然后我们就可以去主动的停止循环。<br>MySQL中响应这个事件的语句如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DECLARE</span> CONTINUE <span class=\"keyword\">HANDLER</span> <span class=\"keyword\">FOR</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">FOUND</span> 语句;</span><br></pre></td></tr></table></figure>\n\n<p>举个🌰，再来改写一下cursor_demo存储过程：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; delimiter $</span><br><span class=\"line\">mysql&gt; CREATE PROCEDURE cursor_demo()</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; -- 声明变量</span><br><span class=\"line\">    -&gt; DECLARE c1 INT;</span><br><span class=\"line\">    -&gt; DECLARE c2 VARCHAR(100);</span><br><span class=\"line\">    -&gt; DECLARE not_done INT DEFAULT 1;</span><br><span class=\"line\">    -&gt;</span><br><span class=\"line\">    -&gt; -- 声明游标</span><br><span class=\"line\">    -&gt; DECLARE first_table_cursor CURSOR FOR select * from first_table;</span><br><span class=\"line\">    -&gt;</span><br><span class=\"line\">    -&gt; -- 在游标遍历完记录的时候将变量 not_done 的值设置为 0，并且继续执行后边的语句</span><br><span class=\"line\">    -&gt; DECLARE CONTINUE HANDLER FOR NOT FOUND SET not_done = 0;</span><br><span class=\"line\">    -&gt;</span><br><span class=\"line\">    -&gt; -- 使用游标遍历</span><br><span class=\"line\">    -&gt; OPEN first_table_cursor;</span><br><span class=\"line\">    -&gt;</span><br><span class=\"line\">    -&gt; WHILE not_done = 1 DO</span><br><span class=\"line\">    -&gt;</span><br><span class=\"line\">    -&gt; FETCH first_table_cursor INTO c1 , c2;</span><br><span class=\"line\">    -&gt; SELECT c1,c2;</span><br><span class=\"line\">    -&gt; END WHILE;</span><br><span class=\"line\">    -&gt; CLOSE first_table_cursor;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt;  CALL cursor_demo();</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| c1   | c2   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">|    1 | aaa  |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| c1   | c2   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">|    <span class=\"number\">2</span> | <span class=\"literal\">NULL</span> |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">row</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| c1   | c2   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| <span class=\"literal\">NULL</span> | ccc  |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">row</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| c1   | c2   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">|    <span class=\"number\">4</span> | <span class=\"keyword\">test</span> |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">row</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| c1   | c2   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">|    <span class=\"number\">4</span> | <span class=\"keyword\">test</span> |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">row</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Query</span> OK, <span class=\"number\">0</span> <span class=\"keyword\">rows</span> affected (<span class=\"number\">0.01</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>我们发现结果集中最后一条记录输出两遍怎么办呢，我们可以使用<code>EXIT</code>来替代上边的<code>CONTINUE</code>：<br><code>CONTINUE</code>表示在FETCH语句获取不到记录的时候仍然会执行之后存储过程的语句，也就是会将最后一次关联的记录中的值放入指定的变量<br><code>EXIT</code>表示在FETCH语句获取不到记录的时候仍然不会执行之后存储过程的语句</p>\n<h1 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h1><p>存储函数与存储过程都是需要我们<code>手动</code>调用的，如果想在执行某条语句之前或者之后自动去调用另外一些语句，就需要用到触发器。</p>\n<h2 id=\"创建触发器\"><a href=\"#创建触发器\" class=\"headerlink\" title=\"创建触发器\"></a>创建触发器</h2><p>触发器的定义：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TRIGGER</span> 触发器名</span><br><span class=\"line\">&#123;<span class=\"keyword\">BEFORE</span>|<span class=\"keyword\">AFTER</span>&#125;          </span><br><span class=\"line\">&#123;<span class=\"keyword\">INSERT</span>|<span class=\"keyword\">DELETE</span>|<span class=\"keyword\">UPDATE</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">ON</span> 表名</span><br><span class=\"line\"><span class=\"keyword\">FOR</span> <span class=\"keyword\">EACH</span> <span class=\"keyword\">ROW</span> </span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">    触发器内容</span><br><span class=\"line\"><span class=\"keyword\">END</span></span><br></pre></td></tr></table></figure>\n\n<p>MySQL中目前只支持对INSERT、DELETE、UPDATE这三种类型的语句设置触发器。</p>\n<p>因为触发器会对某个语句影响的所有记录依次调用我们自定义的触发器内容，所以我们需要一种访问该记录中的内容的方式，<br>MySQL提供了NEW和OLD两个单词来分别代表新记录和旧记录，它们在不同操作中的含义不同：</p>\n<ul>\n<li>对于INSERT语句设置的触发器来说，NEW代表准备插入的记录，不能使用OLD。</li>\n<li>对于DELETE语句设置的触发器来说，OLD代表删除前的记录，不能使用NEW。</li>\n<li>对于UPDATE语句设置的触发器来说，NEW代表修改后的记录，OLD代表修改前的记录。</li>\n</ul>\n<p>举个🌰：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE TRIGGER test_trigger</span><br><span class=\"line\">    -&gt; BEFORE INSERT ON first_table</span><br><span class=\"line\">    -&gt; FOR EACH ROW</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; IF NEW.first_column &lt; 1 THEN</span><br><span class=\"line\">    -&gt;  SET NEW.first_column = 1;</span><br><span class=\"line\">    -&gt; ELSEIF NEW.first_column &gt; 10 THEN</span><br><span class=\"line\">    -&gt;  SET NEW.first_column = 10;</span><br><span class=\"line\">    -&gt; END IF;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.02 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from first_table;</span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">| first_column | second_column |</span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">|            1 | aaa           |</span><br><span class=\"line\">|            2 | NULL          |</span><br><span class=\"line\">|         NULL | ccc           |</span><br><span class=\"line\">|            4 | test          |</span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">4 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; <span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> first_table(first_column,second_column) <span class=\"keyword\">VALUES</span>(<span class=\"number\">5</span>,<span class=\"string\">'5'</span>),(<span class=\"number\">20</span>,<span class=\"string\">'20'</span>);</span><br><span class=\"line\">Query OK, 2 rows affected (0.01 sec)</span><br><span class=\"line\">Records: 2  Duplicates: 0  Warnings: 0</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from first_table;</span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">| first_column | second_column |</span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">|            1 | aaa           |</span><br><span class=\"line\">|            2 | NULL          |</span><br><span class=\"line\">|         NULL | ccc           |</span><br><span class=\"line\">|            4 | test          |</span><br><span class=\"line\">|            5 | 5             |</span><br><span class=\"line\">|           10 | 20            |</span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">6 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>(20,’20’)的插入结果变成了(10,’20’)说明触发器生效了。</p>\n<h2 id=\"查看触发器\"><a href=\"#查看触发器\" class=\"headerlink\" title=\"查看触发器\"></a>查看触发器</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看当前数据库中的所有触发器的语句：</span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">TRIGGERS</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查看某个具体的触发器的定义：</span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">CREATE</span> <span class=\"keyword\">TRIGGER</span> 触发器名;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除触发器：\"><a href=\"#删除触发器：\" class=\"headerlink\" title=\"删除触发器：\"></a>删除触发器：</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TRIGGER</span> 触发器名;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"触发器使用注意事项\"><a href=\"#触发器使用注意事项\" class=\"headerlink\" title=\"触发器使用注意事项\"></a>触发器使用注意事项</h2><ol>\n<li>触发器内容中不能有输出结果集的语句。</li>\n<li>一个表最多只能定义6个触发器分别是：<ul>\n<li>BEFORE INSERT触发器</li>\n<li>BEFORE DELETE触发器</li>\n<li>BEFORE UPDATE触发器</li>\n<li>AFTER INSERT触发器</li>\n<li>AFTER DELETE触发器</li>\n<li>AFTER UPDATE触发器</li>\n</ul>\n</li>\n<li>NEW中的值可以被更改，OLD中的值无法更改。</li>\n<li>如果我们的<code>BEFORE</code>触发器内容执行过程中遇到了<code>ERROR</code>，那这个触发器对应的具体语句将无法执行；如果具体的操作语句执行过程中遇到了<code>ERROR</code>，那与它对应的<code>AFTER</code>触发器的内容将无法执行。</li>\n</ol>\n<h1 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h1><p>如果我们想指定某些语句在某个时间点或者每隔一个时间段执行一次的话,就需要创建一个事件。</p>\n<h2 id=\"创建事件\"><a href=\"#创建事件\" class=\"headerlink\" title=\"创建事件\"></a>创建事件</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">EVENT</span> 事件名</span><br><span class=\"line\"><span class=\"keyword\">ON</span> SCHEDULE</span><br><span class=\"line\">&#123;<span class=\"keyword\">AT</span> 某个确定的时间点 | EVERY 期望的时间间隔 [STARTS datetime][<span class=\"keyword\">END</span> datetime]&#125;</span><br><span class=\"line\"><span class=\"keyword\">DO</span></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">    具体的语句</span><br><span class=\"line\"><span class=\"keyword\">END</span></span><br></pre></td></tr></table></figure>\n\n<p>事件支持两种类型的定时执行：</p>\n<ol>\n<li><p>某个确定的时间点执行</p>\n <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE EVENT insert_first_table</span><br><span class=\"line\">    -&gt; ON SCHEDULE</span><br><span class=\"line\">    -&gt; AT '2019-09-10 11:30:30'</span><br><span class=\"line\">    -&gt; DO</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; INSERT INTO first_table(first_column,second_column) VALUES(6,'6');</span><br><span class=\"line\">    -&gt; END $</span><br></pre></td></tr></table></figure>\n\n<p> 除了直接填某个时间常量，也可以填写一些表达式：</p>\n <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE EVENT insert_first_table</span><br><span class=\"line\">    -&gt; ON SCHEDULE</span><br><span class=\"line\">    -&gt; AT DATE_ADD(NOW(), INTERVAL 2 DAY)</span><br><span class=\"line\">    -&gt; DO</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; INSERT INTO first_table(first_column,second_column) VALUES(6,'6');</span><br><span class=\"line\">    -&gt; END $</span><br></pre></td></tr></table></figure>\n\n<p> DATE_ADD(NOW(), INTERVAL 2 DAY)表示该事件将在当前时间的两天后执行。</p>\n</li>\n<li><p>每隔一段时间执行一次</p>\n <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE EVENT insert_first_table</span><br><span class=\"line\">    -&gt; ON SCHEDULE</span><br><span class=\"line\">    -&gt; EVERY 1 HOUR </span><br><span class=\"line\">    -&gt; DO</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; INSERT INTO first_table(first_column,second_column) VALUES(6,'6');</span><br><span class=\"line\">    -&gt; END $</span><br></pre></td></tr></table></figure>\n\n<p> 默认情况下，采用这种每隔一段时间执行一次的方式将从创建事件的事件开始，无限制的执行下去。我们也可以指定该事件开始执行时间和截止时间：</p>\n <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE EVENT insert_first_table</span><br><span class=\"line\">    -&gt; ON SCHEDULE</span><br><span class=\"line\">    -&gt; EVERY 1 HOUR STARTS '2019-09-10 11:30:30' ENDS '2019-09-12 11:30:30'</span><br><span class=\"line\">    -&gt; DO</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; INSERT INTO first_table(first_column,second_column) VALUES(6,'6');</span><br><span class=\"line\">    -&gt; END $</span><br></pre></td></tr></table></figure>\n\n<p> 在创建好事件之后我们就不用管了，到了指定时间，MySQL服务器会帮我们自动执行的。</p>\n</li>\n</ol>\n<h2 id=\"查看事件\"><a href=\"#查看事件\" class=\"headerlink\" title=\"查看事件\"></a>查看事件</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看当前数据库中的所有事件的语句：</span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">EVENTS</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查看某个具体的事件的定义:</span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">CREATE</span> <span class=\"keyword\">EVENT</span> 事件名;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除事件\"><a href=\"#删除事件\" class=\"headerlink\" title=\"删除事件\"></a>删除事件</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">EVENT</span> 事件名;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"事件使用注意事项\"><a href=\"#事件使用注意事项\" class=\"headerlink\" title=\"事件使用注意事项\"></a>事件使用注意事项</h2><p>默认情况下，MySQL服务器并不会帮助我们执行事件，除非我们在启动服务器的时候就指定了下边这个选项：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">event_scheduler = ON</span><br></pre></td></tr></table></figure>\n\n<p>如果在服务器已经启动的情况下，我们可以通过设置<code>event_scheduler</code>的系统变量来让MySQL服务器帮助我们执行事件，设置方式如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SET GLOBAL event_scheduler = ON;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"错误解决\"><a href=\"#错误解决\" class=\"headerlink\" title=\"错误解决\"></a>错误解决</h1><p>在MySql中创建自定义函数报错信息如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)</span><br></pre></td></tr></table></figure>\n\n<p>解决方法：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set global log_bin_trust_function_creators=1;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>MySQL中的存储程序本质上封装了一些可执行的语句，然后给用户提供一种简单的调用方式来执行这些语句，根据调用方式的不同，我们可以把<code>存储程序</code>分为<code>存储例程</code>、<code>触发器</code>和<code>事件</code>这几种类型。其中，<code>存储例程</code>又可以被细分为<code>存储函数</code>和<code>存储过程</code>。</p>","more":"<p><img src=\"/Mysql/Mysql-storage/640.png\" alt=\"存储程序\"></p>\n<h1 id=\"自定义变量\"><a href=\"#自定义变量\" class=\"headerlink\" title=\"自定义变量\"></a>自定义变量</h1><p>MySQL中对我们自定义的变量的命名有个要求，那就是变量名称前必须加一个<code>@符号</code>。我们自定义变量的值的类型可以是任意MySQL支持的类型，例如我们自定义一个变量<font color=\"red\">a</font>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SET @a = 1;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>如果我们想查看这个变量的值的话，使用<font color=\"Orange\">SELECT</font>语句就好了，不过仍然需要在变量名称加一个@符号：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SELECT @a;</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| @a   |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">|    1 |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>同一个变量也可以存储存储不同类型的值，比方说我们再把一个字符串值赋值给变量<font color=\"red\">a</font>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SET @a = '啦';</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; SELECT @a;</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| @a   |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| 啦   |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>除了把一个常量赋值给一个变量以外，我们还可以把一个变量赋值给另一个变量：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SET @b = @a;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; SELECT @b;</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| @b   |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| 啦   |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>我们还可以将某个查询的结果赋值给一个变量，前提是这个<font color=\"red\">查询的结果只有一个值</font>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SET @a = (SELECT first_column FROM first_table LIMIT 1);</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>还可以用另一种形式的语句来将查询的结果赋值给一个变量：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SELECT first_column FROM first_table LIMIT 1 INTO @b;</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>我们查看一下这两个变量的值：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SELECT @a, @b;</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| @a   | @b   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">|    1 |    1 |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>如果我们的查询结果是一条记录，该记录中有多个列的值的话，我们想把这几个值分别赋值到不同的变量中，只能使用<code>INTO</code>语句了：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SELECT first_column, second_column FROM first_table LIMIT 1 INTO @a, @b;</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; SELECT @a, @b;                                                           </span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| @a   | @b   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">|    1 | aaa  |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"复合语句\"><a href=\"#复合语句\" class=\"headerlink\" title=\"复合语句\"></a>复合语句</h1><p>在MySQL客户端的交互界面处，当我们完成键盘输入并按下回车键时，MySQL客户端会检测我们输入的内容中是否包含<code>;</code>、<code>\\g</code>或者<code>\\G</code>这三个符号之一，如果有的话，会把我们输入的内容发送到服务器。这样一来，如果我们想给服务器发送复合语句（也就是由一条或多条语句组成的语句）的话，就需要把这些语句写到一行中，比如这样：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SELECT first_column FROM first_table ;SELECT second_column FROM first_table;</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">| first_column |</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">|            1 |</span><br><span class=\"line\">|            2 |</span><br><span class=\"line\">|         NULL |</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">3 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\">| second_column |</span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\">| aaa           |</span><br><span class=\"line\">| <span class=\"literal\">NULL</span>          |</span><br><span class=\"line\">| ccc           |</span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>我们也可以用<code>delimiter</code>命令来自定义MySQL的检测输入结束的符号，如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; delimiter $</span><br><span class=\"line\">mysql&gt; SELECT first_column FROM first_table ;</span><br><span class=\"line\">    -&gt; SELECT second_column FROM first_table;</span><br><span class=\"line\">    -&gt; $</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">| first_column |</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">|            1 |</span><br><span class=\"line\">|            2 |</span><br><span class=\"line\">|         NULL |</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">3 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\">| second_column |</span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\">| aaa           |</span><br><span class=\"line\">| <span class=\"literal\">NULL</span>          |</span><br><span class=\"line\">| ccc           |</span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p><code>delimiter $</code>命令意味着修改MySQL客户端检测输入结束的符号为<code>$</code>,也可以使用任何符号来作为MySQL客户端检测输入结束的符号，也包括多个字符，如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; delimiter 666</span><br><span class=\"line\">mysql&gt; SELECT first_column FROM first_table;</span><br><span class=\"line\">    -&gt; SELECT second_column FROM first_table;</span><br><span class=\"line\">    -&gt; 666</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">| first_column |</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">|            1 |</span><br><span class=\"line\">|            2 |</span><br><span class=\"line\">|         NULL |</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">3 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\">| second_column |</span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\">| aaa           |</span><br><span class=\"line\">| <span class=\"literal\">NULL</span>          |</span><br><span class=\"line\">| ccc           |</span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"存储函数\"><a href=\"#存储函数\" class=\"headerlink\" title=\"存储函数\"></a>存储函数</h1><h2 id=\"创建存储函数\"><a href=\"#创建存储函数\" class=\"headerlink\" title=\"创建存储函数\"></a>创建存储函数</h2><p><code>存储函数</code>其实就是一种<code>函数</code>，只不过在这个函数里可以执行命令语句而已。<br>MySQL中定义存储函数的语句如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">FUNCTION</span> 存储函数名称([参数列表])</span><br><span class=\"line\"><span class=\"keyword\">RETURNS</span> 返回值类型</span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">    函数体内容</span><br><span class=\"line\"><span class=\"keyword\">END</span></span><br></pre></td></tr></table></figure>\n\n<p>举个🌰：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; delimiter $</span><br><span class=\"line\">mysql&gt; CREATE FUNCTION second_column(a INT)</span><br><span class=\"line\">    -&gt; RETURNS VARCHAR(100)</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; RETURN (SELECT second_column FROM first_table WHERE first_column = a);</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; delimiter ;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"存储函数的调用\"><a href=\"#存储函数的调用\" class=\"headerlink\" title=\"存储函数的调用\"></a>存储函数的调用</h2><p>我们自定义的函数和系统内置函数的使用方式是一样的，都是在函数名后加小括号<code>()</code>表示函数调用</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SELECT second_column(1);</span><br><span class=\"line\">+<span class=\"comment\">------------------+</span></span><br><span class=\"line\">| second_column(1) |</span><br><span class=\"line\">+<span class=\"comment\">------------------+</span></span><br><span class=\"line\">| aaa              |</span><br><span class=\"line\">+<span class=\"comment\">------------------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查看存储函数\"><a href=\"#查看存储函数\" class=\"headerlink\" title=\"查看存储函数\"></a>查看存储函数</h2><p>查看定义了多少个存储函数:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">FUNCTION</span> <span class=\"keyword\">STATUS</span> [<span class=\"keyword\">LIKE</span> 需要匹配的函数名]</span><br></pre></td></tr></table></figure>\n\n<p>查看某个函数的具体定义:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">CREATE</span> <span class=\"keyword\">FUNCTION</span> 函数名</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除存储函数\"><a href=\"#删除存储函数\" class=\"headerlink\" title=\"删除存储函数\"></a>删除存储函数</h2><p>删除某个存储函数</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">FUNCTION</span> 函数名</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在函数体中定义变量\"><a href=\"#在函数体中定义变量\" class=\"headerlink\" title=\"在函数体中定义变量\"></a>在函数体中定义变量</h2><p>在函数体中使用变量前必须先声明这个变量，函数体中的变量名<code>不允许加@</code>前缀,声明方式如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DECLARE</span> 变量名 数据类型 [<span class=\"keyword\">DEFAULT</span> 默认值];   </span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; delimiter $</span><br><span class=\"line\">mysql&gt; CREATE FUNCTION var_demo(a INT)</span><br><span class=\"line\">    -&gt; RETURNS INT</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; DECLARE b INT;</span><br><span class=\"line\">    -&gt; SET b = 5;</span><br><span class=\"line\">    -&gt; RETURN b+a;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; delimiter ;</span><br></pre></td></tr></table></figure>\n\n<p>我们调用一下这个函数：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SELECT var_demo(2);</span><br><span class=\"line\">+<span class=\"comment\">-------------+</span></span><br><span class=\"line\">| var_demo(2) |</span><br><span class=\"line\">+<span class=\"comment\">-------------+</span></span><br><span class=\"line\">|           7 |</span><br><span class=\"line\">+<span class=\"comment\">-------------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>如果不对声明的变量赋值，它的默认值就是NULL，也可以通过<code>DEFAULT</code>子句来显式的指定变量的默认值.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; delimiter $</span><br><span class=\"line\">mysql&gt; CREATE FUNCTION var_default_demo()</span><br><span class=\"line\">-&gt; RETURNS INT</span><br><span class=\"line\">-&gt; BEGIN</span><br><span class=\"line\">-&gt;     DECLARE c INT DEFAULT 1;</span><br><span class=\"line\">-&gt;     RETURN c;</span><br><span class=\"line\">-&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; delimiter ;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; SELECT var_default_demo();</span><br><span class=\"line\">+<span class=\"comment\">--------------------+</span></span><br><span class=\"line\">| var_default_demo() |</span><br><span class=\"line\">+<span class=\"comment\">--------------------+</span></span><br><span class=\"line\">|                  1 |</span><br><span class=\"line\">+<span class=\"comment\">--------------------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参数定义\"><a href=\"#参数定义\" class=\"headerlink\" title=\"参数定义\"></a>参数定义</h2><p>比如我们上边编写的这个second_column函数：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE FUNCTION second_column(a INT)</span><br><span class=\"line\">    -&gt; RETURNS VARCHAR(100)</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; RETURN (SELECT second_column FROM first_table WHERE first_column = a);</span><br><span class=\"line\">    -&gt; END $</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，参数名不要和函数体语句中其他的变量名、命令语句的标识符冲突。并且函数参数不可以指定默认值，我们在调用函数的时候，必须显式的指定所有的参数，参数类型也一定要匹配</p>\n<h2 id=\"判断语句\"><a href=\"#判断语句\" class=\"headerlink\" title=\"判断语句\"></a>判断语句</h2><p>语法格式如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IF 布尔表达式 THEN </span><br><span class=\"line\">    处理语句</span><br><span class=\"line\">[ELSEIF 布尔表达式 THEN</span><br><span class=\"line\">    处理语句]</span><br><span class=\"line\">[ELSE </span><br><span class=\"line\">    处理语句]    </span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">IF</span>;</span><br></pre></td></tr></table></figure>\n\n<p>举个🌰：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; delimiter $</span><br><span class=\"line\">mysql&gt; CREATE FUNCTION condition_demo(i INT)</span><br><span class=\"line\">    -&gt; RETURNS VARCHAR(10)</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; DECLARE result VARCHAR(10);</span><br><span class=\"line\">    -&gt; IF i = 1 THEN</span><br><span class=\"line\">    -&gt; SET result = '结果是1';</span><br><span class=\"line\">    -&gt; ELSEIF i = 2 THEN</span><br><span class=\"line\">    -&gt;  SET result = '结果是2';</span><br><span class=\"line\">    -&gt; ELSEIF i = 3 THEN</span><br><span class=\"line\">    -&gt; SET result = '结果是3';</span><br><span class=\"line\">    -&gt; ELSE</span><br><span class=\"line\">    -&gt; SET result = '非法参数';</span><br><span class=\"line\">    -&gt; END IF;</span><br><span class=\"line\">    -&gt; RETURN result;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; delimiter;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; SELECT condition_demo(2);</span><br><span class=\"line\">+<span class=\"comment\">-------------------+</span></span><br><span class=\"line\">| condition_demo(2) |</span><br><span class=\"line\">+<span class=\"comment\">-------------------+</span></span><br><span class=\"line\">| 结果是2           |</span><br><span class=\"line\">+<span class=\"comment\">-------------------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h2><p><code>while</code>循环语法格式如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WHILE 布尔表达式 <span class=\"keyword\">DO</span></span><br><span class=\"line\">    循环语句</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">WHILE</span>;</span><br></pre></td></tr></table></figure>\n\n<p>举个🌰：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; delimiter $</span><br><span class=\"line\">mysql&gt; CREATE FUNCTION sum_all(n INT UNSIGNED)</span><br><span class=\"line\">    -&gt; RETURNS INT</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; DECLARE result INT DEFAULT 0;</span><br><span class=\"line\">    -&gt; DECLARE i INT DEFAULT 1;</span><br><span class=\"line\">    -&gt; WHILE i &lt;= n DO</span><br><span class=\"line\">    -&gt; SET result = result + i;</span><br><span class=\"line\">    -&gt; SET i = i + 1;</span><br><span class=\"line\">    -&gt; END WHILE;</span><br><span class=\"line\">    -&gt; RETURN result;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; delimiter;</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select sum_all(10);</span><br><span class=\"line\">+<span class=\"comment\">-------------+</span></span><br><span class=\"line\">| sum_all(10) |</span><br><span class=\"line\">+<span class=\"comment\">-------------+</span></span><br><span class=\"line\">|          55 |</span><br><span class=\"line\">+<span class=\"comment\">-------------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p><code>REPEAT</code>循环语法格式如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REPEAT</span><br><span class=\"line\">    循环语句</span><br><span class=\"line\">UNTIL 布尔表达式 <span class=\"keyword\">END</span> <span class=\"keyword\">REPEAT</span>;</span><br></pre></td></tr></table></figure>\n\n<p>举个🌰：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE FUNCTION sum_repeat(n INT UNSIGNED)</span><br><span class=\"line\">    -&gt; RETURNS INT</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; DECLARE result INT DEFAULT 0;</span><br><span class=\"line\">    -&gt; DECLARE i INT DEFAULT 1;</span><br><span class=\"line\">    -&gt; REPEAT</span><br><span class=\"line\">    -&gt; -- 循环开始</span><br><span class=\"line\">    -&gt; SET result = result + i;</span><br><span class=\"line\">    -&gt; SET i = i + 1;</span><br><span class=\"line\">    -&gt; UNTIL i &gt; n END REPEAT;</span><br><span class=\"line\">    -&gt; RETURN result;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.02 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select sum_repeat(5);</span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\">| sum_repeat(5) |</span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\">|            15 |</span><br><span class=\"line\">+<span class=\"comment\">---------------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p><code>LOOP</code>循环语法格式如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">循环标记:LOOP</span><br><span class=\"line\">    循环语句</span><br><span class=\"line\">    LEAVE 循环标记;</span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">LOOP</span> 循环标记;</span><br></pre></td></tr></table></figure>\n\n<p>举个🌰：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE FUNCTION sum_loop(n INT UNSIGNED)</span><br><span class=\"line\">    -&gt; RETURNS INT</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; DECLARE result INT DEFAULT 0;</span><br><span class=\"line\">    -&gt; DECLARE i INT DEFAULT 1;</span><br><span class=\"line\">    -&gt; LOOP_NAME:LOOP -- 循环开始</span><br><span class=\"line\">    -&gt; IF i &gt; n THEN</span><br><span class=\"line\">    -&gt; LEAVE LOOP_NAME;</span><br><span class=\"line\">    -&gt; END IF;</span><br><span class=\"line\">    -&gt; SET result = result + i;</span><br><span class=\"line\">    -&gt; SET i = i + 1;</span><br><span class=\"line\">    -&gt; END LOOP LOOP_NAME;</span><br><span class=\"line\">    -&gt; RETURN result;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">    </span><br><span class=\"line\">mysql&gt; select sum_loop(10);</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">| sum_loop(10) |</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">|           55 |</span><br><span class=\"line\">+<span class=\"comment\">--------------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"存储过程\"><a href=\"#存储过程\" class=\"headerlink\" title=\"存储过程\"></a>存储过程</h1><p>存储函数侧重于执行语句并返回一个值，而存储过程更侧重于单纯的去执行语句。</p>\n<h2 id=\"创建存储过程\"><a href=\"#创建存储过程\" class=\"headerlink\" title=\"创建存储过程\"></a>创建存储过程</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> 存储过程名称([参数列表])</span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">    需要执行的语句</span><br><span class=\"line\"><span class=\"keyword\">END</span></span><br></pre></td></tr></table></figure>\n\n<p>举个🌰：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE PROCEDURE insert_first_table(c1 INT,c2 VARCHAR(100))</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; SELECT * FROM first_table;</span><br><span class=\"line\">    -&gt; INSERT INTO first_table(first_column,second_column) VALUES(c1,c2);</span><br><span class=\"line\">    -&gt; SELECT * FROM first_table;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"存储过程的调用\"><a href=\"#存储过程的调用\" class=\"headerlink\" title=\"存储过程的调用\"></a>存储过程的调用</h2><p>存储函数执行语句并返回一个值，所以常用在表达式中。<br>存储过程偏向于调用那些语句，并不能用在表达式中。<br>我们需要显式的使用CALL语句来调用一个存储过程：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CALL</span> 存储过程([参数列表]);</span><br></pre></td></tr></table></figure>\n\n<p>举个🌰：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CALL insert_first_table(4,'test');</span><br><span class=\"line\"> </span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">| first_column | second_column |</span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">|            1 | aaa           |</span><br><span class=\"line\">|            2 | NULL          |</span><br><span class=\"line\">|         NULL | ccc           |</span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">3 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">| first_column | second_column |</span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">|            <span class=\"number\">1</span> | aaa           |</span><br><span class=\"line\">|            <span class=\"number\">2</span> | <span class=\"literal\">NULL</span>          |</span><br><span class=\"line\">|         <span class=\"literal\">NULL</span> | ccc           |</span><br><span class=\"line\">|            <span class=\"number\">4</span> | <span class=\"keyword\">test</span>          |</span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"keyword\">rows</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查看存储过程\"><a href=\"#查看存储过程\" class=\"headerlink\" title=\"查看存储过程\"></a>查看存储过程</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看当前数据库中创建的存储过程都有哪些的语句：</span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">PROCEDURE</span> <span class=\"keyword\">STATUS</span> [<span class=\"keyword\">LIKE</span> 需要匹配的函数名]</span><br><span class=\"line\"></span><br><span class=\"line\">查看某个存储过程定义的语句：</span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> 存储过程名称</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除存储过程\"><a href=\"#删除存储过程\" class=\"headerlink\" title=\"删除存储过程\"></a>删除存储过程</h2><p>删除某个存储过程</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">PROCEDURE</span> 存储过程名称</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"存储过程参数类型\"><a href=\"#存储过程参数类型\" class=\"headerlink\" title=\"存储过程参数类型\"></a>存储过程参数类型</h2><table>\n<tr>\n    <th>参数类型</th>\n    <th>实际参数是否必须是变量</th>\n    <th colspan=\"3\">作用</th>\n</tr>\n<tr>\n    <td style=\"text-align:center\">IN</td>\n    <td style=\"text-align:center\">否</td>\n    <td colspan=\"3\">用于调用者向过程传递数据，如果该参数在过程中被修改，调用者不可见</td>\n</tr>\n<tr>\n    <td style=\"text-align:center\">OUT</td>\n    <td style=\"text-align:center\">是</td>\n    <td colspan=\"3\">用于把过程产生的结果放到此参数中，过程结束后调用者可以通过该参数来获取过程执行的结果</td>\n</tr>\n<tr>\n    <td style=\"text-align:center\">INOUT</td>\n    <td style=\"text-align:center\">是</td>\n    <td colspan=\"3\">综合IN和OUT特点，即可用于调用者向过程传递数据，也可用于存放过程中产生的结果</td>\n</tr>\n</table>  \n\n<h3 id=\"IN\"><a href=\"#IN\" class=\"headerlink\" title=\"IN\"></a>IN</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE PROCEDURE test_in(IN num INT)</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; SELECT num;</span><br><span class=\"line\">    -&gt; SET num = 666;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; SET @a = 111;</span><br><span class=\"line\"></span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; CALL test_in(@a);</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| num  |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">|  111 |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Query</span> OK, <span class=\"number\">0</span> <span class=\"keyword\">rows</span> affected (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>IN参数类型的变量只能用于读取，对类型的变量赋值是不会被调用者看到的。<br>如果我们不写明参数类型的话，该参数的类型默认是IN。</p>\n<h3 id=\"OUT\"><a href=\"#OUT\" class=\"headerlink\" title=\"OUT\"></a>OUT</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE PROCEDURE test_out(OUT num INT)</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; SELECT num;</span><br><span class=\"line\">    -&gt; SET num = 666;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; CALL test_out(@a);</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| num  |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| NULL |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Query</span> OK, <span class=\"number\">0</span> <span class=\"keyword\">rows</span> affected (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; <span class=\"keyword\">SELECT</span> @a;</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">| @a   |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">|  666 |</span><br><span class=\"line\">+<span class=\"comment\">------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>OUT参数类型的变量只能用于赋值，对类型的变量赋值是会被调用者看到的,因此参数就不允许是常量。</p>\n<p>存储过程中向调用者返回多个值，举个例子：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE PROCEDURE data_out(OUT a INT,OUT b INT)</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; SET a = 100;</span><br><span class=\"line\">    -&gt; SET b = 200;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; CALL data_out(@a,@b);</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select @a,@b;</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| @a   | @b   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">|  100 |  200 |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"INOUT\"><a href=\"#INOUT\" class=\"headerlink\" title=\"INOUT\"></a>INOUT</h3><p>这种类型的参数既可以在存储过程中被读取，也可以被赋值后被调用者看到，因此参数就不允许是常量。</p>\n<h2 id=\"存储过程和函数的区别\"><a href=\"#存储过程和函数的区别\" class=\"headerlink\" title=\"存储过程和函数的区别\"></a>存储过程和函数的区别</h2><ul>\n<li><p>存储函数在定义时需要显式用RETURNS语句标明返回的数据类型，而且在函数体中必须使用RETURN语句来显式指定返回的值，存储过程不需要。</p>\n</li>\n<li><p>存储函数的参数类型只能是IN，而存储过程支持IN、OUT、INOUT三种参数类型。</p>\n</li>\n<li><p>存储函数只能返回一个值，而存储过程可以通过设置多个OUT类型的参数来返回多个结果。</p>\n</li>\n<li><p>存储函数执行过程中产生的结果集并不会被显示到客户端，而存储过程执行过程中产生的结果集会被显示到客户端。</p>\n</li>\n<li><p>存储函数的调用直接使用在表达式中，而存储过程只能通过CALL语句来显式调用。</p>\n</li>\n</ul>\n<h1 id=\"游标\"><a href=\"#游标\" class=\"headerlink\" title=\"游标\"></a>游标</h1><p>游标（Cursor）是处理数据的一种方法，为了查看或者处理结果集中的数据，游标提供了在结果集中一次一行或者多行前进或向后浏览数据的能力。<br>初始状态下它标记查询结果集中的第一条记录,根据这个游标取出它对应记录的信息，随后再移动游标，让它指向别的记录。</p>\n<h2 id=\"创建游标\"><a href=\"#创建游标\" class=\"headerlink\" title=\"创建游标\"></a>创建游标</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DECLARE</span> 游标名称 <span class=\"keyword\">CURSOR</span> <span class=\"keyword\">FOR</span> 查询语句;</span><br></pre></td></tr></table></figure>\n\n<p>举个🌰：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE PROCEDURE cursor_demo()</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; DECLARE first_table_cursor CURSOR FOR select * from first_table;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"打开和关闭游标\"><a href=\"#打开和关闭游标\" class=\"headerlink\" title=\"打开和关闭游标\"></a>打开和关闭游标</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OPEN 游标名称;</span><br><span class=\"line\"></span><br><span class=\"line\">CLOSE 游标名称;</span><br></pre></td></tr></table></figure>\n\n<p>打开游标意味着执行查询语句，让创建好的游标与该查询语句得到的结果集关联起来，关闭游标意味着会释放该游标占用的内存，所以一旦我们使用完了游标，就要把它关闭掉。</p>\n<h2 id=\"游标获取记录\"><a href=\"#游标获取记录\" class=\"headerlink\" title=\"游标获取记录\"></a>游标获取记录</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FETCH 游标名 INTO 变量1, 变量2, ... 变量n</span><br></pre></td></tr></table></figure>\n\n<p>举个例子：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE PROCEDURE cursor_demo()</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; DECLARE c1 INT;</span><br><span class=\"line\">    -&gt; DECLARE c2 VARCHAR(100);</span><br><span class=\"line\">    -&gt; DECLARE record_count INT;</span><br><span class=\"line\">    -&gt; DECLARE i INT DEFAULT 0;</span><br><span class=\"line\">    -&gt;  -- 声明游标</span><br><span class=\"line\">    -&gt; DECLARE first_table_cursor CURSOR FOR select * from first_table;</span><br><span class=\"line\">    -&gt;</span><br><span class=\"line\">    -&gt; -- 统计表行数</span><br><span class=\"line\">    -&gt; SELECT COUNT(*) FROM first_table INTO record_count;</span><br><span class=\"line\">    -&gt;</span><br><span class=\"line\">    -&gt; -- 使用游标遍历</span><br><span class=\"line\">    -&gt; OPEN first_table_cursor;</span><br><span class=\"line\">    -&gt;</span><br><span class=\"line\">    -&gt; WHILE i &lt; record_count DO</span><br><span class=\"line\">    -&gt; FETCH first_table_cursor INTO c1 , c2;</span><br><span class=\"line\">    -&gt; SELECT c1,c2;</span><br><span class=\"line\">    -&gt; SET i = i + 1;</span><br><span class=\"line\">    -&gt; END WHILE;</span><br><span class=\"line\">    -&gt; CLOSE first_table_cursor;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; CALL cursor_demo();</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| c1   | c2   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">|    1 | aaa  |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| c1   | c2   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">|    <span class=\"number\">2</span> | <span class=\"literal\">NULL</span> |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">row</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| c1   | c2   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| <span class=\"literal\">NULL</span> | ccc  |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">row</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| c1   | c2   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">|    <span class=\"number\">4</span> | <span class=\"keyword\">test</span> |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">row</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Query</span> OK, <span class=\"number\">0</span> <span class=\"keyword\">rows</span> affected (<span class=\"number\">0.01</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>i表示当前游标对应的记录位置。每调用一次 FETCH 语句，游标就移动到下一条记录的位置。</p>\n<h2 id=\"遍历结束的执行策略\"><a href=\"#遍历结束的执行策略\" class=\"headerlink\" title=\"遍历结束的执行策略\"></a>遍历结束的执行策略</h2><p>其实在FETCH语句获取不到记录的时候会触发一个事件，从而我们可以得知所有的记录都被获取过了，然后我们就可以去主动的停止循环。<br>MySQL中响应这个事件的语句如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DECLARE</span> CONTINUE <span class=\"keyword\">HANDLER</span> <span class=\"keyword\">FOR</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">FOUND</span> 语句;</span><br></pre></td></tr></table></figure>\n\n<p>举个🌰，再来改写一下cursor_demo存储过程：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; delimiter $</span><br><span class=\"line\">mysql&gt; CREATE PROCEDURE cursor_demo()</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; -- 声明变量</span><br><span class=\"line\">    -&gt; DECLARE c1 INT;</span><br><span class=\"line\">    -&gt; DECLARE c2 VARCHAR(100);</span><br><span class=\"line\">    -&gt; DECLARE not_done INT DEFAULT 1;</span><br><span class=\"line\">    -&gt;</span><br><span class=\"line\">    -&gt; -- 声明游标</span><br><span class=\"line\">    -&gt; DECLARE first_table_cursor CURSOR FOR select * from first_table;</span><br><span class=\"line\">    -&gt;</span><br><span class=\"line\">    -&gt; -- 在游标遍历完记录的时候将变量 not_done 的值设置为 0，并且继续执行后边的语句</span><br><span class=\"line\">    -&gt; DECLARE CONTINUE HANDLER FOR NOT FOUND SET not_done = 0;</span><br><span class=\"line\">    -&gt;</span><br><span class=\"line\">    -&gt; -- 使用游标遍历</span><br><span class=\"line\">    -&gt; OPEN first_table_cursor;</span><br><span class=\"line\">    -&gt;</span><br><span class=\"line\">    -&gt; WHILE not_done = 1 DO</span><br><span class=\"line\">    -&gt;</span><br><span class=\"line\">    -&gt; FETCH first_table_cursor INTO c1 , c2;</span><br><span class=\"line\">    -&gt; SELECT c1,c2;</span><br><span class=\"line\">    -&gt; END WHILE;</span><br><span class=\"line\">    -&gt; CLOSE first_table_cursor;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt;  CALL cursor_demo();</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| c1   | c2   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">|    1 | aaa  |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">1 row in <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| c1   | c2   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">|    <span class=\"number\">2</span> | <span class=\"literal\">NULL</span> |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">row</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| c1   | c2   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| <span class=\"literal\">NULL</span> | ccc  |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">row</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| c1   | c2   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">|    <span class=\"number\">4</span> | <span class=\"keyword\">test</span> |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">row</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">| c1   | c2   |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\">|    <span class=\"number\">4</span> | <span class=\"keyword\">test</span> |</span><br><span class=\"line\">+<span class=\"comment\">------+------+</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">row</span> <span class=\"keyword\">in</span> <span class=\"keyword\">set</span> (<span class=\"number\">0.01</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">Query</span> OK, <span class=\"number\">0</span> <span class=\"keyword\">rows</span> affected (<span class=\"number\">0.01</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>我们发现结果集中最后一条记录输出两遍怎么办呢，我们可以使用<code>EXIT</code>来替代上边的<code>CONTINUE</code>：<br><code>CONTINUE</code>表示在FETCH语句获取不到记录的时候仍然会执行之后存储过程的语句，也就是会将最后一次关联的记录中的值放入指定的变量<br><code>EXIT</code>表示在FETCH语句获取不到记录的时候仍然不会执行之后存储过程的语句</p>\n<h1 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h1><p>存储函数与存储过程都是需要我们<code>手动</code>调用的，如果想在执行某条语句之前或者之后自动去调用另外一些语句，就需要用到触发器。</p>\n<h2 id=\"创建触发器\"><a href=\"#创建触发器\" class=\"headerlink\" title=\"创建触发器\"></a>创建触发器</h2><p>触发器的定义：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TRIGGER</span> 触发器名</span><br><span class=\"line\">&#123;<span class=\"keyword\">BEFORE</span>|<span class=\"keyword\">AFTER</span>&#125;          </span><br><span class=\"line\">&#123;<span class=\"keyword\">INSERT</span>|<span class=\"keyword\">DELETE</span>|<span class=\"keyword\">UPDATE</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">ON</span> 表名</span><br><span class=\"line\"><span class=\"keyword\">FOR</span> <span class=\"keyword\">EACH</span> <span class=\"keyword\">ROW</span> </span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">    触发器内容</span><br><span class=\"line\"><span class=\"keyword\">END</span></span><br></pre></td></tr></table></figure>\n\n<p>MySQL中目前只支持对INSERT、DELETE、UPDATE这三种类型的语句设置触发器。</p>\n<p>因为触发器会对某个语句影响的所有记录依次调用我们自定义的触发器内容，所以我们需要一种访问该记录中的内容的方式，<br>MySQL提供了NEW和OLD两个单词来分别代表新记录和旧记录，它们在不同操作中的含义不同：</p>\n<ul>\n<li>对于INSERT语句设置的触发器来说，NEW代表准备插入的记录，不能使用OLD。</li>\n<li>对于DELETE语句设置的触发器来说，OLD代表删除前的记录，不能使用NEW。</li>\n<li>对于UPDATE语句设置的触发器来说，NEW代表修改后的记录，OLD代表修改前的记录。</li>\n</ul>\n<p>举个🌰：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE TRIGGER test_trigger</span><br><span class=\"line\">    -&gt; BEFORE INSERT ON first_table</span><br><span class=\"line\">    -&gt; FOR EACH ROW</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; IF NEW.first_column &lt; 1 THEN</span><br><span class=\"line\">    -&gt;  SET NEW.first_column = 1;</span><br><span class=\"line\">    -&gt; ELSEIF NEW.first_column &gt; 10 THEN</span><br><span class=\"line\">    -&gt;  SET NEW.first_column = 10;</span><br><span class=\"line\">    -&gt; END IF;</span><br><span class=\"line\">    -&gt; END $</span><br><span class=\"line\">Query OK, 0 rows affected (0.02 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from first_table;</span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">| first_column | second_column |</span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">|            1 | aaa           |</span><br><span class=\"line\">|            2 | NULL          |</span><br><span class=\"line\">|         NULL | ccc           |</span><br><span class=\"line\">|            4 | test          |</span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">4 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; <span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> first_table(first_column,second_column) <span class=\"keyword\">VALUES</span>(<span class=\"number\">5</span>,<span class=\"string\">'5'</span>),(<span class=\"number\">20</span>,<span class=\"string\">'20'</span>);</span><br><span class=\"line\">Query OK, 2 rows affected (0.01 sec)</span><br><span class=\"line\">Records: 2  Duplicates: 0  Warnings: 0</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from first_table;</span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">| first_column | second_column |</span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">|            1 | aaa           |</span><br><span class=\"line\">|            2 | NULL          |</span><br><span class=\"line\">|         NULL | ccc           |</span><br><span class=\"line\">|            4 | test          |</span><br><span class=\"line\">|            5 | 5             |</span><br><span class=\"line\">|           10 | 20            |</span><br><span class=\"line\">+<span class=\"comment\">--------------+---------------+</span></span><br><span class=\"line\">6 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n\n<p>(20,’20’)的插入结果变成了(10,’20’)说明触发器生效了。</p>\n<h2 id=\"查看触发器\"><a href=\"#查看触发器\" class=\"headerlink\" title=\"查看触发器\"></a>查看触发器</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看当前数据库中的所有触发器的语句：</span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">TRIGGERS</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查看某个具体的触发器的定义：</span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">CREATE</span> <span class=\"keyword\">TRIGGER</span> 触发器名;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除触发器：\"><a href=\"#删除触发器：\" class=\"headerlink\" title=\"删除触发器：\"></a>删除触发器：</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TRIGGER</span> 触发器名;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"触发器使用注意事项\"><a href=\"#触发器使用注意事项\" class=\"headerlink\" title=\"触发器使用注意事项\"></a>触发器使用注意事项</h2><ol>\n<li>触发器内容中不能有输出结果集的语句。</li>\n<li>一个表最多只能定义6个触发器分别是：<ul>\n<li>BEFORE INSERT触发器</li>\n<li>BEFORE DELETE触发器</li>\n<li>BEFORE UPDATE触发器</li>\n<li>AFTER INSERT触发器</li>\n<li>AFTER DELETE触发器</li>\n<li>AFTER UPDATE触发器</li>\n</ul>\n</li>\n<li>NEW中的值可以被更改，OLD中的值无法更改。</li>\n<li>如果我们的<code>BEFORE</code>触发器内容执行过程中遇到了<code>ERROR</code>，那这个触发器对应的具体语句将无法执行；如果具体的操作语句执行过程中遇到了<code>ERROR</code>，那与它对应的<code>AFTER</code>触发器的内容将无法执行。</li>\n</ol>\n<h1 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h1><p>如果我们想指定某些语句在某个时间点或者每隔一个时间段执行一次的话,就需要创建一个事件。</p>\n<h2 id=\"创建事件\"><a href=\"#创建事件\" class=\"headerlink\" title=\"创建事件\"></a>创建事件</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">EVENT</span> 事件名</span><br><span class=\"line\"><span class=\"keyword\">ON</span> SCHEDULE</span><br><span class=\"line\">&#123;<span class=\"keyword\">AT</span> 某个确定的时间点 | EVERY 期望的时间间隔 [STARTS datetime][<span class=\"keyword\">END</span> datetime]&#125;</span><br><span class=\"line\"><span class=\"keyword\">DO</span></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">    具体的语句</span><br><span class=\"line\"><span class=\"keyword\">END</span></span><br></pre></td></tr></table></figure>\n\n<p>事件支持两种类型的定时执行：</p>\n<ol>\n<li><p>某个确定的时间点执行</p>\n <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE EVENT insert_first_table</span><br><span class=\"line\">    -&gt; ON SCHEDULE</span><br><span class=\"line\">    -&gt; AT '2019-09-10 11:30:30'</span><br><span class=\"line\">    -&gt; DO</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; INSERT INTO first_table(first_column,second_column) VALUES(6,'6');</span><br><span class=\"line\">    -&gt; END $</span><br></pre></td></tr></table></figure>\n\n<p> 除了直接填某个时间常量，也可以填写一些表达式：</p>\n <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE EVENT insert_first_table</span><br><span class=\"line\">    -&gt; ON SCHEDULE</span><br><span class=\"line\">    -&gt; AT DATE_ADD(NOW(), INTERVAL 2 DAY)</span><br><span class=\"line\">    -&gt; DO</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; INSERT INTO first_table(first_column,second_column) VALUES(6,'6');</span><br><span class=\"line\">    -&gt; END $</span><br></pre></td></tr></table></figure>\n\n<p> DATE_ADD(NOW(), INTERVAL 2 DAY)表示该事件将在当前时间的两天后执行。</p>\n</li>\n<li><p>每隔一段时间执行一次</p>\n <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE EVENT insert_first_table</span><br><span class=\"line\">    -&gt; ON SCHEDULE</span><br><span class=\"line\">    -&gt; EVERY 1 HOUR </span><br><span class=\"line\">    -&gt; DO</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; INSERT INTO first_table(first_column,second_column) VALUES(6,'6');</span><br><span class=\"line\">    -&gt; END $</span><br></pre></td></tr></table></figure>\n\n<p> 默认情况下，采用这种每隔一段时间执行一次的方式将从创建事件的事件开始，无限制的执行下去。我们也可以指定该事件开始执行时间和截止时间：</p>\n <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE EVENT insert_first_table</span><br><span class=\"line\">    -&gt; ON SCHEDULE</span><br><span class=\"line\">    -&gt; EVERY 1 HOUR STARTS '2019-09-10 11:30:30' ENDS '2019-09-12 11:30:30'</span><br><span class=\"line\">    -&gt; DO</span><br><span class=\"line\">    -&gt; BEGIN</span><br><span class=\"line\">    -&gt; INSERT INTO first_table(first_column,second_column) VALUES(6,'6');</span><br><span class=\"line\">    -&gt; END $</span><br></pre></td></tr></table></figure>\n\n<p> 在创建好事件之后我们就不用管了，到了指定时间，MySQL服务器会帮我们自动执行的。</p>\n</li>\n</ol>\n<h2 id=\"查看事件\"><a href=\"#查看事件\" class=\"headerlink\" title=\"查看事件\"></a>查看事件</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看当前数据库中的所有事件的语句：</span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">EVENTS</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">查看某个具体的事件的定义:</span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">CREATE</span> <span class=\"keyword\">EVENT</span> 事件名;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除事件\"><a href=\"#删除事件\" class=\"headerlink\" title=\"删除事件\"></a>删除事件</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">EVENT</span> 事件名;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"事件使用注意事项\"><a href=\"#事件使用注意事项\" class=\"headerlink\" title=\"事件使用注意事项\"></a>事件使用注意事项</h2><p>默认情况下，MySQL服务器并不会帮助我们执行事件，除非我们在启动服务器的时候就指定了下边这个选项：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">event_scheduler = ON</span><br></pre></td></tr></table></figure>\n\n<p>如果在服务器已经启动的情况下，我们可以通过设置<code>event_scheduler</code>的系统变量来让MySQL服务器帮助我们执行事件，设置方式如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SET GLOBAL event_scheduler = ON;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"错误解决\"><a href=\"#错误解决\" class=\"headerlink\" title=\"错误解决\"></a>错误解决</h1><p>在MySql中创建自定义函数报错信息如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)</span><br></pre></td></tr></table></figure>\n\n<p>解决方法：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set global log_bin_trust_function_creators=1;</span><br></pre></td></tr></table></figure>"},{"title":"《Mysql技术内幕》学习笔记-Mysql文件","author":"Guyuqing","copyright":true,"comments":0,"date":"2019-08-19T11:23:00.000Z","_content":"# 文件种类\n\n* [参数文件](#参数文件)：告诉MySQL实例启动时在哪里可以找到数据库文件，并且指定某些初始化参数，这些参数定义了某种内存结构的大小等设置，还会介绍各种参数的类型。\n\n* [日志文件](#日志文件)：用来记录MySQL实例对某种条件做出响应时写入的文件，如错误日志文件、二进制日志文件、慢查询日志文件、查询日志文件等。\n\n* [socket文件](#套接字文件)：当用UNIX域套接字方式进行连接时需要的文件。\n\n* [pid文件](#pid文件)：MySQL实例的进程ID文件。\n\n* [MySQL表结构文件](#表结构定义文件)：用来存放MySQL表结构定义文件。\n\n* [存储引擎文件](#innoDB存储引擎文件)：因为MySQL表存储引擎的关系，每个存储引擎都会有自己的文件来保存各种数据。这些存储引擎真正存储了记录和索引等数据。本章主要介绍与InnoDB有关的存储引擎文件。”\n\n# 参数文件\n参数分为两类：\n* 动态参数：在 Mysql 实例运行中可以进行更改\n* 静态参数：在整个实例生命周期内都不得更改\n\n更改动态参数的语法如下：\n```sql\nSET\n| [global | session] system_var_name=expr\n| [@@global. | @@session. | @@] system_var_name = expr\n\n# 改变当前会话，不会改变全局\nSET read_buffer_size = 524288\n\n# 改变全局会话参数，不会改变当前\nSET @@global.read_buffer_size = 1048576;\n\n# 查询当前会话参数\nSELECT @@session.read_buffer_size;\n\n# 查询全局会话参数\nSELECT @@global.read_buffer_size;\n\n```\n`​global`：全局的，`session`：当前会话。 \n这种修改，并不最终修改配置文件my.cnf的参数值，所以重新启动后，参数还是按照配置文件中的加载。\n\n# 日志文件\nMySQL中常见的日志文件有：\n* 错误日志（error log）：对MySQL的启动、运行、关闭过程进行记录错误信息、警告信息。\n* 慢查询日志（slow query log）\n* 二进制日志（bin log）\n* 查询日志（log）\n\n## 慢查询日志\n在MySQL启动时设一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询日志文件中。\n\n<table>\n     <tr>\n         <th colspan=\"4\">参数</th>\n         <th colspan=\"4\">作用</th>\n     </tr>\n     <tr>\n         <th colspan=\"4\">set global log_slow_queries = on;</th>\n         <td colspan=\"4\">开启慢查询命令，默认启动慢查询</td>\n     </tr>\n     <tr>\n         <th colspan=\"4\" >set global long_query_time = 1;</th>\n         <td colspan=\"4\">设置慢查询时间超过1s即被认为慢查询，默认10s</td>\n     </tr>\n     <tr>\n         <th colspan=\"4\">set global log_queries_not_using_indeces = on;</th>\n         <td colspan=\"4\">如果SQL语句没有使用索引，会记录到慢查询中</td>\n     </tr>\n     <tr>\n         <th colspan=\"4\">set global log_throttle_queries_not_using_indexs = on;</th>\n         <td colspan=\"4\">设置每分钟允许记录到slow log的且未使用索引的SQL语句次数，默认为0，表示没有限制。</td>\n     </tr>\n</table> \n\n# 套接字文件\n\n# pid文件\n\n# 表结构定义文件\n\n# innoDB存储引擎文件\n\n# 参考\n* MySQL技术内幕：InnoDB存储引擎(第2版)\n* https://www.jianshu.com/p/c1ffd6956e6a\n* https://www.cnblogs.com/BlueMountain-HaggenDazs/p/9297883.html","source":"_posts/Mysql03.md","raw":"title: 《Mysql技术内幕》学习笔记-Mysql文件\ntags:\n  - 学习笔记\n  - MySql\n  - InnoDB\ncategories:\n  - Mysql\nauthor: Guyuqing\ncopyright: true\ncomments: false\ndate: 2019-08-19 19:23:00\n---\n# 文件种类\n\n* [参数文件](#参数文件)：告诉MySQL实例启动时在哪里可以找到数据库文件，并且指定某些初始化参数，这些参数定义了某种内存结构的大小等设置，还会介绍各种参数的类型。\n\n* [日志文件](#日志文件)：用来记录MySQL实例对某种条件做出响应时写入的文件，如错误日志文件、二进制日志文件、慢查询日志文件、查询日志文件等。\n\n* [socket文件](#套接字文件)：当用UNIX域套接字方式进行连接时需要的文件。\n\n* [pid文件](#pid文件)：MySQL实例的进程ID文件。\n\n* [MySQL表结构文件](#表结构定义文件)：用来存放MySQL表结构定义文件。\n\n* [存储引擎文件](#innoDB存储引擎文件)：因为MySQL表存储引擎的关系，每个存储引擎都会有自己的文件来保存各种数据。这些存储引擎真正存储了记录和索引等数据。本章主要介绍与InnoDB有关的存储引擎文件。”\n\n# 参数文件\n参数分为两类：\n* 动态参数：在 Mysql 实例运行中可以进行更改\n* 静态参数：在整个实例生命周期内都不得更改\n\n更改动态参数的语法如下：\n```sql\nSET\n| [global | session] system_var_name=expr\n| [@@global. | @@session. | @@] system_var_name = expr\n\n# 改变当前会话，不会改变全局\nSET read_buffer_size = 524288\n\n# 改变全局会话参数，不会改变当前\nSET @@global.read_buffer_size = 1048576;\n\n# 查询当前会话参数\nSELECT @@session.read_buffer_size;\n\n# 查询全局会话参数\nSELECT @@global.read_buffer_size;\n\n```\n`​global`：全局的，`session`：当前会话。 \n这种修改，并不最终修改配置文件my.cnf的参数值，所以重新启动后，参数还是按照配置文件中的加载。\n\n# 日志文件\nMySQL中常见的日志文件有：\n* 错误日志（error log）：对MySQL的启动、运行、关闭过程进行记录错误信息、警告信息。\n* 慢查询日志（slow query log）\n* 二进制日志（bin log）\n* 查询日志（log）\n\n## 慢查询日志\n在MySQL启动时设一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询日志文件中。\n\n<table>\n     <tr>\n         <th colspan=\"4\">参数</th>\n         <th colspan=\"4\">作用</th>\n     </tr>\n     <tr>\n         <th colspan=\"4\">set global log_slow_queries = on;</th>\n         <td colspan=\"4\">开启慢查询命令，默认启动慢查询</td>\n     </tr>\n     <tr>\n         <th colspan=\"4\" >set global long_query_time = 1;</th>\n         <td colspan=\"4\">设置慢查询时间超过1s即被认为慢查询，默认10s</td>\n     </tr>\n     <tr>\n         <th colspan=\"4\">set global log_queries_not_using_indeces = on;</th>\n         <td colspan=\"4\">如果SQL语句没有使用索引，会记录到慢查询中</td>\n     </tr>\n     <tr>\n         <th colspan=\"4\">set global log_throttle_queries_not_using_indexs = on;</th>\n         <td colspan=\"4\">设置每分钟允许记录到slow log的且未使用索引的SQL语句次数，默认为0，表示没有限制。</td>\n     </tr>\n</table> \n\n# 套接字文件\n\n# pid文件\n\n# 表结构定义文件\n\n# innoDB存储引擎文件\n\n# 参考\n* MySQL技术内幕：InnoDB存储引擎(第2版)\n* https://www.jianshu.com/p/c1ffd6956e6a\n* https://www.cnblogs.com/BlueMountain-HaggenDazs/p/9297883.html","slug":"Mysql03","published":1,"updated":"2019-09-25T14:29:48.414Z","layout":"post","photos":[],"link":"","_id":"ck8fb4adx002wk2o5e20hnos3","content":"<h1 id=\"文件种类\"><a href=\"#文件种类\" class=\"headerlink\" title=\"文件种类\"></a>文件种类</h1><ul>\n<li><p><a href=\"#参数文件\">参数文件</a>：告诉MySQL实例启动时在哪里可以找到数据库文件，并且指定某些初始化参数，这些参数定义了某种内存结构的大小等设置，还会介绍各种参数的类型。</p>\n</li>\n<li><p><a href=\"#日志文件\">日志文件</a>：用来记录MySQL实例对某种条件做出响应时写入的文件，如错误日志文件、二进制日志文件、慢查询日志文件、查询日志文件等。</p>\n</li>\n<li><p><a href=\"#套接字文件\">socket文件</a>：当用UNIX域套接字方式进行连接时需要的文件。</p>\n</li>\n<li><p><a href=\"#pid文件\">pid文件</a>：MySQL实例的进程ID文件。</p>\n</li>\n<li><p><a href=\"#表结构定义文件\">MySQL表结构文件</a>：用来存放MySQL表结构定义文件。</p>\n</li>\n<li><p><a href=\"#innoDB存储引擎文件\">存储引擎文件</a>：因为MySQL表存储引擎的关系，每个存储引擎都会有自己的文件来保存各种数据。这些存储引擎真正存储了记录和索引等数据。本章主要介绍与InnoDB有关的存储引擎文件。”</p>\n</li>\n</ul>\n<h1 id=\"参数文件\"><a href=\"#参数文件\" class=\"headerlink\" title=\"参数文件\"></a>参数文件</h1><p>参数分为两类：</p>\n<ul>\n<li>动态参数：在 Mysql 实例运行中可以进行更改</li>\n<li>静态参数：在整个实例生命周期内都不得更改</li>\n</ul>\n<p>更改动态参数的语法如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span></span><br><span class=\"line\">| [<span class=\"keyword\">global</span> | <span class=\"keyword\">session</span>] system_var_name=expr</span><br><span class=\"line\">| [@@global. | @@session. | @@] system_var_name = expr</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 改变当前会话，不会改变全局</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> read_buffer_size = <span class=\"number\">524288</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 改变全局会话参数，不会改变当前</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> @@global.read_buffer_size = <span class=\"number\">1048576</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查询当前会话参数</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> @@session.read_buffer_size;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查询全局会话参数</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> @@global.read_buffer_size;</span><br></pre></td></tr></table></figure>\n\n<p><code>​global</code>：全局的，<code>session</code>：当前会话。<br>这种修改，并不最终修改配置文件my.cnf的参数值，所以重新启动后，参数还是按照配置文件中的加载。</p>\n<h1 id=\"日志文件\"><a href=\"#日志文件\" class=\"headerlink\" title=\"日志文件\"></a>日志文件</h1><p>MySQL中常见的日志文件有：</p>\n<ul>\n<li>错误日志（error log）：对MySQL的启动、运行、关闭过程进行记录错误信息、警告信息。</li>\n<li>慢查询日志（slow query log）</li>\n<li>二进制日志（bin log）</li>\n<li>查询日志（log）</li>\n</ul>\n<h2 id=\"慢查询日志\"><a href=\"#慢查询日志\" class=\"headerlink\" title=\"慢查询日志\"></a>慢查询日志</h2><p>在MySQL启动时设一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询日志文件中。</p>\n<table>\n     <tr>\n         <th colspan=\"4\">参数</th>\n         <th colspan=\"4\">作用</th>\n     </tr>\n     <tr>\n         <th colspan=\"4\">set global log_slow_queries = on;</th>\n         <td colspan=\"4\">开启慢查询命令，默认启动慢查询</td>\n     </tr>\n     <tr>\n         <th colspan=\"4\">set global long_query_time = 1;</th>\n         <td colspan=\"4\">设置慢查询时间超过1s即被认为慢查询，默认10s</td>\n     </tr>\n     <tr>\n         <th colspan=\"4\">set global log_queries_not_using_indeces = on;</th>\n         <td colspan=\"4\">如果SQL语句没有使用索引，会记录到慢查询中</td>\n     </tr>\n     <tr>\n         <th colspan=\"4\">set global log_throttle_queries_not_using_indexs = on;</th>\n         <td colspan=\"4\">设置每分钟允许记录到slow log的且未使用索引的SQL语句次数，默认为0，表示没有限制。</td>\n     </tr>\n</table> \n\n<h1 id=\"套接字文件\"><a href=\"#套接字文件\" class=\"headerlink\" title=\"套接字文件\"></a>套接字文件</h1><h1 id=\"pid文件\"><a href=\"#pid文件\" class=\"headerlink\" title=\"pid文件\"></a>pid文件</h1><h1 id=\"表结构定义文件\"><a href=\"#表结构定义文件\" class=\"headerlink\" title=\"表结构定义文件\"></a>表结构定义文件</h1><h1 id=\"innoDB存储引擎文件\"><a href=\"#innoDB存储引擎文件\" class=\"headerlink\" title=\"innoDB存储引擎文件\"></a>innoDB存储引擎文件</h1><h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li>MySQL技术内幕：InnoDB存储引擎(第2版)</li>\n<li><a href=\"https://www.jianshu.com/p/c1ffd6956e6a\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/c1ffd6956e6a</a></li>\n<li><a href=\"https://www.cnblogs.com/BlueMountain-HaggenDazs/p/9297883.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/BlueMountain-HaggenDazs/p/9297883.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"文件种类\"><a href=\"#文件种类\" class=\"headerlink\" title=\"文件种类\"></a>文件种类</h1><ul>\n<li><p><a href=\"#参数文件\">参数文件</a>：告诉MySQL实例启动时在哪里可以找到数据库文件，并且指定某些初始化参数，这些参数定义了某种内存结构的大小等设置，还会介绍各种参数的类型。</p>\n</li>\n<li><p><a href=\"#日志文件\">日志文件</a>：用来记录MySQL实例对某种条件做出响应时写入的文件，如错误日志文件、二进制日志文件、慢查询日志文件、查询日志文件等。</p>\n</li>\n<li><p><a href=\"#套接字文件\">socket文件</a>：当用UNIX域套接字方式进行连接时需要的文件。</p>\n</li>\n<li><p><a href=\"#pid文件\">pid文件</a>：MySQL实例的进程ID文件。</p>\n</li>\n<li><p><a href=\"#表结构定义文件\">MySQL表结构文件</a>：用来存放MySQL表结构定义文件。</p>\n</li>\n<li><p><a href=\"#innoDB存储引擎文件\">存储引擎文件</a>：因为MySQL表存储引擎的关系，每个存储引擎都会有自己的文件来保存各种数据。这些存储引擎真正存储了记录和索引等数据。本章主要介绍与InnoDB有关的存储引擎文件。”</p>\n</li>\n</ul>\n<h1 id=\"参数文件\"><a href=\"#参数文件\" class=\"headerlink\" title=\"参数文件\"></a>参数文件</h1><p>参数分为两类：</p>\n<ul>\n<li>动态参数：在 Mysql 实例运行中可以进行更改</li>\n<li>静态参数：在整个实例生命周期内都不得更改</li>\n</ul>\n<p>更改动态参数的语法如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span></span><br><span class=\"line\">| [<span class=\"keyword\">global</span> | <span class=\"keyword\">session</span>] system_var_name=expr</span><br><span class=\"line\">| [@@global. | @@session. | @@] system_var_name = expr</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 改变当前会话，不会改变全局</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> read_buffer_size = <span class=\"number\">524288</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 改变全局会话参数，不会改变当前</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span> @@global.read_buffer_size = <span class=\"number\">1048576</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查询当前会话参数</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> @@session.read_buffer_size;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查询全局会话参数</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> @@global.read_buffer_size;</span><br></pre></td></tr></table></figure>\n\n<p><code>​global</code>：全局的，<code>session</code>：当前会话。<br>这种修改，并不最终修改配置文件my.cnf的参数值，所以重新启动后，参数还是按照配置文件中的加载。</p>\n<h1 id=\"日志文件\"><a href=\"#日志文件\" class=\"headerlink\" title=\"日志文件\"></a>日志文件</h1><p>MySQL中常见的日志文件有：</p>\n<ul>\n<li>错误日志（error log）：对MySQL的启动、运行、关闭过程进行记录错误信息、警告信息。</li>\n<li>慢查询日志（slow query log）</li>\n<li>二进制日志（bin log）</li>\n<li>查询日志（log）</li>\n</ul>\n<h2 id=\"慢查询日志\"><a href=\"#慢查询日志\" class=\"headerlink\" title=\"慢查询日志\"></a>慢查询日志</h2><p>在MySQL启动时设一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询日志文件中。</p>\n<table>\n     <tr>\n         <th colspan=\"4\">参数</th>\n         <th colspan=\"4\">作用</th>\n     </tr>\n     <tr>\n         <th colspan=\"4\">set global log_slow_queries = on;</th>\n         <td colspan=\"4\">开启慢查询命令，默认启动慢查询</td>\n     </tr>\n     <tr>\n         <th colspan=\"4\">set global long_query_time = 1;</th>\n         <td colspan=\"4\">设置慢查询时间超过1s即被认为慢查询，默认10s</td>\n     </tr>\n     <tr>\n         <th colspan=\"4\">set global log_queries_not_using_indeces = on;</th>\n         <td colspan=\"4\">如果SQL语句没有使用索引，会记录到慢查询中</td>\n     </tr>\n     <tr>\n         <th colspan=\"4\">set global log_throttle_queries_not_using_indexs = on;</th>\n         <td colspan=\"4\">设置每分钟允许记录到slow log的且未使用索引的SQL语句次数，默认为0，表示没有限制。</td>\n     </tr>\n</table> \n\n<h1 id=\"套接字文件\"><a href=\"#套接字文件\" class=\"headerlink\" title=\"套接字文件\"></a>套接字文件</h1><h1 id=\"pid文件\"><a href=\"#pid文件\" class=\"headerlink\" title=\"pid文件\"></a>pid文件</h1><h1 id=\"表结构定义文件\"><a href=\"#表结构定义文件\" class=\"headerlink\" title=\"表结构定义文件\"></a>表结构定义文件</h1><h1 id=\"innoDB存储引擎文件\"><a href=\"#innoDB存储引擎文件\" class=\"headerlink\" title=\"innoDB存储引擎文件\"></a>innoDB存储引擎文件</h1><h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li>MySQL技术内幕：InnoDB存储引擎(第2版)</li>\n<li><a href=\"https://www.jianshu.com/p/c1ffd6956e6a\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/c1ffd6956e6a</a></li>\n<li><a href=\"https://www.cnblogs.com/BlueMountain-HaggenDazs/p/9297883.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/BlueMountain-HaggenDazs/p/9297883.html</a></li>\n</ul>\n"},{"title":"《Mysql技术内幕》学习笔记-InnoDB存储引擎","author":"Guyuqing","copyright":true,"comments":0,"date":"2019-07-31T03:34:00.000Z","_content":"# 概述\n\n* InnoDB存储引擎最早由Innobase Oy公司开发，被包括在MySQL数据库所有的二进制发行版本中，\n* 从MySQL 5.5版本开始是默认的表存储引擎<font color=gray>（之前的版本InnoDB存储引擎仅在Windows下为默认的存储引擎）</font>\n* 第一个完整支持ACID事务的MySQL存储引擎<font color=gray>（BDB是第一个支持事务的MySQL存储引擎，现在已经停止开发）</font>\n* 特点：行锁设计、支持 MVCC、支持外键、提供一致性非锁定读、有效利用内存和 CPU\n<!-- more -->\n\n# 体系架构\n![innoDB体系结构图](Mysql02/innodb-Architecture.png)\nInnoDB存储引擎是由内存池、后台线程、磁盘存储三大部分组成。\n\n## 线程\n\nInnoDB 使用的是多线程模型, 其后台有多个不同的线程负责处理不同的任务\n\n### Master Thread\n\nMaster Thread是最核心的一个后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性。包括脏页刷新、合并插入缓冲、UNDO页的回收等。\n\n### IO Thread\n\n在 InnoDB 存储引擎中大量使用了异步IO(Async IO)来处理写IO请求, IO Thread的工作主要是负责这些 IO 请求的回调。\n\n<table>\n<tr>\n    <th>InnoDB 版本</th>\n    <th colspan=\"4\">线程</th>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.0之前 </td>\n    <td colspan=\"4\">4 个 io thread：write，read，insert buffer，log IO Thread.\n    <ul>\n        <li>在Linux下，IO Thread的数量不能进行调整</li>\n        <li>在Windows下可以通过参数 innodb_file_io_threads 来增大IO Thread</li>\n    </ul>\n    </td>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.0之后 </td>\n    <td colspan=\"4\">read 和 write IO thread 分别增大到了 4 个<br>\n    <ul>\n    <li>分别使用 innodb_read_io_threads 和 innodb_write_io_threads 设置线程数</li>\n    </ul>\n    </td>\n</tr>\n</table>  \n\n### Purge Thread\n\n事务提交后，其所使用的undo log可能不再需要，因此需要Purge Thread来回收已经分配并使用的UNDO页。\n\n<table>\n<tr>\n    <th>InnoDB 版本</th>\n    <th colspan=\"4\">作用</th>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.1之前 </td>\n    <td colspan=\"4\">purge 操作在 master thread 内完成</td>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.1之后 </td>\n    <td colspan=\"4\">purge 可以独立到单独的线程,减轻 master thread 工作,提高 cpu 利用率和提高性能<br>\n    <ul>\n    <li>MySQL数据库的配置文件<code>[mysqld]</code>中添加如下命令来启用独立的Purge Thread：</li>\n    <li>innodb_purge_threads=1 </li>\n    <li>1.1版本中，即使将 innodb_purge_threads 设为大于1，InnoDB存储引擎启动时也会将其设为1</li>\n    </ul>\n    </td>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.2之后</td>\n    <td colspan=\"4\">支持多个Purge Thread, 这样做可以加快UNDO页的回收，也能更进一步利用磁盘的随机读取性能</td>\n</tr>\n</table>                                  \n\n### Page Cleaner Thread\n\nPage Cleaner Thread的作用是取代Master Thread中脏页刷新的操作，\n减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高性能。\n\n## 内存\n\ninnoDB内存主要由[缓冲池(innodb buffer pool)](#缓冲池)、[重做日志缓冲(redo log buffer)](#重做日志缓冲)、[额外内存池组成(innodb additional men pool size)](#额外的内存池)组成\n\n### 缓冲池\n缓冲池是主存储器中的一个区域，用于在访问时缓存表和索引数据。缓冲池允许直接从内存处理常用数据，从而加快处理速度。\n在专用服务器上，通常会将最多80％的物理内存分配给缓冲池。\n读取流程：\n     ![流程图](Mysql02/read.png)\n更新流程：\n     ![流程图](Mysql02/write.png)\n\n因此缓冲池的大小影响数据库的整体性能。\n{% note info %}\n\n由于32位操作系统的限制，在该系统下最多将该值设置为3G。\n用户可以打开操作系统的`PAE`选项来获得32位操作系统下最大64GB内存的支持。\n为了让数据库使用更多的内存,建议数据库系统都采用 64 位操作系统。\n\n{% endnote %}\n\n|参数|版本|作用|\n|:---:|:---:|:---:|\n|innodb_buffer_pool_instances|从InnoDB 1.0.x开始|配置多个缓冲池实例，默认为1|\n \n#### 缓冲池中缓存的数据页类型\n \n* 索引页(index page)：缓存数据表索引\n* 数据页(data page)：缓存数据页，占缓冲池的绝大部分\n* undo页(undo Log Page)：undo页是保存事务，为回滚做准备的。\n* [插入缓冲](#插入缓冲)（insert buffer）：插入数据时要先插入到缓存池中。\n* 自适应哈希索引（adaptive hash index）： 除了B+ Tree索引外，在缓冲池还会维护一个哈希索引，以便在缓冲池中快速找到数据页。\n* InnoDB存储的锁信息（lock info）\n* 数据字典信息（data dictionary）\n    在MySQL中，数据字典信息内容就包括表结构、数据库名或表名、字段的数据类型、视图、索引、表字段信息、存储过程、触发器等内容。\n    InnoDB有自己的表缓存，可以称为表定义缓存或者数据字典。当InnoDB打开一张表，就增加一个对应的对象到数据字典。\n\n \n#### 缓冲池管理方式\n![三种list](Mysql02/three-list2.png)\n 1. **Free list**\n    当数据库刚启动时，LRU列表是空的，这时页都存放在Free list中。\n    当需要从缓冲池中分页时，从Free list中查找是否有可用的空闲页，若有则将该页从Free列表中删除，放入到LRU列表中,维持页数守恒。\n\n 2. **LRU list** \n     **LRU算法**：最频繁使用页在LRU列表的前端，最少使用的页在尾端。首先释放LRU列表中的尾端的页。缓冲池中页的大小默认为16KB。\n     **InnoDB优化的LRU算法(midpoint insertion strategy)**：将新读取到的页不放在首部，而是中间部位 `midpoint` 位置。目标是确保频繁访问\"热\"页面保留在缓冲池中。\n     ![lru](Mysql02/innodb-buffer-pool-list.jpg)\n\n     <table>\n     <tr>\n         <th>参数</th>\n         <th colspan=\"2\">作用</th>\n     </tr>\n     <tr>\n         <td style=\"text-align:center\"> innodb_old_blocks_pct </td>\n         <td colspan=\"2\">控制LRU列表中 old list 的百分比。<br>\n            默认值为 37，对应于原始固定比率3/8。<br>\n            值范围是 5（缓冲池中的新页面很快就会老化）到 95。\n         </td>\n     </tr>\n     <tr>\n         <td style=\"text-align:center\"> innodb_old_blocks_time </td>\n         <td colspan=\"2\">指定第一次访问页面之后的时间窗口（ms）<br>\n            在此期间可以访问该页面而不移动到LRU列表的前端<br>\n            默认值为 1000 ms\n         </td>\n     </tr>\n     </table> \n     \n     默认情况下，算法操作如下：\n     * 在默认配置下， `midpoint`位置在LRU list 的5/8处。\n     * `midpoint`是new sublist的尾部与old sublist的头部相交的边界。\n     * 当 InnoDB 将页面读入缓冲池时，将页插入`midpoint`位置(old sublist的头部)。\n     * 访问old sublist中的页 && 该页在old sublist中的停留时间超过innodb_old_blocks_time设置的时间，使其变`young`,将其移动到缓冲池的头部(new sublist的头部)。\n     * 当页从LRU列表的old部分加入到new部分时，称此时发生的操作为`page made young`，而因为innodb_old_blocks_time的设置而导致页没有从old部分移动到new部分的操作称为`page not made young`\n     * 在数据库操作中，被访问的页将移到new sublist的表头，这样一来，在new sublist中的未被访问的节点将逐渐往表尾移动，当移动过中点，将变为old list的节点。当表满时，old list末尾的页将会被移除。\n     \n {% note warning %}\n 为什么不采用朴素的LRU？\n 因为某些SQL操作会访问很多页，甚至全部页，但仅仅在该次查询操作，并不是活跃的热点数据。可能会使缓冲池中的页被刷新出，从而影响缓冲池的效率。\n {% endnote %}  \n \n  3. **Flush list**               \n    在LRU类表的页被修改后，称为脏页（Dirty Page），即缓存和硬盘的页数据不一致。\n    数据库会通过`CHECKPOINT`机制将脏页刷新回磁盘，Flush list中的页即为脏页列表。\n\n### 重做日志缓冲\n   {% note info %}\n    **什么是redo log？**\n    当数据库对数据做修改的时候，需要把数据页从磁盘读到buffer pool中，然后在buffer pool中进行修改，那么这个时候buffer pool中的数据页就与磁盘上的数据页内容不一致，称buffer pool的数据页为dirty page 脏数据。\n    如果发生非正常的DB服务重启，那么这些数据并没有同步到磁盘文件中（注意，同步到磁盘文件是个随机IO），会发生数据丢失。\n    如果这个时候，能够有一个文件，当缓冲池中的data page变更结束后，把相应修改记录记录到这个文件（注意，记录日志是顺序IO），那么当DB服务发生crash的情况，恢复DB的时候，也可以根据这个文件的记录内容，重新应用到磁盘文件，数据保持一致。\n    这个文件就是redo log ，用于记录 数据修改后的记录，顺序记录。<br>\n    **什么是undo log？**\n    undo日志用于存放数据修改被修改前的值。\n    假设修改表中 id=1 的行数据，把Name='B' 修改为Name = 'B2' ，那么undo日志就会用来存放Name='B'的记录，如果这个修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。\n   {% endnote %}  \n\n![lru](Mysql02/redo-buffer.png)\n  \n  重做日志缓冲不需要设置很大，通常情况下8M能满足大部分的应用场景。重做日志支持以下三种情况触发刷新：\n  * Master Thread每一秒将重做日志缓冲刷新到重做日志文件\n  * 每次事务提交时将重做日志缓冲刷新到重做日志文件\n  * 当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件\n  \n### 额外的内存池\n   在InnoDB存储引擎中，对内存的管理是通过一种称为内存堆的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。\n\n# Checkpoint技术 \n        \n{% note info %}    \n   **什么是Checkpoint？**\n   是一个数据库事件(event)，这个事件激活以后会触发数据库写进程(DBWR)将脏数据块写到磁盘中。                           \n   \n   **为什么需要Checkpoint技术？**\n   innoDB在事务提交时，先写重做日志，再修改内存数据这样，就产生了脏页。既然有重做日志保证数据持久性，查询时也可以从缓冲池页中取数据，那为什么还要刷新脏页到磁盘呢？如果重做日志可以无限增大，同时缓冲池足够大，能够缓存所有数据，那么是不需要将缓冲池中的脏页刷新到磁盘。但是，会有以下几个问题：\n   1) 服务器内存有限，缓冲池不够用，无法缓存全部数据\n   2) 重做日志无限增大成本要求太高\n   3) 宕机时如果重做全部日志恢复时间过长            \n                                         \n   **Checkpoint 解决了什么问题？**\n   1) 缩短短数据库的恢复时间\n   2) 缓冲池不够时，将脏页刷新到磁盘\n   3) 重做日志不可用时，刷新脏页\n{% endnote %} \n\n对于InnoDB存储引擎而言，其是通过LSN（Log Sequence Number）来标记版本的。每个页有LSN，重做日志中也有LSN，Checkpoint也有LSN。\n\ninnodb 内部有两种 checkpoint：\n1. **sharp checkpoint**：数据库关闭的时候将`所有的脏页`刷回到磁盘，默认方式，参数 innodb_fast_shudown=1\n2. **fuzzy checkpoint**：只刷新`部分脏页`\n    - master thread checkpoint：master thread 异步的以每秒或者每 10 秒的速度从缓冲池的脏页列表中刷新一定比列的也回磁盘\n         - 周期性，异步，读取flush list，找到脏页，写入磁盘\n    - flush_lru_list checkpoint：InnoDB要保证LRU列表中需要有差不多100个空闲页可供使用。如果没有这么多，就会将 lru list 尾部的页移除。如果这些页有脏页，就需要进行 checkpoint。\n         - innodb 1.1.x版本之前，检查在用户查询线程中,会阻塞用户查询操作。\n         - innodb 1.2.x版本之后，检查放到了单独的 page cleaner 线程中,可通过 **innodb_lru_scan_depth** 控制lru列表中可用页的数量，默认是1024。\n    - async/sync flush checkpoint：重做日志文件不可用时，强制将一些页刷新到磁盘。达到重做日志文件的大小阈值。\n         * checkpoint age = redo_log_lsn - cp_lsn\n            低水位=75% * total_redo_log_file_size\n            高水位=90% * total_redo_log_file_size\n         * checkpoint age < 低水位 \n          \t不需要刷新\n         * 低水位  <=  checkpoint age <= 高水位\n          \t会强制进行 checkpoint ，触发async flush， 根据flush_list的顺序，刷新足够多的脏页，直到 checkpoint age < 低水位\n         * checkpoint age > 高水位\n            会强制进行 checkpoint ，触发sync flush 根据flush_list的顺序，刷新脏页, 直到 checkpoint age < 低水位\n    \n    - dirty page too much checkpoint：当缓冲池中脏页的数量占据一定百分比时，强制进行Checkpoint，用来保证缓冲池中有足够的页，通过 [innodb_max_dirty_pages_pct](#innodb_max_dirty_pages_pct) 参数控制。\n              \n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>-------- 第二部分 --------</span>\n</div>\n                               \n# Master thread 工作方式\n\n## InnoDB 1.0.x 版本之前的 Master thread\nMaster thread 内部有多个循环 loop 组成：\n* 主循环 loop\n* 后台循环 backgroup loop\n* 刷新循环 flush loop\n* 暂停循环 suspend loop\n\n伪代码如下：\n\n```java\nvoid master_thread()\n{\n\tgoto loop;\n\t//主循环\n\tloop ：\n\tfor(int i = 0; i < 10; ++i){\n\t\tthread_sleep(1);\n\t\t//1. 日志缓冲刷新到磁盘，即使事务还没有提交\n\t\tdo log buffer flush to disk;\n\t\t//2. 根据前一秒IO操作小于5，合并插入缓冲\n\t\tif(last_one_second_ios < 5)\n\t\t\tdo merge at most 5 insert buffer;\n\t\t//3. 脏页的比例超过了阈值，刷新 100 个脏页到磁盘\n\t\tif(buf_get_modified_ratio_pct > innodb_max_dirty_pages_pct)\n\t\t\tdo buffer pool flush 100 dirty page;\n\t\t//4. 没有用户活动（数据库空闲时）或者数据库关闭（shutdown），切换到 backgroup loop\n\t\tif(no user activity)\n\t\t\tgoto backgroud loop;\n\t}\n\t\n\t//1. 前10秒IO操作小于200，刷新 100 个脏页到磁盘\n\tif(last_ten_second_ios < 200)\n\t\tdo buffer pool flush 100 dirty page;\n\t//2. 合并至多 5 个插入缓冲\n\tdo merge at most 5 insert buffer;\n\t//3. 将重做日志刷新到磁盘\n\tdo log buffer flush to disk;\n\t//4. 删除无用的 undo 页（每次最多尝试回收 20 个 undo 页）\n\tdo full purge;\n\t//5. 脏页比例超过 70% 刷新100 个脏页到磁盘，否则刷新 10 个脏页\n\tif ( buf_get_modified_ratio_pct ＞ 70 % )\n\t\tdo buffer pool flush 100 dirty page\n\telse\n\t\tbuffer pool flush 10 dirty page\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tgoto loop\n\t//后台循环\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tbackground loop :\n\t//1. 删除无用的 undo 页\n\tdo full purge\n\t//2. 合并 20 个插入缓冲\n\tdo merge 20 insert buffer\n\t//3.如果有任务，跳转到主循环，否则跳转到刷新循环\n\tif not idle\t\n\t\tgoto loop\n\telse\n\t\tgoto flush loop\n\t\n\t//刷新循环\n\tflush loop :\n\t//不断刷新100个脏页，直到脏页比例没有超过阈值\n\tdo buffer pool flush 100 dirty page\n\tif ( buf_get_modified_ratio_pct ＞ innodb_max_dirty_pages_pct )\n\t\tgoto flush loop\n\t//没有任务，跳转到暂停循环\n\tgoto suspend loop\n\t\n\t//暂停循环\n\tsuspend loop :\n\t//将主线程挂起，等待事件发生\n\tsuspend_thread()\n\twaiting event\n\tgoto loop;\n}\n\n```\n## InnoDB 1.2.x 版本之前的 Master thread\n1. 提高刷新脏页数量和合并插入数量，改善磁盘 IO 处理能力,刷新数量不再硬编码，而是使用百分比控制。\n    * 在合并插入缓冲的时候，合并插入缓冲的数量为 [innodb_io_capacity](#innodb_io_capacity) 的 5%\n    * 在从缓冲区刷新脏页的时候，刷新脏页的数量为 [innodb_io_capacity](#innodb_io_capacity)\n2. 增加了自适应刷新脏页功能。\n    * 1.0.x之前版本：脏页在缓冲池占比小于[innodb_max_dirty_pages_pct](#innodb_max_dirty_pages_pct)，不刷新脏页，大于则刷新100个脏页\n    * 1.0.x版本开始：引入[innodb_adaptive_flushing](#innodb_adaptive_flushing)参数，通过函数buf_flush_get_desired_flush_rate判断产生重做日志的速度来决定最适合的刷新脏页数量。\n3. full purge回收的Undo页的数量也不再硬编码，使用参数[innodb_purge_batch_size](#innodb_purge_batch_size)控制。\n\n<table>\n<tr>\n    <th colspan=\"2\">参数</th>\n    <th>InnoDB 版本</th>\n    <th colspan=\"3\">作用</th>\n</tr>\n<tr>\n    <td colspan=\"2\" style=\"text-align:center\"><span id=\"innodb_io_capacity\">innodb_io_capacity</span></td>\n    <td style=\"text-align:center\"> 1.0.x开始 </td>\n    <td colspan=\"3\">表示磁盘IO的吞吐量,默认值是200</td>\n</tr>\n<tr>\n    <td colspan=\"2\" rowspan=\"2\" style=\"text-align:center\"><span id=\"innodb_max_dirty_pages_pct\">innodb_max_dirty_pages_pct</span></td>\n    <td style=\"text-align:center\"> 1.0.x之前 </td>\n    <td colspan=\"3\">脏页在缓冲池中所占比率，默认值是90</td>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.0.x开始</td>\n    <td colspan=\"3\">默认值是75<br>加快刷新脏页的频率，保证了磁盘IO的负载。</td>                       \n</tr>\n<tr>\n    <td colspan=\"2\" style=\"text-align:center\"><span id=\"innodb_adaptive_flushing\">innodb_adaptive_flushing</span></td>\n    <td style=\"text-align:center\"> 1.0.x开始 </td>\n    <td colspan=\"3\">是否自适应刷新脏页，默认为 ON</td>\n</tr>\n<tr>\n    <td colspan=\"2\" style=\"text-align:center\"><span id=\"innodb_purge_batch_size\">innodb_purge_batch_size</span></td>\n    <td style=\"text-align:center\"> 1.0.x开始 </td>\n    <td colspan=\"3\">清除 undo 页时,表示一次删除多少页,默认是 20</td>\n</tr>\n</table>   \n\nMaster Thread的伪代码变为了下面的形式：\n\n```java\nvoid master_thread()\n{\n\tgoto loop;\n\t//主循环\n\tloop ：\n\tfor(int i = 0; i < 10; ++i){\n\t\tthread_sleep(1);\n\t\t//1. 日志缓冲刷新到磁盘，即使事务还没有提交\n\t\tdo log buffer flush to disk;\n\t\t//2. 根据前一秒IO操作小于5%innodb_io_capacity，合并插入缓冲\n\t\tif(last_one_second_ios < 5%innodb_io_capacity)\n\t\t\tdo merge 5%innodb_io_capacity insert buffer;\n\t\t//3. 脏页的比例超过了阈值，刷新 100%innodb_io_capacity 个脏页到磁盘\n\t\tif(buf_get_modified_ratio_pct > innodb_max_dirty_pages_pct)\n\t\t\tdo buffer pool flush 100%innodb_io_capacity dirty page;\n\t\t//4. 没有用户活动（数据库空闲时）或者数据库关闭（shutdown），切换到 backgroup loop\n\t\tif(no user activity)\n\t\t\tgoto backgroud loop;\n\t}\n\t\n\t//1. 前10秒IO操作小于innodb_io_capacity，刷新 innodb_io_capacity 个脏页到磁盘\n\tif(last_ten_second_ios < innodb_io_capacity)\n\t\tdo buffer pool flush 100%innodb_io_capacity dirty page;\n\t//2. 合并至多 5%innodb_io_capacity 个插入缓冲\n\tdo merge at most 5%innodb_io_capacity insert buffer;\n\t//3. 将重做日志刷新到磁盘\n\tdo log buffer flush to disk;\n\t//4. 删除无用的 undo 页（每次最多尝试回收 5%innodb_io_capacity 个 undo 页）\n\tdo full purge;\n\t//5. 脏页比例超过 70% 刷新 100%innodb_io_capacity 个脏页到磁盘，\n\t// 否则刷新 10%innodb_io_capacity 个脏页\n\tif ( buf_get_modified_ratio_pct ＞ 70 % )\n\t\tdo buffer pool flush 100%innodb_io_capacity dirty page\n\telse\n\t\tbuffer pool flush 10%innodb_io_capacity dirty page\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tgoto loop\n\t//后台循环\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tbackground loop :\n\t//1. 删除无用的 undo 页\n\tdo full purge\n\t//2. 合并 100%innodb_io_capacity 个插入缓冲\n\tdo merge 100%innodb_io_capacity insert buffer\n\t//3.如果有任务，跳转到主循环，否则跳转到刷新循环\n\tif not idle\t\n\t\tgoto loop\n\telse\n\t\tgoto flush loop\n\t\n\t//刷新循环\n\tflush loop :\n\t//不断刷新 100%innodb_io_capacity 个脏页，直到脏页比例没有超过阈值\n\tdo buffer pool flush 100%innodb_io_capacity dirty page\n\tif ( buf_get_modified_ratio_pct ＞ innodb_max_dirty_pages_pct )\n\t\tgoto flush loop\n\t//没有任务，跳转到暂停循环\n\tgoto suspend loop\n\t\n\t//暂停循环\n\tsuspend loop :\n\t//将主线程挂起，等待事件发生\n\tsuspend_thread()\n\twaiting event\n\tgoto loop;\n}\n\n```\n## InnoDB 1.2.x 版本的 Master thread\n\nInnoDB 1.2.x 版本中再次对 Master Thread 进行了优化，伪代码如下：\n```java\nif InnoDB is idle\n//之前版本中每10秒的操作\nsrv_master_do_idle_tasks();\nelse\n//之前版本中每秒的操作\nsrv_master_do_active_tasks();\n```\n对于刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。\n\n\n# InnoDB 关键特性\n关键特性包括：\n* 插入缓冲 insert buffer\n* 两次写 double write\n* 自适应哈希索引 adaptive hash index\n* 异步 io async io\n* 刷新邻接页 flush neighbor page\n\n## 插入缓冲\n\n### 聚集索引（一级索引）\n表在存储的时候按照主键排序进行存储，不需要磁盘的随机读取，插入效率高。\n非叶子节点存放的是键值，叶子节点存放的是行数据，称之为数据页。\n\n### 辅助索引（二级索引）\n除了聚集索引之外的索引都可以称之为辅助索引，叶子节点中存放的是主键的键值。叶子节点的插入不再有序，这时就需要离散访问非聚集索引页，插入性能变低。\n一张表可以存在多个辅助索引，但是只能有一个聚集索引，通过辅助索引来查找对应的航记录的话，需要进行两步，第一步通过辅助索引来确定对应的主键，第二步通过相应的主键值在聚集索引中查询到对应的行记录，也就是进行两次B+树搜索。\n\n### 索引数据页的更新（针对二级索引）\n![index更新流程](Mysql02/index-update.png)\n表数据更新的同时也会更新对应的表的索引数据，所以：对表进行insert delete update时，很可能会产生大量的物理读(物理读索引数据页)\n\n![引入insertbuffer后index更新流程](Mysql02/insert-buffer.png)\n\n### 1. insert buffer\nInsert Buffer的使用流程：\n![Insert Buffer的使用流程](Mysql02/Insert-Buffer.svg)\n\n#### 插入缓冲的启用需要满足以下两个条件：\n1）索引是辅助索引（secondary index）\n2）索引不是唯一的：整个索引数据被切分为2部分，无法保证唯一性。\n\n#### insert buffer结构\ninsert buffer的数据结构是B+树，全局只有一颗B+树。\nB+树的非叶子节点是Search key，构造结构为(space,marker,offset)。\n* space：待插入记录所在表的表空间id。每个表都有唯一的表空间id，通过表空间id可以查出是哪张表。\n* marker：兼容之前的版本。\n* offset：在表空间中页的偏移量。\n\n当一个辅助索引要插入到(space,offset)中时，如果该页不在缓冲池中，则按上述规则构造一个search key，将该记录插入到insert buffer中。\n但是如果该页一直在insert buffer中，不断有记录插入到同一个索引页中，那么该索引页的空间就会逐渐缩小，要出现B+树节点的分裂情况，这时就不能进行insert buffer了。\n所以，我们需要一个机制来管理每个页面的剩余空闲空间，这就是`Insert buffer bitmap`。\n每隔page_size个页面，就是一个Insert buffer bitmap page。\n例如：若page_size = 16384(16k)，那么page_no为0，16384，32768，…的page，就是Insert buffer bitmap page，Bitmap page的功能，就是管理其后连续的page_size – 1个page的空间使用率。\n每个辅助索引页在Insert buffer bitmap中占用4bit。\n\n#### merge insert buffer 发生条件\n* 辅助索引页被读取到buffer pool中：正常的select查询操作，索引页被调入内存，该索引页对应在insert buffer中的索引更改记录就会发生merge操作。\n* Insert buffer bitmap page追踪到该索引页无可用空间时。\n* Master Thread。\n\n#### insert buffer 刷新到磁盘条件\n* 有一个后台线程，会认为数据库空闲时；\n* 数据库缓冲池不够用时；\n* 数据库正常关闭时；\n* redo log写满时：_几乎不会出现redo log写满，此时整个数据库处于无法写入的不可用状态_\n\n#### 插入缓冲主要带来如下两个坏处\n1）可能导致数据库宕机后实例恢复时间变长。如果应用程序执行大量的插入和更新操作，且涉及非唯一的聚集索引，一旦出现宕机，这时就有大量内存中的插入缓冲区数据没有合并至索引页中，导致实例恢复时间会很长。\n2）在写密集的情况下，插入缓冲会占用过多的缓冲池内存，默认情况下最大可以占用1/2，这在实际应用中会带来一定的问题。\n\n### 2. change buffer\n\nInnoDB从1.0.x版本开始引入了Change Buffer，可以将其视为Insert Buffer的升级。\n从这个版本开始，InnoDB可以对DML操作——Insert、Delete、Update`(delete+insert)`都进行缓冲，\n它们分别是：Insert Buffer, Delete Buffer,Purge Buffer。\n对一个记录进行 update 操作有两个过程\n\n* 将记录标记为删除：delete buffer\n* 将记录真正删除：pruge buffer\n\n<table>\n<tr>\n    <th colspan=\"2\">参数</th>\n    <th>InnoDB 版本</th>\n    <th colspan=\"3\">作用</th>\n</tr>\n<tr>\n    <td colspan=\"2\" style=\"text-align:center\"><span id=\"innodb_change_buffering\">innodb_change_buffering</span></td>\n    <td style=\"text-align:center\"> 1.0.x开始 </td>\n    <td colspan=\"3\">用来开启各种Buffer选项，默认值是all<br>\n        <ul>\n        <li>inserts</li>\n        <li>deletes</li>\n        <li>purges</li>\n        <li>changes：开启 inserts 和 deletes</li>\n        <li>all：都开启</li>\n        <li>none：都不开启</li>\n        </ul>\n    </td>\n</tr>\n<tr>\n    <td colspan=\"2\" rowspan=\"2\" style=\"text-align:center\"><span id=\"innodb_change_buffer_max_size\">innodb_change_buffer_max_size</span></td>\n    <td style=\"text-align:center\"> 1.2.x开始 </td>\n    <td colspan=\"3\">用来控制change buffer最大使用内存数量<br>默认值为25,表示最多使用1/4的缓存池空间<br>该参数最大有效值是50</td>\n</tr>\n</table>  \n\n## 两次写\n提高innodb的可靠性，用来解决部分写失败(partial page write页断裂)。\n\n### 脏页刷新到磁盘风险\n\nIO的最小单位：\n* 数据库IO的最小单位是16K（MySQL默认，oracle是8K）\n* 文件系统IO的最小单位是4K（也有1K的）\n* 磁盘IO的最小单位是512字节\n\n因此，存在IO写入导致page损坏的风险：\n![IO风险](Mysql02/IO.png)\n\n提高innodb的可靠性，用来解决部分写失败(partial page write页断裂)。\n\n### Double write解决了什么问题\n一个数据页的大小是16K，假设在把内存中的脏页写到数据库的时候，写了8K突然宕机了，也就是说前8K数据是新的，后8K是旧的，那么磁盘数据库这个数据页就是不完整的，是一个坏掉的数据页，这种情况被称为部分`写失效`\n\n**那么可不可以通过 redo log 来进行恢复呢？**\nredo记录的是对页的修改，只能恢复校验完整（还没写）的页，不能修复坏掉的数据页，所以这个数据就丢失了，可能会造成数据不一致，所以需要double write。\n\n{% note info %}   \n为什么 redo log 不需要 doublewrite 的支持？\n因为 redo log 写入的单位就是 512 字节，也就是磁盘 IO 的最小单位，所以无所谓数据损坏。\n{% endnote %}   \n\n### 两次写工作流程\n![两次写流程](Mysql02/doublewrite.png)\ndoublewrite由两部分组成，一部分为内存中的doublewrite buffer，其大小为2MB，另一部分是磁盘上共享表空间(ibdata x)中连续的128个页，即2个区(extent)，大小也是2M。\n1. 当一系列机制触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先拷贝至内存中的doublewrite buffer中；\n2. 接着从两次写缓冲区分两次写入磁盘共享表空间中(连续存储，顺序写，性能很高)，每次写1MB；\n3. 待第二步完成后，再将doublewrite buffer中的脏页数据写入实际的各个表空间文件(离散写)；(脏页数据固化后，即进行标记对应doublewrite数据可覆盖)\n\n现在我们来分析一下为什么 double write 可以生效。当宕机发生时，有那么几种情况：\n1. 磁盘还未写，此时可以通过 redo log 恢复；\n2. 磁盘正在进行从内存到共享表空间的写，此时数据文件中的页还没开始被写入，因此也同样可以通过 redo log 恢复；\n3. 磁盘正在写数据文件，此时共享表空间已经写完，可以从共享表空间拷贝页的副本到数据文件实现恢复。\n\n## 自适应哈希索引\n\n哈希：一次就可以定位数据\n\nB+树：取决于树的高度，生产环境一般是 3-4 层，所以需要查询 3-4 次\n\n自适应哈希索引 AHI（adaptive hash index）建立条件：观察到一个访问模式访问频繁，就会建立哈希索引\n* 通过该模式访问了 100 次（模式：where x = ?）\n* 页通过该模式访问了 N 次，其中 N = 页的记录总数⁄16\n\nInnoDB 存储引擎官方文档显示，启用 AHI 后,读取和写入速度可以提高 2 倍，辅助索引的连接操作性能可以提高 5 倍。\n\n## 异步IO\n为了提高磁盘的操作性能，当前的数据库系统都采用异步IO的方式处理磁盘操作。用户可以在发出一个IO请求胡立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作完成，这就是AIO。\nAIO的另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO, 这样可以提高IOPS(Input/Output Per Second)的性能。\n\n例如：用户访问页的（space, page_no)为(8,6) (8,7) (8,8)，每个页的大小为16KB，同步IO需要3次IO操作。可以优化为从(8,6)开始读取48KB。\n\n## 刷新临接页\n\n当刷新一个脏页时，InnoDB会检查该页所在extent的所有页，如果是脏页，一起刷新。\n\n<table>\n    <tr>\n        <th colspan=\"2\">参数</th>\n        <th>版本</th>\n        <th colspan=\"3\">作用</th>\n    </tr>\n    <tr>\n        <th colspan=\"2\" style=\"text-align:center\" >innodb_flush_neighbors</th>\n        <td style=\"text-align:center\">1.2.x开始</td>\n        <td colspan=\"3\">控制是否启用该特性</td>\n    </tr>\n</table> \n\n\n# 参考：\n* http://oohcode.com/2015/10/14/InnoDB-Key-Features/\n* https://chyroc.cn/posts/innodb-storage-engine-reading-1/\n* https://www.cnblogs.com/zhoujinyi/archive/2013/04/11/2988923.html\n* http://huzb.me/2019/01/14/%E6%8F%92%E5%85%A5%E7%BC%93%E5%86%B2%E3%80%81%E4%B8%A4%E6%AC%A1%E5%86%99%E5%92%8C%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95/\n* https://blog.csdn.net/tanliqing2010/article/details/81509539\n* https://www.cnblogs.com/geaozhang/p/7341333.html\n* https://draveness.me/mysql-innodb\n* http://richfisher.me/blog/2017/12/18/innodb-notes/\n* https://www.docs4dev.com/docs/zh/mysql/5.7/reference/innodb-architecture.html#innodb%E6%9E%B6%E6%9E%84\n* MySQL技术内幕：InnoDB存储引擎(第2版)","source":"_posts/Mysql02.md","raw":"title: 《Mysql技术内幕》学习笔记-InnoDB存储引擎\ntags:\n  - 学习笔记\n  - MySql\n  - InnoDB\ncategories:\n  - Mysql\nauthor: Guyuqing\ncopyright: true\ncomments: false\ndate: 2019-07-31 11:34:00\n---\n# 概述\n\n* InnoDB存储引擎最早由Innobase Oy公司开发，被包括在MySQL数据库所有的二进制发行版本中，\n* 从MySQL 5.5版本开始是默认的表存储引擎<font color=gray>（之前的版本InnoDB存储引擎仅在Windows下为默认的存储引擎）</font>\n* 第一个完整支持ACID事务的MySQL存储引擎<font color=gray>（BDB是第一个支持事务的MySQL存储引擎，现在已经停止开发）</font>\n* 特点：行锁设计、支持 MVCC、支持外键、提供一致性非锁定读、有效利用内存和 CPU\n<!-- more -->\n\n# 体系架构\n![innoDB体系结构图](Mysql02/innodb-Architecture.png)\nInnoDB存储引擎是由内存池、后台线程、磁盘存储三大部分组成。\n\n## 线程\n\nInnoDB 使用的是多线程模型, 其后台有多个不同的线程负责处理不同的任务\n\n### Master Thread\n\nMaster Thread是最核心的一个后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性。包括脏页刷新、合并插入缓冲、UNDO页的回收等。\n\n### IO Thread\n\n在 InnoDB 存储引擎中大量使用了异步IO(Async IO)来处理写IO请求, IO Thread的工作主要是负责这些 IO 请求的回调。\n\n<table>\n<tr>\n    <th>InnoDB 版本</th>\n    <th colspan=\"4\">线程</th>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.0之前 </td>\n    <td colspan=\"4\">4 个 io thread：write，read，insert buffer，log IO Thread.\n    <ul>\n        <li>在Linux下，IO Thread的数量不能进行调整</li>\n        <li>在Windows下可以通过参数 innodb_file_io_threads 来增大IO Thread</li>\n    </ul>\n    </td>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.0之后 </td>\n    <td colspan=\"4\">read 和 write IO thread 分别增大到了 4 个<br>\n    <ul>\n    <li>分别使用 innodb_read_io_threads 和 innodb_write_io_threads 设置线程数</li>\n    </ul>\n    </td>\n</tr>\n</table>  \n\n### Purge Thread\n\n事务提交后，其所使用的undo log可能不再需要，因此需要Purge Thread来回收已经分配并使用的UNDO页。\n\n<table>\n<tr>\n    <th>InnoDB 版本</th>\n    <th colspan=\"4\">作用</th>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.1之前 </td>\n    <td colspan=\"4\">purge 操作在 master thread 内完成</td>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.1之后 </td>\n    <td colspan=\"4\">purge 可以独立到单独的线程,减轻 master thread 工作,提高 cpu 利用率和提高性能<br>\n    <ul>\n    <li>MySQL数据库的配置文件<code>[mysqld]</code>中添加如下命令来启用独立的Purge Thread：</li>\n    <li>innodb_purge_threads=1 </li>\n    <li>1.1版本中，即使将 innodb_purge_threads 设为大于1，InnoDB存储引擎启动时也会将其设为1</li>\n    </ul>\n    </td>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.2之后</td>\n    <td colspan=\"4\">支持多个Purge Thread, 这样做可以加快UNDO页的回收，也能更进一步利用磁盘的随机读取性能</td>\n</tr>\n</table>                                  \n\n### Page Cleaner Thread\n\nPage Cleaner Thread的作用是取代Master Thread中脏页刷新的操作，\n减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高性能。\n\n## 内存\n\ninnoDB内存主要由[缓冲池(innodb buffer pool)](#缓冲池)、[重做日志缓冲(redo log buffer)](#重做日志缓冲)、[额外内存池组成(innodb additional men pool size)](#额外的内存池)组成\n\n### 缓冲池\n缓冲池是主存储器中的一个区域，用于在访问时缓存表和索引数据。缓冲池允许直接从内存处理常用数据，从而加快处理速度。\n在专用服务器上，通常会将最多80％的物理内存分配给缓冲池。\n读取流程：\n     ![流程图](Mysql02/read.png)\n更新流程：\n     ![流程图](Mysql02/write.png)\n\n因此缓冲池的大小影响数据库的整体性能。\n{% note info %}\n\n由于32位操作系统的限制，在该系统下最多将该值设置为3G。\n用户可以打开操作系统的`PAE`选项来获得32位操作系统下最大64GB内存的支持。\n为了让数据库使用更多的内存,建议数据库系统都采用 64 位操作系统。\n\n{% endnote %}\n\n|参数|版本|作用|\n|:---:|:---:|:---:|\n|innodb_buffer_pool_instances|从InnoDB 1.0.x开始|配置多个缓冲池实例，默认为1|\n \n#### 缓冲池中缓存的数据页类型\n \n* 索引页(index page)：缓存数据表索引\n* 数据页(data page)：缓存数据页，占缓冲池的绝大部分\n* undo页(undo Log Page)：undo页是保存事务，为回滚做准备的。\n* [插入缓冲](#插入缓冲)（insert buffer）：插入数据时要先插入到缓存池中。\n* 自适应哈希索引（adaptive hash index）： 除了B+ Tree索引外，在缓冲池还会维护一个哈希索引，以便在缓冲池中快速找到数据页。\n* InnoDB存储的锁信息（lock info）\n* 数据字典信息（data dictionary）\n    在MySQL中，数据字典信息内容就包括表结构、数据库名或表名、字段的数据类型、视图、索引、表字段信息、存储过程、触发器等内容。\n    InnoDB有自己的表缓存，可以称为表定义缓存或者数据字典。当InnoDB打开一张表，就增加一个对应的对象到数据字典。\n\n \n#### 缓冲池管理方式\n![三种list](Mysql02/three-list2.png)\n 1. **Free list**\n    当数据库刚启动时，LRU列表是空的，这时页都存放在Free list中。\n    当需要从缓冲池中分页时，从Free list中查找是否有可用的空闲页，若有则将该页从Free列表中删除，放入到LRU列表中,维持页数守恒。\n\n 2. **LRU list** \n     **LRU算法**：最频繁使用页在LRU列表的前端，最少使用的页在尾端。首先释放LRU列表中的尾端的页。缓冲池中页的大小默认为16KB。\n     **InnoDB优化的LRU算法(midpoint insertion strategy)**：将新读取到的页不放在首部，而是中间部位 `midpoint` 位置。目标是确保频繁访问\"热\"页面保留在缓冲池中。\n     ![lru](Mysql02/innodb-buffer-pool-list.jpg)\n\n     <table>\n     <tr>\n         <th>参数</th>\n         <th colspan=\"2\">作用</th>\n     </tr>\n     <tr>\n         <td style=\"text-align:center\"> innodb_old_blocks_pct </td>\n         <td colspan=\"2\">控制LRU列表中 old list 的百分比。<br>\n            默认值为 37，对应于原始固定比率3/8。<br>\n            值范围是 5（缓冲池中的新页面很快就会老化）到 95。\n         </td>\n     </tr>\n     <tr>\n         <td style=\"text-align:center\"> innodb_old_blocks_time </td>\n         <td colspan=\"2\">指定第一次访问页面之后的时间窗口（ms）<br>\n            在此期间可以访问该页面而不移动到LRU列表的前端<br>\n            默认值为 1000 ms\n         </td>\n     </tr>\n     </table> \n     \n     默认情况下，算法操作如下：\n     * 在默认配置下， `midpoint`位置在LRU list 的5/8处。\n     * `midpoint`是new sublist的尾部与old sublist的头部相交的边界。\n     * 当 InnoDB 将页面读入缓冲池时，将页插入`midpoint`位置(old sublist的头部)。\n     * 访问old sublist中的页 && 该页在old sublist中的停留时间超过innodb_old_blocks_time设置的时间，使其变`young`,将其移动到缓冲池的头部(new sublist的头部)。\n     * 当页从LRU列表的old部分加入到new部分时，称此时发生的操作为`page made young`，而因为innodb_old_blocks_time的设置而导致页没有从old部分移动到new部分的操作称为`page not made young`\n     * 在数据库操作中，被访问的页将移到new sublist的表头，这样一来，在new sublist中的未被访问的节点将逐渐往表尾移动，当移动过中点，将变为old list的节点。当表满时，old list末尾的页将会被移除。\n     \n {% note warning %}\n 为什么不采用朴素的LRU？\n 因为某些SQL操作会访问很多页，甚至全部页，但仅仅在该次查询操作，并不是活跃的热点数据。可能会使缓冲池中的页被刷新出，从而影响缓冲池的效率。\n {% endnote %}  \n \n  3. **Flush list**               \n    在LRU类表的页被修改后，称为脏页（Dirty Page），即缓存和硬盘的页数据不一致。\n    数据库会通过`CHECKPOINT`机制将脏页刷新回磁盘，Flush list中的页即为脏页列表。\n\n### 重做日志缓冲\n   {% note info %}\n    **什么是redo log？**\n    当数据库对数据做修改的时候，需要把数据页从磁盘读到buffer pool中，然后在buffer pool中进行修改，那么这个时候buffer pool中的数据页就与磁盘上的数据页内容不一致，称buffer pool的数据页为dirty page 脏数据。\n    如果发生非正常的DB服务重启，那么这些数据并没有同步到磁盘文件中（注意，同步到磁盘文件是个随机IO），会发生数据丢失。\n    如果这个时候，能够有一个文件，当缓冲池中的data page变更结束后，把相应修改记录记录到这个文件（注意，记录日志是顺序IO），那么当DB服务发生crash的情况，恢复DB的时候，也可以根据这个文件的记录内容，重新应用到磁盘文件，数据保持一致。\n    这个文件就是redo log ，用于记录 数据修改后的记录，顺序记录。<br>\n    **什么是undo log？**\n    undo日志用于存放数据修改被修改前的值。\n    假设修改表中 id=1 的行数据，把Name='B' 修改为Name = 'B2' ，那么undo日志就会用来存放Name='B'的记录，如果这个修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。\n   {% endnote %}  \n\n![lru](Mysql02/redo-buffer.png)\n  \n  重做日志缓冲不需要设置很大，通常情况下8M能满足大部分的应用场景。重做日志支持以下三种情况触发刷新：\n  * Master Thread每一秒将重做日志缓冲刷新到重做日志文件\n  * 每次事务提交时将重做日志缓冲刷新到重做日志文件\n  * 当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件\n  \n### 额外的内存池\n   在InnoDB存储引擎中，对内存的管理是通过一种称为内存堆的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。\n\n# Checkpoint技术 \n        \n{% note info %}    \n   **什么是Checkpoint？**\n   是一个数据库事件(event)，这个事件激活以后会触发数据库写进程(DBWR)将脏数据块写到磁盘中。                           \n   \n   **为什么需要Checkpoint技术？**\n   innoDB在事务提交时，先写重做日志，再修改内存数据这样，就产生了脏页。既然有重做日志保证数据持久性，查询时也可以从缓冲池页中取数据，那为什么还要刷新脏页到磁盘呢？如果重做日志可以无限增大，同时缓冲池足够大，能够缓存所有数据，那么是不需要将缓冲池中的脏页刷新到磁盘。但是，会有以下几个问题：\n   1) 服务器内存有限，缓冲池不够用，无法缓存全部数据\n   2) 重做日志无限增大成本要求太高\n   3) 宕机时如果重做全部日志恢复时间过长            \n                                         \n   **Checkpoint 解决了什么问题？**\n   1) 缩短短数据库的恢复时间\n   2) 缓冲池不够时，将脏页刷新到磁盘\n   3) 重做日志不可用时，刷新脏页\n{% endnote %} \n\n对于InnoDB存储引擎而言，其是通过LSN（Log Sequence Number）来标记版本的。每个页有LSN，重做日志中也有LSN，Checkpoint也有LSN。\n\ninnodb 内部有两种 checkpoint：\n1. **sharp checkpoint**：数据库关闭的时候将`所有的脏页`刷回到磁盘，默认方式，参数 innodb_fast_shudown=1\n2. **fuzzy checkpoint**：只刷新`部分脏页`\n    - master thread checkpoint：master thread 异步的以每秒或者每 10 秒的速度从缓冲池的脏页列表中刷新一定比列的也回磁盘\n         - 周期性，异步，读取flush list，找到脏页，写入磁盘\n    - flush_lru_list checkpoint：InnoDB要保证LRU列表中需要有差不多100个空闲页可供使用。如果没有这么多，就会将 lru list 尾部的页移除。如果这些页有脏页，就需要进行 checkpoint。\n         - innodb 1.1.x版本之前，检查在用户查询线程中,会阻塞用户查询操作。\n         - innodb 1.2.x版本之后，检查放到了单独的 page cleaner 线程中,可通过 **innodb_lru_scan_depth** 控制lru列表中可用页的数量，默认是1024。\n    - async/sync flush checkpoint：重做日志文件不可用时，强制将一些页刷新到磁盘。达到重做日志文件的大小阈值。\n         * checkpoint age = redo_log_lsn - cp_lsn\n            低水位=75% * total_redo_log_file_size\n            高水位=90% * total_redo_log_file_size\n         * checkpoint age < 低水位 \n          \t不需要刷新\n         * 低水位  <=  checkpoint age <= 高水位\n          \t会强制进行 checkpoint ，触发async flush， 根据flush_list的顺序，刷新足够多的脏页，直到 checkpoint age < 低水位\n         * checkpoint age > 高水位\n            会强制进行 checkpoint ，触发sync flush 根据flush_list的顺序，刷新脏页, 直到 checkpoint age < 低水位\n    \n    - dirty page too much checkpoint：当缓冲池中脏页的数量占据一定百分比时，强制进行Checkpoint，用来保证缓冲池中有足够的页，通过 [innodb_max_dirty_pages_pct](#innodb_max_dirty_pages_pct) 参数控制。\n              \n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>-------- 第二部分 --------</span>\n</div>\n                               \n# Master thread 工作方式\n\n## InnoDB 1.0.x 版本之前的 Master thread\nMaster thread 内部有多个循环 loop 组成：\n* 主循环 loop\n* 后台循环 backgroup loop\n* 刷新循环 flush loop\n* 暂停循环 suspend loop\n\n伪代码如下：\n\n```java\nvoid master_thread()\n{\n\tgoto loop;\n\t//主循环\n\tloop ：\n\tfor(int i = 0; i < 10; ++i){\n\t\tthread_sleep(1);\n\t\t//1. 日志缓冲刷新到磁盘，即使事务还没有提交\n\t\tdo log buffer flush to disk;\n\t\t//2. 根据前一秒IO操作小于5，合并插入缓冲\n\t\tif(last_one_second_ios < 5)\n\t\t\tdo merge at most 5 insert buffer;\n\t\t//3. 脏页的比例超过了阈值，刷新 100 个脏页到磁盘\n\t\tif(buf_get_modified_ratio_pct > innodb_max_dirty_pages_pct)\n\t\t\tdo buffer pool flush 100 dirty page;\n\t\t//4. 没有用户活动（数据库空闲时）或者数据库关闭（shutdown），切换到 backgroup loop\n\t\tif(no user activity)\n\t\t\tgoto backgroud loop;\n\t}\n\t\n\t//1. 前10秒IO操作小于200，刷新 100 个脏页到磁盘\n\tif(last_ten_second_ios < 200)\n\t\tdo buffer pool flush 100 dirty page;\n\t//2. 合并至多 5 个插入缓冲\n\tdo merge at most 5 insert buffer;\n\t//3. 将重做日志刷新到磁盘\n\tdo log buffer flush to disk;\n\t//4. 删除无用的 undo 页（每次最多尝试回收 20 个 undo 页）\n\tdo full purge;\n\t//5. 脏页比例超过 70% 刷新100 个脏页到磁盘，否则刷新 10 个脏页\n\tif ( buf_get_modified_ratio_pct ＞ 70 % )\n\t\tdo buffer pool flush 100 dirty page\n\telse\n\t\tbuffer pool flush 10 dirty page\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tgoto loop\n\t//后台循环\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tbackground loop :\n\t//1. 删除无用的 undo 页\n\tdo full purge\n\t//2. 合并 20 个插入缓冲\n\tdo merge 20 insert buffer\n\t//3.如果有任务，跳转到主循环，否则跳转到刷新循环\n\tif not idle\t\n\t\tgoto loop\n\telse\n\t\tgoto flush loop\n\t\n\t//刷新循环\n\tflush loop :\n\t//不断刷新100个脏页，直到脏页比例没有超过阈值\n\tdo buffer pool flush 100 dirty page\n\tif ( buf_get_modified_ratio_pct ＞ innodb_max_dirty_pages_pct )\n\t\tgoto flush loop\n\t//没有任务，跳转到暂停循环\n\tgoto suspend loop\n\t\n\t//暂停循环\n\tsuspend loop :\n\t//将主线程挂起，等待事件发生\n\tsuspend_thread()\n\twaiting event\n\tgoto loop;\n}\n\n```\n## InnoDB 1.2.x 版本之前的 Master thread\n1. 提高刷新脏页数量和合并插入数量，改善磁盘 IO 处理能力,刷新数量不再硬编码，而是使用百分比控制。\n    * 在合并插入缓冲的时候，合并插入缓冲的数量为 [innodb_io_capacity](#innodb_io_capacity) 的 5%\n    * 在从缓冲区刷新脏页的时候，刷新脏页的数量为 [innodb_io_capacity](#innodb_io_capacity)\n2. 增加了自适应刷新脏页功能。\n    * 1.0.x之前版本：脏页在缓冲池占比小于[innodb_max_dirty_pages_pct](#innodb_max_dirty_pages_pct)，不刷新脏页，大于则刷新100个脏页\n    * 1.0.x版本开始：引入[innodb_adaptive_flushing](#innodb_adaptive_flushing)参数，通过函数buf_flush_get_desired_flush_rate判断产生重做日志的速度来决定最适合的刷新脏页数量。\n3. full purge回收的Undo页的数量也不再硬编码，使用参数[innodb_purge_batch_size](#innodb_purge_batch_size)控制。\n\n<table>\n<tr>\n    <th colspan=\"2\">参数</th>\n    <th>InnoDB 版本</th>\n    <th colspan=\"3\">作用</th>\n</tr>\n<tr>\n    <td colspan=\"2\" style=\"text-align:center\"><span id=\"innodb_io_capacity\">innodb_io_capacity</span></td>\n    <td style=\"text-align:center\"> 1.0.x开始 </td>\n    <td colspan=\"3\">表示磁盘IO的吞吐量,默认值是200</td>\n</tr>\n<tr>\n    <td colspan=\"2\" rowspan=\"2\" style=\"text-align:center\"><span id=\"innodb_max_dirty_pages_pct\">innodb_max_dirty_pages_pct</span></td>\n    <td style=\"text-align:center\"> 1.0.x之前 </td>\n    <td colspan=\"3\">脏页在缓冲池中所占比率，默认值是90</td>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.0.x开始</td>\n    <td colspan=\"3\">默认值是75<br>加快刷新脏页的频率，保证了磁盘IO的负载。</td>                       \n</tr>\n<tr>\n    <td colspan=\"2\" style=\"text-align:center\"><span id=\"innodb_adaptive_flushing\">innodb_adaptive_flushing</span></td>\n    <td style=\"text-align:center\"> 1.0.x开始 </td>\n    <td colspan=\"3\">是否自适应刷新脏页，默认为 ON</td>\n</tr>\n<tr>\n    <td colspan=\"2\" style=\"text-align:center\"><span id=\"innodb_purge_batch_size\">innodb_purge_batch_size</span></td>\n    <td style=\"text-align:center\"> 1.0.x开始 </td>\n    <td colspan=\"3\">清除 undo 页时,表示一次删除多少页,默认是 20</td>\n</tr>\n</table>   \n\nMaster Thread的伪代码变为了下面的形式：\n\n```java\nvoid master_thread()\n{\n\tgoto loop;\n\t//主循环\n\tloop ：\n\tfor(int i = 0; i < 10; ++i){\n\t\tthread_sleep(1);\n\t\t//1. 日志缓冲刷新到磁盘，即使事务还没有提交\n\t\tdo log buffer flush to disk;\n\t\t//2. 根据前一秒IO操作小于5%innodb_io_capacity，合并插入缓冲\n\t\tif(last_one_second_ios < 5%innodb_io_capacity)\n\t\t\tdo merge 5%innodb_io_capacity insert buffer;\n\t\t//3. 脏页的比例超过了阈值，刷新 100%innodb_io_capacity 个脏页到磁盘\n\t\tif(buf_get_modified_ratio_pct > innodb_max_dirty_pages_pct)\n\t\t\tdo buffer pool flush 100%innodb_io_capacity dirty page;\n\t\t//4. 没有用户活动（数据库空闲时）或者数据库关闭（shutdown），切换到 backgroup loop\n\t\tif(no user activity)\n\t\t\tgoto backgroud loop;\n\t}\n\t\n\t//1. 前10秒IO操作小于innodb_io_capacity，刷新 innodb_io_capacity 个脏页到磁盘\n\tif(last_ten_second_ios < innodb_io_capacity)\n\t\tdo buffer pool flush 100%innodb_io_capacity dirty page;\n\t//2. 合并至多 5%innodb_io_capacity 个插入缓冲\n\tdo merge at most 5%innodb_io_capacity insert buffer;\n\t//3. 将重做日志刷新到磁盘\n\tdo log buffer flush to disk;\n\t//4. 删除无用的 undo 页（每次最多尝试回收 5%innodb_io_capacity 个 undo 页）\n\tdo full purge;\n\t//5. 脏页比例超过 70% 刷新 100%innodb_io_capacity 个脏页到磁盘，\n\t// 否则刷新 10%innodb_io_capacity 个脏页\n\tif ( buf_get_modified_ratio_pct ＞ 70 % )\n\t\tdo buffer pool flush 100%innodb_io_capacity dirty page\n\telse\n\t\tbuffer pool flush 10%innodb_io_capacity dirty page\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tgoto loop\n\t//后台循环\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tbackground loop :\n\t//1. 删除无用的 undo 页\n\tdo full purge\n\t//2. 合并 100%innodb_io_capacity 个插入缓冲\n\tdo merge 100%innodb_io_capacity insert buffer\n\t//3.如果有任务，跳转到主循环，否则跳转到刷新循环\n\tif not idle\t\n\t\tgoto loop\n\telse\n\t\tgoto flush loop\n\t\n\t//刷新循环\n\tflush loop :\n\t//不断刷新 100%innodb_io_capacity 个脏页，直到脏页比例没有超过阈值\n\tdo buffer pool flush 100%innodb_io_capacity dirty page\n\tif ( buf_get_modified_ratio_pct ＞ innodb_max_dirty_pages_pct )\n\t\tgoto flush loop\n\t//没有任务，跳转到暂停循环\n\tgoto suspend loop\n\t\n\t//暂停循环\n\tsuspend loop :\n\t//将主线程挂起，等待事件发生\n\tsuspend_thread()\n\twaiting event\n\tgoto loop;\n}\n\n```\n## InnoDB 1.2.x 版本的 Master thread\n\nInnoDB 1.2.x 版本中再次对 Master Thread 进行了优化，伪代码如下：\n```java\nif InnoDB is idle\n//之前版本中每10秒的操作\nsrv_master_do_idle_tasks();\nelse\n//之前版本中每秒的操作\nsrv_master_do_active_tasks();\n```\n对于刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。\n\n\n# InnoDB 关键特性\n关键特性包括：\n* 插入缓冲 insert buffer\n* 两次写 double write\n* 自适应哈希索引 adaptive hash index\n* 异步 io async io\n* 刷新邻接页 flush neighbor page\n\n## 插入缓冲\n\n### 聚集索引（一级索引）\n表在存储的时候按照主键排序进行存储，不需要磁盘的随机读取，插入效率高。\n非叶子节点存放的是键值，叶子节点存放的是行数据，称之为数据页。\n\n### 辅助索引（二级索引）\n除了聚集索引之外的索引都可以称之为辅助索引，叶子节点中存放的是主键的键值。叶子节点的插入不再有序，这时就需要离散访问非聚集索引页，插入性能变低。\n一张表可以存在多个辅助索引，但是只能有一个聚集索引，通过辅助索引来查找对应的航记录的话，需要进行两步，第一步通过辅助索引来确定对应的主键，第二步通过相应的主键值在聚集索引中查询到对应的行记录，也就是进行两次B+树搜索。\n\n### 索引数据页的更新（针对二级索引）\n![index更新流程](Mysql02/index-update.png)\n表数据更新的同时也会更新对应的表的索引数据，所以：对表进行insert delete update时，很可能会产生大量的物理读(物理读索引数据页)\n\n![引入insertbuffer后index更新流程](Mysql02/insert-buffer.png)\n\n### 1. insert buffer\nInsert Buffer的使用流程：\n![Insert Buffer的使用流程](Mysql02/Insert-Buffer.svg)\n\n#### 插入缓冲的启用需要满足以下两个条件：\n1）索引是辅助索引（secondary index）\n2）索引不是唯一的：整个索引数据被切分为2部分，无法保证唯一性。\n\n#### insert buffer结构\ninsert buffer的数据结构是B+树，全局只有一颗B+树。\nB+树的非叶子节点是Search key，构造结构为(space,marker,offset)。\n* space：待插入记录所在表的表空间id。每个表都有唯一的表空间id，通过表空间id可以查出是哪张表。\n* marker：兼容之前的版本。\n* offset：在表空间中页的偏移量。\n\n当一个辅助索引要插入到(space,offset)中时，如果该页不在缓冲池中，则按上述规则构造一个search key，将该记录插入到insert buffer中。\n但是如果该页一直在insert buffer中，不断有记录插入到同一个索引页中，那么该索引页的空间就会逐渐缩小，要出现B+树节点的分裂情况，这时就不能进行insert buffer了。\n所以，我们需要一个机制来管理每个页面的剩余空闲空间，这就是`Insert buffer bitmap`。\n每隔page_size个页面，就是一个Insert buffer bitmap page。\n例如：若page_size = 16384(16k)，那么page_no为0，16384，32768，…的page，就是Insert buffer bitmap page，Bitmap page的功能，就是管理其后连续的page_size – 1个page的空间使用率。\n每个辅助索引页在Insert buffer bitmap中占用4bit。\n\n#### merge insert buffer 发生条件\n* 辅助索引页被读取到buffer pool中：正常的select查询操作，索引页被调入内存，该索引页对应在insert buffer中的索引更改记录就会发生merge操作。\n* Insert buffer bitmap page追踪到该索引页无可用空间时。\n* Master Thread。\n\n#### insert buffer 刷新到磁盘条件\n* 有一个后台线程，会认为数据库空闲时；\n* 数据库缓冲池不够用时；\n* 数据库正常关闭时；\n* redo log写满时：_几乎不会出现redo log写满，此时整个数据库处于无法写入的不可用状态_\n\n#### 插入缓冲主要带来如下两个坏处\n1）可能导致数据库宕机后实例恢复时间变长。如果应用程序执行大量的插入和更新操作，且涉及非唯一的聚集索引，一旦出现宕机，这时就有大量内存中的插入缓冲区数据没有合并至索引页中，导致实例恢复时间会很长。\n2）在写密集的情况下，插入缓冲会占用过多的缓冲池内存，默认情况下最大可以占用1/2，这在实际应用中会带来一定的问题。\n\n### 2. change buffer\n\nInnoDB从1.0.x版本开始引入了Change Buffer，可以将其视为Insert Buffer的升级。\n从这个版本开始，InnoDB可以对DML操作——Insert、Delete、Update`(delete+insert)`都进行缓冲，\n它们分别是：Insert Buffer, Delete Buffer,Purge Buffer。\n对一个记录进行 update 操作有两个过程\n\n* 将记录标记为删除：delete buffer\n* 将记录真正删除：pruge buffer\n\n<table>\n<tr>\n    <th colspan=\"2\">参数</th>\n    <th>InnoDB 版本</th>\n    <th colspan=\"3\">作用</th>\n</tr>\n<tr>\n    <td colspan=\"2\" style=\"text-align:center\"><span id=\"innodb_change_buffering\">innodb_change_buffering</span></td>\n    <td style=\"text-align:center\"> 1.0.x开始 </td>\n    <td colspan=\"3\">用来开启各种Buffer选项，默认值是all<br>\n        <ul>\n        <li>inserts</li>\n        <li>deletes</li>\n        <li>purges</li>\n        <li>changes：开启 inserts 和 deletes</li>\n        <li>all：都开启</li>\n        <li>none：都不开启</li>\n        </ul>\n    </td>\n</tr>\n<tr>\n    <td colspan=\"2\" rowspan=\"2\" style=\"text-align:center\"><span id=\"innodb_change_buffer_max_size\">innodb_change_buffer_max_size</span></td>\n    <td style=\"text-align:center\"> 1.2.x开始 </td>\n    <td colspan=\"3\">用来控制change buffer最大使用内存数量<br>默认值为25,表示最多使用1/4的缓存池空间<br>该参数最大有效值是50</td>\n</tr>\n</table>  \n\n## 两次写\n提高innodb的可靠性，用来解决部分写失败(partial page write页断裂)。\n\n### 脏页刷新到磁盘风险\n\nIO的最小单位：\n* 数据库IO的最小单位是16K（MySQL默认，oracle是8K）\n* 文件系统IO的最小单位是4K（也有1K的）\n* 磁盘IO的最小单位是512字节\n\n因此，存在IO写入导致page损坏的风险：\n![IO风险](Mysql02/IO.png)\n\n提高innodb的可靠性，用来解决部分写失败(partial page write页断裂)。\n\n### Double write解决了什么问题\n一个数据页的大小是16K，假设在把内存中的脏页写到数据库的时候，写了8K突然宕机了，也就是说前8K数据是新的，后8K是旧的，那么磁盘数据库这个数据页就是不完整的，是一个坏掉的数据页，这种情况被称为部分`写失效`\n\n**那么可不可以通过 redo log 来进行恢复呢？**\nredo记录的是对页的修改，只能恢复校验完整（还没写）的页，不能修复坏掉的数据页，所以这个数据就丢失了，可能会造成数据不一致，所以需要double write。\n\n{% note info %}   \n为什么 redo log 不需要 doublewrite 的支持？\n因为 redo log 写入的单位就是 512 字节，也就是磁盘 IO 的最小单位，所以无所谓数据损坏。\n{% endnote %}   \n\n### 两次写工作流程\n![两次写流程](Mysql02/doublewrite.png)\ndoublewrite由两部分组成，一部分为内存中的doublewrite buffer，其大小为2MB，另一部分是磁盘上共享表空间(ibdata x)中连续的128个页，即2个区(extent)，大小也是2M。\n1. 当一系列机制触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先拷贝至内存中的doublewrite buffer中；\n2. 接着从两次写缓冲区分两次写入磁盘共享表空间中(连续存储，顺序写，性能很高)，每次写1MB；\n3. 待第二步完成后，再将doublewrite buffer中的脏页数据写入实际的各个表空间文件(离散写)；(脏页数据固化后，即进行标记对应doublewrite数据可覆盖)\n\n现在我们来分析一下为什么 double write 可以生效。当宕机发生时，有那么几种情况：\n1. 磁盘还未写，此时可以通过 redo log 恢复；\n2. 磁盘正在进行从内存到共享表空间的写，此时数据文件中的页还没开始被写入，因此也同样可以通过 redo log 恢复；\n3. 磁盘正在写数据文件，此时共享表空间已经写完，可以从共享表空间拷贝页的副本到数据文件实现恢复。\n\n## 自适应哈希索引\n\n哈希：一次就可以定位数据\n\nB+树：取决于树的高度，生产环境一般是 3-4 层，所以需要查询 3-4 次\n\n自适应哈希索引 AHI（adaptive hash index）建立条件：观察到一个访问模式访问频繁，就会建立哈希索引\n* 通过该模式访问了 100 次（模式：where x = ?）\n* 页通过该模式访问了 N 次，其中 N = 页的记录总数⁄16\n\nInnoDB 存储引擎官方文档显示，启用 AHI 后,读取和写入速度可以提高 2 倍，辅助索引的连接操作性能可以提高 5 倍。\n\n## 异步IO\n为了提高磁盘的操作性能，当前的数据库系统都采用异步IO的方式处理磁盘操作。用户可以在发出一个IO请求胡立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作完成，这就是AIO。\nAIO的另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO, 这样可以提高IOPS(Input/Output Per Second)的性能。\n\n例如：用户访问页的（space, page_no)为(8,6) (8,7) (8,8)，每个页的大小为16KB，同步IO需要3次IO操作。可以优化为从(8,6)开始读取48KB。\n\n## 刷新临接页\n\n当刷新一个脏页时，InnoDB会检查该页所在extent的所有页，如果是脏页，一起刷新。\n\n<table>\n    <tr>\n        <th colspan=\"2\">参数</th>\n        <th>版本</th>\n        <th colspan=\"3\">作用</th>\n    </tr>\n    <tr>\n        <th colspan=\"2\" style=\"text-align:center\" >innodb_flush_neighbors</th>\n        <td style=\"text-align:center\">1.2.x开始</td>\n        <td colspan=\"3\">控制是否启用该特性</td>\n    </tr>\n</table> \n\n\n# 参考：\n* http://oohcode.com/2015/10/14/InnoDB-Key-Features/\n* https://chyroc.cn/posts/innodb-storage-engine-reading-1/\n* https://www.cnblogs.com/zhoujinyi/archive/2013/04/11/2988923.html\n* http://huzb.me/2019/01/14/%E6%8F%92%E5%85%A5%E7%BC%93%E5%86%B2%E3%80%81%E4%B8%A4%E6%AC%A1%E5%86%99%E5%92%8C%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95/\n* https://blog.csdn.net/tanliqing2010/article/details/81509539\n* https://www.cnblogs.com/geaozhang/p/7341333.html\n* https://draveness.me/mysql-innodb\n* http://richfisher.me/blog/2017/12/18/innodb-notes/\n* https://www.docs4dev.com/docs/zh/mysql/5.7/reference/innodb-architecture.html#innodb%E6%9E%B6%E6%9E%84\n* MySQL技术内幕：InnoDB存储引擎(第2版)","slug":"Mysql02","published":1,"updated":"2019-08-31T03:04:00.000Z","layout":"post","photos":[],"link":"","_id":"ck8fb4adz002zk2o5vlxhf5qi","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><ul>\n<li>InnoDB存储引擎最早由Innobase Oy公司开发，被包括在MySQL数据库所有的二进制发行版本中，</li>\n<li>从MySQL 5.5版本开始是默认的表存储引擎<font color=\"gray\">（之前的版本InnoDB存储引擎仅在Windows下为默认的存储引擎）</font></li>\n<li>第一个完整支持ACID事务的MySQL存储引擎<font color=\"gray\">（BDB是第一个支持事务的MySQL存储引擎，现在已经停止开发）</font></li>\n<li>特点：行锁设计、支持 MVCC、支持外键、提供一致性非锁定读、有效利用内存和 CPU<a id=\"more\"></a>\n\n</li>\n</ul>\n<h1 id=\"体系架构\"><a href=\"#体系架构\" class=\"headerlink\" title=\"体系架构\"></a>体系架构</h1><p><img src=\"/Mysql/Mysql02/innodb-Architecture.png\" alt=\"innoDB体系结构图\"><br>InnoDB存储引擎是由内存池、后台线程、磁盘存储三大部分组成。</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>InnoDB 使用的是多线程模型, 其后台有多个不同的线程负责处理不同的任务</p>\n<h3 id=\"Master-Thread\"><a href=\"#Master-Thread\" class=\"headerlink\" title=\"Master Thread\"></a>Master Thread</h3><p>Master Thread是最核心的一个后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性。包括脏页刷新、合并插入缓冲、UNDO页的回收等。</p>\n<h3 id=\"IO-Thread\"><a href=\"#IO-Thread\" class=\"headerlink\" title=\"IO Thread\"></a>IO Thread</h3><p>在 InnoDB 存储引擎中大量使用了异步IO(Async IO)来处理写IO请求, IO Thread的工作主要是负责这些 IO 请求的回调。</p>\n<table>\n<tr>\n    <th>InnoDB 版本</th>\n    <th colspan=\"4\">线程</th>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.0之前 </td>\n    <td colspan=\"4\">4 个 io thread：write，read，insert buffer，log IO Thread.\n    <ul>\n        <li>在Linux下，IO Thread的数量不能进行调整</li>\n        <li>在Windows下可以通过参数 innodb_file_io_threads 来增大IO Thread</li>\n    </ul>\n    </td>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.0之后 </td>\n    <td colspan=\"4\">read 和 write IO thread 分别增大到了 4 个<br>\n    <ul>\n    <li>分别使用 innodb_read_io_threads 和 innodb_write_io_threads 设置线程数</li>\n    </ul>\n    </td>\n</tr>\n</table>  \n\n<h3 id=\"Purge-Thread\"><a href=\"#Purge-Thread\" class=\"headerlink\" title=\"Purge Thread\"></a>Purge Thread</h3><p>事务提交后，其所使用的undo log可能不再需要，因此需要Purge Thread来回收已经分配并使用的UNDO页。</p>\n<table>\n<tr>\n    <th>InnoDB 版本</th>\n    <th colspan=\"4\">作用</th>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.1之前 </td>\n    <td colspan=\"4\">purge 操作在 master thread 内完成</td>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.1之后 </td>\n    <td colspan=\"4\">purge 可以独立到单独的线程,减轻 master thread 工作,提高 cpu 利用率和提高性能<br>\n    <ul>\n    <li>MySQL数据库的配置文件<code>[mysqld]</code>中添加如下命令来启用独立的Purge Thread：</li>\n    <li>innodb_purge_threads=1 </li>\n    <li>1.1版本中，即使将 innodb_purge_threads 设为大于1，InnoDB存储引擎启动时也会将其设为1</li>\n    </ul>\n    </td>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.2之后</td>\n    <td colspan=\"4\">支持多个Purge Thread, 这样做可以加快UNDO页的回收，也能更进一步利用磁盘的随机读取性能</td>\n</tr>\n</table>                                  \n\n<h3 id=\"Page-Cleaner-Thread\"><a href=\"#Page-Cleaner-Thread\" class=\"headerlink\" title=\"Page Cleaner Thread\"></a>Page Cleaner Thread</h3><p>Page Cleaner Thread的作用是取代Master Thread中脏页刷新的操作，<br>减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高性能。</p>\n<h2 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h2><p>innoDB内存主要由<a href=\"#缓冲池\">缓冲池(innodb buffer pool)</a>、<a href=\"#重做日志缓冲\">重做日志缓冲(redo log buffer)</a>、<a href=\"#额外的内存池\">额外内存池组成(innodb additional men pool size)</a>组成</p>\n<h3 id=\"缓冲池\"><a href=\"#缓冲池\" class=\"headerlink\" title=\"缓冲池\"></a>缓冲池</h3><p>缓冲池是主存储器中的一个区域，用于在访问时缓存表和索引数据。缓冲池允许直接从内存处理常用数据，从而加快处理速度。<br>在专用服务器上，通常会将最多80％的物理内存分配给缓冲池。<br>读取流程：<br>     <img src=\"/Mysql/Mysql02/read.png\" alt=\"流程图\"><br>更新流程：<br>     <img src=\"/Mysql/Mysql02/write.png\" alt=\"流程图\"></p>\n<p>因此缓冲池的大小影响数据库的整体性能。</p>\n<div class=\"note info\"><p>由于32位操作系统的限制，在该系统下最多将该值设置为3G。<br>用户可以打开操作系统的<code>PAE</code>选项来获得32位操作系统下最大64GB内存的支持。<br>为了让数据库使用更多的内存,建议数据库系统都采用 64 位操作系统。</p></div>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">参数</th>\n<th align=\"center\">版本</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">innodb_buffer_pool_instances</td>\n<td align=\"center\">从InnoDB 1.0.x开始</td>\n<td align=\"center\">配置多个缓冲池实例，默认为1</td>\n</tr>\n</tbody></table>\n<h4 id=\"缓冲池中缓存的数据页类型\"><a href=\"#缓冲池中缓存的数据页类型\" class=\"headerlink\" title=\"缓冲池中缓存的数据页类型\"></a>缓冲池中缓存的数据页类型</h4><ul>\n<li>索引页(index page)：缓存数据表索引</li>\n<li>数据页(data page)：缓存数据页，占缓冲池的绝大部分</li>\n<li>undo页(undo Log Page)：undo页是保存事务，为回滚做准备的。</li>\n<li><a href=\"#插入缓冲\">插入缓冲</a>（insert buffer）：插入数据时要先插入到缓存池中。</li>\n<li>自适应哈希索引（adaptive hash index）： 除了B+ Tree索引外，在缓冲池还会维护一个哈希索引，以便在缓冲池中快速找到数据页。</li>\n<li>InnoDB存储的锁信息（lock info）</li>\n<li>数据字典信息（data dictionary）<br>  在MySQL中，数据字典信息内容就包括表结构、数据库名或表名、字段的数据类型、视图、索引、表字段信息、存储过程、触发器等内容。<br>  InnoDB有自己的表缓存，可以称为表定义缓存或者数据字典。当InnoDB打开一张表，就增加一个对应的对象到数据字典。</li>\n</ul>\n<h4 id=\"缓冲池管理方式\"><a href=\"#缓冲池管理方式\" class=\"headerlink\" title=\"缓冲池管理方式\"></a>缓冲池管理方式</h4><p><img src=\"/Mysql/Mysql02/three-list2.png\" alt=\"三种list\"></p>\n<ol>\n<li><p><strong>Free list</strong><br>当数据库刚启动时，LRU列表是空的，这时页都存放在Free list中。<br>当需要从缓冲池中分页时，从Free list中查找是否有可用的空闲页，若有则将该页从Free列表中删除，放入到LRU列表中,维持页数守恒。</p>\n</li>\n<li><p><strong>LRU list</strong><br> <strong>LRU算法</strong>：最频繁使用页在LRU列表的前端，最少使用的页在尾端。首先释放LRU列表中的尾端的页。缓冲池中页的大小默认为16KB。<br> <strong>InnoDB优化的LRU算法(midpoint insertion strategy)</strong>：将新读取到的页不放在首部，而是中间部位 <code>midpoint</code> 位置。目标是确保频繁访问”热”页面保留在缓冲池中。<br> <img src=\"/Mysql/Mysql02/innodb-buffer-pool-list.jpg\" alt=\"lru\"></p>\n <table>\n <tr>\n     <th>参数</th>\n     <th colspan=\"2\">作用</th>\n </tr>\n <tr>\n     <td style=\"text-align:center\"> innodb_old_blocks_pct </td>\n     <td colspan=\"2\">控制LRU列表中 old list 的百分比。<br>\n        默认值为 37，对应于原始固定比率3/8。<br>\n        值范围是 5（缓冲池中的新页面很快就会老化）到 95。\n     </td>\n </tr>\n <tr>\n     <td style=\"text-align:center\"> innodb_old_blocks_time </td>\n     <td colspan=\"2\">指定第一次访问页面之后的时间窗口（ms）<br>\n        在此期间可以访问该页面而不移动到LRU列表的前端<br>\n        默认值为 1000 ms\n     </td>\n </tr>\n </table> \n\n<p> 默认情况下，算法操作如下：</p>\n<ul>\n<li>在默认配置下， <code>midpoint</code>位置在LRU list 的5/8处。</li>\n<li><code>midpoint</code>是new sublist的尾部与old sublist的头部相交的边界。</li>\n<li>当 InnoDB 将页面读入缓冲池时，将页插入<code>midpoint</code>位置(old sublist的头部)。</li>\n<li>访问old sublist中的页 &amp;&amp; 该页在old sublist中的停留时间超过innodb_old_blocks_time设置的时间，使其变<code>young</code>,将其移动到缓冲池的头部(new sublist的头部)。</li>\n<li>当页从LRU列表的old部分加入到new部分时，称此时发生的操作为<code>page made young</code>，而因为innodb_old_blocks_time的设置而导致页没有从old部分移动到new部分的操作称为<code>page not made young</code></li>\n<li>在数据库操作中，被访问的页将移到new sublist的表头，这样一来，在new sublist中的未被访问的节点将逐渐往表尾移动，当移动过中点，将变为old list的节点。当表满时，old list末尾的页将会被移除。</li>\n</ul>\n<div class=\"note warning\"><p>为什么不采用朴素的LRU？<br>因为某些SQL操作会访问很多页，甚至全部页，但仅仅在该次查询操作，并不是活跃的热点数据。可能会使缓冲池中的页被刷新出，从而影响缓冲池的效率。</p></div>  \n\n<ol start=\"3\">\n<li><strong>Flush list</strong><br>在LRU类表的页被修改后，称为脏页（Dirty Page），即缓存和硬盘的页数据不一致。<br>数据库会通过<code>CHECKPOINT</code>机制将脏页刷新回磁盘，Flush list中的页即为脏页列表。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"重做日志缓冲\"><a href=\"#重做日志缓冲\" class=\"headerlink\" title=\"重做日志缓冲\"></a>重做日志缓冲</h3>   <div class=\"note info\"><p><strong>什么是redo log？</strong><br>当数据库对数据做修改的时候，需要把数据页从磁盘读到buffer pool中，然后在buffer pool中进行修改，那么这个时候buffer pool中的数据页就与磁盘上的数据页内容不一致，称buffer pool的数据页为dirty page 脏数据。<br>如果发生非正常的DB服务重启，那么这些数据并没有同步到磁盘文件中（注意，同步到磁盘文件是个随机IO），会发生数据丢失。<br>如果这个时候，能够有一个文件，当缓冲池中的data page变更结束后，把相应修改记录记录到这个文件（注意，记录日志是顺序IO），那么当DB服务发生crash的情况，恢复DB的时候，也可以根据这个文件的记录内容，重新应用到磁盘文件，数据保持一致。<br>这个文件就是redo log ，用于记录 数据修改后的记录，顺序记录。<br><br><strong>什么是undo log？</strong><br>undo日志用于存放数据修改被修改前的值。<br>假设修改表中 id=1 的行数据，把Name=’B’ 修改为Name = ‘B2’ ，那么undo日志就会用来存放Name=’B’的记录，如果这个修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。</p></div>  \n\n<p><img src=\"/Mysql/Mysql02/redo-buffer.png\" alt=\"lru\"></p>\n<p>  重做日志缓冲不需要设置很大，通常情况下8M能满足大部分的应用场景。重做日志支持以下三种情况触发刷新：</p>\n<ul>\n<li>Master Thread每一秒将重做日志缓冲刷新到重做日志文件</li>\n<li>每次事务提交时将重做日志缓冲刷新到重做日志文件</li>\n<li>当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件</li>\n</ul>\n<h3 id=\"额外的内存池\"><a href=\"#额外的内存池\" class=\"headerlink\" title=\"额外的内存池\"></a>额外的内存池</h3><p>   在InnoDB存储引擎中，对内存的管理是通过一种称为内存堆的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。</p>\n<h1 id=\"Checkpoint技术\"><a href=\"#Checkpoint技术\" class=\"headerlink\" title=\"Checkpoint技术\"></a>Checkpoint技术</h1><div class=\"note info\"><p><strong>什么是Checkpoint？</strong><br>是一个数据库事件(event)，这个事件激活以后会触发数据库写进程(DBWR)将脏数据块写到磁盘中。                           </p>\n<p><strong>为什么需要Checkpoint技术？</strong><br>innoDB在事务提交时，先写重做日志，再修改内存数据这样，就产生了脏页。既然有重做日志保证数据持久性，查询时也可以从缓冲池页中取数据，那为什么还要刷新脏页到磁盘呢？如果重做日志可以无限增大，同时缓冲池足够大，能够缓存所有数据，那么是不需要将缓冲池中的脏页刷新到磁盘。但是，会有以下几个问题：<br>1) 服务器内存有限，缓冲池不够用，无法缓存全部数据<br>2) 重做日志无限增大成本要求太高<br>3) 宕机时如果重做全部日志恢复时间过长            </p>\n<p><strong>Checkpoint 解决了什么问题？</strong><br>1) 缩短短数据库的恢复时间<br>2) 缓冲池不够时，将脏页刷新到磁盘<br>3) 重做日志不可用时，刷新脏页</p></div> \n\n<p>对于InnoDB存储引擎而言，其是通过LSN（Log Sequence Number）来标记版本的。每个页有LSN，重做日志中也有LSN，Checkpoint也有LSN。</p>\n<p>innodb 内部有两种 checkpoint：</p>\n<ol>\n<li><p><strong>sharp checkpoint</strong>：数据库关闭的时候将<code>所有的脏页</code>刷回到磁盘，默认方式，参数 innodb_fast_shudown=1</p>\n</li>\n<li><p><strong>fuzzy checkpoint</strong>：只刷新<code>部分脏页</code></p>\n<ul>\n<li><p>master thread checkpoint：master thread 异步的以每秒或者每 10 秒的速度从缓冲池的脏页列表中刷新一定比列的也回磁盘</p>\n<ul>\n<li>周期性，异步，读取flush list，找到脏页，写入磁盘</li>\n</ul>\n</li>\n<li><p>flush_lru_list checkpoint：InnoDB要保证LRU列表中需要有差不多100个空闲页可供使用。如果没有这么多，就会将 lru list 尾部的页移除。如果这些页有脏页，就需要进行 checkpoint。</p>\n<ul>\n<li>innodb 1.1.x版本之前，检查在用户查询线程中,会阻塞用户查询操作。</li>\n<li>innodb 1.2.x版本之后，检查放到了单独的 page cleaner 线程中,可通过 <strong>innodb_lru_scan_depth</strong> 控制lru列表中可用页的数量，默认是1024。</li>\n</ul>\n</li>\n<li><p>async/sync flush checkpoint：重做日志文件不可用时，强制将一些页刷新到磁盘。达到重做日志文件的大小阈值。</p>\n<ul>\n<li>checkpoint age = redo_log_lsn - cp_lsn<br> 低水位=75% * total_redo_log_file_size<br> 高水位=90% * total_redo_log_file_size</li>\n<li>checkpoint age &lt; 低水位<br>   不需要刷新</li>\n<li>低水位  &lt;=  checkpoint age &lt;= 高水位<br>   会强制进行 checkpoint ，触发async flush， 根据flush_list的顺序，刷新足够多的脏页，直到 checkpoint age &lt; 低水位</li>\n<li>checkpoint age &gt; 高水位<br> 会强制进行 checkpoint ，触发sync flush 根据flush_list的顺序，刷新脏页, 直到 checkpoint age &lt; 低水位</li>\n</ul>\n</li>\n<li><p>dirty page too much checkpoint：当缓冲池中脏页的数量占据一定百分比时，强制进行Checkpoint，用来保证缓冲池中有足够的页，通过 <a href=\"#innodb_max_dirty_pages_pct\">innodb_max_dirty_pages_pct</a> 参数控制。</p>\n</li>\n</ul>\n</li>\n</ol>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>-------- 第二部分 --------</span>\n</div>\n\n<h1 id=\"Master-thread-工作方式\"><a href=\"#Master-thread-工作方式\" class=\"headerlink\" title=\"Master thread 工作方式\"></a>Master thread 工作方式</h1><h2 id=\"InnoDB-1-0-x-版本之前的-Master-thread\"><a href=\"#InnoDB-1-0-x-版本之前的-Master-thread\" class=\"headerlink\" title=\"InnoDB 1.0.x 版本之前的 Master thread\"></a>InnoDB 1.0.x 版本之前的 Master thread</h2><p>Master thread 内部有多个循环 loop 组成：</p>\n<ul>\n<li>主循环 loop</li>\n<li>后台循环 backgroup loop</li>\n<li>刷新循环 flush loop</li>\n<li>暂停循环 suspend loop</li>\n</ul>\n<p>伪代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">master_thread</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tgoto loop;</span><br><span class=\"line\">\t<span class=\"comment\">//主循环</span></span><br><span class=\"line\">\tloop ：</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i)&#123;</span><br><span class=\"line\">\t\tthread_sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//1. 日志缓冲刷新到磁盘，即使事务还没有提交</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> log buffer flush to disk;</span><br><span class=\"line\">\t\t<span class=\"comment\">//2. 根据前一秒IO操作小于5，合并插入缓冲</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(last_one_second_ios &lt; <span class=\"number\">5</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">do</span> merge at most <span class=\"number\">5</span> insert buffer;</span><br><span class=\"line\">\t\t<span class=\"comment\">//3. 脏页的比例超过了阈值，刷新 100 个脏页到磁盘</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">do</span> buffer pool flush <span class=\"number\">100</span> dirty page;</span><br><span class=\"line\">\t\t<span class=\"comment\">//4. 没有用户活动（数据库空闲时）或者数据库关闭（shutdown），切换到 backgroup loop</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(no user activity)</span><br><span class=\"line\">\t\t\tgoto backgroud loop;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//1. 前10秒IO操作小于200，刷新 100 个脏页到磁盘</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(last_ten_second_ios &lt; <span class=\"number\">200</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> buffer pool flush <span class=\"number\">100</span> dirty page;</span><br><span class=\"line\">\t<span class=\"comment\">//2. 合并至多 5 个插入缓冲</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> merge at most <span class=\"number\">5</span> insert buffer;</span><br><span class=\"line\">\t<span class=\"comment\">//3. 将重做日志刷新到磁盘</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> log buffer flush to disk;</span><br><span class=\"line\">\t<span class=\"comment\">//4. 删除无用的 undo 页（每次最多尝试回收 20 个 undo 页）</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> full purge;</span><br><span class=\"line\">\t<span class=\"comment\">//5. 脏页比例超过 70% 刷新100 个脏页到磁盘，否则刷新 10 个脏页</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( buf_get_modified_ratio_pct ＞ <span class=\"number\">70</span> % )</span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> buffer pool flush <span class=\"number\">100</span> dirty page</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tbuffer pool flush <span class=\"number\">10</span> dirty page</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\tgoto loop</span><br><span class=\"line\">\t<span class=\"comment\">//后台循环\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\">\tbackground loop :</span><br><span class=\"line\">\t<span class=\"comment\">//1. 删除无用的 undo 页</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> full purge</span><br><span class=\"line\">\t<span class=\"comment\">//2. 合并 20 个插入缓冲</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> merge <span class=\"number\">20</span> insert buffer</span><br><span class=\"line\">\t<span class=\"comment\">//3.如果有任务，跳转到主循环，否则跳转到刷新循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> not idle\t</span><br><span class=\"line\">\t\tgoto loop</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tgoto flush loop</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//刷新循环</span></span><br><span class=\"line\">\tflush loop :</span><br><span class=\"line\">\t<span class=\"comment\">//不断刷新100个脏页，直到脏页比例没有超过阈值</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> buffer pool flush <span class=\"number\">100</span> dirty page</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( buf_get_modified_ratio_pct ＞ innodb_max_dirty_pages_pct )</span><br><span class=\"line\">\t\tgoto flush loop</span><br><span class=\"line\">\t<span class=\"comment\">//没有任务，跳转到暂停循环</span></span><br><span class=\"line\">\tgoto suspend loop</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//暂停循环</span></span><br><span class=\"line\">\tsuspend loop :</span><br><span class=\"line\">\t<span class=\"comment\">//将主线程挂起，等待事件发生</span></span><br><span class=\"line\">\tsuspend_thread()</span><br><span class=\"line\">\twaiting event</span><br><span class=\"line\">\tgoto loop;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"InnoDB-1-2-x-版本之前的-Master-thread\"><a href=\"#InnoDB-1-2-x-版本之前的-Master-thread\" class=\"headerlink\" title=\"InnoDB 1.2.x 版本之前的 Master thread\"></a>InnoDB 1.2.x 版本之前的 Master thread</h2><ol>\n<li>提高刷新脏页数量和合并插入数量，改善磁盘 IO 处理能力,刷新数量不再硬编码，而是使用百分比控制。<ul>\n<li>在合并插入缓冲的时候，合并插入缓冲的数量为 <a href=\"#innodb_io_capacity\">innodb_io_capacity</a> 的 5%</li>\n<li>在从缓冲区刷新脏页的时候，刷新脏页的数量为 <a href=\"#innodb_io_capacity\">innodb_io_capacity</a></li>\n</ul>\n</li>\n<li>增加了自适应刷新脏页功能。<ul>\n<li>1.0.x之前版本：脏页在缓冲池占比小于<a href=\"#innodb_max_dirty_pages_pct\">innodb_max_dirty_pages_pct</a>，不刷新脏页，大于则刷新100个脏页</li>\n<li>1.0.x版本开始：引入<a href=\"#innodb_adaptive_flushing\">innodb_adaptive_flushing</a>参数，通过函数buf_flush_get_desired_flush_rate判断产生重做日志的速度来决定最适合的刷新脏页数量。</li>\n</ul>\n</li>\n<li>full purge回收的Undo页的数量也不再硬编码，使用参数<a href=\"#innodb_purge_batch_size\">innodb_purge_batch_size</a>控制。</li>\n</ol>\n<table>\n<tr>\n    <th colspan=\"2\">参数</th>\n    <th>InnoDB 版本</th>\n    <th colspan=\"3\">作用</th>\n</tr>\n<tr>\n    <td colspan=\"2\" style=\"text-align:center\"><span id=\"innodb_io_capacity\">innodb_io_capacity</span></td>\n    <td style=\"text-align:center\"> 1.0.x开始 </td>\n    <td colspan=\"3\">表示磁盘IO的吞吐量,默认值是200</td>\n</tr>\n<tr>\n    <td colspan=\"2\" rowspan=\"2\" style=\"text-align:center\"><span id=\"innodb_max_dirty_pages_pct\">innodb_max_dirty_pages_pct</span></td>\n    <td style=\"text-align:center\"> 1.0.x之前 </td>\n    <td colspan=\"3\">脏页在缓冲池中所占比率，默认值是90</td>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.0.x开始</td>\n    <td colspan=\"3\">默认值是75<br>加快刷新脏页的频率，保证了磁盘IO的负载。</td>                       \n</tr>\n<tr>\n    <td colspan=\"2\" style=\"text-align:center\"><span id=\"innodb_adaptive_flushing\">innodb_adaptive_flushing</span></td>\n    <td style=\"text-align:center\"> 1.0.x开始 </td>\n    <td colspan=\"3\">是否自适应刷新脏页，默认为 ON</td>\n</tr>\n<tr>\n    <td colspan=\"2\" style=\"text-align:center\"><span id=\"innodb_purge_batch_size\">innodb_purge_batch_size</span></td>\n    <td style=\"text-align:center\"> 1.0.x开始 </td>\n    <td colspan=\"3\">清除 undo 页时,表示一次删除多少页,默认是 20</td>\n</tr>\n</table>   \n\n<p>Master Thread的伪代码变为了下面的形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">master_thread</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tgoto loop;</span><br><span class=\"line\">\t<span class=\"comment\">//主循环</span></span><br><span class=\"line\">\tloop ：</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i)&#123;</span><br><span class=\"line\">\t\tthread_sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//1. 日志缓冲刷新到磁盘，即使事务还没有提交</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> log buffer flush to disk;</span><br><span class=\"line\">\t\t<span class=\"comment\">//2. 根据前一秒IO操作小于5%innodb_io_capacity，合并插入缓冲</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(last_one_second_ios &lt; <span class=\"number\">5</span>%innodb_io_capacity)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">do</span> merge <span class=\"number\">5</span>%innodb_io_capacity insert buffer;</span><br><span class=\"line\">\t\t<span class=\"comment\">//3. 脏页的比例超过了阈值，刷新 100%innodb_io_capacity 个脏页到磁盘</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">do</span> buffer pool flush <span class=\"number\">100</span>%innodb_io_capacity dirty page;</span><br><span class=\"line\">\t\t<span class=\"comment\">//4. 没有用户活动（数据库空闲时）或者数据库关闭（shutdown），切换到 backgroup loop</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(no user activity)</span><br><span class=\"line\">\t\t\tgoto backgroud loop;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//1. 前10秒IO操作小于innodb_io_capacity，刷新 innodb_io_capacity 个脏页到磁盘</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(last_ten_second_ios &lt; innodb_io_capacity)</span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> buffer pool flush <span class=\"number\">100</span>%innodb_io_capacity dirty page;</span><br><span class=\"line\">\t<span class=\"comment\">//2. 合并至多 5%innodb_io_capacity 个插入缓冲</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> merge at most <span class=\"number\">5</span>%innodb_io_capacity insert buffer;</span><br><span class=\"line\">\t<span class=\"comment\">//3. 将重做日志刷新到磁盘</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> log buffer flush to disk;</span><br><span class=\"line\">\t<span class=\"comment\">//4. 删除无用的 undo 页（每次最多尝试回收 5%innodb_io_capacity 个 undo 页）</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> full purge;</span><br><span class=\"line\">\t<span class=\"comment\">//5. 脏页比例超过 70% 刷新 100%innodb_io_capacity 个脏页到磁盘，</span></span><br><span class=\"line\">\t<span class=\"comment\">// 否则刷新 10%innodb_io_capacity 个脏页</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( buf_get_modified_ratio_pct ＞ <span class=\"number\">70</span> % )</span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> buffer pool flush <span class=\"number\">100</span>%innodb_io_capacity dirty page</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tbuffer pool flush <span class=\"number\">10</span>%innodb_io_capacity dirty page</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\tgoto loop</span><br><span class=\"line\">\t<span class=\"comment\">//后台循环\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\">\tbackground loop :</span><br><span class=\"line\">\t<span class=\"comment\">//1. 删除无用的 undo 页</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> full purge</span><br><span class=\"line\">\t<span class=\"comment\">//2. 合并 100%innodb_io_capacity 个插入缓冲</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> merge <span class=\"number\">100</span>%innodb_io_capacity insert buffer</span><br><span class=\"line\">\t<span class=\"comment\">//3.如果有任务，跳转到主循环，否则跳转到刷新循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> not idle\t</span><br><span class=\"line\">\t\tgoto loop</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tgoto flush loop</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//刷新循环</span></span><br><span class=\"line\">\tflush loop :</span><br><span class=\"line\">\t<span class=\"comment\">//不断刷新 100%innodb_io_capacity 个脏页，直到脏页比例没有超过阈值</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> buffer pool flush <span class=\"number\">100</span>%innodb_io_capacity dirty page</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( buf_get_modified_ratio_pct ＞ innodb_max_dirty_pages_pct )</span><br><span class=\"line\">\t\tgoto flush loop</span><br><span class=\"line\">\t<span class=\"comment\">//没有任务，跳转到暂停循环</span></span><br><span class=\"line\">\tgoto suspend loop</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//暂停循环</span></span><br><span class=\"line\">\tsuspend loop :</span><br><span class=\"line\">\t<span class=\"comment\">//将主线程挂起，等待事件发生</span></span><br><span class=\"line\">\tsuspend_thread()</span><br><span class=\"line\">\twaiting event</span><br><span class=\"line\">\tgoto loop;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"InnoDB-1-2-x-版本的-Master-thread\"><a href=\"#InnoDB-1-2-x-版本的-Master-thread\" class=\"headerlink\" title=\"InnoDB 1.2.x 版本的 Master thread\"></a>InnoDB 1.2.x 版本的 Master thread</h2><p>InnoDB 1.2.x 版本中再次对 Master Thread 进行了优化，伪代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> InnoDB is idle</span><br><span class=\"line\"><span class=\"comment\">//之前版本中每10秒的操作</span></span><br><span class=\"line\">srv_master_do_idle_tasks();</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"comment\">//之前版本中每秒的操作</span></span><br><span class=\"line\">srv_master_do_active_tasks();</span><br></pre></td></tr></table></figure>\n\n<p>对于刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。</p>\n<h1 id=\"InnoDB-关键特性\"><a href=\"#InnoDB-关键特性\" class=\"headerlink\" title=\"InnoDB 关键特性\"></a>InnoDB 关键特性</h1><p>关键特性包括：</p>\n<ul>\n<li>插入缓冲 insert buffer</li>\n<li>两次写 double write</li>\n<li>自适应哈希索引 adaptive hash index</li>\n<li>异步 io async io</li>\n<li>刷新邻接页 flush neighbor page</li>\n</ul>\n<h2 id=\"插入缓冲\"><a href=\"#插入缓冲\" class=\"headerlink\" title=\"插入缓冲\"></a>插入缓冲</h2><h3 id=\"聚集索引（一级索引）\"><a href=\"#聚集索引（一级索引）\" class=\"headerlink\" title=\"聚集索引（一级索引）\"></a>聚集索引（一级索引）</h3><p>表在存储的时候按照主键排序进行存储，不需要磁盘的随机读取，插入效率高。<br>非叶子节点存放的是键值，叶子节点存放的是行数据，称之为数据页。</p>\n<h3 id=\"辅助索引（二级索引）\"><a href=\"#辅助索引（二级索引）\" class=\"headerlink\" title=\"辅助索引（二级索引）\"></a>辅助索引（二级索引）</h3><p>除了聚集索引之外的索引都可以称之为辅助索引，叶子节点中存放的是主键的键值。叶子节点的插入不再有序，这时就需要离散访问非聚集索引页，插入性能变低。<br>一张表可以存在多个辅助索引，但是只能有一个聚集索引，通过辅助索引来查找对应的航记录的话，需要进行两步，第一步通过辅助索引来确定对应的主键，第二步通过相应的主键值在聚集索引中查询到对应的行记录，也就是进行两次B+树搜索。</p>\n<h3 id=\"索引数据页的更新（针对二级索引）\"><a href=\"#索引数据页的更新（针对二级索引）\" class=\"headerlink\" title=\"索引数据页的更新（针对二级索引）\"></a>索引数据页的更新（针对二级索引）</h3><p><img src=\"/Mysql/Mysql02/index-update.png\" alt=\"index更新流程\"><br>表数据更新的同时也会更新对应的表的索引数据，所以：对表进行insert delete update时，很可能会产生大量的物理读(物理读索引数据页)</p>\n<p><img src=\"/Mysql/Mysql02/insert-buffer.png\" alt=\"引入insertbuffer后index更新流程\"></p>\n<h3 id=\"1-insert-buffer\"><a href=\"#1-insert-buffer\" class=\"headerlink\" title=\"1. insert buffer\"></a>1. insert buffer</h3><p>Insert Buffer的使用流程：<br><img src=\"/Mysql/Mysql02/Insert-Buffer.svg\" alt=\"Insert Buffer的使用流程\"></p>\n<h4 id=\"插入缓冲的启用需要满足以下两个条件：\"><a href=\"#插入缓冲的启用需要满足以下两个条件：\" class=\"headerlink\" title=\"插入缓冲的启用需要满足以下两个条件：\"></a>插入缓冲的启用需要满足以下两个条件：</h4><p>1）索引是辅助索引（secondary index）<br>2）索引不是唯一的：整个索引数据被切分为2部分，无法保证唯一性。</p>\n<h4 id=\"insert-buffer结构\"><a href=\"#insert-buffer结构\" class=\"headerlink\" title=\"insert buffer结构\"></a>insert buffer结构</h4><p>insert buffer的数据结构是B+树，全局只有一颗B+树。<br>B+树的非叶子节点是Search key，构造结构为(space,marker,offset)。</p>\n<ul>\n<li>space：待插入记录所在表的表空间id。每个表都有唯一的表空间id，通过表空间id可以查出是哪张表。</li>\n<li>marker：兼容之前的版本。</li>\n<li>offset：在表空间中页的偏移量。</li>\n</ul>\n<p>当一个辅助索引要插入到(space,offset)中时，如果该页不在缓冲池中，则按上述规则构造一个search key，将该记录插入到insert buffer中。<br>但是如果该页一直在insert buffer中，不断有记录插入到同一个索引页中，那么该索引页的空间就会逐渐缩小，要出现B+树节点的分裂情况，这时就不能进行insert buffer了。<br>所以，我们需要一个机制来管理每个页面的剩余空闲空间，这就是<code>Insert buffer bitmap</code>。<br>每隔page_size个页面，就是一个Insert buffer bitmap page。<br>例如：若page_size = 16384(16k)，那么page_no为0，16384，32768，…的page，就是Insert buffer bitmap page，Bitmap page的功能，就是管理其后连续的page_size – 1个page的空间使用率。<br>每个辅助索引页在Insert buffer bitmap中占用4bit。</p>\n<h4 id=\"merge-insert-buffer-发生条件\"><a href=\"#merge-insert-buffer-发生条件\" class=\"headerlink\" title=\"merge insert buffer 发生条件\"></a>merge insert buffer 发生条件</h4><ul>\n<li>辅助索引页被读取到buffer pool中：正常的select查询操作，索引页被调入内存，该索引页对应在insert buffer中的索引更改记录就会发生merge操作。</li>\n<li>Insert buffer bitmap page追踪到该索引页无可用空间时。</li>\n<li>Master Thread。</li>\n</ul>\n<h4 id=\"insert-buffer-刷新到磁盘条件\"><a href=\"#insert-buffer-刷新到磁盘条件\" class=\"headerlink\" title=\"insert buffer 刷新到磁盘条件\"></a>insert buffer 刷新到磁盘条件</h4><ul>\n<li>有一个后台线程，会认为数据库空闲时；</li>\n<li>数据库缓冲池不够用时；</li>\n<li>数据库正常关闭时；</li>\n<li>redo log写满时：<em>几乎不会出现redo log写满，此时整个数据库处于无法写入的不可用状态</em></li>\n</ul>\n<h4 id=\"插入缓冲主要带来如下两个坏处\"><a href=\"#插入缓冲主要带来如下两个坏处\" class=\"headerlink\" title=\"插入缓冲主要带来如下两个坏处\"></a>插入缓冲主要带来如下两个坏处</h4><p>1）可能导致数据库宕机后实例恢复时间变长。如果应用程序执行大量的插入和更新操作，且涉及非唯一的聚集索引，一旦出现宕机，这时就有大量内存中的插入缓冲区数据没有合并至索引页中，导致实例恢复时间会很长。<br>2）在写密集的情况下，插入缓冲会占用过多的缓冲池内存，默认情况下最大可以占用1/2，这在实际应用中会带来一定的问题。</p>\n<h3 id=\"2-change-buffer\"><a href=\"#2-change-buffer\" class=\"headerlink\" title=\"2. change buffer\"></a>2. change buffer</h3><p>InnoDB从1.0.x版本开始引入了Change Buffer，可以将其视为Insert Buffer的升级。<br>从这个版本开始，InnoDB可以对DML操作——Insert、Delete、Update<code>(delete+insert)</code>都进行缓冲，<br>它们分别是：Insert Buffer, Delete Buffer,Purge Buffer。<br>对一个记录进行 update 操作有两个过程</p>\n<ul>\n<li>将记录标记为删除：delete buffer</li>\n<li>将记录真正删除：pruge buffer</li>\n</ul>\n<table>\n<tr>\n    <th colspan=\"2\">参数</th>\n    <th>InnoDB 版本</th>\n    <th colspan=\"3\">作用</th>\n</tr>\n<tr>\n    <td colspan=\"2\" style=\"text-align:center\"><span id=\"innodb_change_buffering\">innodb_change_buffering</span></td>\n    <td style=\"text-align:center\"> 1.0.x开始 </td>\n    <td colspan=\"3\">用来开启各种Buffer选项，默认值是all<br>\n        <ul>\n        <li>inserts</li>\n        <li>deletes</li>\n        <li>purges</li>\n        <li>changes：开启 inserts 和 deletes</li>\n        <li>all：都开启</li>\n        <li>none：都不开启</li>\n        </ul>\n    </td>\n</tr>\n<tr>\n    <td colspan=\"2\" rowspan=\"2\" style=\"text-align:center\"><span id=\"innodb_change_buffer_max_size\">innodb_change_buffer_max_size</span></td>\n    <td style=\"text-align:center\"> 1.2.x开始 </td>\n    <td colspan=\"3\">用来控制change buffer最大使用内存数量<br>默认值为25,表示最多使用1/4的缓存池空间<br>该参数最大有效值是50</td>\n</tr>\n</table>  \n\n<h2 id=\"两次写\"><a href=\"#两次写\" class=\"headerlink\" title=\"两次写\"></a>两次写</h2><p>提高innodb的可靠性，用来解决部分写失败(partial page write页断裂)。</p>\n<h3 id=\"脏页刷新到磁盘风险\"><a href=\"#脏页刷新到磁盘风险\" class=\"headerlink\" title=\"脏页刷新到磁盘风险\"></a>脏页刷新到磁盘风险</h3><p>IO的最小单位：</p>\n<ul>\n<li>数据库IO的最小单位是16K（MySQL默认，oracle是8K）</li>\n<li>文件系统IO的最小单位是4K（也有1K的）</li>\n<li>磁盘IO的最小单位是512字节</li>\n</ul>\n<p>因此，存在IO写入导致page损坏的风险：<br><img src=\"/Mysql/Mysql02/IO.png\" alt=\"IO风险\"></p>\n<p>提高innodb的可靠性，用来解决部分写失败(partial page write页断裂)。</p>\n<h3 id=\"Double-write解决了什么问题\"><a href=\"#Double-write解决了什么问题\" class=\"headerlink\" title=\"Double write解决了什么问题\"></a>Double write解决了什么问题</h3><p>一个数据页的大小是16K，假设在把内存中的脏页写到数据库的时候，写了8K突然宕机了，也就是说前8K数据是新的，后8K是旧的，那么磁盘数据库这个数据页就是不完整的，是一个坏掉的数据页，这种情况被称为部分<code>写失效</code></p>\n<p><strong>那么可不可以通过 redo log 来进行恢复呢？</strong><br>redo记录的是对页的修改，只能恢复校验完整（还没写）的页，不能修复坏掉的数据页，所以这个数据就丢失了，可能会造成数据不一致，所以需要double write。</p>\n<div class=\"note info\"><p>为什么 redo log 不需要 doublewrite 的支持？<br>因为 redo log 写入的单位就是 512 字节，也就是磁盘 IO 的最小单位，所以无所谓数据损坏。</p></div>   \n\n<h3 id=\"两次写工作流程\"><a href=\"#两次写工作流程\" class=\"headerlink\" title=\"两次写工作流程\"></a>两次写工作流程</h3><p><img src=\"/Mysql/Mysql02/doublewrite.png\" alt=\"两次写流程\"><br>doublewrite由两部分组成，一部分为内存中的doublewrite buffer，其大小为2MB，另一部分是磁盘上共享表空间(ibdata x)中连续的128个页，即2个区(extent)，大小也是2M。</p>\n<ol>\n<li>当一系列机制触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先拷贝至内存中的doublewrite buffer中；</li>\n<li>接着从两次写缓冲区分两次写入磁盘共享表空间中(连续存储，顺序写，性能很高)，每次写1MB；</li>\n<li>待第二步完成后，再将doublewrite buffer中的脏页数据写入实际的各个表空间文件(离散写)；(脏页数据固化后，即进行标记对应doublewrite数据可覆盖)</li>\n</ol>\n<p>现在我们来分析一下为什么 double write 可以生效。当宕机发生时，有那么几种情况：</p>\n<ol>\n<li>磁盘还未写，此时可以通过 redo log 恢复；</li>\n<li>磁盘正在进行从内存到共享表空间的写，此时数据文件中的页还没开始被写入，因此也同样可以通过 redo log 恢复；</li>\n<li>磁盘正在写数据文件，此时共享表空间已经写完，可以从共享表空间拷贝页的副本到数据文件实现恢复。</li>\n</ol>\n<h2 id=\"自适应哈希索引\"><a href=\"#自适应哈希索引\" class=\"headerlink\" title=\"自适应哈希索引\"></a>自适应哈希索引</h2><p>哈希：一次就可以定位数据</p>\n<p>B+树：取决于树的高度，生产环境一般是 3-4 层，所以需要查询 3-4 次</p>\n<p>自适应哈希索引 AHI（adaptive hash index）建立条件：观察到一个访问模式访问频繁，就会建立哈希索引</p>\n<ul>\n<li>通过该模式访问了 100 次（模式：where x = ?）</li>\n<li>页通过该模式访问了 N 次，其中 N = 页的记录总数⁄16</li>\n</ul>\n<p>InnoDB 存储引擎官方文档显示，启用 AHI 后,读取和写入速度可以提高 2 倍，辅助索引的连接操作性能可以提高 5 倍。</p>\n<h2 id=\"异步IO\"><a href=\"#异步IO\" class=\"headerlink\" title=\"异步IO\"></a>异步IO</h2><p>为了提高磁盘的操作性能，当前的数据库系统都采用异步IO的方式处理磁盘操作。用户可以在发出一个IO请求胡立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作完成，这就是AIO。<br>AIO的另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO, 这样可以提高IOPS(Input/Output Per Second)的性能。</p>\n<p>例如：用户访问页的（space, page_no)为(8,6) (8,7) (8,8)，每个页的大小为16KB，同步IO需要3次IO操作。可以优化为从(8,6)开始读取48KB。</p>\n<h2 id=\"刷新临接页\"><a href=\"#刷新临接页\" class=\"headerlink\" title=\"刷新临接页\"></a>刷新临接页</h2><p>当刷新一个脏页时，InnoDB会检查该页所在extent的所有页，如果是脏页，一起刷新。</p>\n<table>\n    <tr>\n        <th colspan=\"2\">参数</th>\n        <th>版本</th>\n        <th colspan=\"3\">作用</th>\n    </tr>\n    <tr>\n        <th colspan=\"2\" style=\"text-align:center\">innodb_flush_neighbors</th>\n        <td style=\"text-align:center\">1.2.x开始</td>\n        <td colspan=\"3\">控制是否启用该特性</td>\n    </tr>\n</table> \n\n\n<h1 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h1><ul>\n<li><a href=\"http://oohcode.com/2015/10/14/InnoDB-Key-Features/\" target=\"_blank\" rel=\"noopener\">http://oohcode.com/2015/10/14/InnoDB-Key-Features/</a></li>\n<li><a href=\"https://chyroc.cn/posts/innodb-storage-engine-reading-1/\" target=\"_blank\" rel=\"noopener\">https://chyroc.cn/posts/innodb-storage-engine-reading-1/</a></li>\n<li><a href=\"https://www.cnblogs.com/zhoujinyi/archive/2013/04/11/2988923.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zhoujinyi/archive/2013/04/11/2988923.html</a></li>\n<li><a href=\"http://huzb.me/2019/01/14/%E6%8F%92%E5%85%A5%E7%BC%93%E5%86%B2%E3%80%81%E4%B8%A4%E6%AC%A1%E5%86%99%E5%92%8C%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95/\" target=\"_blank\" rel=\"noopener\">http://huzb.me/2019/01/14/%E6%8F%92%E5%85%A5%E7%BC%93%E5%86%B2%E3%80%81%E4%B8%A4%E6%AC%A1%E5%86%99%E5%92%8C%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95/</a></li>\n<li><a href=\"https://blog.csdn.net/tanliqing2010/article/details/81509539\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/tanliqing2010/article/details/81509539</a></li>\n<li><a href=\"https://www.cnblogs.com/geaozhang/p/7341333.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/geaozhang/p/7341333.html</a></li>\n<li><a href=\"https://draveness.me/mysql-innodb\" target=\"_blank\" rel=\"noopener\">https://draveness.me/mysql-innodb</a></li>\n<li><a href=\"http://richfisher.me/blog/2017/12/18/innodb-notes/\" target=\"_blank\" rel=\"noopener\">http://richfisher.me/blog/2017/12/18/innodb-notes/</a></li>\n<li><a href=\"https://www.docs4dev.com/docs/zh/mysql/5.7/reference/innodb-architecture.html#innodb%E6%9E%B6%E6%9E%84\" target=\"_blank\" rel=\"noopener\">https://www.docs4dev.com/docs/zh/mysql/5.7/reference/innodb-architecture.html#innodb%E6%9E%B6%E6%9E%84</a></li>\n<li>MySQL技术内幕：InnoDB存储引擎(第2版)</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><ul>\n<li>InnoDB存储引擎最早由Innobase Oy公司开发，被包括在MySQL数据库所有的二进制发行版本中，</li>\n<li>从MySQL 5.5版本开始是默认的表存储引擎<font color=\"gray\">（之前的版本InnoDB存储引擎仅在Windows下为默认的存储引擎）</font></li>\n<li>第一个完整支持ACID事务的MySQL存储引擎<font color=\"gray\">（BDB是第一个支持事务的MySQL存储引擎，现在已经停止开发）</font></li>\n<li>特点：行锁设计、支持 MVCC、支持外键、提供一致性非锁定读、有效利用内存和 CPU</li></ul>","more":"\n\n<h1 id=\"体系架构\"><a href=\"#体系架构\" class=\"headerlink\" title=\"体系架构\"></a>体系架构</h1><p><img src=\"/Mysql/Mysql02/innodb-Architecture.png\" alt=\"innoDB体系结构图\"><br>InnoDB存储引擎是由内存池、后台线程、磁盘存储三大部分组成。</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>InnoDB 使用的是多线程模型, 其后台有多个不同的线程负责处理不同的任务</p>\n<h3 id=\"Master-Thread\"><a href=\"#Master-Thread\" class=\"headerlink\" title=\"Master Thread\"></a>Master Thread</h3><p>Master Thread是最核心的一个后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性。包括脏页刷新、合并插入缓冲、UNDO页的回收等。</p>\n<h3 id=\"IO-Thread\"><a href=\"#IO-Thread\" class=\"headerlink\" title=\"IO Thread\"></a>IO Thread</h3><p>在 InnoDB 存储引擎中大量使用了异步IO(Async IO)来处理写IO请求, IO Thread的工作主要是负责这些 IO 请求的回调。</p>\n<table>\n<tr>\n    <th>InnoDB 版本</th>\n    <th colspan=\"4\">线程</th>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.0之前 </td>\n    <td colspan=\"4\">4 个 io thread：write，read，insert buffer，log IO Thread.\n    <ul>\n        <li>在Linux下，IO Thread的数量不能进行调整</li>\n        <li>在Windows下可以通过参数 innodb_file_io_threads 来增大IO Thread</li>\n    </ul>\n    </td>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.0之后 </td>\n    <td colspan=\"4\">read 和 write IO thread 分别增大到了 4 个<br>\n    <ul>\n    <li>分别使用 innodb_read_io_threads 和 innodb_write_io_threads 设置线程数</li>\n    </ul>\n    </td>\n</tr>\n</table>  \n\n<h3 id=\"Purge-Thread\"><a href=\"#Purge-Thread\" class=\"headerlink\" title=\"Purge Thread\"></a>Purge Thread</h3><p>事务提交后，其所使用的undo log可能不再需要，因此需要Purge Thread来回收已经分配并使用的UNDO页。</p>\n<table>\n<tr>\n    <th>InnoDB 版本</th>\n    <th colspan=\"4\">作用</th>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.1之前 </td>\n    <td colspan=\"4\">purge 操作在 master thread 内完成</td>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.1之后 </td>\n    <td colspan=\"4\">purge 可以独立到单独的线程,减轻 master thread 工作,提高 cpu 利用率和提高性能<br>\n    <ul>\n    <li>MySQL数据库的配置文件<code>[mysqld]</code>中添加如下命令来启用独立的Purge Thread：</li>\n    <li>innodb_purge_threads=1 </li>\n    <li>1.1版本中，即使将 innodb_purge_threads 设为大于1，InnoDB存储引擎启动时也会将其设为1</li>\n    </ul>\n    </td>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.2之后</td>\n    <td colspan=\"4\">支持多个Purge Thread, 这样做可以加快UNDO页的回收，也能更进一步利用磁盘的随机读取性能</td>\n</tr>\n</table>                                  \n\n<h3 id=\"Page-Cleaner-Thread\"><a href=\"#Page-Cleaner-Thread\" class=\"headerlink\" title=\"Page Cleaner Thread\"></a>Page Cleaner Thread</h3><p>Page Cleaner Thread的作用是取代Master Thread中脏页刷新的操作，<br>减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高性能。</p>\n<h2 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h2><p>innoDB内存主要由<a href=\"#缓冲池\">缓冲池(innodb buffer pool)</a>、<a href=\"#重做日志缓冲\">重做日志缓冲(redo log buffer)</a>、<a href=\"#额外的内存池\">额外内存池组成(innodb additional men pool size)</a>组成</p>\n<h3 id=\"缓冲池\"><a href=\"#缓冲池\" class=\"headerlink\" title=\"缓冲池\"></a>缓冲池</h3><p>缓冲池是主存储器中的一个区域，用于在访问时缓存表和索引数据。缓冲池允许直接从内存处理常用数据，从而加快处理速度。<br>在专用服务器上，通常会将最多80％的物理内存分配给缓冲池。<br>读取流程：<br>     <img src=\"/Mysql/Mysql02/read.png\" alt=\"流程图\"><br>更新流程：<br>     <img src=\"/Mysql/Mysql02/write.png\" alt=\"流程图\"></p>\n<p>因此缓冲池的大小影响数据库的整体性能。</p>\n<div class=\"note info\"><p>由于32位操作系统的限制，在该系统下最多将该值设置为3G。<br>用户可以打开操作系统的<code>PAE</code>选项来获得32位操作系统下最大64GB内存的支持。<br>为了让数据库使用更多的内存,建议数据库系统都采用 64 位操作系统。</p></div>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">参数</th>\n<th align=\"center\">版本</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">innodb_buffer_pool_instances</td>\n<td align=\"center\">从InnoDB 1.0.x开始</td>\n<td align=\"center\">配置多个缓冲池实例，默认为1</td>\n</tr>\n</tbody></table>\n<h4 id=\"缓冲池中缓存的数据页类型\"><a href=\"#缓冲池中缓存的数据页类型\" class=\"headerlink\" title=\"缓冲池中缓存的数据页类型\"></a>缓冲池中缓存的数据页类型</h4><ul>\n<li>索引页(index page)：缓存数据表索引</li>\n<li>数据页(data page)：缓存数据页，占缓冲池的绝大部分</li>\n<li>undo页(undo Log Page)：undo页是保存事务，为回滚做准备的。</li>\n<li><a href=\"#插入缓冲\">插入缓冲</a>（insert buffer）：插入数据时要先插入到缓存池中。</li>\n<li>自适应哈希索引（adaptive hash index）： 除了B+ Tree索引外，在缓冲池还会维护一个哈希索引，以便在缓冲池中快速找到数据页。</li>\n<li>InnoDB存储的锁信息（lock info）</li>\n<li>数据字典信息（data dictionary）<br>  在MySQL中，数据字典信息内容就包括表结构、数据库名或表名、字段的数据类型、视图、索引、表字段信息、存储过程、触发器等内容。<br>  InnoDB有自己的表缓存，可以称为表定义缓存或者数据字典。当InnoDB打开一张表，就增加一个对应的对象到数据字典。</li>\n</ul>\n<h4 id=\"缓冲池管理方式\"><a href=\"#缓冲池管理方式\" class=\"headerlink\" title=\"缓冲池管理方式\"></a>缓冲池管理方式</h4><p><img src=\"/Mysql/Mysql02/three-list2.png\" alt=\"三种list\"></p>\n<ol>\n<li><p><strong>Free list</strong><br>当数据库刚启动时，LRU列表是空的，这时页都存放在Free list中。<br>当需要从缓冲池中分页时，从Free list中查找是否有可用的空闲页，若有则将该页从Free列表中删除，放入到LRU列表中,维持页数守恒。</p>\n</li>\n<li><p><strong>LRU list</strong><br> <strong>LRU算法</strong>：最频繁使用页在LRU列表的前端，最少使用的页在尾端。首先释放LRU列表中的尾端的页。缓冲池中页的大小默认为16KB。<br> <strong>InnoDB优化的LRU算法(midpoint insertion strategy)</strong>：将新读取到的页不放在首部，而是中间部位 <code>midpoint</code> 位置。目标是确保频繁访问”热”页面保留在缓冲池中。<br> <img src=\"/Mysql/Mysql02/innodb-buffer-pool-list.jpg\" alt=\"lru\"></p>\n <table>\n <tr>\n     <th>参数</th>\n     <th colspan=\"2\">作用</th>\n </tr>\n <tr>\n     <td style=\"text-align:center\"> innodb_old_blocks_pct </td>\n     <td colspan=\"2\">控制LRU列表中 old list 的百分比。<br>\n        默认值为 37，对应于原始固定比率3/8。<br>\n        值范围是 5（缓冲池中的新页面很快就会老化）到 95。\n     </td>\n </tr>\n <tr>\n     <td style=\"text-align:center\"> innodb_old_blocks_time </td>\n     <td colspan=\"2\">指定第一次访问页面之后的时间窗口（ms）<br>\n        在此期间可以访问该页面而不移动到LRU列表的前端<br>\n        默认值为 1000 ms\n     </td>\n </tr>\n </table> \n\n<p> 默认情况下，算法操作如下：</p>\n<ul>\n<li>在默认配置下， <code>midpoint</code>位置在LRU list 的5/8处。</li>\n<li><code>midpoint</code>是new sublist的尾部与old sublist的头部相交的边界。</li>\n<li>当 InnoDB 将页面读入缓冲池时，将页插入<code>midpoint</code>位置(old sublist的头部)。</li>\n<li>访问old sublist中的页 &amp;&amp; 该页在old sublist中的停留时间超过innodb_old_blocks_time设置的时间，使其变<code>young</code>,将其移动到缓冲池的头部(new sublist的头部)。</li>\n<li>当页从LRU列表的old部分加入到new部分时，称此时发生的操作为<code>page made young</code>，而因为innodb_old_blocks_time的设置而导致页没有从old部分移动到new部分的操作称为<code>page not made young</code></li>\n<li>在数据库操作中，被访问的页将移到new sublist的表头，这样一来，在new sublist中的未被访问的节点将逐渐往表尾移动，当移动过中点，将变为old list的节点。当表满时，old list末尾的页将会被移除。</li>\n</ul>\n<div class=\"note warning\"><p>为什么不采用朴素的LRU？<br>因为某些SQL操作会访问很多页，甚至全部页，但仅仅在该次查询操作，并不是活跃的热点数据。可能会使缓冲池中的页被刷新出，从而影响缓冲池的效率。</p></div>  \n\n<ol start=\"3\">\n<li><strong>Flush list</strong><br>在LRU类表的页被修改后，称为脏页（Dirty Page），即缓存和硬盘的页数据不一致。<br>数据库会通过<code>CHECKPOINT</code>机制将脏页刷新回磁盘，Flush list中的页即为脏页列表。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"重做日志缓冲\"><a href=\"#重做日志缓冲\" class=\"headerlink\" title=\"重做日志缓冲\"></a>重做日志缓冲</h3>   <div class=\"note info\"><p><strong>什么是redo log？</strong><br>当数据库对数据做修改的时候，需要把数据页从磁盘读到buffer pool中，然后在buffer pool中进行修改，那么这个时候buffer pool中的数据页就与磁盘上的数据页内容不一致，称buffer pool的数据页为dirty page 脏数据。<br>如果发生非正常的DB服务重启，那么这些数据并没有同步到磁盘文件中（注意，同步到磁盘文件是个随机IO），会发生数据丢失。<br>如果这个时候，能够有一个文件，当缓冲池中的data page变更结束后，把相应修改记录记录到这个文件（注意，记录日志是顺序IO），那么当DB服务发生crash的情况，恢复DB的时候，也可以根据这个文件的记录内容，重新应用到磁盘文件，数据保持一致。<br>这个文件就是redo log ，用于记录 数据修改后的记录，顺序记录。<br><br><strong>什么是undo log？</strong><br>undo日志用于存放数据修改被修改前的值。<br>假设修改表中 id=1 的行数据，把Name=’B’ 修改为Name = ‘B2’ ，那么undo日志就会用来存放Name=’B’的记录，如果这个修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。</p></div>  \n\n<p><img src=\"/Mysql/Mysql02/redo-buffer.png\" alt=\"lru\"></p>\n<p>  重做日志缓冲不需要设置很大，通常情况下8M能满足大部分的应用场景。重做日志支持以下三种情况触发刷新：</p>\n<ul>\n<li>Master Thread每一秒将重做日志缓冲刷新到重做日志文件</li>\n<li>每次事务提交时将重做日志缓冲刷新到重做日志文件</li>\n<li>当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件</li>\n</ul>\n<h3 id=\"额外的内存池\"><a href=\"#额外的内存池\" class=\"headerlink\" title=\"额外的内存池\"></a>额外的内存池</h3><p>   在InnoDB存储引擎中，对内存的管理是通过一种称为内存堆的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。</p>\n<h1 id=\"Checkpoint技术\"><a href=\"#Checkpoint技术\" class=\"headerlink\" title=\"Checkpoint技术\"></a>Checkpoint技术</h1><div class=\"note info\"><p><strong>什么是Checkpoint？</strong><br>是一个数据库事件(event)，这个事件激活以后会触发数据库写进程(DBWR)将脏数据块写到磁盘中。                           </p>\n<p><strong>为什么需要Checkpoint技术？</strong><br>innoDB在事务提交时，先写重做日志，再修改内存数据这样，就产生了脏页。既然有重做日志保证数据持久性，查询时也可以从缓冲池页中取数据，那为什么还要刷新脏页到磁盘呢？如果重做日志可以无限增大，同时缓冲池足够大，能够缓存所有数据，那么是不需要将缓冲池中的脏页刷新到磁盘。但是，会有以下几个问题：<br>1) 服务器内存有限，缓冲池不够用，无法缓存全部数据<br>2) 重做日志无限增大成本要求太高<br>3) 宕机时如果重做全部日志恢复时间过长            </p>\n<p><strong>Checkpoint 解决了什么问题？</strong><br>1) 缩短短数据库的恢复时间<br>2) 缓冲池不够时，将脏页刷新到磁盘<br>3) 重做日志不可用时，刷新脏页</p></div> \n\n<p>对于InnoDB存储引擎而言，其是通过LSN（Log Sequence Number）来标记版本的。每个页有LSN，重做日志中也有LSN，Checkpoint也有LSN。</p>\n<p>innodb 内部有两种 checkpoint：</p>\n<ol>\n<li><p><strong>sharp checkpoint</strong>：数据库关闭的时候将<code>所有的脏页</code>刷回到磁盘，默认方式，参数 innodb_fast_shudown=1</p>\n</li>\n<li><p><strong>fuzzy checkpoint</strong>：只刷新<code>部分脏页</code></p>\n<ul>\n<li><p>master thread checkpoint：master thread 异步的以每秒或者每 10 秒的速度从缓冲池的脏页列表中刷新一定比列的也回磁盘</p>\n<ul>\n<li>周期性，异步，读取flush list，找到脏页，写入磁盘</li>\n</ul>\n</li>\n<li><p>flush_lru_list checkpoint：InnoDB要保证LRU列表中需要有差不多100个空闲页可供使用。如果没有这么多，就会将 lru list 尾部的页移除。如果这些页有脏页，就需要进行 checkpoint。</p>\n<ul>\n<li>innodb 1.1.x版本之前，检查在用户查询线程中,会阻塞用户查询操作。</li>\n<li>innodb 1.2.x版本之后，检查放到了单独的 page cleaner 线程中,可通过 <strong>innodb_lru_scan_depth</strong> 控制lru列表中可用页的数量，默认是1024。</li>\n</ul>\n</li>\n<li><p>async/sync flush checkpoint：重做日志文件不可用时，强制将一些页刷新到磁盘。达到重做日志文件的大小阈值。</p>\n<ul>\n<li>checkpoint age = redo_log_lsn - cp_lsn<br> 低水位=75% * total_redo_log_file_size<br> 高水位=90% * total_redo_log_file_size</li>\n<li>checkpoint age &lt; 低水位<br>   不需要刷新</li>\n<li>低水位  &lt;=  checkpoint age &lt;= 高水位<br>   会强制进行 checkpoint ，触发async flush， 根据flush_list的顺序，刷新足够多的脏页，直到 checkpoint age &lt; 低水位</li>\n<li>checkpoint age &gt; 高水位<br> 会强制进行 checkpoint ，触发sync flush 根据flush_list的顺序，刷新脏页, 直到 checkpoint age &lt; 低水位</li>\n</ul>\n</li>\n<li><p>dirty page too much checkpoint：当缓冲池中脏页的数量占据一定百分比时，强制进行Checkpoint，用来保证缓冲池中有足够的页，通过 <a href=\"#innodb_max_dirty_pages_pct\">innodb_max_dirty_pages_pct</a> 参数控制。</p>\n</li>\n</ul>\n</li>\n</ol>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>-------- 第二部分 --------</span>\n</div>\n\n<h1 id=\"Master-thread-工作方式\"><a href=\"#Master-thread-工作方式\" class=\"headerlink\" title=\"Master thread 工作方式\"></a>Master thread 工作方式</h1><h2 id=\"InnoDB-1-0-x-版本之前的-Master-thread\"><a href=\"#InnoDB-1-0-x-版本之前的-Master-thread\" class=\"headerlink\" title=\"InnoDB 1.0.x 版本之前的 Master thread\"></a>InnoDB 1.0.x 版本之前的 Master thread</h2><p>Master thread 内部有多个循环 loop 组成：</p>\n<ul>\n<li>主循环 loop</li>\n<li>后台循环 backgroup loop</li>\n<li>刷新循环 flush loop</li>\n<li>暂停循环 suspend loop</li>\n</ul>\n<p>伪代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">master_thread</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tgoto loop;</span><br><span class=\"line\">\t<span class=\"comment\">//主循环</span></span><br><span class=\"line\">\tloop ：</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i)&#123;</span><br><span class=\"line\">\t\tthread_sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//1. 日志缓冲刷新到磁盘，即使事务还没有提交</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> log buffer flush to disk;</span><br><span class=\"line\">\t\t<span class=\"comment\">//2. 根据前一秒IO操作小于5，合并插入缓冲</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(last_one_second_ios &lt; <span class=\"number\">5</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">do</span> merge at most <span class=\"number\">5</span> insert buffer;</span><br><span class=\"line\">\t\t<span class=\"comment\">//3. 脏页的比例超过了阈值，刷新 100 个脏页到磁盘</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">do</span> buffer pool flush <span class=\"number\">100</span> dirty page;</span><br><span class=\"line\">\t\t<span class=\"comment\">//4. 没有用户活动（数据库空闲时）或者数据库关闭（shutdown），切换到 backgroup loop</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(no user activity)</span><br><span class=\"line\">\t\t\tgoto backgroud loop;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//1. 前10秒IO操作小于200，刷新 100 个脏页到磁盘</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(last_ten_second_ios &lt; <span class=\"number\">200</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> buffer pool flush <span class=\"number\">100</span> dirty page;</span><br><span class=\"line\">\t<span class=\"comment\">//2. 合并至多 5 个插入缓冲</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> merge at most <span class=\"number\">5</span> insert buffer;</span><br><span class=\"line\">\t<span class=\"comment\">//3. 将重做日志刷新到磁盘</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> log buffer flush to disk;</span><br><span class=\"line\">\t<span class=\"comment\">//4. 删除无用的 undo 页（每次最多尝试回收 20 个 undo 页）</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> full purge;</span><br><span class=\"line\">\t<span class=\"comment\">//5. 脏页比例超过 70% 刷新100 个脏页到磁盘，否则刷新 10 个脏页</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( buf_get_modified_ratio_pct ＞ <span class=\"number\">70</span> % )</span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> buffer pool flush <span class=\"number\">100</span> dirty page</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tbuffer pool flush <span class=\"number\">10</span> dirty page</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\tgoto loop</span><br><span class=\"line\">\t<span class=\"comment\">//后台循环\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\">\tbackground loop :</span><br><span class=\"line\">\t<span class=\"comment\">//1. 删除无用的 undo 页</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> full purge</span><br><span class=\"line\">\t<span class=\"comment\">//2. 合并 20 个插入缓冲</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> merge <span class=\"number\">20</span> insert buffer</span><br><span class=\"line\">\t<span class=\"comment\">//3.如果有任务，跳转到主循环，否则跳转到刷新循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> not idle\t</span><br><span class=\"line\">\t\tgoto loop</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tgoto flush loop</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//刷新循环</span></span><br><span class=\"line\">\tflush loop :</span><br><span class=\"line\">\t<span class=\"comment\">//不断刷新100个脏页，直到脏页比例没有超过阈值</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> buffer pool flush <span class=\"number\">100</span> dirty page</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( buf_get_modified_ratio_pct ＞ innodb_max_dirty_pages_pct )</span><br><span class=\"line\">\t\tgoto flush loop</span><br><span class=\"line\">\t<span class=\"comment\">//没有任务，跳转到暂停循环</span></span><br><span class=\"line\">\tgoto suspend loop</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//暂停循环</span></span><br><span class=\"line\">\tsuspend loop :</span><br><span class=\"line\">\t<span class=\"comment\">//将主线程挂起，等待事件发生</span></span><br><span class=\"line\">\tsuspend_thread()</span><br><span class=\"line\">\twaiting event</span><br><span class=\"line\">\tgoto loop;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"InnoDB-1-2-x-版本之前的-Master-thread\"><a href=\"#InnoDB-1-2-x-版本之前的-Master-thread\" class=\"headerlink\" title=\"InnoDB 1.2.x 版本之前的 Master thread\"></a>InnoDB 1.2.x 版本之前的 Master thread</h2><ol>\n<li>提高刷新脏页数量和合并插入数量，改善磁盘 IO 处理能力,刷新数量不再硬编码，而是使用百分比控制。<ul>\n<li>在合并插入缓冲的时候，合并插入缓冲的数量为 <a href=\"#innodb_io_capacity\">innodb_io_capacity</a> 的 5%</li>\n<li>在从缓冲区刷新脏页的时候，刷新脏页的数量为 <a href=\"#innodb_io_capacity\">innodb_io_capacity</a></li>\n</ul>\n</li>\n<li>增加了自适应刷新脏页功能。<ul>\n<li>1.0.x之前版本：脏页在缓冲池占比小于<a href=\"#innodb_max_dirty_pages_pct\">innodb_max_dirty_pages_pct</a>，不刷新脏页，大于则刷新100个脏页</li>\n<li>1.0.x版本开始：引入<a href=\"#innodb_adaptive_flushing\">innodb_adaptive_flushing</a>参数，通过函数buf_flush_get_desired_flush_rate判断产生重做日志的速度来决定最适合的刷新脏页数量。</li>\n</ul>\n</li>\n<li>full purge回收的Undo页的数量也不再硬编码，使用参数<a href=\"#innodb_purge_batch_size\">innodb_purge_batch_size</a>控制。</li>\n</ol>\n<table>\n<tr>\n    <th colspan=\"2\">参数</th>\n    <th>InnoDB 版本</th>\n    <th colspan=\"3\">作用</th>\n</tr>\n<tr>\n    <td colspan=\"2\" style=\"text-align:center\"><span id=\"innodb_io_capacity\">innodb_io_capacity</span></td>\n    <td style=\"text-align:center\"> 1.0.x开始 </td>\n    <td colspan=\"3\">表示磁盘IO的吞吐量,默认值是200</td>\n</tr>\n<tr>\n    <td colspan=\"2\" rowspan=\"2\" style=\"text-align:center\"><span id=\"innodb_max_dirty_pages_pct\">innodb_max_dirty_pages_pct</span></td>\n    <td style=\"text-align:center\"> 1.0.x之前 </td>\n    <td colspan=\"3\">脏页在缓冲池中所占比率，默认值是90</td>\n</tr>\n<tr>\n    <td style=\"text-align:center\"> 1.0.x开始</td>\n    <td colspan=\"3\">默认值是75<br>加快刷新脏页的频率，保证了磁盘IO的负载。</td>                       \n</tr>\n<tr>\n    <td colspan=\"2\" style=\"text-align:center\"><span id=\"innodb_adaptive_flushing\">innodb_adaptive_flushing</span></td>\n    <td style=\"text-align:center\"> 1.0.x开始 </td>\n    <td colspan=\"3\">是否自适应刷新脏页，默认为 ON</td>\n</tr>\n<tr>\n    <td colspan=\"2\" style=\"text-align:center\"><span id=\"innodb_purge_batch_size\">innodb_purge_batch_size</span></td>\n    <td style=\"text-align:center\"> 1.0.x开始 </td>\n    <td colspan=\"3\">清除 undo 页时,表示一次删除多少页,默认是 20</td>\n</tr>\n</table>   \n\n<p>Master Thread的伪代码变为了下面的形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">master_thread</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tgoto loop;</span><br><span class=\"line\">\t<span class=\"comment\">//主循环</span></span><br><span class=\"line\">\tloop ：</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i)&#123;</span><br><span class=\"line\">\t\tthread_sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//1. 日志缓冲刷新到磁盘，即使事务还没有提交</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> log buffer flush to disk;</span><br><span class=\"line\">\t\t<span class=\"comment\">//2. 根据前一秒IO操作小于5%innodb_io_capacity，合并插入缓冲</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(last_one_second_ios &lt; <span class=\"number\">5</span>%innodb_io_capacity)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">do</span> merge <span class=\"number\">5</span>%innodb_io_capacity insert buffer;</span><br><span class=\"line\">\t\t<span class=\"comment\">//3. 脏页的比例超过了阈值，刷新 100%innodb_io_capacity 个脏页到磁盘</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">do</span> buffer pool flush <span class=\"number\">100</span>%innodb_io_capacity dirty page;</span><br><span class=\"line\">\t\t<span class=\"comment\">//4. 没有用户活动（数据库空闲时）或者数据库关闭（shutdown），切换到 backgroup loop</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(no user activity)</span><br><span class=\"line\">\t\t\tgoto backgroud loop;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//1. 前10秒IO操作小于innodb_io_capacity，刷新 innodb_io_capacity 个脏页到磁盘</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(last_ten_second_ios &lt; innodb_io_capacity)</span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> buffer pool flush <span class=\"number\">100</span>%innodb_io_capacity dirty page;</span><br><span class=\"line\">\t<span class=\"comment\">//2. 合并至多 5%innodb_io_capacity 个插入缓冲</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> merge at most <span class=\"number\">5</span>%innodb_io_capacity insert buffer;</span><br><span class=\"line\">\t<span class=\"comment\">//3. 将重做日志刷新到磁盘</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> log buffer flush to disk;</span><br><span class=\"line\">\t<span class=\"comment\">//4. 删除无用的 undo 页（每次最多尝试回收 5%innodb_io_capacity 个 undo 页）</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> full purge;</span><br><span class=\"line\">\t<span class=\"comment\">//5. 脏页比例超过 70% 刷新 100%innodb_io_capacity 个脏页到磁盘，</span></span><br><span class=\"line\">\t<span class=\"comment\">// 否则刷新 10%innodb_io_capacity 个脏页</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( buf_get_modified_ratio_pct ＞ <span class=\"number\">70</span> % )</span><br><span class=\"line\">\t\t<span class=\"keyword\">do</span> buffer pool flush <span class=\"number\">100</span>%innodb_io_capacity dirty page</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tbuffer pool flush <span class=\"number\">10</span>%innodb_io_capacity dirty page</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\tgoto loop</span><br><span class=\"line\">\t<span class=\"comment\">//后台循环\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span></span><br><span class=\"line\">\tbackground loop :</span><br><span class=\"line\">\t<span class=\"comment\">//1. 删除无用的 undo 页</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> full purge</span><br><span class=\"line\">\t<span class=\"comment\">//2. 合并 100%innodb_io_capacity 个插入缓冲</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> merge <span class=\"number\">100</span>%innodb_io_capacity insert buffer</span><br><span class=\"line\">\t<span class=\"comment\">//3.如果有任务，跳转到主循环，否则跳转到刷新循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> not idle\t</span><br><span class=\"line\">\t\tgoto loop</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tgoto flush loop</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//刷新循环</span></span><br><span class=\"line\">\tflush loop :</span><br><span class=\"line\">\t<span class=\"comment\">//不断刷新 100%innodb_io_capacity 个脏页，直到脏页比例没有超过阈值</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span> buffer pool flush <span class=\"number\">100</span>%innodb_io_capacity dirty page</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( buf_get_modified_ratio_pct ＞ innodb_max_dirty_pages_pct )</span><br><span class=\"line\">\t\tgoto flush loop</span><br><span class=\"line\">\t<span class=\"comment\">//没有任务，跳转到暂停循环</span></span><br><span class=\"line\">\tgoto suspend loop</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//暂停循环</span></span><br><span class=\"line\">\tsuspend loop :</span><br><span class=\"line\">\t<span class=\"comment\">//将主线程挂起，等待事件发生</span></span><br><span class=\"line\">\tsuspend_thread()</span><br><span class=\"line\">\twaiting event</span><br><span class=\"line\">\tgoto loop;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"InnoDB-1-2-x-版本的-Master-thread\"><a href=\"#InnoDB-1-2-x-版本的-Master-thread\" class=\"headerlink\" title=\"InnoDB 1.2.x 版本的 Master thread\"></a>InnoDB 1.2.x 版本的 Master thread</h2><p>InnoDB 1.2.x 版本中再次对 Master Thread 进行了优化，伪代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> InnoDB is idle</span><br><span class=\"line\"><span class=\"comment\">//之前版本中每10秒的操作</span></span><br><span class=\"line\">srv_master_do_idle_tasks();</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"comment\">//之前版本中每秒的操作</span></span><br><span class=\"line\">srv_master_do_active_tasks();</span><br></pre></td></tr></table></figure>\n\n<p>对于刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。</p>\n<h1 id=\"InnoDB-关键特性\"><a href=\"#InnoDB-关键特性\" class=\"headerlink\" title=\"InnoDB 关键特性\"></a>InnoDB 关键特性</h1><p>关键特性包括：</p>\n<ul>\n<li>插入缓冲 insert buffer</li>\n<li>两次写 double write</li>\n<li>自适应哈希索引 adaptive hash index</li>\n<li>异步 io async io</li>\n<li>刷新邻接页 flush neighbor page</li>\n</ul>\n<h2 id=\"插入缓冲\"><a href=\"#插入缓冲\" class=\"headerlink\" title=\"插入缓冲\"></a>插入缓冲</h2><h3 id=\"聚集索引（一级索引）\"><a href=\"#聚集索引（一级索引）\" class=\"headerlink\" title=\"聚集索引（一级索引）\"></a>聚集索引（一级索引）</h3><p>表在存储的时候按照主键排序进行存储，不需要磁盘的随机读取，插入效率高。<br>非叶子节点存放的是键值，叶子节点存放的是行数据，称之为数据页。</p>\n<h3 id=\"辅助索引（二级索引）\"><a href=\"#辅助索引（二级索引）\" class=\"headerlink\" title=\"辅助索引（二级索引）\"></a>辅助索引（二级索引）</h3><p>除了聚集索引之外的索引都可以称之为辅助索引，叶子节点中存放的是主键的键值。叶子节点的插入不再有序，这时就需要离散访问非聚集索引页，插入性能变低。<br>一张表可以存在多个辅助索引，但是只能有一个聚集索引，通过辅助索引来查找对应的航记录的话，需要进行两步，第一步通过辅助索引来确定对应的主键，第二步通过相应的主键值在聚集索引中查询到对应的行记录，也就是进行两次B+树搜索。</p>\n<h3 id=\"索引数据页的更新（针对二级索引）\"><a href=\"#索引数据页的更新（针对二级索引）\" class=\"headerlink\" title=\"索引数据页的更新（针对二级索引）\"></a>索引数据页的更新（针对二级索引）</h3><p><img src=\"/Mysql/Mysql02/index-update.png\" alt=\"index更新流程\"><br>表数据更新的同时也会更新对应的表的索引数据，所以：对表进行insert delete update时，很可能会产生大量的物理读(物理读索引数据页)</p>\n<p><img src=\"/Mysql/Mysql02/insert-buffer.png\" alt=\"引入insertbuffer后index更新流程\"></p>\n<h3 id=\"1-insert-buffer\"><a href=\"#1-insert-buffer\" class=\"headerlink\" title=\"1. insert buffer\"></a>1. insert buffer</h3><p>Insert Buffer的使用流程：<br><img src=\"/Mysql/Mysql02/Insert-Buffer.svg\" alt=\"Insert Buffer的使用流程\"></p>\n<h4 id=\"插入缓冲的启用需要满足以下两个条件：\"><a href=\"#插入缓冲的启用需要满足以下两个条件：\" class=\"headerlink\" title=\"插入缓冲的启用需要满足以下两个条件：\"></a>插入缓冲的启用需要满足以下两个条件：</h4><p>1）索引是辅助索引（secondary index）<br>2）索引不是唯一的：整个索引数据被切分为2部分，无法保证唯一性。</p>\n<h4 id=\"insert-buffer结构\"><a href=\"#insert-buffer结构\" class=\"headerlink\" title=\"insert buffer结构\"></a>insert buffer结构</h4><p>insert buffer的数据结构是B+树，全局只有一颗B+树。<br>B+树的非叶子节点是Search key，构造结构为(space,marker,offset)。</p>\n<ul>\n<li>space：待插入记录所在表的表空间id。每个表都有唯一的表空间id，通过表空间id可以查出是哪张表。</li>\n<li>marker：兼容之前的版本。</li>\n<li>offset：在表空间中页的偏移量。</li>\n</ul>\n<p>当一个辅助索引要插入到(space,offset)中时，如果该页不在缓冲池中，则按上述规则构造一个search key，将该记录插入到insert buffer中。<br>但是如果该页一直在insert buffer中，不断有记录插入到同一个索引页中，那么该索引页的空间就会逐渐缩小，要出现B+树节点的分裂情况，这时就不能进行insert buffer了。<br>所以，我们需要一个机制来管理每个页面的剩余空闲空间，这就是<code>Insert buffer bitmap</code>。<br>每隔page_size个页面，就是一个Insert buffer bitmap page。<br>例如：若page_size = 16384(16k)，那么page_no为0，16384，32768，…的page，就是Insert buffer bitmap page，Bitmap page的功能，就是管理其后连续的page_size – 1个page的空间使用率。<br>每个辅助索引页在Insert buffer bitmap中占用4bit。</p>\n<h4 id=\"merge-insert-buffer-发生条件\"><a href=\"#merge-insert-buffer-发生条件\" class=\"headerlink\" title=\"merge insert buffer 发生条件\"></a>merge insert buffer 发生条件</h4><ul>\n<li>辅助索引页被读取到buffer pool中：正常的select查询操作，索引页被调入内存，该索引页对应在insert buffer中的索引更改记录就会发生merge操作。</li>\n<li>Insert buffer bitmap page追踪到该索引页无可用空间时。</li>\n<li>Master Thread。</li>\n</ul>\n<h4 id=\"insert-buffer-刷新到磁盘条件\"><a href=\"#insert-buffer-刷新到磁盘条件\" class=\"headerlink\" title=\"insert buffer 刷新到磁盘条件\"></a>insert buffer 刷新到磁盘条件</h4><ul>\n<li>有一个后台线程，会认为数据库空闲时；</li>\n<li>数据库缓冲池不够用时；</li>\n<li>数据库正常关闭时；</li>\n<li>redo log写满时：<em>几乎不会出现redo log写满，此时整个数据库处于无法写入的不可用状态</em></li>\n</ul>\n<h4 id=\"插入缓冲主要带来如下两个坏处\"><a href=\"#插入缓冲主要带来如下两个坏处\" class=\"headerlink\" title=\"插入缓冲主要带来如下两个坏处\"></a>插入缓冲主要带来如下两个坏处</h4><p>1）可能导致数据库宕机后实例恢复时间变长。如果应用程序执行大量的插入和更新操作，且涉及非唯一的聚集索引，一旦出现宕机，这时就有大量内存中的插入缓冲区数据没有合并至索引页中，导致实例恢复时间会很长。<br>2）在写密集的情况下，插入缓冲会占用过多的缓冲池内存，默认情况下最大可以占用1/2，这在实际应用中会带来一定的问题。</p>\n<h3 id=\"2-change-buffer\"><a href=\"#2-change-buffer\" class=\"headerlink\" title=\"2. change buffer\"></a>2. change buffer</h3><p>InnoDB从1.0.x版本开始引入了Change Buffer，可以将其视为Insert Buffer的升级。<br>从这个版本开始，InnoDB可以对DML操作——Insert、Delete、Update<code>(delete+insert)</code>都进行缓冲，<br>它们分别是：Insert Buffer, Delete Buffer,Purge Buffer。<br>对一个记录进行 update 操作有两个过程</p>\n<ul>\n<li>将记录标记为删除：delete buffer</li>\n<li>将记录真正删除：pruge buffer</li>\n</ul>\n<table>\n<tr>\n    <th colspan=\"2\">参数</th>\n    <th>InnoDB 版本</th>\n    <th colspan=\"3\">作用</th>\n</tr>\n<tr>\n    <td colspan=\"2\" style=\"text-align:center\"><span id=\"innodb_change_buffering\">innodb_change_buffering</span></td>\n    <td style=\"text-align:center\"> 1.0.x开始 </td>\n    <td colspan=\"3\">用来开启各种Buffer选项，默认值是all<br>\n        <ul>\n        <li>inserts</li>\n        <li>deletes</li>\n        <li>purges</li>\n        <li>changes：开启 inserts 和 deletes</li>\n        <li>all：都开启</li>\n        <li>none：都不开启</li>\n        </ul>\n    </td>\n</tr>\n<tr>\n    <td colspan=\"2\" rowspan=\"2\" style=\"text-align:center\"><span id=\"innodb_change_buffer_max_size\">innodb_change_buffer_max_size</span></td>\n    <td style=\"text-align:center\"> 1.2.x开始 </td>\n    <td colspan=\"3\">用来控制change buffer最大使用内存数量<br>默认值为25,表示最多使用1/4的缓存池空间<br>该参数最大有效值是50</td>\n</tr>\n</table>  \n\n<h2 id=\"两次写\"><a href=\"#两次写\" class=\"headerlink\" title=\"两次写\"></a>两次写</h2><p>提高innodb的可靠性，用来解决部分写失败(partial page write页断裂)。</p>\n<h3 id=\"脏页刷新到磁盘风险\"><a href=\"#脏页刷新到磁盘风险\" class=\"headerlink\" title=\"脏页刷新到磁盘风险\"></a>脏页刷新到磁盘风险</h3><p>IO的最小单位：</p>\n<ul>\n<li>数据库IO的最小单位是16K（MySQL默认，oracle是8K）</li>\n<li>文件系统IO的最小单位是4K（也有1K的）</li>\n<li>磁盘IO的最小单位是512字节</li>\n</ul>\n<p>因此，存在IO写入导致page损坏的风险：<br><img src=\"/Mysql/Mysql02/IO.png\" alt=\"IO风险\"></p>\n<p>提高innodb的可靠性，用来解决部分写失败(partial page write页断裂)。</p>\n<h3 id=\"Double-write解决了什么问题\"><a href=\"#Double-write解决了什么问题\" class=\"headerlink\" title=\"Double write解决了什么问题\"></a>Double write解决了什么问题</h3><p>一个数据页的大小是16K，假设在把内存中的脏页写到数据库的时候，写了8K突然宕机了，也就是说前8K数据是新的，后8K是旧的，那么磁盘数据库这个数据页就是不完整的，是一个坏掉的数据页，这种情况被称为部分<code>写失效</code></p>\n<p><strong>那么可不可以通过 redo log 来进行恢复呢？</strong><br>redo记录的是对页的修改，只能恢复校验完整（还没写）的页，不能修复坏掉的数据页，所以这个数据就丢失了，可能会造成数据不一致，所以需要double write。</p>\n<div class=\"note info\"><p>为什么 redo log 不需要 doublewrite 的支持？<br>因为 redo log 写入的单位就是 512 字节，也就是磁盘 IO 的最小单位，所以无所谓数据损坏。</p></div>   \n\n<h3 id=\"两次写工作流程\"><a href=\"#两次写工作流程\" class=\"headerlink\" title=\"两次写工作流程\"></a>两次写工作流程</h3><p><img src=\"/Mysql/Mysql02/doublewrite.png\" alt=\"两次写流程\"><br>doublewrite由两部分组成，一部分为内存中的doublewrite buffer，其大小为2MB，另一部分是磁盘上共享表空间(ibdata x)中连续的128个页，即2个区(extent)，大小也是2M。</p>\n<ol>\n<li>当一系列机制触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先拷贝至内存中的doublewrite buffer中；</li>\n<li>接着从两次写缓冲区分两次写入磁盘共享表空间中(连续存储，顺序写，性能很高)，每次写1MB；</li>\n<li>待第二步完成后，再将doublewrite buffer中的脏页数据写入实际的各个表空间文件(离散写)；(脏页数据固化后，即进行标记对应doublewrite数据可覆盖)</li>\n</ol>\n<p>现在我们来分析一下为什么 double write 可以生效。当宕机发生时，有那么几种情况：</p>\n<ol>\n<li>磁盘还未写，此时可以通过 redo log 恢复；</li>\n<li>磁盘正在进行从内存到共享表空间的写，此时数据文件中的页还没开始被写入，因此也同样可以通过 redo log 恢复；</li>\n<li>磁盘正在写数据文件，此时共享表空间已经写完，可以从共享表空间拷贝页的副本到数据文件实现恢复。</li>\n</ol>\n<h2 id=\"自适应哈希索引\"><a href=\"#自适应哈希索引\" class=\"headerlink\" title=\"自适应哈希索引\"></a>自适应哈希索引</h2><p>哈希：一次就可以定位数据</p>\n<p>B+树：取决于树的高度，生产环境一般是 3-4 层，所以需要查询 3-4 次</p>\n<p>自适应哈希索引 AHI（adaptive hash index）建立条件：观察到一个访问模式访问频繁，就会建立哈希索引</p>\n<ul>\n<li>通过该模式访问了 100 次（模式：where x = ?）</li>\n<li>页通过该模式访问了 N 次，其中 N = 页的记录总数⁄16</li>\n</ul>\n<p>InnoDB 存储引擎官方文档显示，启用 AHI 后,读取和写入速度可以提高 2 倍，辅助索引的连接操作性能可以提高 5 倍。</p>\n<h2 id=\"异步IO\"><a href=\"#异步IO\" class=\"headerlink\" title=\"异步IO\"></a>异步IO</h2><p>为了提高磁盘的操作性能，当前的数据库系统都采用异步IO的方式处理磁盘操作。用户可以在发出一个IO请求胡立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作完成，这就是AIO。<br>AIO的另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO, 这样可以提高IOPS(Input/Output Per Second)的性能。</p>\n<p>例如：用户访问页的（space, page_no)为(8,6) (8,7) (8,8)，每个页的大小为16KB，同步IO需要3次IO操作。可以优化为从(8,6)开始读取48KB。</p>\n<h2 id=\"刷新临接页\"><a href=\"#刷新临接页\" class=\"headerlink\" title=\"刷新临接页\"></a>刷新临接页</h2><p>当刷新一个脏页时，InnoDB会检查该页所在extent的所有页，如果是脏页，一起刷新。</p>\n<table>\n    <tr>\n        <th colspan=\"2\">参数</th>\n        <th>版本</th>\n        <th colspan=\"3\">作用</th>\n    </tr>\n    <tr>\n        <th colspan=\"2\" style=\"text-align:center\">innodb_flush_neighbors</th>\n        <td style=\"text-align:center\">1.2.x开始</td>\n        <td colspan=\"3\">控制是否启用该特性</td>\n    </tr>\n</table> \n\n\n<h1 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h1><ul>\n<li><a href=\"http://oohcode.com/2015/10/14/InnoDB-Key-Features/\" target=\"_blank\" rel=\"noopener\">http://oohcode.com/2015/10/14/InnoDB-Key-Features/</a></li>\n<li><a href=\"https://chyroc.cn/posts/innodb-storage-engine-reading-1/\" target=\"_blank\" rel=\"noopener\">https://chyroc.cn/posts/innodb-storage-engine-reading-1/</a></li>\n<li><a href=\"https://www.cnblogs.com/zhoujinyi/archive/2013/04/11/2988923.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zhoujinyi/archive/2013/04/11/2988923.html</a></li>\n<li><a href=\"http://huzb.me/2019/01/14/%E6%8F%92%E5%85%A5%E7%BC%93%E5%86%B2%E3%80%81%E4%B8%A4%E6%AC%A1%E5%86%99%E5%92%8C%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95/\" target=\"_blank\" rel=\"noopener\">http://huzb.me/2019/01/14/%E6%8F%92%E5%85%A5%E7%BC%93%E5%86%B2%E3%80%81%E4%B8%A4%E6%AC%A1%E5%86%99%E5%92%8C%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95/</a></li>\n<li><a href=\"https://blog.csdn.net/tanliqing2010/article/details/81509539\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/tanliqing2010/article/details/81509539</a></li>\n<li><a href=\"https://www.cnblogs.com/geaozhang/p/7341333.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/geaozhang/p/7341333.html</a></li>\n<li><a href=\"https://draveness.me/mysql-innodb\" target=\"_blank\" rel=\"noopener\">https://draveness.me/mysql-innodb</a></li>\n<li><a href=\"http://richfisher.me/blog/2017/12/18/innodb-notes/\" target=\"_blank\" rel=\"noopener\">http://richfisher.me/blog/2017/12/18/innodb-notes/</a></li>\n<li><a href=\"https://www.docs4dev.com/docs/zh/mysql/5.7/reference/innodb-architecture.html#innodb%E6%9E%B6%E6%9E%84\" target=\"_blank\" rel=\"noopener\">https://www.docs4dev.com/docs/zh/mysql/5.7/reference/innodb-architecture.html#innodb%E6%9E%B6%E6%9E%84</a></li>\n<li>MySQL技术内幕：InnoDB存储引擎(第2版)</li>\n</ul>"},{"title":"Spring Boot + MyBatis 多模块项目搭建","date":"2019-06-02T07:30:04.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"### 准备\n#### 开发工具及系统环境\n* IDE：IntelliJ IDEA 2019.1\n* 系统环境：mac OSX\n\n#### 项目目录结构\n* biz层：业务逻辑层\n* dao层：数据持久层，使用MB插件生成相关代码及xml\n* common层：提供工程层面的基础工具类。\n* web层：请求处理层\n<!-- more -->\n### 搭建步骤\n\n#### 搭建父工程\n\n1、 IDEA 工具栏选择菜单 File -> New -> Project...\n![](Project-Module/1.png)\n2、选择Spring Initializr，Initializr默认选择Default，点击Next\n![](Project-Module/2.png)\n3、填写项目资料,点击Next\n![](Project-Module/3.png)\n4、直接点击Next\n![](Project-Module/4.png)\n5、填写name，点击Finish\n![](Project-Module/5.png)\n6、项目结构如下\n![](Project-Module/6.png)\n7、删除多余目录，只留如下结构\n![](Project-Module/7.png)\n\n#### 创建子模块\n8、选择项目根目录,右键->New -> Module\n![](Project-Module/8.png)\n9、选择Maven，点击Next\n![](Project-Module/9.png)\n10、填写ArifactId，点击Next\n![](Project-Module/10.png)\n11、点击Finish\n![](Project-Module/11.png)\n12、同理添加其他子模块，最终项目目录结构如下图\n![](Project-Module/12.png)\n\n#### 模块间依赖关系\n\n各个子模块的依赖关系：\n* biz层：依赖dao层，common层\n* dao层：不依赖\n* common层：不依赖\n* web层：依赖biz层，common层。\n\n13、父pom文件中声明所有子模块依赖\n```xml\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>com.example.test</groupId>\n                <artifactId>biz</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>com.example.test</groupId>\n                <artifactId>common</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>com.example.test</groupId>\n                <artifactId>dao</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>com.example.test</groupId>\n                <artifactId>web</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n```\n14、biz层pom文件中添加dao层，common层依赖\n```xml\n    <dependencies>\n        <dependency>\n            <groupId>com.example.test</groupId>\n            <artifactId>dao</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>com.example.test</groupId>\n            <artifactId>common</artifactId>\n        </dependency>\n    </dependencies>\n```\n15、web层pom文件中添加biz层，common层依赖\n```xml\n    <dependencies>\n        <dependency>\n            <groupId>com.example.test</groupId>\n            <artifactId>biz</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>com.example.test</groupId>\n            <artifactId>common</artifactId>\n        </dependency>\n    </dependencies>\n```\n\n#### 运行项目\n16、在web层pom文件中添加spring-boot-starter-web\n```xml\n        <!-- spring-boot -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n```\n\n17、在web层创建com.example.test.demo.web包并添加入口类AppServiceApplication.java，目录结构如下\n![](Project-Module/17.png)\n入口类代码如下：\n```java\n\npackage com.example.test.demo.web;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class AppServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(AppServiceApplication.class, args);\n    }\n}\n\n```\n18、在com.example.test.demo.web包下创建controller目录添加test方法测试接口是否可以正常访问\n```java\npackage com.example.test.demo.web.controller;\n\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"demo\")\npublic class DemoController {\n\n    @RequestMapping(\"test\")\n    public String test() {\n        return \"Hello World!\";\n    }\n}\n```\n\n19、运行AppServiceApplication中的main方法启动项目，默认端口为8080，访问http://localhost:8080/demo/test得到如下效果\n![](Project-Module/19.png)\n\n20、在biz层创建com.example.test.demo.biz包并创建DemoService接口类代码如下：\n```java\npackage com.example.test.demo.biz;\n\npublic interface DemoService {\n    String test();\n}\n\n```\n\n21、在com.example.test.demo.biz包下创建impl目录并添加DemoServiceImpl类，代码如下：\n```java\npackage com.example.test.demo.biz.impl;\n\n\nimport com.example.test.demo.biz.DemoService;\nimport org.springframework.stereotype.Service;\n\n\n@Service\npublic class DemoServiceImpl implements DemoService {\n\n    @Override\n    public String test() {\n        return \"biz test\";\n    }\n}\n```\n\n22、DemoController类通过@Autowired注解注入DemoService，修改DemoController的test方法，代码如下：\n```java\npackage com.example.test.demo.web.controller;\n\n\nimport com.example.test.demo.biz.DemoService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"demo\")\npublic class DemoController {\n\n    @Autowired\n    private DemoService demoService;\n\n    @RequestMapping(\"test\")\n    public String test() {\n        return demoService.test();\n    }\n}\n```\n\n23、在入口类AppServiceApplication上添加@ComponentScan注解\n```java\npackage com.example.test.demo.web;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.ComponentScan;\n\n@SpringBootApplication\n@ComponentScan(basePackages = {\n        \"com.example.test.demo.*\"\n})\npublic class AppServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(AppServiceApplication.class, args);\n    }\n}\n```\n\n24、更改完之后运行main方法，访问http://localhost:8080/demo/test得到如下效果\n![](Project-Module/24.png)\n\n25、其他层同理验证。\n\n#### 集成Mybatis\n\n26、父pom文件中声明mybatis-spring-boot-starter、mysql-connector-java等依赖。\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <packaging>pom</packaging>\n    <modules>\n        <module>biz</module>\n        <module>dao</module>\n        <module>common</module>\n        <module>web</module>\n    </modules>\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.1.2.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n    <groupId>com.example.test</groupId>\n    <artifactId>demo</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>demo</name>\n    <description>Demo project for Spring Boot</description>\n\n    <properties>\n        <java.version>1.8</java.version>\n        <mysql-connector.version>8.0.11</mysql-connector.version>\n        <mybatis.version>1.3.2</mybatis.version>\n        <mybatis.generator.version>1.3.2</mybatis.generator.version>\n    </properties>\n\n    <build>\n        <pluginManagement>\n            <plugins>\n                <plugin>\n                    <groupId>org.springframework.boot</groupId>\n                    <artifactId>spring-boot-maven-plugin</artifactId>\n                </plugin>\n                <!--mybatis-->\n                <plugin>\n                    <groupId>org.mybatis.generator</groupId>\n                    <artifactId>mybatis-generator-maven-plugin</artifactId>\n                    <version>${mybatis.generator.version}</version>\n                    <dependencies>\n                        <dependency>\n                            <groupId>mysql</groupId>\n                            <artifactId>mysql-connector-java</artifactId>\n                            <version>${mysql-connector.version}</version>\n                        </dependency>\n                        <dependency>\n                            <groupId>org.mybatis.generator</groupId>\n                            <artifactId>mybatis-generator-core</artifactId>\n                            <version>${mybatis.generator.version}</version>\n                        </dependency>\n                    </dependencies>\n                </plugin>\n            </plugins>\n        </pluginManagement>\n        <resources>\n            <resource>\n                <directory>src/main/resources</directory>\n                <filtering>true</filtering>\n            </resource>\n        </resources>\n    </build>\n\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>com.example.test</groupId>\n                <artifactId>biz</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>com.example.test</groupId>\n                <artifactId>common</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>com.example.test</groupId>\n                <artifactId>dao</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>com.example.test</groupId>\n                <artifactId>web</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n\n\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter</artifactId>\n            </dependency>\n\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-test</artifactId>\n                <scope>test</scope>\n            </dependency>\n\n            <!--mybatis-->\n            <dependency>\n                <groupId>org.mybatis.spring.boot</groupId>\n                <artifactId>mybatis-spring-boot-starter</artifactId>\n                <version>${mybatis.version}</version>\n            </dependency>\n\n            <!-- mysql -->\n            <dependency>\n                <groupId>mysql</groupId>\n                <artifactId>mysql-connector-java</artifactId>\n                <version>${mysql-connector.version}</version>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n</project>\n\n```\n27、在dao层中的pom文件中添加以下依赖\n```xml\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n            <plugin>\n                <groupId>org.mybatis.generator</groupId>\n                <artifactId>mybatis-generator-maven-plugin</artifactId>\n                <configuration>\n                    <configurationFile>${basedir}/src/main/resources/mybatis-generator.xml</configurationFile>\n                    <overwrite>true</overwrite>\n                    <verbose>true</verbose>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n```\n28、在web/src/main/resources下添加application.properties\n\n* **com.mysql.jdbc.Driver** 是 mysql-connector-java 5中的\n* **com.mysql.cj.jdbc.Driver** 是 mysql-connector-java 6中的\n\n```properties\nspring.datasource.driverClassName = com.mysql.cj.jdbc.Driver\nspring.datasource.url = jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=UTF8&connectTimeout=1000&socketTimeout=3000\nspring.datasource.username = root\nspring.datasource.password = qwertyui\n\nmybatis.type-aliases-package = com.example.test.demo.dao.po\nmybatis.mapper-locations = classpath:mapper/*.xml\n```\n29、在web/src/main/resources下添加mybatis-generator.xml配置内容如下\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE generatorConfiguration\n        PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\n<generatorConfiguration>\n    <!-- 引入SpringBoot配置文件 -->\n    <properties resource=\"application.properties\"/>\n\n    <context id=\"Mysql\" targetRuntime=\"MyBatis3\" defaultModelType=\"flat\">\n        <!-- 生成的pojo，将implements Serializable-->\n        <plugin type=\"org.mybatis.generator.plugins.SerializablePlugin\"/>\n\n        <commentGenerator>\n            <!--*是否去除自动生成的注释包含时间戳 true：是 ： false:否-->\n            <property name=\"suppressDate\" value=\"true\" />\n            <!-- 是否去除自动生成的注释 true：是 ： false:否 -->\n            <property name=\"suppressAllComments\" value=\"true\" />\n        </commentGenerator>\n\n        <jdbcConnection driverClass=\"${spring.datasource.driverClassName}\"\n                        connectionURL=\"${spring.datasource.url}\"\n                        userId=\"${spring.datasource.username}\"\n                        password=\"${spring.datasource.password}\">\n        </jdbcConnection>\n\n        <!--\n       生成model模型，对应的包路径，以及文件存放路径(targetProject)，targetProject可以指定具体的路径,如./src/main/java，\n       也可以使用“MAVEN”来自动生成，这样生成的代码会在target/generatord-source目录下\n       -->\n        <javaModelGenerator targetPackage=\"com.example.test.demo.dao.po\" targetProject=\"../dao/src/main/java\" >\n            <!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false -->\n            <property name=\"enableSubPackages\" value=\"true\"/>\n            <!-- 从数据库返回的值被清理前后的空格 -->\n            <property name=\"trimStrings\" value=\"true\"/>\n        </javaModelGenerator>\n\n        <!--对应的mapper.xml文件 -->\n        <sqlMapGenerator targetPackage=\"mapper\"\n                         targetProject=\"../dao/src/main/resources\">\n            <property name=\"enableSubPackages\" value=\"true\"/>\n        </sqlMapGenerator>\n\n        <!-- 对应的Mapper接口类文件 -->\n        <javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.example.test.demo.dao.mapper\"\n                             targetProject=\"../dao/src/main/java\">\n            <property name=\"enableSubPackages\" value=\"true\"/>\n        </javaClientGenerator>\n\n        <!-- 表名及对应po类名称-->\n        <table tableName=\"user_info\" domainObjectName=\"UserInfoPO\"\n               enableCountByExample=\"true\" enableUpdateByExample=\"true\" enableDeleteByExample=\"true\"\n               enableSelectByExample=\"true\" selectByExampleQueryId=\"false\">\n            <property name=\"useActualColumnNames\" value=\"false\"/>\n            <generatedKey column=\"id\" identity=\"true\" sqlStatement=\"MySql\"/>\n        </table>\n    </context>\n</generatorConfiguration>\n```\n30、根据表自动生成对应的Mapper以及po类,步骤如下。\n![](Project-Module/30.1.png)\n得到目录如下\n![](Project-Module/30.2.png)\n\n30、biz层下DemoServiceImpl通过@Autowired注解注入UserMapper，修改DemoService的test方法如下：\n```java\npackage com.example.test.demo.biz.impl;\n\n\nimport com.example.test.demo.biz.DemoService;\nimport com.example.test.demo.dao.mapper.UserInfoPOMapper;\nimport com.example.test.demo.dao.po.UserInfoPO;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n\n@Service\npublic class DemoServiceImpl implements DemoService {\n\n    @Autowired\n    private UserInfoPOMapper userInfoPOMapper;\n\n    @Override\n    public String test() {\n        UserInfoPO po = userInfoPOMapper.selectByPrimaryKey(1L);\n        return \"UserInfo name is:\" + po.getName();\n    }\n}\n```\n31、在入口类AppServiceApplication上中添加注解\n```java\n@MapperScan(\"com.example.test.demo.dao.mapper\")\n```\n32、运行main方法启动项目\n![](Project-Module/32.png)\n\n### 遇到的坑\nmybatis 自动生成时遇到\n> Client does not support authentication protocol requested by server; consider upgrading MySQL client\n\n解决方法登录mysql：\n```bash\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'qwertyui';\nSELECT plugin FROM mysql.user WHERE User = 'root';\n```","source":"_posts/Project-Module.md","raw":"---\ntitle: Spring Boot + MyBatis 多模块项目搭建\ndate: 2019-06-02 15:30:04\ntags:\n    - MyBatis\n    - 教程\n    - Spring Boot\ncategories: 项目搭建\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n### 准备\n#### 开发工具及系统环境\n* IDE：IntelliJ IDEA 2019.1\n* 系统环境：mac OSX\n\n#### 项目目录结构\n* biz层：业务逻辑层\n* dao层：数据持久层，使用MB插件生成相关代码及xml\n* common层：提供工程层面的基础工具类。\n* web层：请求处理层\n<!-- more -->\n### 搭建步骤\n\n#### 搭建父工程\n\n1、 IDEA 工具栏选择菜单 File -> New -> Project...\n![](Project-Module/1.png)\n2、选择Spring Initializr，Initializr默认选择Default，点击Next\n![](Project-Module/2.png)\n3、填写项目资料,点击Next\n![](Project-Module/3.png)\n4、直接点击Next\n![](Project-Module/4.png)\n5、填写name，点击Finish\n![](Project-Module/5.png)\n6、项目结构如下\n![](Project-Module/6.png)\n7、删除多余目录，只留如下结构\n![](Project-Module/7.png)\n\n#### 创建子模块\n8、选择项目根目录,右键->New -> Module\n![](Project-Module/8.png)\n9、选择Maven，点击Next\n![](Project-Module/9.png)\n10、填写ArifactId，点击Next\n![](Project-Module/10.png)\n11、点击Finish\n![](Project-Module/11.png)\n12、同理添加其他子模块，最终项目目录结构如下图\n![](Project-Module/12.png)\n\n#### 模块间依赖关系\n\n各个子模块的依赖关系：\n* biz层：依赖dao层，common层\n* dao层：不依赖\n* common层：不依赖\n* web层：依赖biz层，common层。\n\n13、父pom文件中声明所有子模块依赖\n```xml\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>com.example.test</groupId>\n                <artifactId>biz</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>com.example.test</groupId>\n                <artifactId>common</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>com.example.test</groupId>\n                <artifactId>dao</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>com.example.test</groupId>\n                <artifactId>web</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n```\n14、biz层pom文件中添加dao层，common层依赖\n```xml\n    <dependencies>\n        <dependency>\n            <groupId>com.example.test</groupId>\n            <artifactId>dao</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>com.example.test</groupId>\n            <artifactId>common</artifactId>\n        </dependency>\n    </dependencies>\n```\n15、web层pom文件中添加biz层，common层依赖\n```xml\n    <dependencies>\n        <dependency>\n            <groupId>com.example.test</groupId>\n            <artifactId>biz</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>com.example.test</groupId>\n            <artifactId>common</artifactId>\n        </dependency>\n    </dependencies>\n```\n\n#### 运行项目\n16、在web层pom文件中添加spring-boot-starter-web\n```xml\n        <!-- spring-boot -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n```\n\n17、在web层创建com.example.test.demo.web包并添加入口类AppServiceApplication.java，目录结构如下\n![](Project-Module/17.png)\n入口类代码如下：\n```java\n\npackage com.example.test.demo.web;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class AppServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(AppServiceApplication.class, args);\n    }\n}\n\n```\n18、在com.example.test.demo.web包下创建controller目录添加test方法测试接口是否可以正常访问\n```java\npackage com.example.test.demo.web.controller;\n\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"demo\")\npublic class DemoController {\n\n    @RequestMapping(\"test\")\n    public String test() {\n        return \"Hello World!\";\n    }\n}\n```\n\n19、运行AppServiceApplication中的main方法启动项目，默认端口为8080，访问http://localhost:8080/demo/test得到如下效果\n![](Project-Module/19.png)\n\n20、在biz层创建com.example.test.demo.biz包并创建DemoService接口类代码如下：\n```java\npackage com.example.test.demo.biz;\n\npublic interface DemoService {\n    String test();\n}\n\n```\n\n21、在com.example.test.demo.biz包下创建impl目录并添加DemoServiceImpl类，代码如下：\n```java\npackage com.example.test.demo.biz.impl;\n\n\nimport com.example.test.demo.biz.DemoService;\nimport org.springframework.stereotype.Service;\n\n\n@Service\npublic class DemoServiceImpl implements DemoService {\n\n    @Override\n    public String test() {\n        return \"biz test\";\n    }\n}\n```\n\n22、DemoController类通过@Autowired注解注入DemoService，修改DemoController的test方法，代码如下：\n```java\npackage com.example.test.demo.web.controller;\n\n\nimport com.example.test.demo.biz.DemoService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"demo\")\npublic class DemoController {\n\n    @Autowired\n    private DemoService demoService;\n\n    @RequestMapping(\"test\")\n    public String test() {\n        return demoService.test();\n    }\n}\n```\n\n23、在入口类AppServiceApplication上添加@ComponentScan注解\n```java\npackage com.example.test.demo.web;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.ComponentScan;\n\n@SpringBootApplication\n@ComponentScan(basePackages = {\n        \"com.example.test.demo.*\"\n})\npublic class AppServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(AppServiceApplication.class, args);\n    }\n}\n```\n\n24、更改完之后运行main方法，访问http://localhost:8080/demo/test得到如下效果\n![](Project-Module/24.png)\n\n25、其他层同理验证。\n\n#### 集成Mybatis\n\n26、父pom文件中声明mybatis-spring-boot-starter、mysql-connector-java等依赖。\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <packaging>pom</packaging>\n    <modules>\n        <module>biz</module>\n        <module>dao</module>\n        <module>common</module>\n        <module>web</module>\n    </modules>\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.1.2.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n    <groupId>com.example.test</groupId>\n    <artifactId>demo</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>demo</name>\n    <description>Demo project for Spring Boot</description>\n\n    <properties>\n        <java.version>1.8</java.version>\n        <mysql-connector.version>8.0.11</mysql-connector.version>\n        <mybatis.version>1.3.2</mybatis.version>\n        <mybatis.generator.version>1.3.2</mybatis.generator.version>\n    </properties>\n\n    <build>\n        <pluginManagement>\n            <plugins>\n                <plugin>\n                    <groupId>org.springframework.boot</groupId>\n                    <artifactId>spring-boot-maven-plugin</artifactId>\n                </plugin>\n                <!--mybatis-->\n                <plugin>\n                    <groupId>org.mybatis.generator</groupId>\n                    <artifactId>mybatis-generator-maven-plugin</artifactId>\n                    <version>${mybatis.generator.version}</version>\n                    <dependencies>\n                        <dependency>\n                            <groupId>mysql</groupId>\n                            <artifactId>mysql-connector-java</artifactId>\n                            <version>${mysql-connector.version}</version>\n                        </dependency>\n                        <dependency>\n                            <groupId>org.mybatis.generator</groupId>\n                            <artifactId>mybatis-generator-core</artifactId>\n                            <version>${mybatis.generator.version}</version>\n                        </dependency>\n                    </dependencies>\n                </plugin>\n            </plugins>\n        </pluginManagement>\n        <resources>\n            <resource>\n                <directory>src/main/resources</directory>\n                <filtering>true</filtering>\n            </resource>\n        </resources>\n    </build>\n\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>com.example.test</groupId>\n                <artifactId>biz</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>com.example.test</groupId>\n                <artifactId>common</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>com.example.test</groupId>\n                <artifactId>dao</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n            <dependency>\n                <groupId>com.example.test</groupId>\n                <artifactId>web</artifactId>\n                <version>${project.version}</version>\n            </dependency>\n\n\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter</artifactId>\n            </dependency>\n\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-test</artifactId>\n                <scope>test</scope>\n            </dependency>\n\n            <!--mybatis-->\n            <dependency>\n                <groupId>org.mybatis.spring.boot</groupId>\n                <artifactId>mybatis-spring-boot-starter</artifactId>\n                <version>${mybatis.version}</version>\n            </dependency>\n\n            <!-- mysql -->\n            <dependency>\n                <groupId>mysql</groupId>\n                <artifactId>mysql-connector-java</artifactId>\n                <version>${mysql-connector.version}</version>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n</project>\n\n```\n27、在dao层中的pom文件中添加以下依赖\n```xml\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n            <plugin>\n                <groupId>org.mybatis.generator</groupId>\n                <artifactId>mybatis-generator-maven-plugin</artifactId>\n                <configuration>\n                    <configurationFile>${basedir}/src/main/resources/mybatis-generator.xml</configurationFile>\n                    <overwrite>true</overwrite>\n                    <verbose>true</verbose>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n```\n28、在web/src/main/resources下添加application.properties\n\n* **com.mysql.jdbc.Driver** 是 mysql-connector-java 5中的\n* **com.mysql.cj.jdbc.Driver** 是 mysql-connector-java 6中的\n\n```properties\nspring.datasource.driverClassName = com.mysql.cj.jdbc.Driver\nspring.datasource.url = jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=UTF8&connectTimeout=1000&socketTimeout=3000\nspring.datasource.username = root\nspring.datasource.password = qwertyui\n\nmybatis.type-aliases-package = com.example.test.demo.dao.po\nmybatis.mapper-locations = classpath:mapper/*.xml\n```\n29、在web/src/main/resources下添加mybatis-generator.xml配置内容如下\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE generatorConfiguration\n        PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\n<generatorConfiguration>\n    <!-- 引入SpringBoot配置文件 -->\n    <properties resource=\"application.properties\"/>\n\n    <context id=\"Mysql\" targetRuntime=\"MyBatis3\" defaultModelType=\"flat\">\n        <!-- 生成的pojo，将implements Serializable-->\n        <plugin type=\"org.mybatis.generator.plugins.SerializablePlugin\"/>\n\n        <commentGenerator>\n            <!--*是否去除自动生成的注释包含时间戳 true：是 ： false:否-->\n            <property name=\"suppressDate\" value=\"true\" />\n            <!-- 是否去除自动生成的注释 true：是 ： false:否 -->\n            <property name=\"suppressAllComments\" value=\"true\" />\n        </commentGenerator>\n\n        <jdbcConnection driverClass=\"${spring.datasource.driverClassName}\"\n                        connectionURL=\"${spring.datasource.url}\"\n                        userId=\"${spring.datasource.username}\"\n                        password=\"${spring.datasource.password}\">\n        </jdbcConnection>\n\n        <!--\n       生成model模型，对应的包路径，以及文件存放路径(targetProject)，targetProject可以指定具体的路径,如./src/main/java，\n       也可以使用“MAVEN”来自动生成，这样生成的代码会在target/generatord-source目录下\n       -->\n        <javaModelGenerator targetPackage=\"com.example.test.demo.dao.po\" targetProject=\"../dao/src/main/java\" >\n            <!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false -->\n            <property name=\"enableSubPackages\" value=\"true\"/>\n            <!-- 从数据库返回的值被清理前后的空格 -->\n            <property name=\"trimStrings\" value=\"true\"/>\n        </javaModelGenerator>\n\n        <!--对应的mapper.xml文件 -->\n        <sqlMapGenerator targetPackage=\"mapper\"\n                         targetProject=\"../dao/src/main/resources\">\n            <property name=\"enableSubPackages\" value=\"true\"/>\n        </sqlMapGenerator>\n\n        <!-- 对应的Mapper接口类文件 -->\n        <javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.example.test.demo.dao.mapper\"\n                             targetProject=\"../dao/src/main/java\">\n            <property name=\"enableSubPackages\" value=\"true\"/>\n        </javaClientGenerator>\n\n        <!-- 表名及对应po类名称-->\n        <table tableName=\"user_info\" domainObjectName=\"UserInfoPO\"\n               enableCountByExample=\"true\" enableUpdateByExample=\"true\" enableDeleteByExample=\"true\"\n               enableSelectByExample=\"true\" selectByExampleQueryId=\"false\">\n            <property name=\"useActualColumnNames\" value=\"false\"/>\n            <generatedKey column=\"id\" identity=\"true\" sqlStatement=\"MySql\"/>\n        </table>\n    </context>\n</generatorConfiguration>\n```\n30、根据表自动生成对应的Mapper以及po类,步骤如下。\n![](Project-Module/30.1.png)\n得到目录如下\n![](Project-Module/30.2.png)\n\n30、biz层下DemoServiceImpl通过@Autowired注解注入UserMapper，修改DemoService的test方法如下：\n```java\npackage com.example.test.demo.biz.impl;\n\n\nimport com.example.test.demo.biz.DemoService;\nimport com.example.test.demo.dao.mapper.UserInfoPOMapper;\nimport com.example.test.demo.dao.po.UserInfoPO;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n\n@Service\npublic class DemoServiceImpl implements DemoService {\n\n    @Autowired\n    private UserInfoPOMapper userInfoPOMapper;\n\n    @Override\n    public String test() {\n        UserInfoPO po = userInfoPOMapper.selectByPrimaryKey(1L);\n        return \"UserInfo name is:\" + po.getName();\n    }\n}\n```\n31、在入口类AppServiceApplication上中添加注解\n```java\n@MapperScan(\"com.example.test.demo.dao.mapper\")\n```\n32、运行main方法启动项目\n![](Project-Module/32.png)\n\n### 遇到的坑\nmybatis 自动生成时遇到\n> Client does not support authentication protocol requested by server; consider upgrading MySQL client\n\n解决方法登录mysql：\n```bash\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'qwertyui';\nSELECT plugin FROM mysql.user WHERE User = 'root';\n```","slug":"Project-Module","published":1,"updated":"2019-07-31T13:41:40.998Z","layout":"post","photos":[],"link":"","_id":"ck8fb4ae20034k2o5rlnmohc6","content":"<h3 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h3><h4 id=\"开发工具及系统环境\"><a href=\"#开发工具及系统环境\" class=\"headerlink\" title=\"开发工具及系统环境\"></a>开发工具及系统环境</h4><ul>\n<li>IDE：IntelliJ IDEA 2019.1</li>\n<li>系统环境：mac OSX</li>\n</ul>\n<h4 id=\"项目目录结构\"><a href=\"#项目目录结构\" class=\"headerlink\" title=\"项目目录结构\"></a>项目目录结构</h4><ul>\n<li>biz层：业务逻辑层</li>\n<li>dao层：数据持久层，使用MB插件生成相关代码及xml</li>\n<li>common层：提供工程层面的基础工具类。</li>\n<li>web层：请求处理层<a id=\"more\"></a>\n<h3 id=\"搭建步骤\"><a href=\"#搭建步骤\" class=\"headerlink\" title=\"搭建步骤\"></a>搭建步骤</h3></li>\n</ul>\n<h4 id=\"搭建父工程\"><a href=\"#搭建父工程\" class=\"headerlink\" title=\"搭建父工程\"></a>搭建父工程</h4><p>1、 IDEA 工具栏选择菜单 File -&gt; New -&gt; Project…<br><img src=\"/项目搭建/Project-Module/1.png\" alt=\"\"><br>2、选择Spring Initializr，Initializr默认选择Default，点击Next<br><img src=\"/项目搭建/Project-Module/2.png\" alt=\"\"><br>3、填写项目资料,点击Next<br><img src=\"/项目搭建/Project-Module/3.png\" alt=\"\"><br>4、直接点击Next<br><img src=\"/项目搭建/Project-Module/4.png\" alt=\"\"><br>5、填写name，点击Finish<br><img src=\"/项目搭建/Project-Module/5.png\" alt=\"\"><br>6、项目结构如下<br><img src=\"/项目搭建/Project-Module/6.png\" alt=\"\"><br>7、删除多余目录，只留如下结构<br><img src=\"/项目搭建/Project-Module/7.png\" alt=\"\"></p>\n<h4 id=\"创建子模块\"><a href=\"#创建子模块\" class=\"headerlink\" title=\"创建子模块\"></a>创建子模块</h4><p>8、选择项目根目录,右键-&gt;New -&gt; Module<br><img src=\"/项目搭建/Project-Module/8.png\" alt=\"\"><br>9、选择Maven，点击Next<br><img src=\"/项目搭建/Project-Module/9.png\" alt=\"\"><br>10、填写ArifactId，点击Next<br><img src=\"/项目搭建/Project-Module/10.png\" alt=\"\"><br>11、点击Finish<br><img src=\"/项目搭建/Project-Module/11.png\" alt=\"\"><br>12、同理添加其他子模块，最终项目目录结构如下图<br><img src=\"/项目搭建/Project-Module/12.png\" alt=\"\"></p>\n<h4 id=\"模块间依赖关系\"><a href=\"#模块间依赖关系\" class=\"headerlink\" title=\"模块间依赖关系\"></a>模块间依赖关系</h4><p>各个子模块的依赖关系：</p>\n<ul>\n<li>biz层：依赖dao层，common层</li>\n<li>dao层：不依赖</li>\n<li>common层：不依赖</li>\n<li>web层：依赖biz层，common层。</li>\n</ul>\n<p>13、父pom文件中声明所有子模块依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>biz<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;project.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>common<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;project.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dao<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;project.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;project.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>14、biz层pom文件中添加dao层，common层依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dao<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>common<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>15、web层pom文件中添加biz层，common层依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>biz<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>common<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"运行项目\"><a href=\"#运行项目\" class=\"headerlink\" title=\"运行项目\"></a>运行项目</h4><p>16、在web层pom文件中添加spring-boot-starter-web</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- spring-boot --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>17、在web层创建com.example.test.demo.web包并添加入口类AppServiceApplication.java，目录结构如下<br><img src=\"/项目搭建/Project-Module/17.png\" alt=\"\"><br>入口类代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.example.test.demo.web;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppServiceApplication</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(AppServiceApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>18、在com.example.test.demo.web包下创建controller目录添加test方法测试接口是否可以正常访问</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.test.demo.web.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"demo\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"test\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Hello World!\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>19、运行AppServiceApplication中的main方法启动项目，默认端口为8080，访问<a href=\"http://localhost:8080/demo/test得到如下效果\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/demo/test得到如下效果</a><br><img src=\"/项目搭建/Project-Module/19.png\" alt=\"\"></p>\n<p>20、在biz层创建com.example.test.demo.biz包并创建DemoService接口类代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.test.demo.biz;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DemoService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">test</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>21、在com.example.test.demo.biz包下创建impl目录并添加DemoServiceImpl类，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.test.demo.biz.impl;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.test.demo.biz.DemoService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Service;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">DemoService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"biz test\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>22、DemoController类通过@Autowired注解注入DemoService，修改DemoController的test方法，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.test.demo.web.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.test.demo.biz.DemoService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"demo\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DemoService demoService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"test\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> demoService.test();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>23、在入口类AppServiceApplication上添加@ComponentScan注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.test.demo.web;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(basePackages = &#123;</span><br><span class=\"line\">        <span class=\"string\">\"com.example.test.demo.*\"</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppServiceApplication</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(AppServiceApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>24、更改完之后运行main方法，访问<a href=\"http://localhost:8080/demo/test得到如下效果\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/demo/test得到如下效果</a><br><img src=\"/项目搭建/Project-Module/24.png\" alt=\"\"></p>\n<p>25、其他层同理验证。</p>\n<h4 id=\"集成Mybatis\"><a href=\"#集成Mybatis\" class=\"headerlink\" title=\"集成Mybatis\"></a>集成Mybatis</h4><p>26、父pom文件中声明mybatis-spring-boot-starter、mysql-connector-java等依赖。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modules</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">module</span>&gt;</span>biz<span class=\"tag\">&lt;/<span class=\"name\">module</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">module</span>&gt;</span>dao<span class=\"tag\">&lt;/<span class=\"name\">module</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">module</span>&gt;</span>common<span class=\"tag\">&lt;/<span class=\"name\">module</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">module</span>&gt;</span>web<span class=\"tag\">&lt;/<span class=\"name\">module</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">modules</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.1.2.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">relativePath</span>/&gt;</span> <span class=\"comment\">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>demo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>demo<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>Demo project for Spring Boot<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mysql-connector.version</span>&gt;</span>8.0.11<span class=\"tag\">&lt;/<span class=\"name\">mysql-connector.version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mybatis.version</span>&gt;</span>1.3.2<span class=\"tag\">&lt;/<span class=\"name\">mybatis.version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mybatis.generator.version</span>&gt;</span>1.3.2<span class=\"tag\">&lt;/<span class=\"name\">mybatis.generator.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">pluginManagement</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--mybatis--&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis.generator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;mybatis.generator.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;mysql-connector.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis.generator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-generator-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;mybatis.generator.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">pluginManagement</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">resources</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">directory</span>&gt;</span>src/main/resources<span class=\"tag\">&lt;/<span class=\"name\">directory</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">filtering</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">filtering</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>biz<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;project.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>common<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;project.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dao<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;project.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;project.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--mybatis--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis.spring.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- mysql --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;mysql-connector.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>27、在dao层中的pom文件中添加以下依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis.generator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">configurationFile</span>&gt;</span>$&#123;basedir&#125;/src/main/resources/mybatis-generator.xml<span class=\"tag\">&lt;/<span class=\"name\">configurationFile</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">overwrite</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">overwrite</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">verbose</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">verbose</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>28、在web/src/main/resources下添加application.properties</p>\n<ul>\n<li><strong>com.mysql.jdbc.Driver</strong> 是 mysql-connector-java 5中的</li>\n<li><strong>com.mysql.cj.jdbc.Driver</strong> 是 mysql-connector-java 6中的</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.datasource.driverClassName = com.mysql.cj.jdbc.Driver</span><br><span class=\"line\">spring.datasource.url = jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF8&amp;connectTimeout=1000&amp;socketTimeout=3000</span><br><span class=\"line\">spring.datasource.username = root</span><br><span class=\"line\">spring.datasource.password = qwertyui</span><br><span class=\"line\"></span><br><span class=\"line\">mybatis.type-aliases-package = com.example.test.demo.dao.po</span><br><span class=\"line\">mybatis.mapper-locations = classpath:mapper/*.xml</span><br></pre></td></tr></table></figure>\n\n<p>29、在web/src/main/resources下添加mybatis-generator.xml配置内容如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE generatorConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">        PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"</span></span><br><span class=\"line\"><span class=\"meta\">        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">generatorConfiguration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 引入SpringBoot配置文件 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span> <span class=\"attr\">resource</span>=<span class=\"string\">\"application.properties\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context</span> <span class=\"attr\">id</span>=<span class=\"string\">\"Mysql\"</span> <span class=\"attr\">targetRuntime</span>=<span class=\"string\">\"MyBatis3\"</span> <span class=\"attr\">defaultModelType</span>=<span class=\"string\">\"flat\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 生成的pojo，将implements Serializable--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span> <span class=\"attr\">type</span>=<span class=\"string\">\"org.mybatis.generator.plugins.SerializablePlugin\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">commentGenerator</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--*是否去除自动生成的注释包含时间戳 true：是 ： false:否--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suppressDate\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suppressAllComments\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">commentGenerator</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">jdbcConnection</span> <span class=\"attr\">driverClass</span>=<span class=\"string\">\"$&#123;spring.datasource.driverClassName&#125;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                        <span class=\"attr\">connectionURL</span>=<span class=\"string\">\"$&#123;spring.datasource.url&#125;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                        <span class=\"attr\">userId</span>=<span class=\"string\">\"$&#123;spring.datasource.username&#125;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                        <span class=\"attr\">password</span>=<span class=\"string\">\"$&#123;spring.datasource.password&#125;\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">jdbcConnection</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">       生成model模型，对应的包路径，以及文件存放路径(targetProject)，targetProject可以指定具体的路径,如./src/main/java，</span></span><br><span class=\"line\"><span class=\"comment\">       也可以使用“MAVEN”来自动生成，这样生成的代码会在target/generatord-source目录下</span></span><br><span class=\"line\"><span class=\"comment\">       --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">javaModelGenerator</span> <span class=\"attr\">targetPackage</span>=<span class=\"string\">\"com.example.test.demo.dao.po\"</span> <span class=\"attr\">targetProject</span>=<span class=\"string\">\"../dao/src/main/java\"</span> &gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"enableSubPackages\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 从数据库返回的值被清理前后的空格 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"trimStrings\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">javaModelGenerator</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--对应的mapper.xml文件 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">sqlMapGenerator</span> <span class=\"attr\">targetPackage</span>=<span class=\"string\">\"mapper\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                         <span class=\"attr\">targetProject</span>=<span class=\"string\">\"../dao/src/main/resources\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"enableSubPackages\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">sqlMapGenerator</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 对应的Mapper接口类文件 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">javaClientGenerator</span> <span class=\"attr\">type</span>=<span class=\"string\">\"XMLMAPPER\"</span> <span class=\"attr\">targetPackage</span>=<span class=\"string\">\"com.example.test.demo.dao.mapper\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                             <span class=\"attr\">targetProject</span>=<span class=\"string\">\"../dao/src/main/java\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"enableSubPackages\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">javaClientGenerator</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 表名及对应po类名称--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">tableName</span>=<span class=\"string\">\"user_info\"</span> <span class=\"attr\">domainObjectName</span>=<span class=\"string\">\"UserInfoPO\"</span></span></span><br><span class=\"line\"><span class=\"tag\">               <span class=\"attr\">enableCountByExample</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">enableUpdateByExample</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">enableDeleteByExample</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">               <span class=\"attr\">enableSelectByExample</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">selectByExampleQueryId</span>=<span class=\"string\">\"false\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"useActualColumnNames\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"false\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">generatedKey</span> <span class=\"attr\">column</span>=<span class=\"string\">\"id\"</span> <span class=\"attr\">identity</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">sqlStatement</span>=<span class=\"string\">\"MySql\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">context</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>30、根据表自动生成对应的Mapper以及po类,步骤如下。<br><img src=\"/项目搭建/Project-Module/30.1.png\" alt=\"\"><br>得到目录如下<br><img src=\"/项目搭建/Project-Module/30.2.png\" alt=\"\"></p>\n<p>30、biz层下DemoServiceImpl通过@Autowired注解注入UserMapper，修改DemoService的test方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.test.demo.biz.impl;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.test.demo.biz.DemoService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.test.demo.dao.mapper.UserInfoPOMapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.test.demo.dao.po.UserInfoPO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Service;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">DemoService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserInfoPOMapper userInfoPOMapper;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        UserInfoPO po = userInfoPOMapper.selectByPrimaryKey(<span class=\"number\">1L</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"UserInfo name is:\"</span> + po.getName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>31、在入口类AppServiceApplication上中添加注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MapperScan</span>(<span class=\"string\">\"com.example.test.demo.dao.mapper\"</span>)</span><br></pre></td></tr></table></figure>\n\n<p>32、运行main方法启动项目<br><img src=\"/项目搭建/Project-Module/32.png\" alt=\"\"></p>\n<h3 id=\"遇到的坑\"><a href=\"#遇到的坑\" class=\"headerlink\" title=\"遇到的坑\"></a>遇到的坑</h3><p>mybatis 自动生成时遇到</p>\n<blockquote>\n<p>Client does not support authentication protocol requested by server; consider upgrading MySQL client</p>\n</blockquote>\n<p>解决方法登录mysql：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER USER <span class=\"string\">'root'</span>@<span class=\"string\">'localhost'</span> IDENTIFIED WITH mysql_native_password BY <span class=\"string\">'qwertyui'</span>;</span><br><span class=\"line\">SELECT plugin FROM mysql.user WHERE User = <span class=\"string\">'root'</span>;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h3><h4 id=\"开发工具及系统环境\"><a href=\"#开发工具及系统环境\" class=\"headerlink\" title=\"开发工具及系统环境\"></a>开发工具及系统环境</h4><ul>\n<li>IDE：IntelliJ IDEA 2019.1</li>\n<li>系统环境：mac OSX</li>\n</ul>\n<h4 id=\"项目目录结构\"><a href=\"#项目目录结构\" class=\"headerlink\" title=\"项目目录结构\"></a>项目目录结构</h4><ul>\n<li>biz层：业务逻辑层</li>\n<li>dao层：数据持久层，使用MB插件生成相关代码及xml</li>\n<li>common层：提供工程层面的基础工具类。</li>\n<li>web层：请求处理层</li></ul>","more":"<h3 id=\"搭建步骤\"><a href=\"#搭建步骤\" class=\"headerlink\" title=\"搭建步骤\"></a>搭建步骤</h3>\n\n<h4 id=\"搭建父工程\"><a href=\"#搭建父工程\" class=\"headerlink\" title=\"搭建父工程\"></a>搭建父工程</h4><p>1、 IDEA 工具栏选择菜单 File -&gt; New -&gt; Project…<br><img src=\"/项目搭建/Project-Module/1.png\" alt=\"\"><br>2、选择Spring Initializr，Initializr默认选择Default，点击Next<br><img src=\"/项目搭建/Project-Module/2.png\" alt=\"\"><br>3、填写项目资料,点击Next<br><img src=\"/项目搭建/Project-Module/3.png\" alt=\"\"><br>4、直接点击Next<br><img src=\"/项目搭建/Project-Module/4.png\" alt=\"\"><br>5、填写name，点击Finish<br><img src=\"/项目搭建/Project-Module/5.png\" alt=\"\"><br>6、项目结构如下<br><img src=\"/项目搭建/Project-Module/6.png\" alt=\"\"><br>7、删除多余目录，只留如下结构<br><img src=\"/项目搭建/Project-Module/7.png\" alt=\"\"></p>\n<h4 id=\"创建子模块\"><a href=\"#创建子模块\" class=\"headerlink\" title=\"创建子模块\"></a>创建子模块</h4><p>8、选择项目根目录,右键-&gt;New -&gt; Module<br><img src=\"/项目搭建/Project-Module/8.png\" alt=\"\"><br>9、选择Maven，点击Next<br><img src=\"/项目搭建/Project-Module/9.png\" alt=\"\"><br>10、填写ArifactId，点击Next<br><img src=\"/项目搭建/Project-Module/10.png\" alt=\"\"><br>11、点击Finish<br><img src=\"/项目搭建/Project-Module/11.png\" alt=\"\"><br>12、同理添加其他子模块，最终项目目录结构如下图<br><img src=\"/项目搭建/Project-Module/12.png\" alt=\"\"></p>\n<h4 id=\"模块间依赖关系\"><a href=\"#模块间依赖关系\" class=\"headerlink\" title=\"模块间依赖关系\"></a>模块间依赖关系</h4><p>各个子模块的依赖关系：</p>\n<ul>\n<li>biz层：依赖dao层，common层</li>\n<li>dao层：不依赖</li>\n<li>common层：不依赖</li>\n<li>web层：依赖biz层，common层。</li>\n</ul>\n<p>13、父pom文件中声明所有子模块依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>biz<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;project.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>common<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;project.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dao<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;project.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;project.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>14、biz层pom文件中添加dao层，common层依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dao<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>common<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>15、web层pom文件中添加biz层，common层依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>biz<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>common<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"运行项目\"><a href=\"#运行项目\" class=\"headerlink\" title=\"运行项目\"></a>运行项目</h4><p>16、在web层pom文件中添加spring-boot-starter-web</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- spring-boot --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>17、在web层创建com.example.test.demo.web包并添加入口类AppServiceApplication.java，目录结构如下<br><img src=\"/项目搭建/Project-Module/17.png\" alt=\"\"><br>入口类代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.example.test.demo.web;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppServiceApplication</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(AppServiceApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>18、在com.example.test.demo.web包下创建controller目录添加test方法测试接口是否可以正常访问</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.test.demo.web.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"demo\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"test\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Hello World!\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>19、运行AppServiceApplication中的main方法启动项目，默认端口为8080，访问<a href=\"http://localhost:8080/demo/test得到如下效果\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/demo/test得到如下效果</a><br><img src=\"/项目搭建/Project-Module/19.png\" alt=\"\"></p>\n<p>20、在biz层创建com.example.test.demo.biz包并创建DemoService接口类代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.test.demo.biz;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DemoService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">test</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>21、在com.example.test.demo.biz包下创建impl目录并添加DemoServiceImpl类，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.test.demo.biz.impl;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.test.demo.biz.DemoService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Service;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">DemoService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"biz test\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>22、DemoController类通过@Autowired注解注入DemoService，修改DemoController的test方法，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.test.demo.web.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.test.demo.biz.DemoService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"demo\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DemoService demoService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"test\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> demoService.test();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>23、在入口类AppServiceApplication上添加@ComponentScan注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.test.demo.web;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(basePackages = &#123;</span><br><span class=\"line\">        <span class=\"string\">\"com.example.test.demo.*\"</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppServiceApplication</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(AppServiceApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>24、更改完之后运行main方法，访问<a href=\"http://localhost:8080/demo/test得到如下效果\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/demo/test得到如下效果</a><br><img src=\"/项目搭建/Project-Module/24.png\" alt=\"\"></p>\n<p>25、其他层同理验证。</p>\n<h4 id=\"集成Mybatis\"><a href=\"#集成Mybatis\" class=\"headerlink\" title=\"集成Mybatis\"></a>集成Mybatis</h4><p>26、父pom文件中声明mybatis-spring-boot-starter、mysql-connector-java等依赖。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modules</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">module</span>&gt;</span>biz<span class=\"tag\">&lt;/<span class=\"name\">module</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">module</span>&gt;</span>dao<span class=\"tag\">&lt;/<span class=\"name\">module</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">module</span>&gt;</span>common<span class=\"tag\">&lt;/<span class=\"name\">module</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">module</span>&gt;</span>web<span class=\"tag\">&lt;/<span class=\"name\">module</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">modules</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.1.2.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">relativePath</span>/&gt;</span> <span class=\"comment\">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>demo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>demo<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>Demo project for Spring Boot<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>1.8<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mysql-connector.version</span>&gt;</span>8.0.11<span class=\"tag\">&lt;/<span class=\"name\">mysql-connector.version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mybatis.version</span>&gt;</span>1.3.2<span class=\"tag\">&lt;/<span class=\"name\">mybatis.version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mybatis.generator.version</span>&gt;</span>1.3.2<span class=\"tag\">&lt;/<span class=\"name\">mybatis.generator.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">pluginManagement</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--mybatis--&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis.generator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;mybatis.generator.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;mysql-connector.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis.generator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-generator-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;mybatis.generator.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">pluginManagement</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">resources</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">directory</span>&gt;</span>src/main/resources<span class=\"tag\">&lt;/<span class=\"name\">directory</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">filtering</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">filtering</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>biz<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;project.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>common<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;project.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dao<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;project.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.example.test<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;project.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--mybatis--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis.spring.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- mysql --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;mysql-connector.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>27、在dao层中的pom文件中添加以下依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis.generator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">configurationFile</span>&gt;</span>$&#123;basedir&#125;/src/main/resources/mybatis-generator.xml<span class=\"tag\">&lt;/<span class=\"name\">configurationFile</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">overwrite</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">overwrite</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">verbose</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">verbose</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>28、在web/src/main/resources下添加application.properties</p>\n<ul>\n<li><strong>com.mysql.jdbc.Driver</strong> 是 mysql-connector-java 5中的</li>\n<li><strong>com.mysql.cj.jdbc.Driver</strong> 是 mysql-connector-java 6中的</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.datasource.driverClassName = com.mysql.cj.jdbc.Driver</span><br><span class=\"line\">spring.datasource.url = jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF8&amp;connectTimeout=1000&amp;socketTimeout=3000</span><br><span class=\"line\">spring.datasource.username = root</span><br><span class=\"line\">spring.datasource.password = qwertyui</span><br><span class=\"line\"></span><br><span class=\"line\">mybatis.type-aliases-package = com.example.test.demo.dao.po</span><br><span class=\"line\">mybatis.mapper-locations = classpath:mapper/*.xml</span><br></pre></td></tr></table></figure>\n\n<p>29、在web/src/main/resources下添加mybatis-generator.xml配置内容如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE generatorConfiguration</span></span><br><span class=\"line\"><span class=\"meta\">        PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"</span></span><br><span class=\"line\"><span class=\"meta\">        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">generatorConfiguration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 引入SpringBoot配置文件 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span> <span class=\"attr\">resource</span>=<span class=\"string\">\"application.properties\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">context</span> <span class=\"attr\">id</span>=<span class=\"string\">\"Mysql\"</span> <span class=\"attr\">targetRuntime</span>=<span class=\"string\">\"MyBatis3\"</span> <span class=\"attr\">defaultModelType</span>=<span class=\"string\">\"flat\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 生成的pojo，将implements Serializable--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span> <span class=\"attr\">type</span>=<span class=\"string\">\"org.mybatis.generator.plugins.SerializablePlugin\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">commentGenerator</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--*是否去除自动生成的注释包含时间戳 true：是 ： false:否--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suppressDate\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suppressAllComments\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">commentGenerator</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">jdbcConnection</span> <span class=\"attr\">driverClass</span>=<span class=\"string\">\"$&#123;spring.datasource.driverClassName&#125;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                        <span class=\"attr\">connectionURL</span>=<span class=\"string\">\"$&#123;spring.datasource.url&#125;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                        <span class=\"attr\">userId</span>=<span class=\"string\">\"$&#123;spring.datasource.username&#125;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                        <span class=\"attr\">password</span>=<span class=\"string\">\"$&#123;spring.datasource.password&#125;\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">jdbcConnection</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">       生成model模型，对应的包路径，以及文件存放路径(targetProject)，targetProject可以指定具体的路径,如./src/main/java，</span></span><br><span class=\"line\"><span class=\"comment\">       也可以使用“MAVEN”来自动生成，这样生成的代码会在target/generatord-source目录下</span></span><br><span class=\"line\"><span class=\"comment\">       --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">javaModelGenerator</span> <span class=\"attr\">targetPackage</span>=<span class=\"string\">\"com.example.test.demo.dao.po\"</span> <span class=\"attr\">targetProject</span>=<span class=\"string\">\"../dao/src/main/java\"</span> &gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"enableSubPackages\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 从数据库返回的值被清理前后的空格 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"trimStrings\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">javaModelGenerator</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--对应的mapper.xml文件 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">sqlMapGenerator</span> <span class=\"attr\">targetPackage</span>=<span class=\"string\">\"mapper\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                         <span class=\"attr\">targetProject</span>=<span class=\"string\">\"../dao/src/main/resources\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"enableSubPackages\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">sqlMapGenerator</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 对应的Mapper接口类文件 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">javaClientGenerator</span> <span class=\"attr\">type</span>=<span class=\"string\">\"XMLMAPPER\"</span> <span class=\"attr\">targetPackage</span>=<span class=\"string\">\"com.example.test.demo.dao.mapper\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                             <span class=\"attr\">targetProject</span>=<span class=\"string\">\"../dao/src/main/java\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"enableSubPackages\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">javaClientGenerator</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 表名及对应po类名称--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">tableName</span>=<span class=\"string\">\"user_info\"</span> <span class=\"attr\">domainObjectName</span>=<span class=\"string\">\"UserInfoPO\"</span></span></span><br><span class=\"line\"><span class=\"tag\">               <span class=\"attr\">enableCountByExample</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">enableUpdateByExample</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">enableDeleteByExample</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">               <span class=\"attr\">enableSelectByExample</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">selectByExampleQueryId</span>=<span class=\"string\">\"false\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"useActualColumnNames\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"false\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">generatedKey</span> <span class=\"attr\">column</span>=<span class=\"string\">\"id\"</span> <span class=\"attr\">identity</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">sqlStatement</span>=<span class=\"string\">\"MySql\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">context</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>30、根据表自动生成对应的Mapper以及po类,步骤如下。<br><img src=\"/项目搭建/Project-Module/30.1.png\" alt=\"\"><br>得到目录如下<br><img src=\"/项目搭建/Project-Module/30.2.png\" alt=\"\"></p>\n<p>30、biz层下DemoServiceImpl通过@Autowired注解注入UserMapper，修改DemoService的test方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.test.demo.biz.impl;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.test.demo.biz.DemoService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.test.demo.dao.mapper.UserInfoPOMapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.example.test.demo.dao.po.UserInfoPO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Service;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">DemoService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserInfoPOMapper userInfoPOMapper;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        UserInfoPO po = userInfoPOMapper.selectByPrimaryKey(<span class=\"number\">1L</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"UserInfo name is:\"</span> + po.getName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>31、在入口类AppServiceApplication上中添加注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MapperScan</span>(<span class=\"string\">\"com.example.test.demo.dao.mapper\"</span>)</span><br></pre></td></tr></table></figure>\n\n<p>32、运行main方法启动项目<br><img src=\"/项目搭建/Project-Module/32.png\" alt=\"\"></p>\n<h3 id=\"遇到的坑\"><a href=\"#遇到的坑\" class=\"headerlink\" title=\"遇到的坑\"></a>遇到的坑</h3><p>mybatis 自动生成时遇到</p>\n<blockquote>\n<p>Client does not support authentication protocol requested by server; consider upgrading MySQL client</p>\n</blockquote>\n<p>解决方法登录mysql：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER USER <span class=\"string\">'root'</span>@<span class=\"string\">'localhost'</span> IDENTIFIED WITH mysql_native_password BY <span class=\"string\">'qwertyui'</span>;</span><br><span class=\"line\">SELECT plugin FROM mysql.user WHERE User = <span class=\"string\">'root'</span>;</span><br></pre></td></tr></table></figure>"},{"title":"redis-list双向链表【学习笔记】","date":"2019-03-28T08:18:04.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"## list定义\n```c\n/*\n * 双端链表节点\n */\ntypedef struct listNode {\n\n    // 前置节点\n    struct listNode *prev;\n\n    // 后置节点\n    struct listNode *next;\n\n    // 节点的值\n    void *value;\n\n} listNode;\n\n/*\n * 双端链表迭代器\n */\ntypedef struct listIter {\n\n    // 当前迭代到的节点\n    listNode *next;\n\n    // 迭代的方向\n    int direction;\n\n} listIter;\n\n/*\n * 双端链表结构\n */\ntypedef struct list {\n\n    // 表头节点\n    listNode *head;\n\n    // 表尾节点\n    listNode *tail;\n\n    // 节点值复制函数\n    void *(*dup)(void *ptr);\n\n    // 节点值释放函数\n    void (*free)(void *ptr);\n\n    // 节点值对比函数\n    int (*match)(void *ptr, void *key);\n\n    // 链表所包含的节点数量\n    unsigned long len;\n\n} list;\n```\n<!-- more -->\n![list](Redis-adlist/list.png)\n## list常用函数\n\n### listCreate-创建新链表\n```c\n/**\n * 创建一个新的链表\n * @return  创建成功返回链表，失败返回 NULL\n * T = O(1)\n */\nlist *listCreate(void)\n{\n    struct list *list;\n\n    // 分配内存\n    if ((list = zmalloc(sizeof(*list))) == NULL)\n        return NULL;\n\n    // 初始化属性\n    list->head = list->tail = NULL;\n    list->len = 0;\n    list->dup = NULL;\n    list->free = NULL;\n    list->match = NULL;\n\n    return list;\n}\n```\n\n### listRelease-释放整个链表\n```c\n/**\n * 释放整个链表，以及链表中所有节点\n * @param list\n * T = O(N)\n */\nvoid listRelease(list *list)\n{\n    unsigned long len;\n    listNode *current, *next;\n\n    // 指向头指针\n    current = list->head;\n    // 遍历整个链表\n    len = list->len;\n    while(len--) {\n        next = current->next;\n\n        // 如果有设置值释放函数，那么调用它\n        if (list->free) list->free(current->value);\n\n        // 释放节点结构\n        zfree(current);\n\n        current = next;\n    }\n\n    // 释放链表结构\n    zfree(list);\n}\n```\n### listAddNodeHead-添加新节点到链表头\n```c\n/**\n * 将一个包含有给定值指针 value 的新节点添加到链表的表头\n * @param list\n * @param value\n * @return 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL，如果执行成功，返回传入的链表指针\n * T = O(1)\n */\nlist *listAddNodeHead(list *list, void *value)\n{\n    listNode *node;\n\n    // 为节点分配内存\n    if ((node = zmalloc(sizeof(*node))) == NULL)\n        return NULL;\n\n    // 保存值指针\n    node->value = value;\n\n    // 添加节点到空链表\n    if (list->len == 0) {\n        list->head = list->tail = node;\n        node->prev = node->next = NULL;\n    // 添加节点到非空链表\n    } else {\n        node->prev = NULL;\n        node->next = list->head;\n        list->head->prev = node;\n        list->head = node;\n    }\n\n    // 更新链表节点数\n    list->len++;\n\n    return list;\n}\n```\n### listAddNodeTail-添加新节点到链表尾\n```c\n/**\n * 将一个包含有给定值指针 value 的新节点添加到链表的表尾\n * @param list\n * @param value 新节点\n * @return 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL，如果执行成功，返回传入的链表指针\n * T = O(1)\n */\nlist *listAddNodeTail(list *list, void *value)\n{\n    listNode *node;\n\n    // 为新节点分配内存\n    if ((node = zmalloc(sizeof(*node))) == NULL)\n        return NULL;\n\n    // 保存值指针\n    node->value = value;\n\n    // 目标链表为空\n    if (list->len == 0) {\n        list->head = list->tail = node;\n        node->prev = node->next = NULL;\n    // 目标链表非空\n    } else {\n        node->prev = list->tail;\n        node->next = NULL;\n        list->tail->next = node;\n        list->tail = node;\n    }\n\n    // 更新链表节点数\n    list->len++;\n\n    return list;\n}\n```\n### listInsertNode-将新节点添加到老节点之前或之后\n```c\n/**\n * 创建一个包含值 value 的新节点，并将它插入到 old_node 的之前或之后\n * 如果 after 为 0 ，将新节点插入到 old_node 之前。\n * 如果 after 为 1 ，将新节点插入到 old_node 之后。\n * @param list 链表\n * @param old_node 老节点\n * @param value 值\n * @param after\n * @return 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL，如果执行成功，返回传入的链表指针\n * T = O(1)\n */\nlist *listInsertNode(list *list, listNode *old_node, void *value, int after) {\n    listNode *node;\n\n    // 创建新节点\n    if ((node = zmalloc(sizeof(*node))) == NULL)\n        return NULL;\n\n    // 保存值\n    node->value = value;\n\n    // 将新节点添加到给定节点之后\n    if (after) {\n        node->prev = old_node;\n        node->next = old_node->next;\n        // 给定节点是原表尾节点\n        if (list->tail == old_node) {\n            list->tail = node;\n        }\n    // 将新节点添加到给定节点之前\n    } else {\n        node->next = old_node;\n        node->prev = old_node->prev;\n        // 给定节点是原表头节点\n        if (list->head == old_node) {\n            list->head = node;\n        }\n    }\n\n    // 更新新节点的前置指针\n    if (node->prev != NULL) {\n        node->prev->next = node;\n    }\n    // 更新新节点的后置指针\n    if (node->next != NULL) {\n        node->next->prev = node;\n    }\n\n    // 更新链表节点数\n    list->len++;\n\n    return list;\n}\n```\n### listDelNode-删除指定节点\n```c\n/**\n * 从链表 list 中删除给定节点 node \n * 对节点私有值(private value of the node)的释放工作由调用者进行。\n * @param list \n * @param node \n * T = O(1)\n */\nvoid listDelNode(list *list, listNode *node)\n{\n    // 调整前置节点的指针\n    if (node->prev)\n        node->prev->next = node->next;\n    else\n        list->head = node->next;\n\n    // 调整后置节点的指针\n    if (node->next)\n        node->next->prev = node->prev;\n    else\n        list->tail = node->prev;\n\n    // 释放值\n    if (list->free) list->free(node->value);\n\n    // 释放节点\n    zfree(node);\n\n    // 链表数减一\n    list->len--;\n}\n\n```\n### listGetIterator-生成链表的迭代器\n```c\n/**\n * 为给定链表创建一个迭代器，\n * 之后每次对这个迭代器调用 listNext 都返回被迭代到的链表节点\n * @param list 链表\n * @param direction 迭代方向 \n *        AL_START_HEAD ：从表头向表尾迭代\n *        AL_START_TAIL ：从表尾想表头迭代\n * @return 迭代器\n * T = O(1)\n */\nlistIter *listGetIterator(list *list, int direction)\n{\n    // 为迭代器分配内存\n    listIter *iter;\n    if ((iter = zmalloc(sizeof(*iter))) == NULL) return NULL;\n\n    // 根据迭代方向，设置迭代器的起始节点\n    if (direction == AL_START_HEAD)\n        iter->next = list->head;\n    else\n        iter->next = list->tail;\n\n    // 记录迭代方向\n    iter->direction = direction;\n\n    return iter;\n}\n```\n### listNext-返回迭代器当前所指向的节点\n```c\n/**\n * 返回迭代器当前所指向的节点。\n * 删除当前节点是允许的，但不能修改链表里的其他节点。\n * @param iter 迭代器\n * @return 函数要么返回一个节点，要么返回 NULL \n * T = O(1)\n */\nlistNode *listNext(listIter *iter)\n{\n    listNode *current = iter->next;\n\n    if (current != NULL) {\n        // 根据方向选择下一个节点\n        if (iter->direction == AL_START_HEAD)\n            // 保存下一个节点，防止当前节点被删除而造成指针丢失\n            iter->next = current->next;\n        else\n            // 保存下一个节点，防止当前节点被删除而造成指针丢失\n            iter->next = current->prev;\n    }\n\n    return current;\n}\n```\n### listDup-复制整个链表\n```c\n/**\n * 复制整个链表。\n * 无论复制是成功还是失败，输入节点都不会修改。\n * 如果链表有设置值复制函数 dup ，那么对值的复制将使用复制函数进行，\n * 否则，新节点将和旧节点共享同一个指针。\n * @param orig\n * @return 复制成功返回输入链表的副本，如果因为内存不足而造成复制失败，返回 NULL 。\n * T = O(N)\n */\nlist *listDup(list *orig)\n{\n    list *copy;\n    listIter *iter;\n    listNode *node;\n\n    // 创建新链表\n    if ((copy = listCreate()) == NULL)\n        return NULL;\n\n    // 设置节点值处理函数\n    copy->dup = orig->dup;\n    copy->free = orig->free;\n    copy->match = orig->match;\n\n    // 迭代整个输入链表\n    iter = listGetIterator(orig, AL_START_HEAD);\n    while((node = listNext(iter)) != NULL) {\n        void *value;\n\n        // 复制节点值到新节点\n        if (copy->dup) {\n            value = copy->dup(node->value);\n            if (value == NULL) {\n                listRelease(copy);\n                listReleaseIterator(iter);\n                return NULL;\n            }\n        } else\n            value = node->value;\n\n        // 将节点添加到链表\n        if (listAddNodeTail(copy, value) == NULL) {\n            listRelease(copy);\n            listReleaseIterator(iter);\n            return NULL;\n        }\n    }\n\n    // 释放迭代器\n    listReleaseIterator(iter);\n\n    // 返回副本\n    return copy;\n}\n```\n### listSearchKey-查找值为key的节点\n```c\n/**\n * 查找链表 list 中值和 key 匹配的节点。\n * 对比操作由链表的 match 函数负责进行，如果没有设置 match 函数，\n * 那么直接通过对比值的指针来决定是否匹配。\n * @param list 链表\n * @param key 值\n * @return 如果匹配成功，那么第一个匹配的节点会被返回。\n *         如果没有匹配任何节点，那么返回 NULL 。\n */\nlistNode *listSearchKey(list *list, void *key)\n{\n    listIter *iter;\n    listNode *node;\n\n    // 迭代整个链表\n    iter = listGetIterator(list, AL_START_HEAD);\n    while((node = listNext(iter)) != NULL) {\n        \n        // 对比\n        if (list->match) {\n            if (list->match(node->value, key)) {\n                listReleaseIterator(iter);\n                // 找到\n                return node;\n            }\n        } else {\n            if (key == node->value) {\n                listReleaseIterator(iter);\n                // 找到\n                return node;\n            }\n        }\n    }\n    \n    listReleaseIterator(iter);\n\n    // 未找到\n    return NULL;\n}\n```\n### listIndex-返回链表在指定索引上的值\n```c\n/**\n * 返回链表在给定索引上的值。\n * @param list \n * @param index 索引以 0 为起始，也可以是负数， -1 表示链表最后一个节点，诸如此类。\n * @return 如果索引超出范围（out of range），返回 NULL 。\n * T = O(N)\n */\nlistNode *listIndex(list *list, long index) {\n    listNode *n;\n\n    // 如果索引为负数，从表尾开始查找\n    if (index < 0) {\n        index = (-index)-1;\n        n = list->tail;\n        while(index-- && n) n = n->prev;\n    // 如果索引为正数，从表头开始查找\n    } else {\n        n = list->head;\n        while(index-- && n) n = n->next;\n    }\n\n    return n;\n}\n```\n### listRewind-设置正向迭代器\n```c\n/**\n * 将迭代器的方向设置为 AL_START_HEAD ，并将迭代指针重新指向表头节点。\n * @param list 链表\n * @param li 迭代器\n * T = O(1)\n */\nvoid listRewind(list *list, listIter *li) {\n    li->next = list->head;\n    li->direction = AL_START_HEAD;\n}\n```\n### listRewindTail-设置反向迭代器\n```c\n/**\n * 将迭代器的方向设置为 AL_START_TAIL, 并将迭代指针重新指向表尾节点。\n * @param list 链表\n * @param li 迭代器\n * T = O(1)\n */\nvoid listRewindTail(list *list, listIter *li) {\n    li->next = list->tail;\n    li->direction = AL_START_TAIL;\n}\n```\n### listRotate-将链表尾移动到表头\n```c\n/\n * 取出链表的表尾节点，并将它移动到表头，成为新的表头节点。\n * @param list \n * T = O(1)\n */\nvoid listRotate(list *list) {\n    listNode *tail = list->tail;\n\n    if (listLength(list) <= 1) return;\n\n    // 取出表尾节点\n    list->tail = tail->prev;\n    list->tail->next = NULL;\n\n    // 插入到表头\n    list->head->prev = tail;\n    tail->prev = NULL;\n    tail->next = list->head;\n    list->head = tail;\n}\n```","source":"_posts/Redis-adlist.md","raw":"---\ntitle: redis-list双向链表【学习笔记】\ndate: 2019-03-28 16:18:04\ntags:\n    - redis\n    - 源码\ncategories: redis\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n## list定义\n```c\n/*\n * 双端链表节点\n */\ntypedef struct listNode {\n\n    // 前置节点\n    struct listNode *prev;\n\n    // 后置节点\n    struct listNode *next;\n\n    // 节点的值\n    void *value;\n\n} listNode;\n\n/*\n * 双端链表迭代器\n */\ntypedef struct listIter {\n\n    // 当前迭代到的节点\n    listNode *next;\n\n    // 迭代的方向\n    int direction;\n\n} listIter;\n\n/*\n * 双端链表结构\n */\ntypedef struct list {\n\n    // 表头节点\n    listNode *head;\n\n    // 表尾节点\n    listNode *tail;\n\n    // 节点值复制函数\n    void *(*dup)(void *ptr);\n\n    // 节点值释放函数\n    void (*free)(void *ptr);\n\n    // 节点值对比函数\n    int (*match)(void *ptr, void *key);\n\n    // 链表所包含的节点数量\n    unsigned long len;\n\n} list;\n```\n<!-- more -->\n![list](Redis-adlist/list.png)\n## list常用函数\n\n### listCreate-创建新链表\n```c\n/**\n * 创建一个新的链表\n * @return  创建成功返回链表，失败返回 NULL\n * T = O(1)\n */\nlist *listCreate(void)\n{\n    struct list *list;\n\n    // 分配内存\n    if ((list = zmalloc(sizeof(*list))) == NULL)\n        return NULL;\n\n    // 初始化属性\n    list->head = list->tail = NULL;\n    list->len = 0;\n    list->dup = NULL;\n    list->free = NULL;\n    list->match = NULL;\n\n    return list;\n}\n```\n\n### listRelease-释放整个链表\n```c\n/**\n * 释放整个链表，以及链表中所有节点\n * @param list\n * T = O(N)\n */\nvoid listRelease(list *list)\n{\n    unsigned long len;\n    listNode *current, *next;\n\n    // 指向头指针\n    current = list->head;\n    // 遍历整个链表\n    len = list->len;\n    while(len--) {\n        next = current->next;\n\n        // 如果有设置值释放函数，那么调用它\n        if (list->free) list->free(current->value);\n\n        // 释放节点结构\n        zfree(current);\n\n        current = next;\n    }\n\n    // 释放链表结构\n    zfree(list);\n}\n```\n### listAddNodeHead-添加新节点到链表头\n```c\n/**\n * 将一个包含有给定值指针 value 的新节点添加到链表的表头\n * @param list\n * @param value\n * @return 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL，如果执行成功，返回传入的链表指针\n * T = O(1)\n */\nlist *listAddNodeHead(list *list, void *value)\n{\n    listNode *node;\n\n    // 为节点分配内存\n    if ((node = zmalloc(sizeof(*node))) == NULL)\n        return NULL;\n\n    // 保存值指针\n    node->value = value;\n\n    // 添加节点到空链表\n    if (list->len == 0) {\n        list->head = list->tail = node;\n        node->prev = node->next = NULL;\n    // 添加节点到非空链表\n    } else {\n        node->prev = NULL;\n        node->next = list->head;\n        list->head->prev = node;\n        list->head = node;\n    }\n\n    // 更新链表节点数\n    list->len++;\n\n    return list;\n}\n```\n### listAddNodeTail-添加新节点到链表尾\n```c\n/**\n * 将一个包含有给定值指针 value 的新节点添加到链表的表尾\n * @param list\n * @param value 新节点\n * @return 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL，如果执行成功，返回传入的链表指针\n * T = O(1)\n */\nlist *listAddNodeTail(list *list, void *value)\n{\n    listNode *node;\n\n    // 为新节点分配内存\n    if ((node = zmalloc(sizeof(*node))) == NULL)\n        return NULL;\n\n    // 保存值指针\n    node->value = value;\n\n    // 目标链表为空\n    if (list->len == 0) {\n        list->head = list->tail = node;\n        node->prev = node->next = NULL;\n    // 目标链表非空\n    } else {\n        node->prev = list->tail;\n        node->next = NULL;\n        list->tail->next = node;\n        list->tail = node;\n    }\n\n    // 更新链表节点数\n    list->len++;\n\n    return list;\n}\n```\n### listInsertNode-将新节点添加到老节点之前或之后\n```c\n/**\n * 创建一个包含值 value 的新节点，并将它插入到 old_node 的之前或之后\n * 如果 after 为 0 ，将新节点插入到 old_node 之前。\n * 如果 after 为 1 ，将新节点插入到 old_node 之后。\n * @param list 链表\n * @param old_node 老节点\n * @param value 值\n * @param after\n * @return 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL，如果执行成功，返回传入的链表指针\n * T = O(1)\n */\nlist *listInsertNode(list *list, listNode *old_node, void *value, int after) {\n    listNode *node;\n\n    // 创建新节点\n    if ((node = zmalloc(sizeof(*node))) == NULL)\n        return NULL;\n\n    // 保存值\n    node->value = value;\n\n    // 将新节点添加到给定节点之后\n    if (after) {\n        node->prev = old_node;\n        node->next = old_node->next;\n        // 给定节点是原表尾节点\n        if (list->tail == old_node) {\n            list->tail = node;\n        }\n    // 将新节点添加到给定节点之前\n    } else {\n        node->next = old_node;\n        node->prev = old_node->prev;\n        // 给定节点是原表头节点\n        if (list->head == old_node) {\n            list->head = node;\n        }\n    }\n\n    // 更新新节点的前置指针\n    if (node->prev != NULL) {\n        node->prev->next = node;\n    }\n    // 更新新节点的后置指针\n    if (node->next != NULL) {\n        node->next->prev = node;\n    }\n\n    // 更新链表节点数\n    list->len++;\n\n    return list;\n}\n```\n### listDelNode-删除指定节点\n```c\n/**\n * 从链表 list 中删除给定节点 node \n * 对节点私有值(private value of the node)的释放工作由调用者进行。\n * @param list \n * @param node \n * T = O(1)\n */\nvoid listDelNode(list *list, listNode *node)\n{\n    // 调整前置节点的指针\n    if (node->prev)\n        node->prev->next = node->next;\n    else\n        list->head = node->next;\n\n    // 调整后置节点的指针\n    if (node->next)\n        node->next->prev = node->prev;\n    else\n        list->tail = node->prev;\n\n    // 释放值\n    if (list->free) list->free(node->value);\n\n    // 释放节点\n    zfree(node);\n\n    // 链表数减一\n    list->len--;\n}\n\n```\n### listGetIterator-生成链表的迭代器\n```c\n/**\n * 为给定链表创建一个迭代器，\n * 之后每次对这个迭代器调用 listNext 都返回被迭代到的链表节点\n * @param list 链表\n * @param direction 迭代方向 \n *        AL_START_HEAD ：从表头向表尾迭代\n *        AL_START_TAIL ：从表尾想表头迭代\n * @return 迭代器\n * T = O(1)\n */\nlistIter *listGetIterator(list *list, int direction)\n{\n    // 为迭代器分配内存\n    listIter *iter;\n    if ((iter = zmalloc(sizeof(*iter))) == NULL) return NULL;\n\n    // 根据迭代方向，设置迭代器的起始节点\n    if (direction == AL_START_HEAD)\n        iter->next = list->head;\n    else\n        iter->next = list->tail;\n\n    // 记录迭代方向\n    iter->direction = direction;\n\n    return iter;\n}\n```\n### listNext-返回迭代器当前所指向的节点\n```c\n/**\n * 返回迭代器当前所指向的节点。\n * 删除当前节点是允许的，但不能修改链表里的其他节点。\n * @param iter 迭代器\n * @return 函数要么返回一个节点，要么返回 NULL \n * T = O(1)\n */\nlistNode *listNext(listIter *iter)\n{\n    listNode *current = iter->next;\n\n    if (current != NULL) {\n        // 根据方向选择下一个节点\n        if (iter->direction == AL_START_HEAD)\n            // 保存下一个节点，防止当前节点被删除而造成指针丢失\n            iter->next = current->next;\n        else\n            // 保存下一个节点，防止当前节点被删除而造成指针丢失\n            iter->next = current->prev;\n    }\n\n    return current;\n}\n```\n### listDup-复制整个链表\n```c\n/**\n * 复制整个链表。\n * 无论复制是成功还是失败，输入节点都不会修改。\n * 如果链表有设置值复制函数 dup ，那么对值的复制将使用复制函数进行，\n * 否则，新节点将和旧节点共享同一个指针。\n * @param orig\n * @return 复制成功返回输入链表的副本，如果因为内存不足而造成复制失败，返回 NULL 。\n * T = O(N)\n */\nlist *listDup(list *orig)\n{\n    list *copy;\n    listIter *iter;\n    listNode *node;\n\n    // 创建新链表\n    if ((copy = listCreate()) == NULL)\n        return NULL;\n\n    // 设置节点值处理函数\n    copy->dup = orig->dup;\n    copy->free = orig->free;\n    copy->match = orig->match;\n\n    // 迭代整个输入链表\n    iter = listGetIterator(orig, AL_START_HEAD);\n    while((node = listNext(iter)) != NULL) {\n        void *value;\n\n        // 复制节点值到新节点\n        if (copy->dup) {\n            value = copy->dup(node->value);\n            if (value == NULL) {\n                listRelease(copy);\n                listReleaseIterator(iter);\n                return NULL;\n            }\n        } else\n            value = node->value;\n\n        // 将节点添加到链表\n        if (listAddNodeTail(copy, value) == NULL) {\n            listRelease(copy);\n            listReleaseIterator(iter);\n            return NULL;\n        }\n    }\n\n    // 释放迭代器\n    listReleaseIterator(iter);\n\n    // 返回副本\n    return copy;\n}\n```\n### listSearchKey-查找值为key的节点\n```c\n/**\n * 查找链表 list 中值和 key 匹配的节点。\n * 对比操作由链表的 match 函数负责进行，如果没有设置 match 函数，\n * 那么直接通过对比值的指针来决定是否匹配。\n * @param list 链表\n * @param key 值\n * @return 如果匹配成功，那么第一个匹配的节点会被返回。\n *         如果没有匹配任何节点，那么返回 NULL 。\n */\nlistNode *listSearchKey(list *list, void *key)\n{\n    listIter *iter;\n    listNode *node;\n\n    // 迭代整个链表\n    iter = listGetIterator(list, AL_START_HEAD);\n    while((node = listNext(iter)) != NULL) {\n        \n        // 对比\n        if (list->match) {\n            if (list->match(node->value, key)) {\n                listReleaseIterator(iter);\n                // 找到\n                return node;\n            }\n        } else {\n            if (key == node->value) {\n                listReleaseIterator(iter);\n                // 找到\n                return node;\n            }\n        }\n    }\n    \n    listReleaseIterator(iter);\n\n    // 未找到\n    return NULL;\n}\n```\n### listIndex-返回链表在指定索引上的值\n```c\n/**\n * 返回链表在给定索引上的值。\n * @param list \n * @param index 索引以 0 为起始，也可以是负数， -1 表示链表最后一个节点，诸如此类。\n * @return 如果索引超出范围（out of range），返回 NULL 。\n * T = O(N)\n */\nlistNode *listIndex(list *list, long index) {\n    listNode *n;\n\n    // 如果索引为负数，从表尾开始查找\n    if (index < 0) {\n        index = (-index)-1;\n        n = list->tail;\n        while(index-- && n) n = n->prev;\n    // 如果索引为正数，从表头开始查找\n    } else {\n        n = list->head;\n        while(index-- && n) n = n->next;\n    }\n\n    return n;\n}\n```\n### listRewind-设置正向迭代器\n```c\n/**\n * 将迭代器的方向设置为 AL_START_HEAD ，并将迭代指针重新指向表头节点。\n * @param list 链表\n * @param li 迭代器\n * T = O(1)\n */\nvoid listRewind(list *list, listIter *li) {\n    li->next = list->head;\n    li->direction = AL_START_HEAD;\n}\n```\n### listRewindTail-设置反向迭代器\n```c\n/**\n * 将迭代器的方向设置为 AL_START_TAIL, 并将迭代指针重新指向表尾节点。\n * @param list 链表\n * @param li 迭代器\n * T = O(1)\n */\nvoid listRewindTail(list *list, listIter *li) {\n    li->next = list->tail;\n    li->direction = AL_START_TAIL;\n}\n```\n### listRotate-将链表尾移动到表头\n```c\n/\n * 取出链表的表尾节点，并将它移动到表头，成为新的表头节点。\n * @param list \n * T = O(1)\n */\nvoid listRotate(list *list) {\n    listNode *tail = list->tail;\n\n    if (listLength(list) <= 1) return;\n\n    // 取出表尾节点\n    list->tail = tail->prev;\n    list->tail->next = NULL;\n\n    // 插入到表头\n    list->head->prev = tail;\n    tail->prev = NULL;\n    tail->next = list->head;\n    list->head = tail;\n}\n```","slug":"Redis-adlist","published":1,"updated":"2019-07-31T13:41:40.998Z","layout":"post","photos":[],"link":"","_id":"ck8fb4ae30037k2o5u8igi2zj","content":"<h2 id=\"list定义\"><a href=\"#list定义\" class=\"headerlink\" title=\"list定义\"></a>list定义</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 双端链表节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 前置节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">prev</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 后置节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点的值</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *value;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; listNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 双端链表迭代器</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listIter</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当前迭代到的节点</span></span><br><span class=\"line\">    listNode *next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 迭代的方向</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> direction;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; listIter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 双端链表结构</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表头节点</span></span><br><span class=\"line\">    listNode *head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表尾节点</span></span><br><span class=\"line\">    listNode *tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点值复制函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*dup)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点值释放函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">free</span>)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点值对比函数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 链表所包含的节点数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"built_in\">list</span>;</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n<p><img src=\"/redis/Redis-adlist/list.png\" alt=\"list\"></p>\n<h2 id=\"list常用函数\"><a href=\"#list常用函数\" class=\"headerlink\" title=\"list常用函数\"></a>list常用函数</h2><h3 id=\"listCreate-创建新链表\"><a href=\"#listCreate-创建新链表\" class=\"headerlink\" title=\"listCreate-创建新链表\"></a>listCreate-创建新链表</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 创建一个新的链表</span></span><br><span class=\"line\"><span class=\"comment\"> * @return  创建成功返回链表，失败返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">list</span> *<span class=\"title\">listCreate</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span> *<span class=\"title\">list</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 分配内存</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">list</span> = zmalloc(<span class=\"keyword\">sizeof</span>(*<span class=\"built_in\">list</span>))) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化属性</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;head = <span class=\"built_in\">list</span>-&gt;tail = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;dup = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;match = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listRelease-释放整个链表\"><a href=\"#listRelease-释放整个链表\" class=\"headerlink\" title=\"listRelease-释放整个链表\"></a>listRelease-释放整个链表</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 释放整个链表，以及链表中所有节点</span></span><br><span class=\"line\"><span class=\"comment\"> * @param list</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listRelease</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;</span><br><span class=\"line\">    listNode *current, *next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指向头指针</span></span><br><span class=\"line\">    current = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历整个链表</span></span><br><span class=\"line\">    len = <span class=\"built_in\">list</span>-&gt;len;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(len--) &#123;</span><br><span class=\"line\">        next = current-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果有设置值释放函数，那么调用它</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span>) <span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span>(current-&gt;value);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 释放节点结构</span></span><br><span class=\"line\">        zfree(current);</span><br><span class=\"line\"></span><br><span class=\"line\">        current = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 释放链表结构</span></span><br><span class=\"line\">    zfree(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listAddNodeHead-添加新节点到链表头\"><a href=\"#listAddNodeHead-添加新节点到链表头\" class=\"headerlink\" title=\"listAddNodeHead-添加新节点到链表头\"></a>listAddNodeHead-添加新节点到链表头</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将一个包含有给定值指针 value 的新节点添加到链表的表头</span></span><br><span class=\"line\"><span class=\"comment\"> * @param list</span></span><br><span class=\"line\"><span class=\"comment\"> * @param value</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL，如果执行成功，返回传入的链表指针</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">list</span> *<span class=\"title\">listAddNodeHead</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, <span class=\"keyword\">void</span> *value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    listNode *node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 为节点分配内存</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((node = zmalloc(<span class=\"keyword\">sizeof</span>(*node))) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保存值指针</span></span><br><span class=\"line\">    node-&gt;value = value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加节点到空链表</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head = <span class=\"built_in\">list</span>-&gt;tail = node;</span><br><span class=\"line\">        node-&gt;prev = node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 添加节点到非空链表</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        node-&gt;prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        node-&gt;next = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head-&gt;prev = node;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新链表节点数</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;len++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listAddNodeTail-添加新节点到链表尾\"><a href=\"#listAddNodeTail-添加新节点到链表尾\" class=\"headerlink\" title=\"listAddNodeTail-添加新节点到链表尾\"></a>listAddNodeTail-添加新节点到链表尾</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将一个包含有给定值指针 value 的新节点添加到链表的表尾</span></span><br><span class=\"line\"><span class=\"comment\"> * @param list</span></span><br><span class=\"line\"><span class=\"comment\"> * @param value 新节点</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL，如果执行成功，返回传入的链表指针</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">list</span> *<span class=\"title\">listAddNodeTail</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, <span class=\"keyword\">void</span> *value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    listNode *node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 为新节点分配内存</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((node = zmalloc(<span class=\"keyword\">sizeof</span>(*node))) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保存值指针</span></span><br><span class=\"line\">    node-&gt;value = value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 目标链表为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head = <span class=\"built_in\">list</span>-&gt;tail = node;</span><br><span class=\"line\">        node-&gt;prev = node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 目标链表非空</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        node-&gt;prev = <span class=\"built_in\">list</span>-&gt;tail;</span><br><span class=\"line\">        node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;tail-&gt;next = node;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;tail = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新链表节点数</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;len++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listInsertNode-将新节点添加到老节点之前或之后\"><a href=\"#listInsertNode-将新节点添加到老节点之前或之后\" class=\"headerlink\" title=\"listInsertNode-将新节点添加到老节点之前或之后\"></a>listInsertNode-将新节点添加到老节点之前或之后</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 创建一个包含值 value 的新节点，并将它插入到 old_node 的之前或之后</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果 after 为 0 ，将新节点插入到 old_node 之前。</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果 after 为 1 ，将新节点插入到 old_node 之后。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param list 链表</span></span><br><span class=\"line\"><span class=\"comment\"> * @param old_node 老节点</span></span><br><span class=\"line\"><span class=\"comment\"> * @param value 值</span></span><br><span class=\"line\"><span class=\"comment\"> * @param after</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL，如果执行成功，返回传入的链表指针</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">list</span> *<span class=\"title\">listInsertNode</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, listNode *old_node, <span class=\"keyword\">void</span> *value, <span class=\"keyword\">int</span> after)</span> </span>&#123;</span><br><span class=\"line\">    listNode *node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建新节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((node = zmalloc(<span class=\"keyword\">sizeof</span>(*node))) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保存值</span></span><br><span class=\"line\">    node-&gt;value = value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将新节点添加到给定节点之后</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (after) &#123;</span><br><span class=\"line\">        node-&gt;prev = old_node;</span><br><span class=\"line\">        node-&gt;next = old_node-&gt;next;</span><br><span class=\"line\">        <span class=\"comment\">// 给定节点是原表尾节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;tail == old_node) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">list</span>-&gt;tail = node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将新节点添加到给定节点之前</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        node-&gt;next = old_node;</span><br><span class=\"line\">        node-&gt;prev = old_node-&gt;prev;</span><br><span class=\"line\">        <span class=\"comment\">// 给定节点是原表头节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;head == old_node) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">list</span>-&gt;head = node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新新节点的前置指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node-&gt;prev != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        node-&gt;prev-&gt;next = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 更新新节点的后置指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node-&gt;next != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        node-&gt;next-&gt;prev = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新链表节点数</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;len++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listDelNode-删除指定节点\"><a href=\"#listDelNode-删除指定节点\" class=\"headerlink\" title=\"listDelNode-删除指定节点\"></a>listDelNode-删除指定节点</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 从链表 list 中删除给定节点 node </span></span><br><span class=\"line\"><span class=\"comment\"> * 对节点私有值(private value of the node)的释放工作由调用者进行。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param list </span></span><br><span class=\"line\"><span class=\"comment\"> * @param node </span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listDelNode</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, listNode *node)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调整前置节点的指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node-&gt;prev)</span><br><span class=\"line\">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head = node-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调整后置节点的指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node-&gt;next)</span><br><span class=\"line\">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;tail = node-&gt;prev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 释放值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span>) <span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span>(node-&gt;value);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 释放节点</span></span><br><span class=\"line\">    zfree(node);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 链表数减一</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;len--;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listGetIterator-生成链表的迭代器\"><a href=\"#listGetIterator-生成链表的迭代器\" class=\"headerlink\" title=\"listGetIterator-生成链表的迭代器\"></a>listGetIterator-生成链表的迭代器</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 为给定链表创建一个迭代器，</span></span><br><span class=\"line\"><span class=\"comment\"> * 之后每次对这个迭代器调用 listNext 都返回被迭代到的链表节点</span></span><br><span class=\"line\"><span class=\"comment\"> * @param list 链表</span></span><br><span class=\"line\"><span class=\"comment\"> * @param direction 迭代方向 </span></span><br><span class=\"line\"><span class=\"comment\"> *        AL_START_HEAD ：从表头向表尾迭代</span></span><br><span class=\"line\"><span class=\"comment\"> *        AL_START_TAIL ：从表尾想表头迭代</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 迭代器</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">listIter *<span class=\"title\">listGetIterator</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> direction)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 为迭代器分配内存</span></span><br><span class=\"line\">    listIter *iter;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((iter = zmalloc(<span class=\"keyword\">sizeof</span>(*iter))) == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据迭代方向，设置迭代器的起始节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (direction == AL_START_HEAD)</span><br><span class=\"line\">        iter-&gt;next = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        iter-&gt;next = <span class=\"built_in\">list</span>-&gt;tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 记录迭代方向</span></span><br><span class=\"line\">    iter-&gt;direction = direction;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> iter;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listNext-返回迭代器当前所指向的节点\"><a href=\"#listNext-返回迭代器当前所指向的节点\" class=\"headerlink\" title=\"listNext-返回迭代器当前所指向的节点\"></a>listNext-返回迭代器当前所指向的节点</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回迭代器当前所指向的节点。</span></span><br><span class=\"line\"><span class=\"comment\"> * 删除当前节点是允许的，但不能修改链表里的其他节点。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param iter 迭代器</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 函数要么返回一个节点，要么返回 NULL </span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">listNode *<span class=\"title\">listNext</span><span class=\"params\">(listIter *iter)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    listNode *current = iter-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据方向选择下一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class=\"line\">            <span class=\"comment\">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></span><br><span class=\"line\">            iter-&gt;next = current-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"comment\">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></span><br><span class=\"line\">            iter-&gt;next = current-&gt;prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listDup-复制整个链表\"><a href=\"#listDup-复制整个链表\" class=\"headerlink\" title=\"listDup-复制整个链表\"></a>listDup-复制整个链表</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 复制整个链表。</span></span><br><span class=\"line\"><span class=\"comment\"> * 无论复制是成功还是失败，输入节点都不会修改。</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果链表有设置值复制函数 dup ，那么对值的复制将使用复制函数进行，</span></span><br><span class=\"line\"><span class=\"comment\"> * 否则，新节点将和旧节点共享同一个指针。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param orig</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 复制成功返回输入链表的副本，如果因为内存不足而造成复制失败，返回 NULL 。</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">list</span> *<span class=\"title\">listDup</span><span class=\"params\">(<span class=\"built_in\">list</span> *orig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">list</span> *copy;</span><br><span class=\"line\">    listIter *iter;</span><br><span class=\"line\">    listNode *node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建新链表</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((copy = listCreate()) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置节点值处理函数</span></span><br><span class=\"line\">    copy-&gt;dup = orig-&gt;dup;</span><br><span class=\"line\">    copy-&gt;<span class=\"built_in\">free</span> = orig-&gt;<span class=\"built_in\">free</span>;</span><br><span class=\"line\">    copy-&gt;match = orig-&gt;match;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 迭代整个输入链表</span></span><br><span class=\"line\">    iter = listGetIterator(orig, AL_START_HEAD);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((node = listNext(iter)) != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 复制节点值到新节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (copy-&gt;dup) &#123;</span><br><span class=\"line\">            value = copy-&gt;dup(node-&gt;value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">                listRelease(copy);</span><br><span class=\"line\">                listReleaseIterator(iter);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">            value = node-&gt;value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将节点添加到链表</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listAddNodeTail(copy, value) == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            listRelease(copy);</span><br><span class=\"line\">            listReleaseIterator(iter);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 释放迭代器</span></span><br><span class=\"line\">    listReleaseIterator(iter);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回副本</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listSearchKey-查找值为key的节点\"><a href=\"#listSearchKey-查找值为key的节点\" class=\"headerlink\" title=\"listSearchKey-查找值为key的节点\"></a>listSearchKey-查找值为key的节点</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 查找链表 list 中值和 key 匹配的节点。</span></span><br><span class=\"line\"><span class=\"comment\"> * 对比操作由链表的 match 函数负责进行，如果没有设置 match 函数，</span></span><br><span class=\"line\"><span class=\"comment\"> * 那么直接通过对比值的指针来决定是否匹配。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param list 链表</span></span><br><span class=\"line\"><span class=\"comment\"> * @param key 值</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果匹配成功，那么第一个匹配的节点会被返回。</span></span><br><span class=\"line\"><span class=\"comment\"> *         如果没有匹配任何节点，那么返回 NULL 。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">listNode *<span class=\"title\">listSearchKey</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, <span class=\"keyword\">void</span> *key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    listIter *iter;</span><br><span class=\"line\">    listNode *node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 迭代整个链表</span></span><br><span class=\"line\">    iter = listGetIterator(<span class=\"built_in\">list</span>, AL_START_HEAD);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((node = listNext(iter)) != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 对比</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;match) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;match(node-&gt;value, key)) &#123;</span><br><span class=\"line\">                listReleaseIterator(iter);</span><br><span class=\"line\">                <span class=\"comment\">// 找到</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key == node-&gt;value) &#123;</span><br><span class=\"line\">                listReleaseIterator(iter);</span><br><span class=\"line\">                <span class=\"comment\">// 找到</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    listReleaseIterator(iter);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 未找到</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listIndex-返回链表在指定索引上的值\"><a href=\"#listIndex-返回链表在指定索引上的值\" class=\"headerlink\" title=\"listIndex-返回链表在指定索引上的值\"></a>listIndex-返回链表在指定索引上的值</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回链表在给定索引上的值。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param list </span></span><br><span class=\"line\"><span class=\"comment\"> * @param index 索引以 0 为起始，也可以是负数， -1 表示链表最后一个节点，诸如此类。</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果索引超出范围（out of range），返回 NULL 。</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">listNode *<span class=\"title\">listIndex</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, <span class=\"keyword\">long</span> index)</span> </span>&#123;</span><br><span class=\"line\">    listNode *n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果索引为负数，从表尾开始查找</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        index = (-index)<span class=\"number\">-1</span>;</span><br><span class=\"line\">        n = <span class=\"built_in\">list</span>-&gt;tail;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(index-- &amp;&amp; n) n = n-&gt;prev;</span><br><span class=\"line\">    <span class=\"comment\">// 如果索引为正数，从表头开始查找</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        n = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(index-- &amp;&amp; n) n = n-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listRewind-设置正向迭代器\"><a href=\"#listRewind-设置正向迭代器\" class=\"headerlink\" title=\"listRewind-设置正向迭代器\"></a>listRewind-设置正向迭代器</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将迭代器的方向设置为 AL_START_HEAD ，并将迭代指针重新指向表头节点。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param list 链表</span></span><br><span class=\"line\"><span class=\"comment\"> * @param li 迭代器</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listRewind</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, listIter *li)</span> </span>&#123;</span><br><span class=\"line\">    li-&gt;next = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    li-&gt;direction = AL_START_HEAD;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listRewindTail-设置反向迭代器\"><a href=\"#listRewindTail-设置反向迭代器\" class=\"headerlink\" title=\"listRewindTail-设置反向迭代器\"></a>listRewindTail-设置反向迭代器</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将迭代器的方向设置为 AL_START_TAIL, 并将迭代指针重新指向表尾节点。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param list 链表</span></span><br><span class=\"line\"><span class=\"comment\"> * @param li 迭代器</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listRewindTail</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, listIter *li)</span> </span>&#123;</span><br><span class=\"line\">    li-&gt;next = <span class=\"built_in\">list</span>-&gt;tail;</span><br><span class=\"line\">    li-&gt;direction = AL_START_TAIL;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listRotate-将链表尾移动到表头\"><a href=\"#listRotate-将链表尾移动到表头\" class=\"headerlink\" title=\"listRotate-将链表尾移动到表头\"></a>listRotate-将链表尾移动到表头</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/</span><br><span class=\"line\"> * 取出链表的表尾节点，并将它移动到表头，成为新的表头节点。</span><br><span class=\"line\"> * @param <span class=\"built_in\">list</span> </span><br><span class=\"line\"> * T = O(<span class=\"number\">1</span>)</span><br><span class=\"line\"> */</span><br><span class=\"line\"><span class=\"keyword\">void</span> listRotate(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">    listNode *tail = <span class=\"built_in\">list</span>-&gt;tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (listLength(<span class=\"built_in\">list</span>) &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 取出表尾节点</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;tail = tail-&gt;prev;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;tail-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 插入到表头</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;head-&gt;prev = tail;</span><br><span class=\"line\">    tail-&gt;prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    tail-&gt;next = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;head = tail;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"list定义\"><a href=\"#list定义\" class=\"headerlink\" title=\"list定义\"></a>list定义</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 双端链表节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 前置节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">prev</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 后置节点</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点的值</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *value;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; listNode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 双端链表迭代器</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">listIter</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当前迭代到的节点</span></span><br><span class=\"line\">    listNode *next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 迭代的方向</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> direction;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; listIter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 双端链表结构</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表头节点</span></span><br><span class=\"line\">    listNode *head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表尾节点</span></span><br><span class=\"line\">    listNode *tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点值复制函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*dup)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点值释放函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*<span class=\"built_in\">free</span>)(<span class=\"keyword\">void</span> *ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点值对比函数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> (*match)(<span class=\"keyword\">void</span> *ptr, <span class=\"keyword\">void</span> *key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 链表所包含的节点数量</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"built_in\">list</span>;</span><br></pre></td></tr></table></figure>","more":"<p><img src=\"/redis/Redis-adlist/list.png\" alt=\"list\"></p>\n<h2 id=\"list常用函数\"><a href=\"#list常用函数\" class=\"headerlink\" title=\"list常用函数\"></a>list常用函数</h2><h3 id=\"listCreate-创建新链表\"><a href=\"#listCreate-创建新链表\" class=\"headerlink\" title=\"listCreate-创建新链表\"></a>listCreate-创建新链表</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 创建一个新的链表</span></span><br><span class=\"line\"><span class=\"comment\"> * @return  创建成功返回链表，失败返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">list</span> *<span class=\"title\">listCreate</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list</span> *<span class=\"title\">list</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 分配内存</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">list</span> = zmalloc(<span class=\"keyword\">sizeof</span>(*<span class=\"built_in\">list</span>))) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化属性</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;head = <span class=\"built_in\">list</span>-&gt;tail = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;dup = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span> = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;match = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listRelease-释放整个链表\"><a href=\"#listRelease-释放整个链表\" class=\"headerlink\" title=\"listRelease-释放整个链表\"></a>listRelease-释放整个链表</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 释放整个链表，以及链表中所有节点</span></span><br><span class=\"line\"><span class=\"comment\"> * @param list</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listRelease</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> len;</span><br><span class=\"line\">    listNode *current, *next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指向头指针</span></span><br><span class=\"line\">    current = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历整个链表</span></span><br><span class=\"line\">    len = <span class=\"built_in\">list</span>-&gt;len;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(len--) &#123;</span><br><span class=\"line\">        next = current-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果有设置值释放函数，那么调用它</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span>) <span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span>(current-&gt;value);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 释放节点结构</span></span><br><span class=\"line\">        zfree(current);</span><br><span class=\"line\"></span><br><span class=\"line\">        current = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 释放链表结构</span></span><br><span class=\"line\">    zfree(<span class=\"built_in\">list</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listAddNodeHead-添加新节点到链表头\"><a href=\"#listAddNodeHead-添加新节点到链表头\" class=\"headerlink\" title=\"listAddNodeHead-添加新节点到链表头\"></a>listAddNodeHead-添加新节点到链表头</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将一个包含有给定值指针 value 的新节点添加到链表的表头</span></span><br><span class=\"line\"><span class=\"comment\"> * @param list</span></span><br><span class=\"line\"><span class=\"comment\"> * @param value</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL，如果执行成功，返回传入的链表指针</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">list</span> *<span class=\"title\">listAddNodeHead</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, <span class=\"keyword\">void</span> *value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    listNode *node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 为节点分配内存</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((node = zmalloc(<span class=\"keyword\">sizeof</span>(*node))) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保存值指针</span></span><br><span class=\"line\">    node-&gt;value = value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加节点到空链表</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head = <span class=\"built_in\">list</span>-&gt;tail = node;</span><br><span class=\"line\">        node-&gt;prev = node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 添加节点到非空链表</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        node-&gt;prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        node-&gt;next = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head-&gt;prev = node;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新链表节点数</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;len++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listAddNodeTail-添加新节点到链表尾\"><a href=\"#listAddNodeTail-添加新节点到链表尾\" class=\"headerlink\" title=\"listAddNodeTail-添加新节点到链表尾\"></a>listAddNodeTail-添加新节点到链表尾</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将一个包含有给定值指针 value 的新节点添加到链表的表尾</span></span><br><span class=\"line\"><span class=\"comment\"> * @param list</span></span><br><span class=\"line\"><span class=\"comment\"> * @param value 新节点</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL，如果执行成功，返回传入的链表指针</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">list</span> *<span class=\"title\">listAddNodeTail</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, <span class=\"keyword\">void</span> *value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    listNode *node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 为新节点分配内存</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((node = zmalloc(<span class=\"keyword\">sizeof</span>(*node))) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保存值指针</span></span><br><span class=\"line\">    node-&gt;value = value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 目标链表为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head = <span class=\"built_in\">list</span>-&gt;tail = node;</span><br><span class=\"line\">        node-&gt;prev = node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 目标链表非空</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        node-&gt;prev = <span class=\"built_in\">list</span>-&gt;tail;</span><br><span class=\"line\">        node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;tail-&gt;next = node;</span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;tail = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新链表节点数</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;len++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listInsertNode-将新节点添加到老节点之前或之后\"><a href=\"#listInsertNode-将新节点添加到老节点之前或之后\" class=\"headerlink\" title=\"listInsertNode-将新节点添加到老节点之前或之后\"></a>listInsertNode-将新节点添加到老节点之前或之后</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 创建一个包含值 value 的新节点，并将它插入到 old_node 的之前或之后</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果 after 为 0 ，将新节点插入到 old_node 之前。</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果 after 为 1 ，将新节点插入到 old_node 之后。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param list 链表</span></span><br><span class=\"line\"><span class=\"comment\"> * @param old_node 老节点</span></span><br><span class=\"line\"><span class=\"comment\"> * @param value 值</span></span><br><span class=\"line\"><span class=\"comment\"> * @param after</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL，如果执行成功，返回传入的链表指针</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">list</span> *<span class=\"title\">listInsertNode</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, listNode *old_node, <span class=\"keyword\">void</span> *value, <span class=\"keyword\">int</span> after)</span> </span>&#123;</span><br><span class=\"line\">    listNode *node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建新节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((node = zmalloc(<span class=\"keyword\">sizeof</span>(*node))) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保存值</span></span><br><span class=\"line\">    node-&gt;value = value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将新节点添加到给定节点之后</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (after) &#123;</span><br><span class=\"line\">        node-&gt;prev = old_node;</span><br><span class=\"line\">        node-&gt;next = old_node-&gt;next;</span><br><span class=\"line\">        <span class=\"comment\">// 给定节点是原表尾节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;tail == old_node) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">list</span>-&gt;tail = node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将新节点添加到给定节点之前</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        node-&gt;next = old_node;</span><br><span class=\"line\">        node-&gt;prev = old_node-&gt;prev;</span><br><span class=\"line\">        <span class=\"comment\">// 给定节点是原表头节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;head == old_node) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">list</span>-&gt;head = node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新新节点的前置指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node-&gt;prev != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        node-&gt;prev-&gt;next = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 更新新节点的后置指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node-&gt;next != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        node-&gt;next-&gt;prev = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新链表节点数</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;len++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listDelNode-删除指定节点\"><a href=\"#listDelNode-删除指定节点\" class=\"headerlink\" title=\"listDelNode-删除指定节点\"></a>listDelNode-删除指定节点</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 从链表 list 中删除给定节点 node </span></span><br><span class=\"line\"><span class=\"comment\"> * 对节点私有值(private value of the node)的释放工作由调用者进行。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param list </span></span><br><span class=\"line\"><span class=\"comment\"> * @param node </span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listDelNode</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, listNode *node)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调整前置节点的指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node-&gt;prev)</span><br><span class=\"line\">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;head = node-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调整后置节点的指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node-&gt;next)</span><br><span class=\"line\">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">list</span>-&gt;tail = node-&gt;prev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 释放值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span>) <span class=\"built_in\">list</span>-&gt;<span class=\"built_in\">free</span>(node-&gt;value);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 释放节点</span></span><br><span class=\"line\">    zfree(node);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 链表数减一</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;len--;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listGetIterator-生成链表的迭代器\"><a href=\"#listGetIterator-生成链表的迭代器\" class=\"headerlink\" title=\"listGetIterator-生成链表的迭代器\"></a>listGetIterator-生成链表的迭代器</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 为给定链表创建一个迭代器，</span></span><br><span class=\"line\"><span class=\"comment\"> * 之后每次对这个迭代器调用 listNext 都返回被迭代到的链表节点</span></span><br><span class=\"line\"><span class=\"comment\"> * @param list 链表</span></span><br><span class=\"line\"><span class=\"comment\"> * @param direction 迭代方向 </span></span><br><span class=\"line\"><span class=\"comment\"> *        AL_START_HEAD ：从表头向表尾迭代</span></span><br><span class=\"line\"><span class=\"comment\"> *        AL_START_TAIL ：从表尾想表头迭代</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 迭代器</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">listIter *<span class=\"title\">listGetIterator</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> direction)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 为迭代器分配内存</span></span><br><span class=\"line\">    listIter *iter;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((iter = zmalloc(<span class=\"keyword\">sizeof</span>(*iter))) == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据迭代方向，设置迭代器的起始节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (direction == AL_START_HEAD)</span><br><span class=\"line\">        iter-&gt;next = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        iter-&gt;next = <span class=\"built_in\">list</span>-&gt;tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 记录迭代方向</span></span><br><span class=\"line\">    iter-&gt;direction = direction;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> iter;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listNext-返回迭代器当前所指向的节点\"><a href=\"#listNext-返回迭代器当前所指向的节点\" class=\"headerlink\" title=\"listNext-返回迭代器当前所指向的节点\"></a>listNext-返回迭代器当前所指向的节点</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回迭代器当前所指向的节点。</span></span><br><span class=\"line\"><span class=\"comment\"> * 删除当前节点是允许的，但不能修改链表里的其他节点。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param iter 迭代器</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 函数要么返回一个节点，要么返回 NULL </span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">listNode *<span class=\"title\">listNext</span><span class=\"params\">(listIter *iter)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    listNode *current = iter-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据方向选择下一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class=\"line\">            <span class=\"comment\">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></span><br><span class=\"line\">            iter-&gt;next = current-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"comment\">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></span><br><span class=\"line\">            iter-&gt;next = current-&gt;prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listDup-复制整个链表\"><a href=\"#listDup-复制整个链表\" class=\"headerlink\" title=\"listDup-复制整个链表\"></a>listDup-复制整个链表</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 复制整个链表。</span></span><br><span class=\"line\"><span class=\"comment\"> * 无论复制是成功还是失败，输入节点都不会修改。</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果链表有设置值复制函数 dup ，那么对值的复制将使用复制函数进行，</span></span><br><span class=\"line\"><span class=\"comment\"> * 否则，新节点将和旧节点共享同一个指针。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param orig</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 复制成功返回输入链表的副本，如果因为内存不足而造成复制失败，返回 NULL 。</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">list</span> *<span class=\"title\">listDup</span><span class=\"params\">(<span class=\"built_in\">list</span> *orig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">list</span> *copy;</span><br><span class=\"line\">    listIter *iter;</span><br><span class=\"line\">    listNode *node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建新链表</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((copy = listCreate()) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置节点值处理函数</span></span><br><span class=\"line\">    copy-&gt;dup = orig-&gt;dup;</span><br><span class=\"line\">    copy-&gt;<span class=\"built_in\">free</span> = orig-&gt;<span class=\"built_in\">free</span>;</span><br><span class=\"line\">    copy-&gt;match = orig-&gt;match;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 迭代整个输入链表</span></span><br><span class=\"line\">    iter = listGetIterator(orig, AL_START_HEAD);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((node = listNext(iter)) != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> *value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 复制节点值到新节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (copy-&gt;dup) &#123;</span><br><span class=\"line\">            value = copy-&gt;dup(node-&gt;value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">                listRelease(copy);</span><br><span class=\"line\">                listReleaseIterator(iter);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">            value = node-&gt;value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将节点添加到链表</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listAddNodeTail(copy, value) == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            listRelease(copy);</span><br><span class=\"line\">            listReleaseIterator(iter);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 释放迭代器</span></span><br><span class=\"line\">    listReleaseIterator(iter);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回副本</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listSearchKey-查找值为key的节点\"><a href=\"#listSearchKey-查找值为key的节点\" class=\"headerlink\" title=\"listSearchKey-查找值为key的节点\"></a>listSearchKey-查找值为key的节点</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 查找链表 list 中值和 key 匹配的节点。</span></span><br><span class=\"line\"><span class=\"comment\"> * 对比操作由链表的 match 函数负责进行，如果没有设置 match 函数，</span></span><br><span class=\"line\"><span class=\"comment\"> * 那么直接通过对比值的指针来决定是否匹配。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param list 链表</span></span><br><span class=\"line\"><span class=\"comment\"> * @param key 值</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果匹配成功，那么第一个匹配的节点会被返回。</span></span><br><span class=\"line\"><span class=\"comment\"> *         如果没有匹配任何节点，那么返回 NULL 。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">listNode *<span class=\"title\">listSearchKey</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, <span class=\"keyword\">void</span> *key)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    listIter *iter;</span><br><span class=\"line\">    listNode *node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 迭代整个链表</span></span><br><span class=\"line\">    iter = listGetIterator(<span class=\"built_in\">list</span>, AL_START_HEAD);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((node = listNext(iter)) != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 对比</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;match) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>-&gt;match(node-&gt;value, key)) &#123;</span><br><span class=\"line\">                listReleaseIterator(iter);</span><br><span class=\"line\">                <span class=\"comment\">// 找到</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key == node-&gt;value) &#123;</span><br><span class=\"line\">                listReleaseIterator(iter);</span><br><span class=\"line\">                <span class=\"comment\">// 找到</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    listReleaseIterator(iter);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 未找到</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listIndex-返回链表在指定索引上的值\"><a href=\"#listIndex-返回链表在指定索引上的值\" class=\"headerlink\" title=\"listIndex-返回链表在指定索引上的值\"></a>listIndex-返回链表在指定索引上的值</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回链表在给定索引上的值。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param list </span></span><br><span class=\"line\"><span class=\"comment\"> * @param index 索引以 0 为起始，也可以是负数， -1 表示链表最后一个节点，诸如此类。</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果索引超出范围（out of range），返回 NULL 。</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">listNode *<span class=\"title\">listIndex</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, <span class=\"keyword\">long</span> index)</span> </span>&#123;</span><br><span class=\"line\">    listNode *n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果索引为负数，从表尾开始查找</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        index = (-index)<span class=\"number\">-1</span>;</span><br><span class=\"line\">        n = <span class=\"built_in\">list</span>-&gt;tail;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(index-- &amp;&amp; n) n = n-&gt;prev;</span><br><span class=\"line\">    <span class=\"comment\">// 如果索引为正数，从表头开始查找</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        n = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(index-- &amp;&amp; n) n = n-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listRewind-设置正向迭代器\"><a href=\"#listRewind-设置正向迭代器\" class=\"headerlink\" title=\"listRewind-设置正向迭代器\"></a>listRewind-设置正向迭代器</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将迭代器的方向设置为 AL_START_HEAD ，并将迭代指针重新指向表头节点。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param list 链表</span></span><br><span class=\"line\"><span class=\"comment\"> * @param li 迭代器</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listRewind</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, listIter *li)</span> </span>&#123;</span><br><span class=\"line\">    li-&gt;next = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    li-&gt;direction = AL_START_HEAD;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listRewindTail-设置反向迭代器\"><a href=\"#listRewindTail-设置反向迭代器\" class=\"headerlink\" title=\"listRewindTail-设置反向迭代器\"></a>listRewindTail-设置反向迭代器</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将迭代器的方向设置为 AL_START_TAIL, 并将迭代指针重新指向表尾节点。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param list 链表</span></span><br><span class=\"line\"><span class=\"comment\"> * @param li 迭代器</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">listRewindTail</span><span class=\"params\">(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>, listIter *li)</span> </span>&#123;</span><br><span class=\"line\">    li-&gt;next = <span class=\"built_in\">list</span>-&gt;tail;</span><br><span class=\"line\">    li-&gt;direction = AL_START_TAIL;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"listRotate-将链表尾移动到表头\"><a href=\"#listRotate-将链表尾移动到表头\" class=\"headerlink\" title=\"listRotate-将链表尾移动到表头\"></a>listRotate-将链表尾移动到表头</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/</span><br><span class=\"line\"> * 取出链表的表尾节点，并将它移动到表头，成为新的表头节点。</span><br><span class=\"line\"> * @param <span class=\"built_in\">list</span> </span><br><span class=\"line\"> * T = O(<span class=\"number\">1</span>)</span><br><span class=\"line\"> */</span><br><span class=\"line\"><span class=\"keyword\">void</span> listRotate(<span class=\"built_in\">list</span> *<span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\">    listNode *tail = <span class=\"built_in\">list</span>-&gt;tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (listLength(<span class=\"built_in\">list</span>) &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 取出表尾节点</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;tail = tail-&gt;prev;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;tail-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 插入到表头</span></span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;head-&gt;prev = tail;</span><br><span class=\"line\">    tail-&gt;prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    tail-&gt;next = <span class=\"built_in\">list</span>-&gt;head;</span><br><span class=\"line\">    <span class=\"built_in\">list</span>-&gt;head = tail;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"redis-sds动态字符串【学习笔记】","date":"2019-03-27T07:56:04.000Z","author":"Guyuqing","copyright":true,"comments":0,"_content":"## SDS定义\n\n```c\n/*\n * 类型别名，用于指向 sdshdr 的 buf 属性\n */\ntypedef char *sds;\n\n/*\n * 保存字符串对象的结构\n */\nstruct sdshdr {\n    \n    // buf 中已占用空间的长度\n    int len;\n\n    // buf 中剩余可用空间的长度\n    int free;\n\n    // 数据空间\n    char buf[];\n};\n\n```\n<!-- more -->\n## SDS常用函数\n\n### sdslen-sds长度\n```c\n/*\n * 返回 sds 实际保存的字符串的长度\n *\n * T = O(1)\n */\nstatic inline size_t sdslen(const sds s) {\n    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));\n    return sh->len;\n}\n\n```\ns 实际上存的是buf首个char数据的地址，也就是向前移动8个字节，就能到sdshdr的len的首地址\nchar buf[]这个数组没有大小，是所谓的柔性数组，是不占据内存大小的，所以sizeof(struct sdshdr)为8。\n具体结构如下图\n![sdshdr](Redis-sds/sdshdr.png)\n### sdsavail-sds可用free空间长度\n```c\n/*\n * 返回 sds 可用空间的长度\n *\n * T = O(1)\n */\nstatic inline size_t sdsavail(const sds s) {\n    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));\n    return sh->free;\n}\n```\n\n### sdsnewlen-根据字符串长度创建sds\n```c\n/**\n * 根据给定的初始化字符串 init 和字符串长度 initlen,创建一个新的 sds\n * @param init 初始化字符串指针\n * @param initlen 初始化字符串的长度\n * @return 创建成功返回 sdshdr 相对应的 sds,创建失败返回 NULL\n * T = O(N)\n */\nsds sdsnewlen(const void *init, size_t initlen) {\n\n    struct sdshdr *sh;\n\n    // 根据是否有初始化内容，选择适当的内存分配方式\n    // T = O(N)\n    if (init) {\n        // zmalloc 不初始化所分配的内存\n        sh = zmalloc(sizeof(struct sdshdr)+initlen+1);\n    } else {\n        // zcalloc 将分配的内存全部初始化为 0\n        sh = zcalloc(sizeof(struct sdshdr)+initlen+1);\n    }\n\n    // 内存分配失败，返回\n    if (sh == NULL) return NULL;\n\n    // 设置初始化长度\n    sh->len = initlen;\n    // 新 sds 不预留任何空间\n    sh->free = 0;\n    // 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中\n    // T = O(N)\n    if (initlen && init)\n        memcpy(sh->buf, init, initlen);\n    // 以 \\0 结尾\n    sh->buf[initlen] = '\\0';\n\n    // 返回 buf 部分，而不是整个 sdshdr\n    return (char*)sh->buf;\n}\n```\n### sdsnew-创建sds\n```c\n/**\n * 根据给定字符串 init ，创建一个包含同样字符串的 sds\n * @param init 如果输入为 NULL ，那么创建一个空白 sds\n * @return 创建成功返回 sdshdr 相对应的 sds，创建失败返回 NULL\n * T = O(N)\n */\nsds sdsnew(const char *init) {\n    size_t initlen = (init == NULL) ? 0 : strlen(init);\n    return sdsnewlen(init, initlen);\n}\n```\n### sdsempty-创建空sds\n```c\n/**\n * 创建并返回一个只保存了空字符串 \"\" 的 sds\n * @return 创建成功返回 sdshdr 相对应的 sds,创建失败返回 NULL\n * T = O(1)\n */\nsds sdsempty(void) {\n    return sdsnewlen(\"\",0);\n}\n```\n### sdsdup-复制sds创建副本\n```c\n/**\n * 复制给定 sds 创建副本\n * @param s sds\n * @return 创建成功返回输入 sds 的副本\n *  T = O(N)\n */\nsds sdsdup(const sds s) {\n    return sdsnewlen(s, sdslen(s));\n}\n```\n### sdsfree-释放sds\n```c\n/**\n * 释放给定的 sds\n * @param s \n * T = O(N)\n */\nvoid sdsfree(sds s) {\n    if (s == NULL) return;\n    zfree(s-sizeof(struct sdshdr));\n}\n```\n### sdsgrowzero-扩充sds未使用空间补0\n```c\n/**\n * 将 sds 扩充至指定长度，未使用的空间以 0 字节填充。\n * @param s\n * @param len 指定长度\n * @return 扩充成功返回新 sds ，失败返回 NULL\n * T = O(N)\n */\nsds sdsgrowzero(sds s, size_t len) {\n    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));\n    size_t totlen, curlen = sh->len;\n\n    // 如果 len 比字符串的现有长度小，\n    // 那么直接返回，不做动作\n    if (len <= curlen) return s;\n\n    // 扩展 sds\n    // T = O(N)\n    s = sdsMakeRoomFor(s,len-curlen);\n    // 如果内存不足，直接返回\n    if (s == NULL) return NULL;\n\n    // 将新分配的空间用 0 填充，防止出现垃圾内容\n    // T = O(N)\n    sh = (void*)(s-(sizeof(struct sdshdr)));\n    memset(s+curlen,0,(len-curlen+1));\n\n    // 更新属性\n    totlen = sh->len+sh->free;\n    sh->len = len;\n    sh->free = totlen-sh->len;\n\n    // 返回新的 sds\n    return s;\n}\n\n/**\n * 对 sds 中 buf 的长度进行扩展，确保在函数执行之后，\n * buf 至少会有 addlen + 1 长度的空余空间（额外的 1 字节是为 \\0 准备的）\n * @param s \n * @param addlen \n * @return 扩展成功返回扩展后的 sds，扩展失败返回 NULL\n * T = O(N)\n */\nsds sdsMakeRoomFor(sds s, size_t addlen) {\n\n    struct sdshdr *sh, *newsh;\n\n    // 获取 s 目前的空余空间长度\n    size_t free = sdsavail(s);\n\n    size_t len, newlen;\n\n    // s 目前的空余空间已经足够，无须再进行扩展，直接返回\n    if (free >= addlen) return s;\n\n    // 获取 s 目前已占用空间的长度\n    len = sdslen(s);\n    sh = (void*) (s-(sizeof(struct sdshdr)));\n\n    // s 最少需要的长度\n    newlen = (len+addlen);\n\n    // 根据新长度，为 s 分配新空间所需的大小\n    if (newlen < SDS_MAX_PREALLOC)\n        // 如果新长度小于 SDS_MAX_PREALLOC \n        // 那么为它分配两倍于所需长度的空间\n        newlen *= 2;\n    else\n        // 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC\n        newlen += SDS_MAX_PREALLOC;\n    // T = O(N)\n    newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1);\n\n    // 内存不足，分配失败，返回\n    if (newsh == NULL) return NULL;\n\n    // 更新 sds 的空余长度\n    newsh->free = newlen - len;\n\n    // 返回 sds\n    return newsh->buf;\n}\n\n/*\n * 最大预分配长度\n */\n#define SDS_MAX_PREALLOC (1024*1024)\n```\n\n### sdscatlen-根据字符串长度将字符串追加到sds末尾\n```c\n/**\n *  将长度为 len 的字符串 t 追加到 sds 的字符串末尾\n * @param s\n * @param t 字符串t\n * @param len t的长度\n * @return 追加成功返回新 sds ，失败返回 NULL\n * T = O(N)\n */\nsds sdscatlen(sds s, const void *t, size_t len) {\n    \n    struct sdshdr *sh;\n    \n    // 原有字符串长度\n    size_t curlen = sdslen(s);\n\n    // 扩展 sds 空间\n    // T = O(N)\n    s = sdsMakeRoomFor(s,len);\n\n    // 内存不足？直接返回\n    if (s == NULL) return NULL;\n\n    // 复制 t 中的内容到字符串后部\n    // T = O(N)\n    sh = (void*) (s-(sizeof(struct sdshdr)));\n    memcpy(s+curlen, t, len);\n\n    // 更新属性\n    sh->len = curlen+len;\n    sh->free = sh->free-len;\n\n    // 添加新结尾符号\n    s[curlen+len] = '\\0';\n\n    // 返回新 sds\n    return s;\n}\n```\n### sdscat-将字符串追加到sds末尾\n```c\n/**\n * 将给定字符串 t 追加到 sds 的末尾\n * @return 追加成功返回新 sds ，失败返回 NULL\n *  T = O(N)\n */\nsds sdscat(sds s, const char *t) {\n    return sdscatlen(s, t, strlen(t));\n}\n```\n\n### sdscatsds-将sds追加到另一个sds末尾\n```c\n/**\n * 将另一个 sds 追加到一个 sds 的末尾\n * @return 追加成功返回新 sds ，失败返回 NULL\n * T = O(N)\n */\nsds sdscatsds(sds s, const sds t) {\n    return sdscatlen(s, t, sdslen(t));\n}\n```\n### sdscpylen-将字符串前len复制到sds\n```c\n/**\n * 将字符串 t 的前 len 个字符复制到 sds s 当中,覆盖原有的字符\n * 如果 sds 的长度少于 len 个字符，那么扩展 sds\n * @return 复制成功返回新的 sds ，否则返回 NULL\n * T = O(N)\n */\nsds sdscpylen(sds s, const char *t, size_t len) {\n\n    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));\n\n    // sds 现有 buf 的长度\n    size_t totlen = sh->free+sh->len;\n\n    // 如果 s 的 buf 长度不满足 len ，那么扩展它\n    if (totlen < len) {\n        // T = O(N)\n        s = sdsMakeRoomFor(s,len-sh->len);\n        if (s == NULL) return NULL;\n        sh = (void*) (s-(sizeof(struct sdshdr)));\n        totlen = sh->free+sh->len;\n    }\n\n    // 复制内容\n    // T = O(N)\n    memcpy(s, t, len);\n\n    // 添加终结符号\n    s[len] = '\\0';\n\n    // 更新属性\n    sh->len = len;\n    sh->free = totlen-len;\n\n    // 返回新的 sds\n    return s;\n}\n```\n### sdscpy-将字符串复制到 sds 当中\n```c\n/**\n * 将字符串复制到 sds 当中,覆盖原有的字符\n * @return 复制成功返回新的 sds ，否则返回 NULL\n * T = O(N)\n */\nsds sdscpy(sds s, const char *t) {\n    return sdscpylen(s, t, strlen(t));\n}\n```","source":"_posts/Redis-sds.md","raw":"---\ntitle: redis-sds动态字符串【学习笔记】\ndate: 2019-03-27 15:56:04\ntags:\n    - redis\n    - 源码\ncategories: redis\nauthor: Guyuqing\ncopyright: true\ncomments: false\n---\n## SDS定义\n\n```c\n/*\n * 类型别名，用于指向 sdshdr 的 buf 属性\n */\ntypedef char *sds;\n\n/*\n * 保存字符串对象的结构\n */\nstruct sdshdr {\n    \n    // buf 中已占用空间的长度\n    int len;\n\n    // buf 中剩余可用空间的长度\n    int free;\n\n    // 数据空间\n    char buf[];\n};\n\n```\n<!-- more -->\n## SDS常用函数\n\n### sdslen-sds长度\n```c\n/*\n * 返回 sds 实际保存的字符串的长度\n *\n * T = O(1)\n */\nstatic inline size_t sdslen(const sds s) {\n    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));\n    return sh->len;\n}\n\n```\ns 实际上存的是buf首个char数据的地址，也就是向前移动8个字节，就能到sdshdr的len的首地址\nchar buf[]这个数组没有大小，是所谓的柔性数组，是不占据内存大小的，所以sizeof(struct sdshdr)为8。\n具体结构如下图\n![sdshdr](Redis-sds/sdshdr.png)\n### sdsavail-sds可用free空间长度\n```c\n/*\n * 返回 sds 可用空间的长度\n *\n * T = O(1)\n */\nstatic inline size_t sdsavail(const sds s) {\n    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));\n    return sh->free;\n}\n```\n\n### sdsnewlen-根据字符串长度创建sds\n```c\n/**\n * 根据给定的初始化字符串 init 和字符串长度 initlen,创建一个新的 sds\n * @param init 初始化字符串指针\n * @param initlen 初始化字符串的长度\n * @return 创建成功返回 sdshdr 相对应的 sds,创建失败返回 NULL\n * T = O(N)\n */\nsds sdsnewlen(const void *init, size_t initlen) {\n\n    struct sdshdr *sh;\n\n    // 根据是否有初始化内容，选择适当的内存分配方式\n    // T = O(N)\n    if (init) {\n        // zmalloc 不初始化所分配的内存\n        sh = zmalloc(sizeof(struct sdshdr)+initlen+1);\n    } else {\n        // zcalloc 将分配的内存全部初始化为 0\n        sh = zcalloc(sizeof(struct sdshdr)+initlen+1);\n    }\n\n    // 内存分配失败，返回\n    if (sh == NULL) return NULL;\n\n    // 设置初始化长度\n    sh->len = initlen;\n    // 新 sds 不预留任何空间\n    sh->free = 0;\n    // 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中\n    // T = O(N)\n    if (initlen && init)\n        memcpy(sh->buf, init, initlen);\n    // 以 \\0 结尾\n    sh->buf[initlen] = '\\0';\n\n    // 返回 buf 部分，而不是整个 sdshdr\n    return (char*)sh->buf;\n}\n```\n### sdsnew-创建sds\n```c\n/**\n * 根据给定字符串 init ，创建一个包含同样字符串的 sds\n * @param init 如果输入为 NULL ，那么创建一个空白 sds\n * @return 创建成功返回 sdshdr 相对应的 sds，创建失败返回 NULL\n * T = O(N)\n */\nsds sdsnew(const char *init) {\n    size_t initlen = (init == NULL) ? 0 : strlen(init);\n    return sdsnewlen(init, initlen);\n}\n```\n### sdsempty-创建空sds\n```c\n/**\n * 创建并返回一个只保存了空字符串 \"\" 的 sds\n * @return 创建成功返回 sdshdr 相对应的 sds,创建失败返回 NULL\n * T = O(1)\n */\nsds sdsempty(void) {\n    return sdsnewlen(\"\",0);\n}\n```\n### sdsdup-复制sds创建副本\n```c\n/**\n * 复制给定 sds 创建副本\n * @param s sds\n * @return 创建成功返回输入 sds 的副本\n *  T = O(N)\n */\nsds sdsdup(const sds s) {\n    return sdsnewlen(s, sdslen(s));\n}\n```\n### sdsfree-释放sds\n```c\n/**\n * 释放给定的 sds\n * @param s \n * T = O(N)\n */\nvoid sdsfree(sds s) {\n    if (s == NULL) return;\n    zfree(s-sizeof(struct sdshdr));\n}\n```\n### sdsgrowzero-扩充sds未使用空间补0\n```c\n/**\n * 将 sds 扩充至指定长度，未使用的空间以 0 字节填充。\n * @param s\n * @param len 指定长度\n * @return 扩充成功返回新 sds ，失败返回 NULL\n * T = O(N)\n */\nsds sdsgrowzero(sds s, size_t len) {\n    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));\n    size_t totlen, curlen = sh->len;\n\n    // 如果 len 比字符串的现有长度小，\n    // 那么直接返回，不做动作\n    if (len <= curlen) return s;\n\n    // 扩展 sds\n    // T = O(N)\n    s = sdsMakeRoomFor(s,len-curlen);\n    // 如果内存不足，直接返回\n    if (s == NULL) return NULL;\n\n    // 将新分配的空间用 0 填充，防止出现垃圾内容\n    // T = O(N)\n    sh = (void*)(s-(sizeof(struct sdshdr)));\n    memset(s+curlen,0,(len-curlen+1));\n\n    // 更新属性\n    totlen = sh->len+sh->free;\n    sh->len = len;\n    sh->free = totlen-sh->len;\n\n    // 返回新的 sds\n    return s;\n}\n\n/**\n * 对 sds 中 buf 的长度进行扩展，确保在函数执行之后，\n * buf 至少会有 addlen + 1 长度的空余空间（额外的 1 字节是为 \\0 准备的）\n * @param s \n * @param addlen \n * @return 扩展成功返回扩展后的 sds，扩展失败返回 NULL\n * T = O(N)\n */\nsds sdsMakeRoomFor(sds s, size_t addlen) {\n\n    struct sdshdr *sh, *newsh;\n\n    // 获取 s 目前的空余空间长度\n    size_t free = sdsavail(s);\n\n    size_t len, newlen;\n\n    // s 目前的空余空间已经足够，无须再进行扩展，直接返回\n    if (free >= addlen) return s;\n\n    // 获取 s 目前已占用空间的长度\n    len = sdslen(s);\n    sh = (void*) (s-(sizeof(struct sdshdr)));\n\n    // s 最少需要的长度\n    newlen = (len+addlen);\n\n    // 根据新长度，为 s 分配新空间所需的大小\n    if (newlen < SDS_MAX_PREALLOC)\n        // 如果新长度小于 SDS_MAX_PREALLOC \n        // 那么为它分配两倍于所需长度的空间\n        newlen *= 2;\n    else\n        // 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC\n        newlen += SDS_MAX_PREALLOC;\n    // T = O(N)\n    newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1);\n\n    // 内存不足，分配失败，返回\n    if (newsh == NULL) return NULL;\n\n    // 更新 sds 的空余长度\n    newsh->free = newlen - len;\n\n    // 返回 sds\n    return newsh->buf;\n}\n\n/*\n * 最大预分配长度\n */\n#define SDS_MAX_PREALLOC (1024*1024)\n```\n\n### sdscatlen-根据字符串长度将字符串追加到sds末尾\n```c\n/**\n *  将长度为 len 的字符串 t 追加到 sds 的字符串末尾\n * @param s\n * @param t 字符串t\n * @param len t的长度\n * @return 追加成功返回新 sds ，失败返回 NULL\n * T = O(N)\n */\nsds sdscatlen(sds s, const void *t, size_t len) {\n    \n    struct sdshdr *sh;\n    \n    // 原有字符串长度\n    size_t curlen = sdslen(s);\n\n    // 扩展 sds 空间\n    // T = O(N)\n    s = sdsMakeRoomFor(s,len);\n\n    // 内存不足？直接返回\n    if (s == NULL) return NULL;\n\n    // 复制 t 中的内容到字符串后部\n    // T = O(N)\n    sh = (void*) (s-(sizeof(struct sdshdr)));\n    memcpy(s+curlen, t, len);\n\n    // 更新属性\n    sh->len = curlen+len;\n    sh->free = sh->free-len;\n\n    // 添加新结尾符号\n    s[curlen+len] = '\\0';\n\n    // 返回新 sds\n    return s;\n}\n```\n### sdscat-将字符串追加到sds末尾\n```c\n/**\n * 将给定字符串 t 追加到 sds 的末尾\n * @return 追加成功返回新 sds ，失败返回 NULL\n *  T = O(N)\n */\nsds sdscat(sds s, const char *t) {\n    return sdscatlen(s, t, strlen(t));\n}\n```\n\n### sdscatsds-将sds追加到另一个sds末尾\n```c\n/**\n * 将另一个 sds 追加到一个 sds 的末尾\n * @return 追加成功返回新 sds ，失败返回 NULL\n * T = O(N)\n */\nsds sdscatsds(sds s, const sds t) {\n    return sdscatlen(s, t, sdslen(t));\n}\n```\n### sdscpylen-将字符串前len复制到sds\n```c\n/**\n * 将字符串 t 的前 len 个字符复制到 sds s 当中,覆盖原有的字符\n * 如果 sds 的长度少于 len 个字符，那么扩展 sds\n * @return 复制成功返回新的 sds ，否则返回 NULL\n * T = O(N)\n */\nsds sdscpylen(sds s, const char *t, size_t len) {\n\n    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));\n\n    // sds 现有 buf 的长度\n    size_t totlen = sh->free+sh->len;\n\n    // 如果 s 的 buf 长度不满足 len ，那么扩展它\n    if (totlen < len) {\n        // T = O(N)\n        s = sdsMakeRoomFor(s,len-sh->len);\n        if (s == NULL) return NULL;\n        sh = (void*) (s-(sizeof(struct sdshdr)));\n        totlen = sh->free+sh->len;\n    }\n\n    // 复制内容\n    // T = O(N)\n    memcpy(s, t, len);\n\n    // 添加终结符号\n    s[len] = '\\0';\n\n    // 更新属性\n    sh->len = len;\n    sh->free = totlen-len;\n\n    // 返回新的 sds\n    return s;\n}\n```\n### sdscpy-将字符串复制到 sds 当中\n```c\n/**\n * 将字符串复制到 sds 当中,覆盖原有的字符\n * @return 复制成功返回新的 sds ，否则返回 NULL\n * T = O(N)\n */\nsds sdscpy(sds s, const char *t) {\n    return sdscpylen(s, t, strlen(t));\n}\n```","slug":"Redis-sds","published":1,"updated":"2019-07-31T13:41:40.999Z","layout":"post","photos":[],"link":"","_id":"ck8fb4ae5003ck2o5y3l1nfvu","content":"<h2 id=\"SDS定义\"><a href=\"#SDS定义\" class=\"headerlink\" title=\"SDS定义\"></a>SDS定义</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 类型别名，用于指向 sdshdr 的 buf 属性</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span> *sds;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 保存字符串对象的结构</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> &#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// buf 中已占用空间的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// buf 中剩余可用空间的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"built_in\">free</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 数据空间</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n<h2 id=\"SDS常用函数\"><a href=\"#SDS常用函数\" class=\"headerlink\" title=\"SDS常用函数\"></a>SDS常用函数</h2><h3 id=\"sdslen-sds长度\"><a href=\"#sdslen-sds长度\" class=\"headerlink\" title=\"sdslen-sds长度\"></a>sdslen-sds长度</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回 sds 实际保存的字符串的长度</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> size_t <span class=\"title\">sdslen</span><span class=\"params\">(<span class=\"keyword\">const</span> sds s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span> = (<span class=\"title\">void</span>*)(<span class=\"title\">s</span>-(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">sdshdr</span>)));</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sh-&gt;len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>s 实际上存的是buf首个char数据的地址，也就是向前移动8个字节，就能到sdshdr的len的首地址<br>char buf[]这个数组没有大小，是所谓的柔性数组，是不占据内存大小的，所以sizeof(struct sdshdr)为8。<br>具体结构如下图<br><img src=\"/redis/Redis-sds/sdshdr.png\" alt=\"sdshdr\"></p>\n<h3 id=\"sdsavail-sds可用free空间长度\"><a href=\"#sdsavail-sds可用free空间长度\" class=\"headerlink\" title=\"sdsavail-sds可用free空间长度\"></a>sdsavail-sds可用free空间长度</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回 sds 可用空间的长度</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> size_t <span class=\"title\">sdsavail</span><span class=\"params\">(<span class=\"keyword\">const</span> sds s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span> = (<span class=\"title\">void</span>*)(<span class=\"title\">s</span>-(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">sdshdr</span>)));</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sh-&gt;<span class=\"built_in\">free</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdsnewlen-根据字符串长度创建sds\"><a href=\"#sdsnewlen-根据字符串长度创建sds\" class=\"headerlink\" title=\"sdsnewlen-根据字符串长度创建sds\"></a>sdsnewlen-根据字符串长度创建sds</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 根据给定的初始化字符串 init 和字符串长度 initlen,创建一个新的 sds</span></span><br><span class=\"line\"><span class=\"comment\"> * @param init 初始化字符串指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param initlen 初始化字符串的长度</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 创建成功返回 sdshdr 相对应的 sds,创建失败返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsnewlen</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *init, <span class=\"keyword\">size_t</span> initlen)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据是否有初始化内容，选择适当的内存分配方式</span></span><br><span class=\"line\">    <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (init) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// zmalloc 不初始化所分配的内存</span></span><br><span class=\"line\">        sh = zmalloc(<span class=\"keyword\">sizeof</span>(struct sdshdr)+initlen+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// zcalloc 将分配的内存全部初始化为 0</span></span><br><span class=\"line\">        sh = zcalloc(<span class=\"keyword\">sizeof</span>(struct sdshdr)+initlen+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 内存分配失败，返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置初始化长度</span></span><br><span class=\"line\">    sh-&gt;len = initlen;</span><br><span class=\"line\">    <span class=\"comment\">// 新 sds 不预留任何空间</span></span><br><span class=\"line\">    sh-&gt;<span class=\"built_in\">free</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中</span></span><br><span class=\"line\">    <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initlen &amp;&amp; init)</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(sh-&gt;buf, init, initlen);</span><br><span class=\"line\">    <span class=\"comment\">// 以 \\0 结尾</span></span><br><span class=\"line\">    sh-&gt;buf[initlen] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回 buf 部分，而不是整个 sdshdr</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">char</span>*)sh-&gt;buf;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdsnew-创建sds\"><a href=\"#sdsnew-创建sds\" class=\"headerlink\" title=\"sdsnew-创建sds\"></a>sdsnew-创建sds</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 根据给定字符串 init ，创建一个包含同样字符串的 sds</span></span><br><span class=\"line\"><span class=\"comment\"> * @param init 如果输入为 NULL ，那么创建一个空白 sds</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 创建成功返回 sdshdr 相对应的 sds，创建失败返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsnew</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *init)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> initlen = (init == <span class=\"literal\">NULL</span>) ? <span class=\"number\">0</span> : <span class=\"built_in\">strlen</span>(init);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdsnewlen(init, initlen);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdsempty-创建空sds\"><a href=\"#sdsempty-创建空sds\" class=\"headerlink\" title=\"sdsempty-创建空sds\"></a>sdsempty-创建空sds</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 创建并返回一个只保存了空字符串 \"\" 的 sds</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 创建成功返回 sdshdr 相对应的 sds,创建失败返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsempty</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdsnewlen(<span class=\"string\">\"\"</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdsdup-复制sds创建副本\"><a href=\"#sdsdup-复制sds创建副本\" class=\"headerlink\" title=\"sdsdup-复制sds创建副本\"></a>sdsdup-复制sds创建副本</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 复制给定 sds 创建副本</span></span><br><span class=\"line\"><span class=\"comment\"> * @param s sds</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 创建成功返回输入 sds 的副本</span></span><br><span class=\"line\"><span class=\"comment\"> *  T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsdup</span><span class=\"params\">(<span class=\"keyword\">const</span> sds s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdsnewlen(s, sdslen(s));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdsfree-释放sds\"><a href=\"#sdsfree-释放sds\" class=\"headerlink\" title=\"sdsfree-释放sds\"></a>sdsfree-释放sds</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 释放给定的 sds</span></span><br><span class=\"line\"><span class=\"comment\"> * @param s </span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sdsfree</span><span class=\"params\">(sds s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    zfree(s-<span class=\"keyword\">sizeof</span>(struct sdshdr));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdsgrowzero-扩充sds未使用空间补0\"><a href=\"#sdsgrowzero-扩充sds未使用空间补0\" class=\"headerlink\" title=\"sdsgrowzero-扩充sds未使用空间补0\"></a>sdsgrowzero-扩充sds未使用空间补0</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将 sds 扩充至指定长度，未使用的空间以 0 字节填充。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param s</span></span><br><span class=\"line\"><span class=\"comment\"> * @param len 指定长度</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 扩充成功返回新 sds ，失败返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsgrowzero</span><span class=\"params\">(sds s, <span class=\"keyword\">size_t</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span> = (<span class=\"title\">void</span>*)(<span class=\"title\">s</span>-(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">sdshdr</span>)));</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> totlen, curlen = sh-&gt;len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果 len 比字符串的现有长度小，</span></span><br><span class=\"line\">    <span class=\"comment\">// 那么直接返回，不做动作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &lt;= curlen) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 扩展 sds</span></span><br><span class=\"line\">    <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">    s = sdsMakeRoomFor(s,len-curlen);</span><br><span class=\"line\">    <span class=\"comment\">// 如果内存不足，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将新分配的空间用 0 填充，防止出现垃圾内容</span></span><br><span class=\"line\">    <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">    sh = (<span class=\"keyword\">void</span>*)(s-(<span class=\"keyword\">sizeof</span>(struct sdshdr)));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(s+curlen,<span class=\"number\">0</span>,(len-curlen+<span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新属性</span></span><br><span class=\"line\">    totlen = sh-&gt;len+sh-&gt;<span class=\"built_in\">free</span>;</span><br><span class=\"line\">    sh-&gt;len = len;</span><br><span class=\"line\">    sh-&gt;<span class=\"built_in\">free</span> = totlen-sh-&gt;len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回新的 sds</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 对 sds 中 buf 的长度进行扩展，确保在函数执行之后，</span></span><br><span class=\"line\"><span class=\"comment\"> * buf 至少会有 addlen + 1 长度的空余空间（额外的 1 字节是为 \\0 准备的）</span></span><br><span class=\"line\"><span class=\"comment\"> * @param s </span></span><br><span class=\"line\"><span class=\"comment\"> * @param addlen </span></span><br><span class=\"line\"><span class=\"comment\"> * @return 扩展成功返回扩展后的 sds，扩展失败返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsMakeRoomFor</span><span class=\"params\">(sds s, <span class=\"keyword\">size_t</span> addlen)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span>, *<span class=\"title\">newsh</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取 s 目前的空余空间长度</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> <span class=\"built_in\">free</span> = sdsavail(s);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> len, newlen;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">free</span> &gt;= addlen) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取 s 目前已占用空间的长度</span></span><br><span class=\"line\">    len = sdslen(s);</span><br><span class=\"line\">    sh = (<span class=\"keyword\">void</span>*) (s-(<span class=\"keyword\">sizeof</span>(struct sdshdr)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// s 最少需要的长度</span></span><br><span class=\"line\">    newlen = (len+addlen);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据新长度，为 s 分配新空间所需的大小</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class=\"line\">        <span class=\"comment\">// 如果新长度小于 SDS_MAX_PREALLOC </span></span><br><span class=\"line\">        <span class=\"comment\">// 那么为它分配两倍于所需长度的空间</span></span><br><span class=\"line\">        newlen *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">// 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span></span><br><span class=\"line\">        newlen += SDS_MAX_PREALLOC;</span><br><span class=\"line\">    <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">    newsh = zrealloc(sh, <span class=\"keyword\">sizeof</span>(struct sdshdr)+newlen+<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 内存不足，分配失败，返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newsh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新 sds 的空余长度</span></span><br><span class=\"line\">    newsh-&gt;<span class=\"built_in\">free</span> = newlen - len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回 sds</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> newsh-&gt;buf;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 最大预分配长度</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SDS_MAX_PREALLOC (1024*1024)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdscatlen-根据字符串长度将字符串追加到sds末尾\"><a href=\"#sdscatlen-根据字符串长度将字符串追加到sds末尾\" class=\"headerlink\" title=\"sdscatlen-根据字符串长度将字符串追加到sds末尾\"></a>sdscatlen-根据字符串长度将字符串追加到sds末尾</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  将长度为 len 的字符串 t 追加到 sds 的字符串末尾</span></span><br><span class=\"line\"><span class=\"comment\"> * @param s</span></span><br><span class=\"line\"><span class=\"comment\"> * @param t 字符串t</span></span><br><span class=\"line\"><span class=\"comment\"> * @param len t的长度</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 追加成功返回新 sds ，失败返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscatlen</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *t, <span class=\"keyword\">size_t</span> len)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span>;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 原有字符串长度</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> curlen = sdslen(s);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 扩展 sds 空间</span></span><br><span class=\"line\">    <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">    s = sdsMakeRoomFor(s,len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 内存不足？直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 复制 t 中的内容到字符串后部</span></span><br><span class=\"line\">    <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">    sh = (<span class=\"keyword\">void</span>*) (s-(<span class=\"keyword\">sizeof</span>(struct sdshdr)));</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(s+curlen, t, len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新属性</span></span><br><span class=\"line\">    sh-&gt;len = curlen+len;</span><br><span class=\"line\">    sh-&gt;<span class=\"built_in\">free</span> = sh-&gt;<span class=\"built_in\">free</span>-len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加新结尾符号</span></span><br><span class=\"line\">    s[curlen+len] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回新 sds</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdscat-将字符串追加到sds末尾\"><a href=\"#sdscat-将字符串追加到sds末尾\" class=\"headerlink\" title=\"sdscat-将字符串追加到sds末尾\"></a>sdscat-将字符串追加到sds末尾</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将给定字符串 t 追加到 sds 的末尾</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 追加成功返回新 sds ，失败返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> *  T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscat</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdscatlen(s, t, <span class=\"built_in\">strlen</span>(t));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdscatsds-将sds追加到另一个sds末尾\"><a href=\"#sdscatsds-将sds追加到另一个sds末尾\" class=\"headerlink\" title=\"sdscatsds-将sds追加到另一个sds末尾\"></a>sdscatsds-将sds追加到另一个sds末尾</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将另一个 sds 追加到一个 sds 的末尾</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 追加成功返回新 sds ，失败返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscatsds</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> sds t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdscatlen(s, t, sdslen(t));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdscpylen-将字符串前len复制到sds\"><a href=\"#sdscpylen-将字符串前len复制到sds\" class=\"headerlink\" title=\"sdscpylen-将字符串前len复制到sds\"></a>sdscpylen-将字符串前len复制到sds</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将字符串 t 的前 len 个字符复制到 sds s 当中,覆盖原有的字符</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果 sds 的长度少于 len 个字符，那么扩展 sds</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 复制成功返回新的 sds ，否则返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscpylen</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *t, <span class=\"keyword\">size_t</span> len)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span> = (<span class=\"title\">void</span>*) (<span class=\"title\">s</span>-(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">sdshdr</span>)));</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// sds 现有 buf 的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> totlen = sh-&gt;<span class=\"built_in\">free</span>+sh-&gt;len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果 s 的 buf 长度不满足 len ，那么扩展它</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (totlen &lt; len) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">        s = sdsMakeRoomFor(s,len-sh-&gt;len);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        sh = (<span class=\"keyword\">void</span>*) (s-(<span class=\"keyword\">sizeof</span>(struct sdshdr)));</span><br><span class=\"line\">        totlen = sh-&gt;<span class=\"built_in\">free</span>+sh-&gt;len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 复制内容</span></span><br><span class=\"line\">    <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(s, t, len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加终结符号</span></span><br><span class=\"line\">    s[len] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新属性</span></span><br><span class=\"line\">    sh-&gt;len = len;</span><br><span class=\"line\">    sh-&gt;<span class=\"built_in\">free</span> = totlen-len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回新的 sds</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdscpy-将字符串复制到-sds-当中\"><a href=\"#sdscpy-将字符串复制到-sds-当中\" class=\"headerlink\" title=\"sdscpy-将字符串复制到 sds 当中\"></a>sdscpy-将字符串复制到 sds 当中</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将字符串复制到 sds 当中,覆盖原有的字符</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 复制成功返回新的 sds ，否则返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscpy</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdscpylen(s, t, <span class=\"built_in\">strlen</span>(t));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"SDS定义\"><a href=\"#SDS定义\" class=\"headerlink\" title=\"SDS定义\"></a>SDS定义</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 类型别名，用于指向 sdshdr 的 buf 属性</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span> *sds;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 保存字符串对象的结构</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> &#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// buf 中已占用空间的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// buf 中剩余可用空间的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"built_in\">free</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 数据空间</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"SDS常用函数\"><a href=\"#SDS常用函数\" class=\"headerlink\" title=\"SDS常用函数\"></a>SDS常用函数</h2><h3 id=\"sdslen-sds长度\"><a href=\"#sdslen-sds长度\" class=\"headerlink\" title=\"sdslen-sds长度\"></a>sdslen-sds长度</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回 sds 实际保存的字符串的长度</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> size_t <span class=\"title\">sdslen</span><span class=\"params\">(<span class=\"keyword\">const</span> sds s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span> = (<span class=\"title\">void</span>*)(<span class=\"title\">s</span>-(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">sdshdr</span>)));</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sh-&gt;len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>s 实际上存的是buf首个char数据的地址，也就是向前移动8个字节，就能到sdshdr的len的首地址<br>char buf[]这个数组没有大小，是所谓的柔性数组，是不占据内存大小的，所以sizeof(struct sdshdr)为8。<br>具体结构如下图<br><img src=\"/redis/Redis-sds/sdshdr.png\" alt=\"sdshdr\"></p>\n<h3 id=\"sdsavail-sds可用free空间长度\"><a href=\"#sdsavail-sds可用free空间长度\" class=\"headerlink\" title=\"sdsavail-sds可用free空间长度\"></a>sdsavail-sds可用free空间长度</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回 sds 可用空间的长度</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> size_t <span class=\"title\">sdsavail</span><span class=\"params\">(<span class=\"keyword\">const</span> sds s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span> = (<span class=\"title\">void</span>*)(<span class=\"title\">s</span>-(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">sdshdr</span>)));</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sh-&gt;<span class=\"built_in\">free</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdsnewlen-根据字符串长度创建sds\"><a href=\"#sdsnewlen-根据字符串长度创建sds\" class=\"headerlink\" title=\"sdsnewlen-根据字符串长度创建sds\"></a>sdsnewlen-根据字符串长度创建sds</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 根据给定的初始化字符串 init 和字符串长度 initlen,创建一个新的 sds</span></span><br><span class=\"line\"><span class=\"comment\"> * @param init 初始化字符串指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param initlen 初始化字符串的长度</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 创建成功返回 sdshdr 相对应的 sds,创建失败返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsnewlen</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *init, <span class=\"keyword\">size_t</span> initlen)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据是否有初始化内容，选择适当的内存分配方式</span></span><br><span class=\"line\">    <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (init) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// zmalloc 不初始化所分配的内存</span></span><br><span class=\"line\">        sh = zmalloc(<span class=\"keyword\">sizeof</span>(struct sdshdr)+initlen+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// zcalloc 将分配的内存全部初始化为 0</span></span><br><span class=\"line\">        sh = zcalloc(<span class=\"keyword\">sizeof</span>(struct sdshdr)+initlen+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 内存分配失败，返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置初始化长度</span></span><br><span class=\"line\">    sh-&gt;len = initlen;</span><br><span class=\"line\">    <span class=\"comment\">// 新 sds 不预留任何空间</span></span><br><span class=\"line\">    sh-&gt;<span class=\"built_in\">free</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中</span></span><br><span class=\"line\">    <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initlen &amp;&amp; init)</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(sh-&gt;buf, init, initlen);</span><br><span class=\"line\">    <span class=\"comment\">// 以 \\0 结尾</span></span><br><span class=\"line\">    sh-&gt;buf[initlen] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回 buf 部分，而不是整个 sdshdr</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">char</span>*)sh-&gt;buf;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdsnew-创建sds\"><a href=\"#sdsnew-创建sds\" class=\"headerlink\" title=\"sdsnew-创建sds\"></a>sdsnew-创建sds</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 根据给定字符串 init ，创建一个包含同样字符串的 sds</span></span><br><span class=\"line\"><span class=\"comment\"> * @param init 如果输入为 NULL ，那么创建一个空白 sds</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 创建成功返回 sdshdr 相对应的 sds，创建失败返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsnew</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *init)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> initlen = (init == <span class=\"literal\">NULL</span>) ? <span class=\"number\">0</span> : <span class=\"built_in\">strlen</span>(init);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdsnewlen(init, initlen);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdsempty-创建空sds\"><a href=\"#sdsempty-创建空sds\" class=\"headerlink\" title=\"sdsempty-创建空sds\"></a>sdsempty-创建空sds</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 创建并返回一个只保存了空字符串 \"\" 的 sds</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 创建成功返回 sdshdr 相对应的 sds,创建失败返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(1)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsempty</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdsnewlen(<span class=\"string\">\"\"</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdsdup-复制sds创建副本\"><a href=\"#sdsdup-复制sds创建副本\" class=\"headerlink\" title=\"sdsdup-复制sds创建副本\"></a>sdsdup-复制sds创建副本</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 复制给定 sds 创建副本</span></span><br><span class=\"line\"><span class=\"comment\"> * @param s sds</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 创建成功返回输入 sds 的副本</span></span><br><span class=\"line\"><span class=\"comment\"> *  T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsdup</span><span class=\"params\">(<span class=\"keyword\">const</span> sds s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdsnewlen(s, sdslen(s));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdsfree-释放sds\"><a href=\"#sdsfree-释放sds\" class=\"headerlink\" title=\"sdsfree-释放sds\"></a>sdsfree-释放sds</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 释放给定的 sds</span></span><br><span class=\"line\"><span class=\"comment\"> * @param s </span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sdsfree</span><span class=\"params\">(sds s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    zfree(s-<span class=\"keyword\">sizeof</span>(struct sdshdr));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdsgrowzero-扩充sds未使用空间补0\"><a href=\"#sdsgrowzero-扩充sds未使用空间补0\" class=\"headerlink\" title=\"sdsgrowzero-扩充sds未使用空间补0\"></a>sdsgrowzero-扩充sds未使用空间补0</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将 sds 扩充至指定长度，未使用的空间以 0 字节填充。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param s</span></span><br><span class=\"line\"><span class=\"comment\"> * @param len 指定长度</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 扩充成功返回新 sds ，失败返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsgrowzero</span><span class=\"params\">(sds s, <span class=\"keyword\">size_t</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span> = (<span class=\"title\">void</span>*)(<span class=\"title\">s</span>-(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">sdshdr</span>)));</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> totlen, curlen = sh-&gt;len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果 len 比字符串的现有长度小，</span></span><br><span class=\"line\">    <span class=\"comment\">// 那么直接返回，不做动作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &lt;= curlen) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 扩展 sds</span></span><br><span class=\"line\">    <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">    s = sdsMakeRoomFor(s,len-curlen);</span><br><span class=\"line\">    <span class=\"comment\">// 如果内存不足，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将新分配的空间用 0 填充，防止出现垃圾内容</span></span><br><span class=\"line\">    <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">    sh = (<span class=\"keyword\">void</span>*)(s-(<span class=\"keyword\">sizeof</span>(struct sdshdr)));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(s+curlen,<span class=\"number\">0</span>,(len-curlen+<span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新属性</span></span><br><span class=\"line\">    totlen = sh-&gt;len+sh-&gt;<span class=\"built_in\">free</span>;</span><br><span class=\"line\">    sh-&gt;len = len;</span><br><span class=\"line\">    sh-&gt;<span class=\"built_in\">free</span> = totlen-sh-&gt;len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回新的 sds</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 对 sds 中 buf 的长度进行扩展，确保在函数执行之后，</span></span><br><span class=\"line\"><span class=\"comment\"> * buf 至少会有 addlen + 1 长度的空余空间（额外的 1 字节是为 \\0 准备的）</span></span><br><span class=\"line\"><span class=\"comment\"> * @param s </span></span><br><span class=\"line\"><span class=\"comment\"> * @param addlen </span></span><br><span class=\"line\"><span class=\"comment\"> * @return 扩展成功返回扩展后的 sds，扩展失败返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdsMakeRoomFor</span><span class=\"params\">(sds s, <span class=\"keyword\">size_t</span> addlen)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span>, *<span class=\"title\">newsh</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取 s 目前的空余空间长度</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> <span class=\"built_in\">free</span> = sdsavail(s);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> len, newlen;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">free</span> &gt;= addlen) <span class=\"keyword\">return</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取 s 目前已占用空间的长度</span></span><br><span class=\"line\">    len = sdslen(s);</span><br><span class=\"line\">    sh = (<span class=\"keyword\">void</span>*) (s-(<span class=\"keyword\">sizeof</span>(struct sdshdr)));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// s 最少需要的长度</span></span><br><span class=\"line\">    newlen = (len+addlen);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据新长度，为 s 分配新空间所需的大小</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class=\"line\">        <span class=\"comment\">// 如果新长度小于 SDS_MAX_PREALLOC </span></span><br><span class=\"line\">        <span class=\"comment\">// 那么为它分配两倍于所需长度的空间</span></span><br><span class=\"line\">        newlen *= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">// 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span></span><br><span class=\"line\">        newlen += SDS_MAX_PREALLOC;</span><br><span class=\"line\">    <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">    newsh = zrealloc(sh, <span class=\"keyword\">sizeof</span>(struct sdshdr)+newlen+<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 内存不足，分配失败，返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newsh == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新 sds 的空余长度</span></span><br><span class=\"line\">    newsh-&gt;<span class=\"built_in\">free</span> = newlen - len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回 sds</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> newsh-&gt;buf;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 最大预分配长度</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SDS_MAX_PREALLOC (1024*1024)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdscatlen-根据字符串长度将字符串追加到sds末尾\"><a href=\"#sdscatlen-根据字符串长度将字符串追加到sds末尾\" class=\"headerlink\" title=\"sdscatlen-根据字符串长度将字符串追加到sds末尾\"></a>sdscatlen-根据字符串长度将字符串追加到sds末尾</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  将长度为 len 的字符串 t 追加到 sds 的字符串末尾</span></span><br><span class=\"line\"><span class=\"comment\"> * @param s</span></span><br><span class=\"line\"><span class=\"comment\"> * @param t 字符串t</span></span><br><span class=\"line\"><span class=\"comment\"> * @param len t的长度</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 追加成功返回新 sds ，失败返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscatlen</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *t, <span class=\"keyword\">size_t</span> len)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span>;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 原有字符串长度</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> curlen = sdslen(s);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 扩展 sds 空间</span></span><br><span class=\"line\">    <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">    s = sdsMakeRoomFor(s,len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 内存不足？直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 复制 t 中的内容到字符串后部</span></span><br><span class=\"line\">    <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">    sh = (<span class=\"keyword\">void</span>*) (s-(<span class=\"keyword\">sizeof</span>(struct sdshdr)));</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(s+curlen, t, len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新属性</span></span><br><span class=\"line\">    sh-&gt;len = curlen+len;</span><br><span class=\"line\">    sh-&gt;<span class=\"built_in\">free</span> = sh-&gt;<span class=\"built_in\">free</span>-len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加新结尾符号</span></span><br><span class=\"line\">    s[curlen+len] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回新 sds</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdscat-将字符串追加到sds末尾\"><a href=\"#sdscat-将字符串追加到sds末尾\" class=\"headerlink\" title=\"sdscat-将字符串追加到sds末尾\"></a>sdscat-将字符串追加到sds末尾</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将给定字符串 t 追加到 sds 的末尾</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 追加成功返回新 sds ，失败返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> *  T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscat</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdscatlen(s, t, <span class=\"built_in\">strlen</span>(t));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdscatsds-将sds追加到另一个sds末尾\"><a href=\"#sdscatsds-将sds追加到另一个sds末尾\" class=\"headerlink\" title=\"sdscatsds-将sds追加到另一个sds末尾\"></a>sdscatsds-将sds追加到另一个sds末尾</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将另一个 sds 追加到一个 sds 的末尾</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 追加成功返回新 sds ，失败返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscatsds</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> sds t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdscatlen(s, t, sdslen(t));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdscpylen-将字符串前len复制到sds\"><a href=\"#sdscpylen-将字符串前len复制到sds\" class=\"headerlink\" title=\"sdscpylen-将字符串前len复制到sds\"></a>sdscpylen-将字符串前len复制到sds</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将字符串 t 的前 len 个字符复制到 sds s 当中,覆盖原有的字符</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果 sds 的长度少于 len 个字符，那么扩展 sds</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 复制成功返回新的 sds ，否则返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscpylen</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *t, <span class=\"keyword\">size_t</span> len)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> *<span class=\"title\">sh</span> = (<span class=\"title\">void</span>*) (<span class=\"title\">s</span>-(<span class=\"title\">sizeof</span>(<span class=\"title\">struct</span> <span class=\"title\">sdshdr</span>)));</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// sds 现有 buf 的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> totlen = sh-&gt;<span class=\"built_in\">free</span>+sh-&gt;len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果 s 的 buf 长度不满足 len ，那么扩展它</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (totlen &lt; len) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">        s = sdsMakeRoomFor(s,len-sh-&gt;len);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        sh = (<span class=\"keyword\">void</span>*) (s-(<span class=\"keyword\">sizeof</span>(struct sdshdr)));</span><br><span class=\"line\">        totlen = sh-&gt;<span class=\"built_in\">free</span>+sh-&gt;len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 复制内容</span></span><br><span class=\"line\">    <span class=\"comment\">// T = O(N)</span></span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(s, t, len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加终结符号</span></span><br><span class=\"line\">    s[len] = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新属性</span></span><br><span class=\"line\">    sh-&gt;len = len;</span><br><span class=\"line\">    sh-&gt;<span class=\"built_in\">free</span> = totlen-len;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回新的 sds</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sdscpy-将字符串复制到-sds-当中\"><a href=\"#sdscpy-将字符串复制到-sds-当中\" class=\"headerlink\" title=\"sdscpy-将字符串复制到 sds 当中\"></a>sdscpy-将字符串复制到 sds 当中</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将字符串复制到 sds 当中,覆盖原有的字符</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 复制成功返回新的 sds ，否则返回 NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * T = O(N)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">sds <span class=\"title\">sdscpy</span><span class=\"params\">(sds s, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sdscpylen(s, t, <span class=\"built_in\">strlen</span>(t));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"泰国旅游攻略","date":"2019-07-12T09:49:04.000Z","author":"Guyuqing","copyright":true,"comments":0,"password":12345,"_content":"## 准备工作\n### 一、签证\n* 所需资料\n    1. 护照原件（无皮损，且有180天以上的有效期）\n    2. 往返泰国的机票\n    3. 携带20,000以上泰铢的现金或者等值货币（约3700-4000元人民币，汇率会有所波动，建议携带足够现金）过关时抽查，如没有携带足够的现金，有可能会被拒签或遣返。\n    4. 1张2寸白底彩色照片（如没有带照片。可现场拍照，额外拍照费用100泰铢）\n<!-- more -->\n* 费用\n    1. 1000泰铢手续费（目前落地签免费）\n    2. 如没带照片，需现场拍照，加收100泰铢拍照费\n    3. 只收泰铢现多，旁有兑换点，但汇率比较低，建议办理落地签，提前在国内换好所需泰铢费用。(中国银行可预约兑换泰铢，汇率约为1：5，实时汇率请咨询银行）\n\n* 落地签办理流程\n    1. 在机场按照指示牌找到“`Visa on Arrival`” （落地签）柜台\n    2. 填写落地签申请表（柜台上就发放有表格，以及填写示例，最好`提前打印`下来填好）\n    3. 递交资料（包括申请表、照片、护照、往返机票等），工作人员审核后给排队号\n    4. 等叫号，上交资料和手续费，工作人员在你的护照上盖上落地签的章，病提供泰文收据等\n    5. 走到“`For Visa-on-Arrival Only`”的柜台，入境官会再检查你的护照等资料，然后把出入境卡的入境部分撕掉，将出境卡盖章之后订在护照上，你就可以跨过边检柜台，正式进入泰国境内了\n    6. 落地签的有效期是15天，即你可以在泰国逗留不超过15天的时间\n\n## 9.10北京出发\n\n\n北京南站->天津站： `C2077 20：50-21：20 二等座 54.5￥`\n![](Thailand-Raiders/1.png)\n\n### 天津\n\n天津站->天津滨海国际机场T1航站楼  地铁二号线 `45min` 约`3￥`\n![](Thailand-Raiders/tianjin-airport.png)\n\n约10点到达机场\n\n天津滨海国际机场T1航站楼 ->廊曼国际机场T1航站楼\n`SL963  23:50-03:35 +1 经济舱 `\n\n### 9.11泰国曼谷\n\n曼谷酒店位置：`455/4 Maha Chai Road`, Bangkok, Krung Thep Maha Nakhon 10200, Thailand\n![](Thailand-Raiders/2.png)\n![](Thailand-Raiders/455.jpeg)\n![](Thailand-Raiders/455-2.jpeg)\n![](Thailand-Raiders/455-3.jpeg)\n\n廊曼国际机场T1航站楼 ->曼谷酒店 `455/4 Maha Chai Road`\n淘宝下单接送机，或者携程下单（建议携程，航班延误可以2小时免费等）。\n到酒店睡觉啦啦啦啦\n\n#### 9.11 10:00\n浏览景点安排\n\n大皇宫   `3h  500泰铢 111.5￥` 长袖，长裙不能露膝盖\n卧佛寺  `0.5h  200泰铢 44￥`\n坐船 3泰铢\n郑王庙  `0.5h  30泰铢  7￥`\n考山路夜市吃吃吃 `2h` \n\n### 9.12 泰国曼谷\n退房**（留小费）**\n\n酒店->汽车站\nbegin\n![](Thailand-Raiders/3.png)\n1、步行到船站 船票单次`50🐷`\n![](Thailand-Raiders/4.png)\n2、坐船\n![](Thailand-Raiders/5.png)\n3、下船后步行到BST车站\n![](Thailand-Raiders/6.png)\n4、坐上BST，约8站到达Ekkamai ，2号出站口出站下楼梯再向后方走100m就到了\nend\n\n汽车站买票：窗口正上方写着`Pattaya`就可以买票了约`108🐷`一位上下浮动 厕所`3🐷`一次\n曼谷到芭提雅媒体7：00-20：00，每半小时一班车 `车程2h`\n\n### 9.12 芭提雅\n酒店位置：88/999,Moo.10 Building B Room No.999, Pattayasaisong Rd, Muang Pattaya, Amphoe Bang Lamung, Chang Wat Chon Buri 20150\n#### 双条车\n路线图\n![](Thailand-Raiders/10.jpeg)\n![](Thailand-Raiders/11.png)\n上车不要说话，说话会被误认为包车，10🐷/人\n\n#### 游玩路线\n\n芭提雅车站在North Pattaya Road路 Bus Terminal\n距酒店2.6公里，可以考虑步行\n![](Thailand-Raiders/7.png)\n\n东芭乐园 9：00-18：00 `800泰铢   178￥` 双条车\n![](Thailand-Raiders/8.png)\n\n四方水上市场 9：00-20：00\n![](Thailand-Raiders/9.png)\n\n蒂芬妮人妖秀  每天18：00、19：30、21：00共三场  `普通800🐷，vip1000🐷、金vip1200🐷   178￥` 双条车每人10🐷 或步行\n![](Thailand-Raiders/Tiffany.png)\n\n芭提雅海滩走一波 吃小吃\n\n### 9.13芭提雅\n格兰岛一日游：网上跟团即可\n海上滑翔、海底漫步、摩托艇、香蕉船、浮潜。\n\n### 9.14芭提雅\n购物中心逛一逛\n\n到Bus Terminal汽车站买票回曼谷：窗口正上方写着`Ekkamai`，最晚班次晚上11点\n\n### 9.14曼谷\n曼谷酒店位置：Ratchaprarop Road Ratchaprarop Road indraCondo/177/209 soi saengkran/ratchprarop road, Khet Ratchathewi, Krung Thep Maha Nakhon 10400, Thailand, Khet Ratchathewi, Krung Thep Maha Nakhon 10400, Thailand\n\n![](Thailand-Raiders/WechatIMG38.jpeg)\n![](Thailand-Raiders/WechatIMG39.png)\n![](Thailand-Raiders/WechatIMG40.png)\n\n#### 9.15天津\n预约接机（提前两天预定）\n\n## 泰国必买\nBIG-C零食\n![](Thailand-Raiders/Screenshot_2019-08-31-11-46-03-072_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-11-46-08-364_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-11-46-00-652_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-11-45-53-237_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-11-45-57-687_com.xingin.xhs.png)\n711\n![](Thailand-Raiders/Screenshot_2019-08-31-12-05-14-972_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-12-05-18-389_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-12-05-20-912_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-12-05-23-188_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-12-05-25-297_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-12-05-30-499_com.xingin.xhs.png)\n\n### 必买药品\n![](Thailand-Raiders/Screenshot_2019-08-31-13-11-50-782_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-13-11-56-133_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-13-12-27-105_com.xingin.xhs.png)\n\n### 必买化妆品\n欧莱雅唇膏、小黑瓶\nONLY 小白瓶\nN7冰激凌面膜\n\n### 必逛\n华歌尔内衣Wacoal（曼谷尚泰商圈和暹罗挨着central world 三/四楼）\nLee\nLeVI'S（暹罗广场，国内五折）\neveryandboy泰国本土美妆店\n日本松本清（central world 三楼）\n![](Thailand-Raiders/Screenshot_2019-08-31-14-05-58-003_com.xingin.xhs.png)\n\n## 泰国机场退税取货\n\n![](Thailand-Raiders/Screenshot_2019-08-31-14-25-04-833_com.xingin.xhs.png)\n\n\n\n","source":"_posts/Thailand-Raiders.md","raw":"---\ntitle: 泰国旅游攻略\ndate: 2019-07-12 17:49:04\ntags:\n    - 旅游攻略\ncategories: 旅游\nauthor: Guyuqing\ncopyright: true\ncomments: false\npassword: 12345\n---\n## 准备工作\n### 一、签证\n* 所需资料\n    1. 护照原件（无皮损，且有180天以上的有效期）\n    2. 往返泰国的机票\n    3. 携带20,000以上泰铢的现金或者等值货币（约3700-4000元人民币，汇率会有所波动，建议携带足够现金）过关时抽查，如没有携带足够的现金，有可能会被拒签或遣返。\n    4. 1张2寸白底彩色照片（如没有带照片。可现场拍照，额外拍照费用100泰铢）\n<!-- more -->\n* 费用\n    1. 1000泰铢手续费（目前落地签免费）\n    2. 如没带照片，需现场拍照，加收100泰铢拍照费\n    3. 只收泰铢现多，旁有兑换点，但汇率比较低，建议办理落地签，提前在国内换好所需泰铢费用。(中国银行可预约兑换泰铢，汇率约为1：5，实时汇率请咨询银行）\n\n* 落地签办理流程\n    1. 在机场按照指示牌找到“`Visa on Arrival`” （落地签）柜台\n    2. 填写落地签申请表（柜台上就发放有表格，以及填写示例，最好`提前打印`下来填好）\n    3. 递交资料（包括申请表、照片、护照、往返机票等），工作人员审核后给排队号\n    4. 等叫号，上交资料和手续费，工作人员在你的护照上盖上落地签的章，病提供泰文收据等\n    5. 走到“`For Visa-on-Arrival Only`”的柜台，入境官会再检查你的护照等资料，然后把出入境卡的入境部分撕掉，将出境卡盖章之后订在护照上，你就可以跨过边检柜台，正式进入泰国境内了\n    6. 落地签的有效期是15天，即你可以在泰国逗留不超过15天的时间\n\n## 9.10北京出发\n\n\n北京南站->天津站： `C2077 20：50-21：20 二等座 54.5￥`\n![](Thailand-Raiders/1.png)\n\n### 天津\n\n天津站->天津滨海国际机场T1航站楼  地铁二号线 `45min` 约`3￥`\n![](Thailand-Raiders/tianjin-airport.png)\n\n约10点到达机场\n\n天津滨海国际机场T1航站楼 ->廊曼国际机场T1航站楼\n`SL963  23:50-03:35 +1 经济舱 `\n\n### 9.11泰国曼谷\n\n曼谷酒店位置：`455/4 Maha Chai Road`, Bangkok, Krung Thep Maha Nakhon 10200, Thailand\n![](Thailand-Raiders/2.png)\n![](Thailand-Raiders/455.jpeg)\n![](Thailand-Raiders/455-2.jpeg)\n![](Thailand-Raiders/455-3.jpeg)\n\n廊曼国际机场T1航站楼 ->曼谷酒店 `455/4 Maha Chai Road`\n淘宝下单接送机，或者携程下单（建议携程，航班延误可以2小时免费等）。\n到酒店睡觉啦啦啦啦\n\n#### 9.11 10:00\n浏览景点安排\n\n大皇宫   `3h  500泰铢 111.5￥` 长袖，长裙不能露膝盖\n卧佛寺  `0.5h  200泰铢 44￥`\n坐船 3泰铢\n郑王庙  `0.5h  30泰铢  7￥`\n考山路夜市吃吃吃 `2h` \n\n### 9.12 泰国曼谷\n退房**（留小费）**\n\n酒店->汽车站\nbegin\n![](Thailand-Raiders/3.png)\n1、步行到船站 船票单次`50🐷`\n![](Thailand-Raiders/4.png)\n2、坐船\n![](Thailand-Raiders/5.png)\n3、下船后步行到BST车站\n![](Thailand-Raiders/6.png)\n4、坐上BST，约8站到达Ekkamai ，2号出站口出站下楼梯再向后方走100m就到了\nend\n\n汽车站买票：窗口正上方写着`Pattaya`就可以买票了约`108🐷`一位上下浮动 厕所`3🐷`一次\n曼谷到芭提雅媒体7：00-20：00，每半小时一班车 `车程2h`\n\n### 9.12 芭提雅\n酒店位置：88/999,Moo.10 Building B Room No.999, Pattayasaisong Rd, Muang Pattaya, Amphoe Bang Lamung, Chang Wat Chon Buri 20150\n#### 双条车\n路线图\n![](Thailand-Raiders/10.jpeg)\n![](Thailand-Raiders/11.png)\n上车不要说话，说话会被误认为包车，10🐷/人\n\n#### 游玩路线\n\n芭提雅车站在North Pattaya Road路 Bus Terminal\n距酒店2.6公里，可以考虑步行\n![](Thailand-Raiders/7.png)\n\n东芭乐园 9：00-18：00 `800泰铢   178￥` 双条车\n![](Thailand-Raiders/8.png)\n\n四方水上市场 9：00-20：00\n![](Thailand-Raiders/9.png)\n\n蒂芬妮人妖秀  每天18：00、19：30、21：00共三场  `普通800🐷，vip1000🐷、金vip1200🐷   178￥` 双条车每人10🐷 或步行\n![](Thailand-Raiders/Tiffany.png)\n\n芭提雅海滩走一波 吃小吃\n\n### 9.13芭提雅\n格兰岛一日游：网上跟团即可\n海上滑翔、海底漫步、摩托艇、香蕉船、浮潜。\n\n### 9.14芭提雅\n购物中心逛一逛\n\n到Bus Terminal汽车站买票回曼谷：窗口正上方写着`Ekkamai`，最晚班次晚上11点\n\n### 9.14曼谷\n曼谷酒店位置：Ratchaprarop Road Ratchaprarop Road indraCondo/177/209 soi saengkran/ratchprarop road, Khet Ratchathewi, Krung Thep Maha Nakhon 10400, Thailand, Khet Ratchathewi, Krung Thep Maha Nakhon 10400, Thailand\n\n![](Thailand-Raiders/WechatIMG38.jpeg)\n![](Thailand-Raiders/WechatIMG39.png)\n![](Thailand-Raiders/WechatIMG40.png)\n\n#### 9.15天津\n预约接机（提前两天预定）\n\n## 泰国必买\nBIG-C零食\n![](Thailand-Raiders/Screenshot_2019-08-31-11-46-03-072_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-11-46-08-364_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-11-46-00-652_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-11-45-53-237_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-11-45-57-687_com.xingin.xhs.png)\n711\n![](Thailand-Raiders/Screenshot_2019-08-31-12-05-14-972_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-12-05-18-389_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-12-05-20-912_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-12-05-23-188_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-12-05-25-297_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-12-05-30-499_com.xingin.xhs.png)\n\n### 必买药品\n![](Thailand-Raiders/Screenshot_2019-08-31-13-11-50-782_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-13-11-56-133_com.xingin.xhs.png)\n![](Thailand-Raiders/Screenshot_2019-08-31-13-12-27-105_com.xingin.xhs.png)\n\n### 必买化妆品\n欧莱雅唇膏、小黑瓶\nONLY 小白瓶\nN7冰激凌面膜\n\n### 必逛\n华歌尔内衣Wacoal（曼谷尚泰商圈和暹罗挨着central world 三/四楼）\nLee\nLeVI'S（暹罗广场，国内五折）\neveryandboy泰国本土美妆店\n日本松本清（central world 三楼）\n![](Thailand-Raiders/Screenshot_2019-08-31-14-05-58-003_com.xingin.xhs.png)\n\n## 泰国机场退税取货\n\n![](Thailand-Raiders/Screenshot_2019-08-31-14-25-04-833_com.xingin.xhs.png)\n\n\n\n","slug":"Thailand-Raiders","published":1,"updated":"2019-08-31T12:37:03.601Z","layout":"post","photos":[],"link":"","_id":"ck8fb4ajy006wk2o5bkmx50wk","content":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"一、签证\"><a href=\"#一、签证\" class=\"headerlink\" title=\"一、签证\"></a>一、签证</h3><ul>\n<li><p>所需资料</p>\n<ol>\n<li>护照原件（无皮损，且有180天以上的有效期）</li>\n<li>往返泰国的机票</li>\n<li>携带20,000以上泰铢的现金或者等值货币（约3700-4000元人民币，汇率会有所波动，建议携带足够现金）过关时抽查，如没有携带足够的现金，有可能会被拒签或遣返。</li>\n<li>1张2寸白底彩色照片（如没有带照片。可现场拍照，额外拍照费用100泰铢）<a id=\"more\"></a></li>\n</ol>\n</li>\n<li><p>费用</p>\n<ol>\n<li>1000泰铢手续费（目前落地签免费）</li>\n<li>如没带照片，需现场拍照，加收100泰铢拍照费</li>\n<li>只收泰铢现多，旁有兑换点，但汇率比较低，建议办理落地签，提前在国内换好所需泰铢费用。(中国银行可预约兑换泰铢，汇率约为1：5，实时汇率请咨询银行）</li>\n</ol>\n</li>\n<li><p>落地签办理流程</p>\n<ol>\n<li>在机场按照指示牌找到“<code>Visa on Arrival</code>” （落地签）柜台</li>\n<li>填写落地签申请表（柜台上就发放有表格，以及填写示例，最好<code>提前打印</code>下来填好）</li>\n<li>递交资料（包括申请表、照片、护照、往返机票等），工作人员审核后给排队号</li>\n<li>等叫号，上交资料和手续费，工作人员在你的护照上盖上落地签的章，病提供泰文收据等</li>\n<li>走到“<code>For Visa-on-Arrival Only</code>”的柜台，入境官会再检查你的护照等资料，然后把出入境卡的入境部分撕掉，将出境卡盖章之后订在护照上，你就可以跨过边检柜台，正式进入泰国境内了</li>\n<li>落地签的有效期是15天，即你可以在泰国逗留不超过15天的时间</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"9-10北京出发\"><a href=\"#9-10北京出发\" class=\"headerlink\" title=\"9.10北京出发\"></a>9.10北京出发</h2><p>北京南站-&gt;天津站： <code>C2077 20：50-21：20 二等座 54.5￥</code><br><img src=\"/旅游/Thailand-Raiders/1.png\" alt=\"\"></p>\n<h3 id=\"天津\"><a href=\"#天津\" class=\"headerlink\" title=\"天津\"></a>天津</h3><p>天津站-&gt;天津滨海国际机场T1航站楼  地铁二号线 <code>45min</code> 约<code>3￥</code><br><img src=\"/旅游/Thailand-Raiders/tianjin-airport.png\" alt=\"\"></p>\n<p>约10点到达机场</p>\n<p>天津滨海国际机场T1航站楼 -&gt;廊曼国际机场T1航站楼<br><code>SL963  23:50-03:35 +1 经济舱</code></p>\n<h3 id=\"9-11泰国曼谷\"><a href=\"#9-11泰国曼谷\" class=\"headerlink\" title=\"9.11泰国曼谷\"></a>9.11泰国曼谷</h3><p>曼谷酒店位置：<code>455/4 Maha Chai Road</code>, Bangkok, Krung Thep Maha Nakhon 10200, Thailand<br><img src=\"/旅游/Thailand-Raiders/2.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/455.jpeg\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/455-2.jpeg\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/455-3.jpeg\" alt=\"\"></p>\n<p>廊曼国际机场T1航站楼 -&gt;曼谷酒店 <code>455/4 Maha Chai Road</code><br>淘宝下单接送机，或者携程下单（建议携程，航班延误可以2小时免费等）。<br>到酒店睡觉啦啦啦啦</p>\n<h4 id=\"9-11-10-00\"><a href=\"#9-11-10-00\" class=\"headerlink\" title=\"9.11 10:00\"></a>9.11 10:00</h4><p>浏览景点安排</p>\n<p>大皇宫   <code>3h  500泰铢 111.5￥</code> 长袖，长裙不能露膝盖<br>卧佛寺  <code>0.5h  200泰铢 44￥</code><br>坐船 3泰铢<br>郑王庙  <code>0.5h  30泰铢  7￥</code><br>考山路夜市吃吃吃 <code>2h</code> </p>\n<h3 id=\"9-12-泰国曼谷\"><a href=\"#9-12-泰国曼谷\" class=\"headerlink\" title=\"9.12 泰国曼谷\"></a>9.12 泰国曼谷</h3><p>退房<strong>（留小费）</strong></p>\n<p>酒店-&gt;汽车站<br>begin<br><img src=\"/旅游/Thailand-Raiders/3.png\" alt=\"\"><br>1、步行到船站 船票单次<code>50🐷</code><br><img src=\"/旅游/Thailand-Raiders/4.png\" alt=\"\"><br>2、坐船<br><img src=\"/旅游/Thailand-Raiders/5.png\" alt=\"\"><br>3、下船后步行到BST车站<br><img src=\"/旅游/Thailand-Raiders/6.png\" alt=\"\"><br>4、坐上BST，约8站到达Ekkamai ，2号出站口出站下楼梯再向后方走100m就到了<br>end</p>\n<p>汽车站买票：窗口正上方写着<code>Pattaya</code>就可以买票了约<code>108🐷</code>一位上下浮动 厕所<code>3🐷</code>一次<br>曼谷到芭提雅媒体7：00-20：00，每半小时一班车 <code>车程2h</code></p>\n<h3 id=\"9-12-芭提雅\"><a href=\"#9-12-芭提雅\" class=\"headerlink\" title=\"9.12 芭提雅\"></a>9.12 芭提雅</h3><p>酒店位置：88/999,Moo.10 Building B Room No.999, Pattayasaisong Rd, Muang Pattaya, Amphoe Bang Lamung, Chang Wat Chon Buri 20150</p>\n<h4 id=\"双条车\"><a href=\"#双条车\" class=\"headerlink\" title=\"双条车\"></a>双条车</h4><p>路线图<br><img src=\"/旅游/Thailand-Raiders/10.jpeg\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/11.png\" alt=\"\"><br>上车不要说话，说话会被误认为包车，10🐷/人</p>\n<h4 id=\"游玩路线\"><a href=\"#游玩路线\" class=\"headerlink\" title=\"游玩路线\"></a>游玩路线</h4><p>芭提雅车站在North Pattaya Road路 Bus Terminal<br>距酒店2.6公里，可以考虑步行<br><img src=\"/旅游/Thailand-Raiders/7.png\" alt=\"\"></p>\n<p>东芭乐园 9：00-18：00 <code>800泰铢   178￥</code> 双条车<br><img src=\"/旅游/Thailand-Raiders/8.png\" alt=\"\"></p>\n<p>四方水上市场 9：00-20：00<br><img src=\"/旅游/Thailand-Raiders/9.png\" alt=\"\"></p>\n<p>蒂芬妮人妖秀  每天18：00、19：30、21：00共三场  <code>普通800🐷，vip1000🐷、金vip1200🐷   178￥</code> 双条车每人10🐷 或步行<br><img src=\"/旅游/Thailand-Raiders/Tiffany.png\" alt=\"\"></p>\n<p>芭提雅海滩走一波 吃小吃</p>\n<h3 id=\"9-13芭提雅\"><a href=\"#9-13芭提雅\" class=\"headerlink\" title=\"9.13芭提雅\"></a>9.13芭提雅</h3><p>格兰岛一日游：网上跟团即可<br>海上滑翔、海底漫步、摩托艇、香蕉船、浮潜。</p>\n<h3 id=\"9-14芭提雅\"><a href=\"#9-14芭提雅\" class=\"headerlink\" title=\"9.14芭提雅\"></a>9.14芭提雅</h3><p>购物中心逛一逛</p>\n<p>到Bus Terminal汽车站买票回曼谷：窗口正上方写着<code>Ekkamai</code>，最晚班次晚上11点</p>\n<h3 id=\"9-14曼谷\"><a href=\"#9-14曼谷\" class=\"headerlink\" title=\"9.14曼谷\"></a>9.14曼谷</h3><p>曼谷酒店位置：Ratchaprarop Road Ratchaprarop Road indraCondo/177/209 soi saengkran/ratchprarop road, Khet Ratchathewi, Krung Thep Maha Nakhon 10400, Thailand, Khet Ratchathewi, Krung Thep Maha Nakhon 10400, Thailand</p>\n<p><img src=\"/旅游/Thailand-Raiders/WechatIMG38.jpeg\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/WechatIMG39.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/WechatIMG40.png\" alt=\"\"></p>\n<h4 id=\"9-15天津\"><a href=\"#9-15天津\" class=\"headerlink\" title=\"9.15天津\"></a>9.15天津</h4><p>预约接机（提前两天预定）</p>\n<h2 id=\"泰国必买\"><a href=\"#泰国必买\" class=\"headerlink\" title=\"泰国必买\"></a>泰国必买</h2><p>BIG-C零食<br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-11-46-03-072_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-11-46-08-364_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-11-46-00-652_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-11-45-53-237_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-11-45-57-687_com.xingin.xhs.png\" alt=\"\"><br>711<br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-12-05-14-972_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-12-05-18-389_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-12-05-20-912_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-12-05-23-188_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-12-05-25-297_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-12-05-30-499_com.xingin.xhs.png\" alt=\"\"></p>\n<h3 id=\"必买药品\"><a href=\"#必买药品\" class=\"headerlink\" title=\"必买药品\"></a>必买药品</h3><p><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-13-11-50-782_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-13-11-56-133_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-13-12-27-105_com.xingin.xhs.png\" alt=\"\"></p>\n<h3 id=\"必买化妆品\"><a href=\"#必买化妆品\" class=\"headerlink\" title=\"必买化妆品\"></a>必买化妆品</h3><p>欧莱雅唇膏、小黑瓶<br>ONLY 小白瓶<br>N7冰激凌面膜</p>\n<h3 id=\"必逛\"><a href=\"#必逛\" class=\"headerlink\" title=\"必逛\"></a>必逛</h3><p>华歌尔内衣Wacoal（曼谷尚泰商圈和暹罗挨着central world 三/四楼）<br>Lee<br>LeVI’S（暹罗广场，国内五折）<br>everyandboy泰国本土美妆店<br>日本松本清（central world 三楼）<br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-14-05-58-003_com.xingin.xhs.png\" alt=\"\"></p>\n<h2 id=\"泰国机场退税取货\"><a href=\"#泰国机场退税取货\" class=\"headerlink\" title=\"泰国机场退税取货\"></a>泰国机场退税取货</h2><p><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-14-25-04-833_com.xingin.xhs.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"一、签证\"><a href=\"#一、签证\" class=\"headerlink\" title=\"一、签证\"></a>一、签证</h3><ul>\n<li><p>所需资料</p>\n<ol>\n<li>护照原件（无皮损，且有180天以上的有效期）</li>\n<li>往返泰国的机票</li>\n<li>携带20,000以上泰铢的现金或者等值货币（约3700-4000元人民币，汇率会有所波动，建议携带足够现金）过关时抽查，如没有携带足够的现金，有可能会被拒签或遣返。</li>\n<li>1张2寸白底彩色照片（如没有带照片。可现场拍照，额外拍照费用100泰铢）</li></ol></li></ul>","more":"\n\n\n<li><p>费用</p>\n<ol>\n<li>1000泰铢手续费（目前落地签免费）</li>\n<li>如没带照片，需现场拍照，加收100泰铢拍照费</li>\n<li>只收泰铢现多，旁有兑换点，但汇率比较低，建议办理落地签，提前在国内换好所需泰铢费用。(中国银行可预约兑换泰铢，汇率约为1：5，实时汇率请咨询银行）</li>\n</ol>\n</li>\n<li><p>落地签办理流程</p>\n<ol>\n<li>在机场按照指示牌找到“<code>Visa on Arrival</code>” （落地签）柜台</li>\n<li>填写落地签申请表（柜台上就发放有表格，以及填写示例，最好<code>提前打印</code>下来填好）</li>\n<li>递交资料（包括申请表、照片、护照、往返机票等），工作人员审核后给排队号</li>\n<li>等叫号，上交资料和手续费，工作人员在你的护照上盖上落地签的章，病提供泰文收据等</li>\n<li>走到“<code>For Visa-on-Arrival Only</code>”的柜台，入境官会再检查你的护照等资料，然后把出入境卡的入境部分撕掉，将出境卡盖章之后订在护照上，你就可以跨过边检柜台，正式进入泰国境内了</li>\n<li>落地签的有效期是15天，即你可以在泰国逗留不超过15天的时间</li>\n</ol>\n</li>\n\n<h2 id=\"9-10北京出发\"><a href=\"#9-10北京出发\" class=\"headerlink\" title=\"9.10北京出发\"></a>9.10北京出发</h2><p>北京南站-&gt;天津站： <code>C2077 20：50-21：20 二等座 54.5￥</code><br><img src=\"/旅游/Thailand-Raiders/1.png\" alt=\"\"></p>\n<h3 id=\"天津\"><a href=\"#天津\" class=\"headerlink\" title=\"天津\"></a>天津</h3><p>天津站-&gt;天津滨海国际机场T1航站楼  地铁二号线 <code>45min</code> 约<code>3￥</code><br><img src=\"/旅游/Thailand-Raiders/tianjin-airport.png\" alt=\"\"></p>\n<p>约10点到达机场</p>\n<p>天津滨海国际机场T1航站楼 -&gt;廊曼国际机场T1航站楼<br><code>SL963  23:50-03:35 +1 经济舱</code></p>\n<h3 id=\"9-11泰国曼谷\"><a href=\"#9-11泰国曼谷\" class=\"headerlink\" title=\"9.11泰国曼谷\"></a>9.11泰国曼谷</h3><p>曼谷酒店位置：<code>455/4 Maha Chai Road</code>, Bangkok, Krung Thep Maha Nakhon 10200, Thailand<br><img src=\"/旅游/Thailand-Raiders/2.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/455.jpeg\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/455-2.jpeg\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/455-3.jpeg\" alt=\"\"></p>\n<p>廊曼国际机场T1航站楼 -&gt;曼谷酒店 <code>455/4 Maha Chai Road</code><br>淘宝下单接送机，或者携程下单（建议携程，航班延误可以2小时免费等）。<br>到酒店睡觉啦啦啦啦</p>\n<h4 id=\"9-11-10-00\"><a href=\"#9-11-10-00\" class=\"headerlink\" title=\"9.11 10:00\"></a>9.11 10:00</h4><p>浏览景点安排</p>\n<p>大皇宫   <code>3h  500泰铢 111.5￥</code> 长袖，长裙不能露膝盖<br>卧佛寺  <code>0.5h  200泰铢 44￥</code><br>坐船 3泰铢<br>郑王庙  <code>0.5h  30泰铢  7￥</code><br>考山路夜市吃吃吃 <code>2h</code> </p>\n<h3 id=\"9-12-泰国曼谷\"><a href=\"#9-12-泰国曼谷\" class=\"headerlink\" title=\"9.12 泰国曼谷\"></a>9.12 泰国曼谷</h3><p>退房<strong>（留小费）</strong></p>\n<p>酒店-&gt;汽车站<br>begin<br><img src=\"/旅游/Thailand-Raiders/3.png\" alt=\"\"><br>1、步行到船站 船票单次<code>50🐷</code><br><img src=\"/旅游/Thailand-Raiders/4.png\" alt=\"\"><br>2、坐船<br><img src=\"/旅游/Thailand-Raiders/5.png\" alt=\"\"><br>3、下船后步行到BST车站<br><img src=\"/旅游/Thailand-Raiders/6.png\" alt=\"\"><br>4、坐上BST，约8站到达Ekkamai ，2号出站口出站下楼梯再向后方走100m就到了<br>end</p>\n<p>汽车站买票：窗口正上方写着<code>Pattaya</code>就可以买票了约<code>108🐷</code>一位上下浮动 厕所<code>3🐷</code>一次<br>曼谷到芭提雅媒体7：00-20：00，每半小时一班车 <code>车程2h</code></p>\n<h3 id=\"9-12-芭提雅\"><a href=\"#9-12-芭提雅\" class=\"headerlink\" title=\"9.12 芭提雅\"></a>9.12 芭提雅</h3><p>酒店位置：88/999,Moo.10 Building B Room No.999, Pattayasaisong Rd, Muang Pattaya, Amphoe Bang Lamung, Chang Wat Chon Buri 20150</p>\n<h4 id=\"双条车\"><a href=\"#双条车\" class=\"headerlink\" title=\"双条车\"></a>双条车</h4><p>路线图<br><img src=\"/旅游/Thailand-Raiders/10.jpeg\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/11.png\" alt=\"\"><br>上车不要说话，说话会被误认为包车，10🐷/人</p>\n<h4 id=\"游玩路线\"><a href=\"#游玩路线\" class=\"headerlink\" title=\"游玩路线\"></a>游玩路线</h4><p>芭提雅车站在North Pattaya Road路 Bus Terminal<br>距酒店2.6公里，可以考虑步行<br><img src=\"/旅游/Thailand-Raiders/7.png\" alt=\"\"></p>\n<p>东芭乐园 9：00-18：00 <code>800泰铢   178￥</code> 双条车<br><img src=\"/旅游/Thailand-Raiders/8.png\" alt=\"\"></p>\n<p>四方水上市场 9：00-20：00<br><img src=\"/旅游/Thailand-Raiders/9.png\" alt=\"\"></p>\n<p>蒂芬妮人妖秀  每天18：00、19：30、21：00共三场  <code>普通800🐷，vip1000🐷、金vip1200🐷   178￥</code> 双条车每人10🐷 或步行<br><img src=\"/旅游/Thailand-Raiders/Tiffany.png\" alt=\"\"></p>\n<p>芭提雅海滩走一波 吃小吃</p>\n<h3 id=\"9-13芭提雅\"><a href=\"#9-13芭提雅\" class=\"headerlink\" title=\"9.13芭提雅\"></a>9.13芭提雅</h3><p>格兰岛一日游：网上跟团即可<br>海上滑翔、海底漫步、摩托艇、香蕉船、浮潜。</p>\n<h3 id=\"9-14芭提雅\"><a href=\"#9-14芭提雅\" class=\"headerlink\" title=\"9.14芭提雅\"></a>9.14芭提雅</h3><p>购物中心逛一逛</p>\n<p>到Bus Terminal汽车站买票回曼谷：窗口正上方写着<code>Ekkamai</code>，最晚班次晚上11点</p>\n<h3 id=\"9-14曼谷\"><a href=\"#9-14曼谷\" class=\"headerlink\" title=\"9.14曼谷\"></a>9.14曼谷</h3><p>曼谷酒店位置：Ratchaprarop Road Ratchaprarop Road indraCondo/177/209 soi saengkran/ratchprarop road, Khet Ratchathewi, Krung Thep Maha Nakhon 10400, Thailand, Khet Ratchathewi, Krung Thep Maha Nakhon 10400, Thailand</p>\n<p><img src=\"/旅游/Thailand-Raiders/WechatIMG38.jpeg\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/WechatIMG39.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/WechatIMG40.png\" alt=\"\"></p>\n<h4 id=\"9-15天津\"><a href=\"#9-15天津\" class=\"headerlink\" title=\"9.15天津\"></a>9.15天津</h4><p>预约接机（提前两天预定）</p>\n<h2 id=\"泰国必买\"><a href=\"#泰国必买\" class=\"headerlink\" title=\"泰国必买\"></a>泰国必买</h2><p>BIG-C零食<br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-11-46-03-072_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-11-46-08-364_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-11-46-00-652_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-11-45-53-237_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-11-45-57-687_com.xingin.xhs.png\" alt=\"\"><br>711<br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-12-05-14-972_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-12-05-18-389_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-12-05-20-912_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-12-05-23-188_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-12-05-25-297_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-12-05-30-499_com.xingin.xhs.png\" alt=\"\"></p>\n<h3 id=\"必买药品\"><a href=\"#必买药品\" class=\"headerlink\" title=\"必买药品\"></a>必买药品</h3><p><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-13-11-50-782_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-13-11-56-133_com.xingin.xhs.png\" alt=\"\"><br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-13-12-27-105_com.xingin.xhs.png\" alt=\"\"></p>\n<h3 id=\"必买化妆品\"><a href=\"#必买化妆品\" class=\"headerlink\" title=\"必买化妆品\"></a>必买化妆品</h3><p>欧莱雅唇膏、小黑瓶<br>ONLY 小白瓶<br>N7冰激凌面膜</p>\n<h3 id=\"必逛\"><a href=\"#必逛\" class=\"headerlink\" title=\"必逛\"></a>必逛</h3><p>华歌尔内衣Wacoal（曼谷尚泰商圈和暹罗挨着central world 三/四楼）<br>Lee<br>LeVI’S（暹罗广场，国内五折）<br>everyandboy泰国本土美妆店<br>日本松本清（central world 三楼）<br><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-14-05-58-003_com.xingin.xhs.png\" alt=\"\"></p>\n<h2 id=\"泰国机场退税取货\"><a href=\"#泰国机场退税取货\" class=\"headerlink\" title=\"泰国机场退税取货\"></a>泰国机场退税取货</h2><p><img src=\"/旅游/Thailand-Raiders/Screenshot_2019-08-31-14-25-04-833_com.xingin.xhs.png\" alt=\"\"></p>"},{"title":"数据结构之<树>","author":"Guyuqing","copyright":true,"comments":0,"date":"2019-10-17T08:25:00.000Z","_content":"\n# 二叉查找树\n\n在介绍B+树前，需要先了解一下二叉查找树。B+树是通过二叉查找树，再由平衡二叉树，B树演化而来。\n\n## 定义\n\n左孩子比父节点小，右孩子比父节点大，中序遍历可以得到键值的排序输出。\n\n## 插入\n![BST_insert](Tree/BST_insert.png)\n\n## 删除\n单孩子的情况：如果删除的节点有左孩子那就把左孩子顶上去，如果有右孩子就把右孩子顶上去\n![BST_delete](Tree/BST_delete1.png)\n\n左右都有孩子的情况：可以这么想象，如果我们要删除一个数组的元素，那么我们在删除后会将其后面的一个元素顶到被删除的位置。\n二叉树操作同样，我们根据`中序遍历`找到要删除结点的后一个结点，然后顶上去，原理跟`数组`一样。\n![BST_delete](Tree/BST_delete2.png)\n\n## 查找\n查找的平均时间复杂度log(N)，在最坏的情况下会出现`链表`的形式，复杂度退化到O(N)。\n![BST_delete](Tree/BST_linked.png)\n\n# 平衡二叉树\n\n当二叉查找树以`完全二叉树`的形式展现，这样我才能做到查找是严格的O(logN)，\n\n## 定义\n\n首先符合二叉查找树的定义，其次必须满足任何节点的两个子树的高度最大差为1。\n\n## 旋转\n节点再怎么失衡都逃不过4种情况\n\n### 左子树的左边节点\n\n![BBT1](Tree/BBT1.png)\n\n### 右子树的右边节点\n\n![BBT2](Tree/BBT2.png)\n\n### 左子树的右边节点\n![BBT3](Tree/BBT3.png)\n找到`失衡点`，失衡点的左子树进行[右子树的右边节点](#右子树的右边节点)情况旋转，然后进行[左子树的左边节点](#左子树的左边节点)旋转\n\n### 右子树的左边节点\n\n![BBT4](Tree/BBT4.png)\n\n## 插入&删除\n\n步骤同[二叉查找树](#二叉查找树)，只是在插入或删除节点之后多了一步[旋转](#旋转)的过程\n\n\n# 红黑树\n红黑树也是二叉查找树，因此查找操作与普通二叉查找树操作相同。红黑树插入和删除操作会导致不再匹配红黑树性质，需要进行颜色变更和旋转调整红黑树，使其恢复性质。\n![红黑树](Tree/Red01.jpg)\n\n## 定义\n1. 每个节点要么是黑色，要么是红色。（节点非黑即红）\n2. 根节点是黑色。\n3. 每个叶子节点（NIL）是黑色。 \n4. 如果一个节点是红色的，则它的子节点必须是黑色的。（也就是说父子节点不能同时为红色）\n5. 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。（这一点是平衡的关键）\n\n## 旋转 \n同平衡二叉树\n\n## 插入\n**场景一：空树**\n根据红黑树性质第二点，红黑树根节点为黑色，即将插入节点修改成黑色即可；\n![红黑树](Tree/Red02.jpeg)\n\n**场景二：插入节点 Key 已存在**\n在插入节点之前，红黑树是保持着平衡状态，只需要将插入节点的颜色变为被替换节点的颜色，同时替换掉原节点；\n![红黑树](Tree/Red03.jpeg)\n\n**场景三：插入节点的父节点是黑色节点**\n插入的是红色节点 N，并不影响红黑树的平衡，插入之后不需要作其它处理。\n![红黑树](Tree/Red04.jpeg)\n\n**场景四：插入节点的`父节点是红色`节点且`叔叔是红色`节点**\n根据红黑树性质 4 ，两个红色节点不能直接相连；\n把父节点 P 及叔叔节点 S 由红色节点变成黑色节点，再把祖父节点 PP 变成红色，至此解决了插入节点与父节点两个红色节点直连的问题，并且黑色节点数量保持不变，但祖父节点由黑色变成了红色；\n>如果祖父节点的父节点是红色节点应如何处理？ \n处理：将祖父节点 PP 当作新插入的红色节点，从祖父节点的父节点开始由底向上进行处理，直至插入节点的父节点为黑色节点或者插入节点为根节点。\n\n>祖父节点 PP 刚好为根结点时，应如何处理？\n处理：根据性质2，我们必须把PP重新设为黑色，那么树的红黑结构变为：黑黑红。换句话说，从根结点到叶子结点的路径中，黑色结点增加了。**这也是唯一一种会增加红黑树黑色结点层数的插入情景。**\n\n![红黑树](Tree/Red05.jpeg)\n\n**场景五：插入节点的`父节点是红色`节点，且叔叔节点是空 (null) 节点或者是黑色节点**\n* 场景 5.1，插入节点 N 是父节点 P 的左节点且父节点 P 是祖父节点 PP 的左节点:\n  处理：父节点 P 变成红黑色，祖父节点变成红色，并以祖父节点 PP 为支点进行`右旋`；\n  ![红黑树](Tree/Red06.jpeg)\n* 场景 5.2，插入节点是父节点的右节点且父节点 P 是祖父节点 PP 的左节点:\n  处理：以插入节点的父节点 P 为支点进行`左旋`，转换到场景 5.1；\n  ![红黑树](Tree/Red07.jpeg)\n* 场景 5.3，插入节点 N 是父节点 P 的右子节点且父节点 P 是祖父节点 PP 的右节点:\n  处理：与场景 5.1 互为镜像，父节点 P 变成黑色，祖父节点变成红色，并以祖父节点 PP 为支点进行`左旋`；\n  ![红黑树](Tree/Red08.jpeg)\n* 场景 5.4，插入节点的父节点的左子节点，父节点是祖父节点的右子节点：\n  处理：与场景 5.2 互为镜像，以插入节点的父节点 P 为支点进行`右旋`，转换到场景 5.3；\n  ![红黑树](Tree/Red09.jpeg)\n  \n## 删除\n删除分为两部：\n1.二叉搜索树的删除(见⬆️述二叉搜索树)\n2.红黑树的删除调整。\n![红黑树](Tree/Red10.jpg)\n**R是即将被替换到删除结点的位置的替代结点，在删除前，它还在原来所在位置参与树的子平衡，平衡后再替换到删除结点的位置，才算删除完成。R最终可以看作是删除的**\n\n**删除情景1：替换结点是`红色`结点**\n由于替换结点时红色，删除也了不会影响红黑树的平衡。\n处理：颜色变为删除结点的颜色\n\n**删除情景2：替换结点是`黑结`点**\n当替换结点是黑色时，我们就不得不进行自平衡处理了。我们必须还得考虑替换结点是其父结点的左子结点还是右子结点，来做不同的旋转操作，使树重新平衡。\n* **删除情景2.1**：替换结点是其父结点的左子结点\n    * **删除情景2.1.1**：替换结点的`兄弟结点是红结点`\n      若兄弟结点是红结点，那么根据性质4，兄弟结点的父结点和子结点肯定为黑色，按下图处理，得到删除情景**2.1.2.3**\n      处理：\n        * 将S设为黑色\n        * 将P设为红色\n        * 对P进行左旋，得到情景2.1.2.3\n      ![红黑树](Tree/Red11.jpg)\n    * **删除情景2.1.2**：替换结点的`兄弟结点是黑结点`\n      当兄弟结点为黑时，其父结点和子结点的具体颜色也无法确定,此时又得考虑多种子情景。\n        * **删除情景2.1.2.1**：替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色\n          即将删除的左子树的一个黑色结点，显然左子树的黑色结点少1了，然而右子树又有红色结点，那么我们直接向右子树“借”个红结点来补充黑结点就好啦，此时肯定需要用旋转处理了。\n          处理：\n            * 将S的颜色设为P的颜色\n            * 将P设为黑色\n            * 将SR设为黑色\n            * 对P进行左旋\n          ![红黑树](Tree/Red12.jpg)\n          平衡后的图怎么不满足红黑树的性质？\n          前文提醒过，R是即将替换的，它还参与树的自平衡，平衡后再替换到删除结点的位置，所以R最终可以看作是删除的。\n          另外图2.1.2.1是考虑到第一次替换和自底向上处理的情况，如果只考虑第一次替换的情况，根据红黑树性质，SL肯定是红色或为Nil，所以最终结果树是平衡的。\n        * **删除情景2.1.2.2**：替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点\n          兄弟结点所在的子树有红结点，我们总是可以向兄弟子树借个红结点过来，显然该情景可以转换为情景2.1.2.1\n          处理：\n            * 将S设为红色，将SL设为黑色\n            * 对S进行右旋，得到情景2.1.2.1\n          ![红黑树](Tree/Red13.jpg)\n        * **删除情景2.1.2.3**：替换结点的兄弟结点的子结点都为黑结点\n          此次兄弟子树都没红结点“借”了，兄弟帮忙不了，找父母呗，这种情景我们把兄弟结点设为红色，再把父结点当作替代结点，自底向上处理，去找父结点的兄弟结点去“借”。\n          但为什么需要把兄弟结点设为红色呢？\n          显然是为了在P所在的子树中保证平衡（R即将删除，少了一个黑色结点，子树也需要少一个），后续的平衡工作交给父辈们考虑了，还是那句，当每棵子树都保持平衡时，最终整棵总是平衡的。\n          处理：将S设为红色,把P作为新的替换结点,重新进行删除结点情景处理\n          \n* **删除情景2.2**：替换结点是其父结点的右子结点（和上述操作相反）\n    * **删除情景2.2.1**：替换结点的`兄弟结点是红结点`\n      处理：\n        * 将S设为黑色\n        * 将P设为红色\n        * 对P进行右旋，得到情景2.2.2.3\n      ![红黑树](Tree/Red14.jpg)\n    * **删除情景2.2.2**：替换结点的`兄弟结点是黑结点`\n        * **删除情景2.2.2.1**：替换结点的兄弟结点的左子结点是红结点，右子结点任意颜色\n          处理：\n            * 将S的颜色设为P的颜色\n            * 将P设为黑色\n            * 将SL设为黑色\n            * 对P进行右旋\n          ![红黑树](Tree/Red15.jpg)\n        * **删除情景2.2.2.2**：替换结点的兄弟结点的左子结点为黑结点，右子结点为红结点\n          处理：\n            * 将S设为红色\n            * 将SR设为黑色\n            * 对S进行左旋，得到情景2.2.2.1\n          ![红黑树](Tree/Red16.jpg)\n        * **删除情景2.2.2.3**：替换结点的兄弟结点的子结点都为黑结点   \n          处理：\n            * 将S设为红色,把P作为新的替换结点,重新进行删除结点情景处理\n          ![红黑树](Tree/Red17.jpg)\n          \n综上，红黑树删除后自平衡的处理可以总结为：\n* 自己能搞定的自消化（情景1）\n* 自己不能搞定的叫兄弟帮忙（除了情景1、情景2.1.2.3和情景2.2.2.3）\n* 兄弟都帮忙不了的，通过父母，找远方亲戚（情景2.1.2.3和情景2.2.2.3）\n\n请画出下图的删除自平衡处理过程。     \n![红黑树](Tree/Req18.jpg)       \n   \n参考：https://www.jianshu.com/p/e136ec79235c\n","source":"_posts/Tree.md","raw":"title: 数据结构之<树>\ntags:\n  - 学习笔记\n  - 树\n  - 数据结构\ncategories:\n  - 数据结构\nauthor: Guyuqing\ncopyright: true\ncomments: false\ndate: 2019-10-17 16:25:00\n---\n\n# 二叉查找树\n\n在介绍B+树前，需要先了解一下二叉查找树。B+树是通过二叉查找树，再由平衡二叉树，B树演化而来。\n\n## 定义\n\n左孩子比父节点小，右孩子比父节点大，中序遍历可以得到键值的排序输出。\n\n## 插入\n![BST_insert](Tree/BST_insert.png)\n\n## 删除\n单孩子的情况：如果删除的节点有左孩子那就把左孩子顶上去，如果有右孩子就把右孩子顶上去\n![BST_delete](Tree/BST_delete1.png)\n\n左右都有孩子的情况：可以这么想象，如果我们要删除一个数组的元素，那么我们在删除后会将其后面的一个元素顶到被删除的位置。\n二叉树操作同样，我们根据`中序遍历`找到要删除结点的后一个结点，然后顶上去，原理跟`数组`一样。\n![BST_delete](Tree/BST_delete2.png)\n\n## 查找\n查找的平均时间复杂度log(N)，在最坏的情况下会出现`链表`的形式，复杂度退化到O(N)。\n![BST_delete](Tree/BST_linked.png)\n\n# 平衡二叉树\n\n当二叉查找树以`完全二叉树`的形式展现，这样我才能做到查找是严格的O(logN)，\n\n## 定义\n\n首先符合二叉查找树的定义，其次必须满足任何节点的两个子树的高度最大差为1。\n\n## 旋转\n节点再怎么失衡都逃不过4种情况\n\n### 左子树的左边节点\n\n![BBT1](Tree/BBT1.png)\n\n### 右子树的右边节点\n\n![BBT2](Tree/BBT2.png)\n\n### 左子树的右边节点\n![BBT3](Tree/BBT3.png)\n找到`失衡点`，失衡点的左子树进行[右子树的右边节点](#右子树的右边节点)情况旋转，然后进行[左子树的左边节点](#左子树的左边节点)旋转\n\n### 右子树的左边节点\n\n![BBT4](Tree/BBT4.png)\n\n## 插入&删除\n\n步骤同[二叉查找树](#二叉查找树)，只是在插入或删除节点之后多了一步[旋转](#旋转)的过程\n\n\n# 红黑树\n红黑树也是二叉查找树，因此查找操作与普通二叉查找树操作相同。红黑树插入和删除操作会导致不再匹配红黑树性质，需要进行颜色变更和旋转调整红黑树，使其恢复性质。\n![红黑树](Tree/Red01.jpg)\n\n## 定义\n1. 每个节点要么是黑色，要么是红色。（节点非黑即红）\n2. 根节点是黑色。\n3. 每个叶子节点（NIL）是黑色。 \n4. 如果一个节点是红色的，则它的子节点必须是黑色的。（也就是说父子节点不能同时为红色）\n5. 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。（这一点是平衡的关键）\n\n## 旋转 \n同平衡二叉树\n\n## 插入\n**场景一：空树**\n根据红黑树性质第二点，红黑树根节点为黑色，即将插入节点修改成黑色即可；\n![红黑树](Tree/Red02.jpeg)\n\n**场景二：插入节点 Key 已存在**\n在插入节点之前，红黑树是保持着平衡状态，只需要将插入节点的颜色变为被替换节点的颜色，同时替换掉原节点；\n![红黑树](Tree/Red03.jpeg)\n\n**场景三：插入节点的父节点是黑色节点**\n插入的是红色节点 N，并不影响红黑树的平衡，插入之后不需要作其它处理。\n![红黑树](Tree/Red04.jpeg)\n\n**场景四：插入节点的`父节点是红色`节点且`叔叔是红色`节点**\n根据红黑树性质 4 ，两个红色节点不能直接相连；\n把父节点 P 及叔叔节点 S 由红色节点变成黑色节点，再把祖父节点 PP 变成红色，至此解决了插入节点与父节点两个红色节点直连的问题，并且黑色节点数量保持不变，但祖父节点由黑色变成了红色；\n>如果祖父节点的父节点是红色节点应如何处理？ \n处理：将祖父节点 PP 当作新插入的红色节点，从祖父节点的父节点开始由底向上进行处理，直至插入节点的父节点为黑色节点或者插入节点为根节点。\n\n>祖父节点 PP 刚好为根结点时，应如何处理？\n处理：根据性质2，我们必须把PP重新设为黑色，那么树的红黑结构变为：黑黑红。换句话说，从根结点到叶子结点的路径中，黑色结点增加了。**这也是唯一一种会增加红黑树黑色结点层数的插入情景。**\n\n![红黑树](Tree/Red05.jpeg)\n\n**场景五：插入节点的`父节点是红色`节点，且叔叔节点是空 (null) 节点或者是黑色节点**\n* 场景 5.1，插入节点 N 是父节点 P 的左节点且父节点 P 是祖父节点 PP 的左节点:\n  处理：父节点 P 变成红黑色，祖父节点变成红色，并以祖父节点 PP 为支点进行`右旋`；\n  ![红黑树](Tree/Red06.jpeg)\n* 场景 5.2，插入节点是父节点的右节点且父节点 P 是祖父节点 PP 的左节点:\n  处理：以插入节点的父节点 P 为支点进行`左旋`，转换到场景 5.1；\n  ![红黑树](Tree/Red07.jpeg)\n* 场景 5.3，插入节点 N 是父节点 P 的右子节点且父节点 P 是祖父节点 PP 的右节点:\n  处理：与场景 5.1 互为镜像，父节点 P 变成黑色，祖父节点变成红色，并以祖父节点 PP 为支点进行`左旋`；\n  ![红黑树](Tree/Red08.jpeg)\n* 场景 5.4，插入节点的父节点的左子节点，父节点是祖父节点的右子节点：\n  处理：与场景 5.2 互为镜像，以插入节点的父节点 P 为支点进行`右旋`，转换到场景 5.3；\n  ![红黑树](Tree/Red09.jpeg)\n  \n## 删除\n删除分为两部：\n1.二叉搜索树的删除(见⬆️述二叉搜索树)\n2.红黑树的删除调整。\n![红黑树](Tree/Red10.jpg)\n**R是即将被替换到删除结点的位置的替代结点，在删除前，它还在原来所在位置参与树的子平衡，平衡后再替换到删除结点的位置，才算删除完成。R最终可以看作是删除的**\n\n**删除情景1：替换结点是`红色`结点**\n由于替换结点时红色，删除也了不会影响红黑树的平衡。\n处理：颜色变为删除结点的颜色\n\n**删除情景2：替换结点是`黑结`点**\n当替换结点是黑色时，我们就不得不进行自平衡处理了。我们必须还得考虑替换结点是其父结点的左子结点还是右子结点，来做不同的旋转操作，使树重新平衡。\n* **删除情景2.1**：替换结点是其父结点的左子结点\n    * **删除情景2.1.1**：替换结点的`兄弟结点是红结点`\n      若兄弟结点是红结点，那么根据性质4，兄弟结点的父结点和子结点肯定为黑色，按下图处理，得到删除情景**2.1.2.3**\n      处理：\n        * 将S设为黑色\n        * 将P设为红色\n        * 对P进行左旋，得到情景2.1.2.3\n      ![红黑树](Tree/Red11.jpg)\n    * **删除情景2.1.2**：替换结点的`兄弟结点是黑结点`\n      当兄弟结点为黑时，其父结点和子结点的具体颜色也无法确定,此时又得考虑多种子情景。\n        * **删除情景2.1.2.1**：替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色\n          即将删除的左子树的一个黑色结点，显然左子树的黑色结点少1了，然而右子树又有红色结点，那么我们直接向右子树“借”个红结点来补充黑结点就好啦，此时肯定需要用旋转处理了。\n          处理：\n            * 将S的颜色设为P的颜色\n            * 将P设为黑色\n            * 将SR设为黑色\n            * 对P进行左旋\n          ![红黑树](Tree/Red12.jpg)\n          平衡后的图怎么不满足红黑树的性质？\n          前文提醒过，R是即将替换的，它还参与树的自平衡，平衡后再替换到删除结点的位置，所以R最终可以看作是删除的。\n          另外图2.1.2.1是考虑到第一次替换和自底向上处理的情况，如果只考虑第一次替换的情况，根据红黑树性质，SL肯定是红色或为Nil，所以最终结果树是平衡的。\n        * **删除情景2.1.2.2**：替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点\n          兄弟结点所在的子树有红结点，我们总是可以向兄弟子树借个红结点过来，显然该情景可以转换为情景2.1.2.1\n          处理：\n            * 将S设为红色，将SL设为黑色\n            * 对S进行右旋，得到情景2.1.2.1\n          ![红黑树](Tree/Red13.jpg)\n        * **删除情景2.1.2.3**：替换结点的兄弟结点的子结点都为黑结点\n          此次兄弟子树都没红结点“借”了，兄弟帮忙不了，找父母呗，这种情景我们把兄弟结点设为红色，再把父结点当作替代结点，自底向上处理，去找父结点的兄弟结点去“借”。\n          但为什么需要把兄弟结点设为红色呢？\n          显然是为了在P所在的子树中保证平衡（R即将删除，少了一个黑色结点，子树也需要少一个），后续的平衡工作交给父辈们考虑了，还是那句，当每棵子树都保持平衡时，最终整棵总是平衡的。\n          处理：将S设为红色,把P作为新的替换结点,重新进行删除结点情景处理\n          \n* **删除情景2.2**：替换结点是其父结点的右子结点（和上述操作相反）\n    * **删除情景2.2.1**：替换结点的`兄弟结点是红结点`\n      处理：\n        * 将S设为黑色\n        * 将P设为红色\n        * 对P进行右旋，得到情景2.2.2.3\n      ![红黑树](Tree/Red14.jpg)\n    * **删除情景2.2.2**：替换结点的`兄弟结点是黑结点`\n        * **删除情景2.2.2.1**：替换结点的兄弟结点的左子结点是红结点，右子结点任意颜色\n          处理：\n            * 将S的颜色设为P的颜色\n            * 将P设为黑色\n            * 将SL设为黑色\n            * 对P进行右旋\n          ![红黑树](Tree/Red15.jpg)\n        * **删除情景2.2.2.2**：替换结点的兄弟结点的左子结点为黑结点，右子结点为红结点\n          处理：\n            * 将S设为红色\n            * 将SR设为黑色\n            * 对S进行左旋，得到情景2.2.2.1\n          ![红黑树](Tree/Red16.jpg)\n        * **删除情景2.2.2.3**：替换结点的兄弟结点的子结点都为黑结点   \n          处理：\n            * 将S设为红色,把P作为新的替换结点,重新进行删除结点情景处理\n          ![红黑树](Tree/Red17.jpg)\n          \n综上，红黑树删除后自平衡的处理可以总结为：\n* 自己能搞定的自消化（情景1）\n* 自己不能搞定的叫兄弟帮忙（除了情景1、情景2.1.2.3和情景2.2.2.3）\n* 兄弟都帮忙不了的，通过父母，找远方亲戚（情景2.1.2.3和情景2.2.2.3）\n\n请画出下图的删除自平衡处理过程。     \n![红黑树](Tree/Req18.jpg)       \n   \n参考：https://www.jianshu.com/p/e136ec79235c\n","slug":"Tree","published":1,"updated":"2020-03-06T12:01:11.889Z","layout":"post","photos":[],"link":"","_id":"ck8fb4ajz006xk2o5ntw5xnjq","content":"<h1 id=\"二叉查找树\"><a href=\"#二叉查找树\" class=\"headerlink\" title=\"二叉查找树\"></a>二叉查找树</h1><p>在介绍B+树前，需要先了解一下二叉查找树。B+树是通过二叉查找树，再由平衡二叉树，B树演化而来。</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>左孩子比父节点小，右孩子比父节点大，中序遍历可以得到键值的排序输出。</p>\n<h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><p><img src=\"/数据结构/Tree/BST_insert.png\" alt=\"BST_insert\"></p>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><p>单孩子的情况：如果删除的节点有左孩子那就把左孩子顶上去，如果有右孩子就把右孩子顶上去<br><img src=\"/数据结构/Tree/BST_delete1.png\" alt=\"BST_delete\"></p>\n<p>左右都有孩子的情况：可以这么想象，如果我们要删除一个数组的元素，那么我们在删除后会将其后面的一个元素顶到被删除的位置。<br>二叉树操作同样，我们根据<code>中序遍历</code>找到要删除结点的后一个结点，然后顶上去，原理跟<code>数组</code>一样。<br><img src=\"/数据结构/Tree/BST_delete2.png\" alt=\"BST_delete\"></p>\n<h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><p>查找的平均时间复杂度log(N)，在最坏的情况下会出现<code>链表</code>的形式，复杂度退化到O(N)。<br><img src=\"/数据结构/Tree/BST_linked.png\" alt=\"BST_delete\"></p>\n<h1 id=\"平衡二叉树\"><a href=\"#平衡二叉树\" class=\"headerlink\" title=\"平衡二叉树\"></a>平衡二叉树</h1><p>当二叉查找树以<code>完全二叉树</code>的形式展现，这样我才能做到查找是严格的O(logN)，</p>\n<h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>首先符合二叉查找树的定义，其次必须满足任何节点的两个子树的高度最大差为1。</p>\n<h2 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h2><p>节点再怎么失衡都逃不过4种情况</p>\n<h3 id=\"左子树的左边节点\"><a href=\"#左子树的左边节点\" class=\"headerlink\" title=\"左子树的左边节点\"></a>左子树的左边节点</h3><p><img src=\"/数据结构/Tree/BBT1.png\" alt=\"BBT1\"></p>\n<h3 id=\"右子树的右边节点\"><a href=\"#右子树的右边节点\" class=\"headerlink\" title=\"右子树的右边节点\"></a>右子树的右边节点</h3><p><img src=\"/数据结构/Tree/BBT2.png\" alt=\"BBT2\"></p>\n<h3 id=\"左子树的右边节点\"><a href=\"#左子树的右边节点\" class=\"headerlink\" title=\"左子树的右边节点\"></a>左子树的右边节点</h3><p><img src=\"/数据结构/Tree/BBT3.png\" alt=\"BBT3\"><br>找到<code>失衡点</code>，失衡点的左子树进行<a href=\"#右子树的右边节点\">右子树的右边节点</a>情况旋转，然后进行<a href=\"#左子树的左边节点\">左子树的左边节点</a>旋转</p>\n<h3 id=\"右子树的左边节点\"><a href=\"#右子树的左边节点\" class=\"headerlink\" title=\"右子树的左边节点\"></a>右子树的左边节点</h3><p><img src=\"/数据结构/Tree/BBT4.png\" alt=\"BBT4\"></p>\n<h2 id=\"插入-amp-删除\"><a href=\"#插入-amp-删除\" class=\"headerlink\" title=\"插入&amp;删除\"></a>插入&amp;删除</h2><p>步骤同<a href=\"#二叉查找树\">二叉查找树</a>，只是在插入或删除节点之后多了一步<a href=\"#旋转\">旋转</a>的过程</p>\n<h1 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h1><p>红黑树也是二叉查找树，因此查找操作与普通二叉查找树操作相同。红黑树插入和删除操作会导致不再匹配红黑树性质，需要进行颜色变更和旋转调整红黑树，使其恢复性质。<br><img src=\"/数据结构/Tree/Red01.jpg\" alt=\"红黑树\"></p>\n<h2 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h2><ol>\n<li>每个节点要么是黑色，要么是红色。（节点非黑即红）</li>\n<li>根节点是黑色。</li>\n<li>每个叶子节点（NIL）是黑色。 </li>\n<li>如果一个节点是红色的，则它的子节点必须是黑色的。（也就是说父子节点不能同时为红色）</li>\n<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。（这一点是平衡的关键）</li>\n</ol>\n<h2 id=\"旋转-1\"><a href=\"#旋转-1\" class=\"headerlink\" title=\"旋转\"></a>旋转</h2><p>同平衡二叉树</p>\n<h2 id=\"插入-1\"><a href=\"#插入-1\" class=\"headerlink\" title=\"插入\"></a>插入</h2><p><strong>场景一：空树</strong><br>根据红黑树性质第二点，红黑树根节点为黑色，即将插入节点修改成黑色即可；<br><img src=\"/数据结构/Tree/Red02.jpeg\" alt=\"红黑树\"></p>\n<p><strong>场景二：插入节点 Key 已存在</strong><br>在插入节点之前，红黑树是保持着平衡状态，只需要将插入节点的颜色变为被替换节点的颜色，同时替换掉原节点；<br><img src=\"/数据结构/Tree/Red03.jpeg\" alt=\"红黑树\"></p>\n<p><strong>场景三：插入节点的父节点是黑色节点</strong><br>插入的是红色节点 N，并不影响红黑树的平衡，插入之后不需要作其它处理。<br><img src=\"/数据结构/Tree/Red04.jpeg\" alt=\"红黑树\"></p>\n<p><strong>场景四：插入节点的<code>父节点是红色</code>节点且<code>叔叔是红色</code>节点</strong><br>根据红黑树性质 4 ，两个红色节点不能直接相连；<br>把父节点 P 及叔叔节点 S 由红色节点变成黑色节点，再把祖父节点 PP 变成红色，至此解决了插入节点与父节点两个红色节点直连的问题，并且黑色节点数量保持不变，但祖父节点由黑色变成了红色；</p>\n<blockquote>\n<p>如果祖父节点的父节点是红色节点应如何处理？<br>处理：将祖父节点 PP 当作新插入的红色节点，从祖父节点的父节点开始由底向上进行处理，直至插入节点的父节点为黑色节点或者插入节点为根节点。</p>\n</blockquote>\n<blockquote>\n<p>祖父节点 PP 刚好为根结点时，应如何处理？<br>处理：根据性质2，我们必须把PP重新设为黑色，那么树的红黑结构变为：黑黑红。换句话说，从根结点到叶子结点的路径中，黑色结点增加了。<strong>这也是唯一一种会增加红黑树黑色结点层数的插入情景。</strong></p>\n</blockquote>\n<p><img src=\"/数据结构/Tree/Red05.jpeg\" alt=\"红黑树\"></p>\n<p><strong>场景五：插入节点的<code>父节点是红色</code>节点，且叔叔节点是空 (null) 节点或者是黑色节点</strong></p>\n<ul>\n<li>场景 5.1，插入节点 N 是父节点 P 的左节点且父节点 P 是祖父节点 PP 的左节点:<br>处理：父节点 P 变成红黑色，祖父节点变成红色，并以祖父节点 PP 为支点进行<code>右旋</code>；<br><img src=\"/数据结构/Tree/Red06.jpeg\" alt=\"红黑树\"></li>\n<li>场景 5.2，插入节点是父节点的右节点且父节点 P 是祖父节点 PP 的左节点:<br>处理：以插入节点的父节点 P 为支点进行<code>左旋</code>，转换到场景 5.1；<br><img src=\"/数据结构/Tree/Red07.jpeg\" alt=\"红黑树\"></li>\n<li>场景 5.3，插入节点 N 是父节点 P 的右子节点且父节点 P 是祖父节点 PP 的右节点:<br>处理：与场景 5.1 互为镜像，父节点 P 变成黑色，祖父节点变成红色，并以祖父节点 PP 为支点进行<code>左旋</code>；<br><img src=\"/数据结构/Tree/Red08.jpeg\" alt=\"红黑树\"></li>\n<li>场景 5.4，插入节点的父节点的左子节点，父节点是祖父节点的右子节点：<br>处理：与场景 5.2 互为镜像，以插入节点的父节点 P 为支点进行<code>右旋</code>，转换到场景 5.3；<br><img src=\"/数据结构/Tree/Red09.jpeg\" alt=\"红黑树\"></li>\n</ul>\n<h2 id=\"删除-1\"><a href=\"#删除-1\" class=\"headerlink\" title=\"删除\"></a>删除</h2><p>删除分为两部：<br>1.二叉搜索树的删除(见⬆️述二叉搜索树)<br>2.红黑树的删除调整。<br><img src=\"/数据结构/Tree/Red10.jpg\" alt=\"红黑树\"><br><strong>R是即将被替换到删除结点的位置的替代结点，在删除前，它还在原来所在位置参与树的子平衡，平衡后再替换到删除结点的位置，才算删除完成。R最终可以看作是删除的</strong></p>\n<p><strong>删除情景1：替换结点是<code>红色</code>结点</strong><br>由于替换结点时红色，删除也了不会影响红黑树的平衡。<br>处理：颜色变为删除结点的颜色</p>\n<p><strong>删除情景2：替换结点是<code>黑结</code>点</strong><br>当替换结点是黑色时，我们就不得不进行自平衡处理了。我们必须还得考虑替换结点是其父结点的左子结点还是右子结点，来做不同的旋转操作，使树重新平衡。</p>\n<ul>\n<li><p><strong>删除情景2.1</strong>：替换结点是其父结点的左子结点</p>\n<ul>\n<li><strong>删除情景2.1.1</strong>：替换结点的<code>兄弟结点是红结点</code><br>若兄弟结点是红结点，那么根据性质4，兄弟结点的父结点和子结点肯定为黑色，按下图处理，得到删除情景<strong>2.1.2.3</strong><br>处理：<ul>\n<li>将S设为黑色</li>\n<li>将P设为红色</li>\n<li>对P进行左旋，得到情景2.1.2.3<br><img src=\"/数据结构/Tree/Red11.jpg\" alt=\"红黑树\"></li>\n</ul>\n</li>\n<li><strong>删除情景2.1.2</strong>：替换结点的<code>兄弟结点是黑结点</code><br>当兄弟结点为黑时，其父结点和子结点的具体颜色也无法确定,此时又得考虑多种子情景。<ul>\n<li><strong>删除情景2.1.2.1</strong>：替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色<br>即将删除的左子树的一个黑色结点，显然左子树的黑色结点少1了，然而右子树又有红色结点，那么我们直接向右子树“借”个红结点来补充黑结点就好啦，此时肯定需要用旋转处理了。<br>处理：<ul>\n<li>将S的颜色设为P的颜色</li>\n<li>将P设为黑色</li>\n<li>将SR设为黑色</li>\n<li>对P进行左旋<br><img src=\"/数据结构/Tree/Red12.jpg\" alt=\"红黑树\"><br>平衡后的图怎么不满足红黑树的性质？<br>前文提醒过，R是即将替换的，它还参与树的自平衡，平衡后再替换到删除结点的位置，所以R最终可以看作是删除的。<br>另外图2.1.2.1是考虑到第一次替换和自底向上处理的情况，如果只考虑第一次替换的情况，根据红黑树性质，SL肯定是红色或为Nil，所以最终结果树是平衡的。</li>\n</ul>\n</li>\n<li><strong>删除情景2.1.2.2</strong>：替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点<br>兄弟结点所在的子树有红结点，我们总是可以向兄弟子树借个红结点过来，显然该情景可以转换为情景2.1.2.1<br>处理：<ul>\n<li>将S设为红色，将SL设为黑色</li>\n<li>对S进行右旋，得到情景2.1.2.1<br><img src=\"/数据结构/Tree/Red13.jpg\" alt=\"红黑树\"></li>\n</ul>\n</li>\n<li><strong>删除情景2.1.2.3</strong>：替换结点的兄弟结点的子结点都为黑结点<br>此次兄弟子树都没红结点“借”了，兄弟帮忙不了，找父母呗，这种情景我们把兄弟结点设为红色，再把父结点当作替代结点，自底向上处理，去找父结点的兄弟结点去“借”。<br>但为什么需要把兄弟结点设为红色呢？<br>显然是为了在P所在的子树中保证平衡（R即将删除，少了一个黑色结点，子树也需要少一个），后续的平衡工作交给父辈们考虑了，还是那句，当每棵子树都保持平衡时，最终整棵总是平衡的。<br>处理：将S设为红色,把P作为新的替换结点,重新进行删除结点情景处理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>删除情景2.2</strong>：替换结点是其父结点的右子结点（和上述操作相反）</p>\n<ul>\n<li><strong>删除情景2.2.1</strong>：替换结点的<code>兄弟结点是红结点</code><br>处理：<ul>\n<li>将S设为黑色</li>\n<li>将P设为红色</li>\n<li>对P进行右旋，得到情景2.2.2.3<br><img src=\"/数据结构/Tree/Red14.jpg\" alt=\"红黑树\"></li>\n</ul>\n</li>\n<li><strong>删除情景2.2.2</strong>：替换结点的<code>兄弟结点是黑结点</code><ul>\n<li><strong>删除情景2.2.2.1</strong>：替换结点的兄弟结点的左子结点是红结点，右子结点任意颜色<br>处理：<ul>\n<li>将S的颜色设为P的颜色</li>\n<li>将P设为黑色</li>\n<li>将SL设为黑色</li>\n<li>对P进行右旋<br><img src=\"/数据结构/Tree/Red15.jpg\" alt=\"红黑树\"></li>\n</ul>\n</li>\n<li><strong>删除情景2.2.2.2</strong>：替换结点的兄弟结点的左子结点为黑结点，右子结点为红结点<br>处理：<ul>\n<li>将S设为红色</li>\n<li>将SR设为黑色</li>\n<li>对S进行左旋，得到情景2.2.2.1<br><img src=\"/数据结构/Tree/Red16.jpg\" alt=\"红黑树\"></li>\n</ul>\n</li>\n<li><strong>删除情景2.2.2.3</strong>：替换结点的兄弟结点的子结点都为黑结点<br>处理：<ul>\n<li>将S设为红色,把P作为新的替换结点,重新进行删除结点情景处理<br><img src=\"/数据结构/Tree/Red17.jpg\" alt=\"红黑树\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>综上，红黑树删除后自平衡的处理可以总结为：</p>\n<ul>\n<li>自己能搞定的自消化（情景1）</li>\n<li>自己不能搞定的叫兄弟帮忙（除了情景1、情景2.1.2.3和情景2.2.2.3）</li>\n<li>兄弟都帮忙不了的，通过父母，找远方亲戚（情景2.1.2.3和情景2.2.2.3）</li>\n</ul>\n<p>请画出下图的删除自平衡处理过程。<br><img src=\"/数据结构/Tree/Req18.jpg\" alt=\"红黑树\">       </p>\n<p>参考：<a href=\"https://www.jianshu.com/p/e136ec79235c\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/e136ec79235c</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"二叉查找树\"><a href=\"#二叉查找树\" class=\"headerlink\" title=\"二叉查找树\"></a>二叉查找树</h1><p>在介绍B+树前，需要先了解一下二叉查找树。B+树是通过二叉查找树，再由平衡二叉树，B树演化而来。</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>左孩子比父节点小，右孩子比父节点大，中序遍历可以得到键值的排序输出。</p>\n<h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><p><img src=\"/数据结构/Tree/BST_insert.png\" alt=\"BST_insert\"></p>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><p>单孩子的情况：如果删除的节点有左孩子那就把左孩子顶上去，如果有右孩子就把右孩子顶上去<br><img src=\"/数据结构/Tree/BST_delete1.png\" alt=\"BST_delete\"></p>\n<p>左右都有孩子的情况：可以这么想象，如果我们要删除一个数组的元素，那么我们在删除后会将其后面的一个元素顶到被删除的位置。<br>二叉树操作同样，我们根据<code>中序遍历</code>找到要删除结点的后一个结点，然后顶上去，原理跟<code>数组</code>一样。<br><img src=\"/数据结构/Tree/BST_delete2.png\" alt=\"BST_delete\"></p>\n<h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><p>查找的平均时间复杂度log(N)，在最坏的情况下会出现<code>链表</code>的形式，复杂度退化到O(N)。<br><img src=\"/数据结构/Tree/BST_linked.png\" alt=\"BST_delete\"></p>\n<h1 id=\"平衡二叉树\"><a href=\"#平衡二叉树\" class=\"headerlink\" title=\"平衡二叉树\"></a>平衡二叉树</h1><p>当二叉查找树以<code>完全二叉树</code>的形式展现，这样我才能做到查找是严格的O(logN)，</p>\n<h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>首先符合二叉查找树的定义，其次必须满足任何节点的两个子树的高度最大差为1。</p>\n<h2 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h2><p>节点再怎么失衡都逃不过4种情况</p>\n<h3 id=\"左子树的左边节点\"><a href=\"#左子树的左边节点\" class=\"headerlink\" title=\"左子树的左边节点\"></a>左子树的左边节点</h3><p><img src=\"/数据结构/Tree/BBT1.png\" alt=\"BBT1\"></p>\n<h3 id=\"右子树的右边节点\"><a href=\"#右子树的右边节点\" class=\"headerlink\" title=\"右子树的右边节点\"></a>右子树的右边节点</h3><p><img src=\"/数据结构/Tree/BBT2.png\" alt=\"BBT2\"></p>\n<h3 id=\"左子树的右边节点\"><a href=\"#左子树的右边节点\" class=\"headerlink\" title=\"左子树的右边节点\"></a>左子树的右边节点</h3><p><img src=\"/数据结构/Tree/BBT3.png\" alt=\"BBT3\"><br>找到<code>失衡点</code>，失衡点的左子树进行<a href=\"#右子树的右边节点\">右子树的右边节点</a>情况旋转，然后进行<a href=\"#左子树的左边节点\">左子树的左边节点</a>旋转</p>\n<h3 id=\"右子树的左边节点\"><a href=\"#右子树的左边节点\" class=\"headerlink\" title=\"右子树的左边节点\"></a>右子树的左边节点</h3><p><img src=\"/数据结构/Tree/BBT4.png\" alt=\"BBT4\"></p>\n<h2 id=\"插入-amp-删除\"><a href=\"#插入-amp-删除\" class=\"headerlink\" title=\"插入&amp;删除\"></a>插入&amp;删除</h2><p>步骤同<a href=\"#二叉查找树\">二叉查找树</a>，只是在插入或删除节点之后多了一步<a href=\"#旋转\">旋转</a>的过程</p>\n<h1 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h1><p>红黑树也是二叉查找树，因此查找操作与普通二叉查找树操作相同。红黑树插入和删除操作会导致不再匹配红黑树性质，需要进行颜色变更和旋转调整红黑树，使其恢复性质。<br><img src=\"/数据结构/Tree/Red01.jpg\" alt=\"红黑树\"></p>\n<h2 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h2><ol>\n<li>每个节点要么是黑色，要么是红色。（节点非黑即红）</li>\n<li>根节点是黑色。</li>\n<li>每个叶子节点（NIL）是黑色。 </li>\n<li>如果一个节点是红色的，则它的子节点必须是黑色的。（也就是说父子节点不能同时为红色）</li>\n<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。（这一点是平衡的关键）</li>\n</ol>\n<h2 id=\"旋转-1\"><a href=\"#旋转-1\" class=\"headerlink\" title=\"旋转\"></a>旋转</h2><p>同平衡二叉树</p>\n<h2 id=\"插入-1\"><a href=\"#插入-1\" class=\"headerlink\" title=\"插入\"></a>插入</h2><p><strong>场景一：空树</strong><br>根据红黑树性质第二点，红黑树根节点为黑色，即将插入节点修改成黑色即可；<br><img src=\"/数据结构/Tree/Red02.jpeg\" alt=\"红黑树\"></p>\n<p><strong>场景二：插入节点 Key 已存在</strong><br>在插入节点之前，红黑树是保持着平衡状态，只需要将插入节点的颜色变为被替换节点的颜色，同时替换掉原节点；<br><img src=\"/数据结构/Tree/Red03.jpeg\" alt=\"红黑树\"></p>\n<p><strong>场景三：插入节点的父节点是黑色节点</strong><br>插入的是红色节点 N，并不影响红黑树的平衡，插入之后不需要作其它处理。<br><img src=\"/数据结构/Tree/Red04.jpeg\" alt=\"红黑树\"></p>\n<p><strong>场景四：插入节点的<code>父节点是红色</code>节点且<code>叔叔是红色</code>节点</strong><br>根据红黑树性质 4 ，两个红色节点不能直接相连；<br>把父节点 P 及叔叔节点 S 由红色节点变成黑色节点，再把祖父节点 PP 变成红色，至此解决了插入节点与父节点两个红色节点直连的问题，并且黑色节点数量保持不变，但祖父节点由黑色变成了红色；</p>\n<blockquote>\n<p>如果祖父节点的父节点是红色节点应如何处理？<br>处理：将祖父节点 PP 当作新插入的红色节点，从祖父节点的父节点开始由底向上进行处理，直至插入节点的父节点为黑色节点或者插入节点为根节点。</p>\n</blockquote>\n<blockquote>\n<p>祖父节点 PP 刚好为根结点时，应如何处理？<br>处理：根据性质2，我们必须把PP重新设为黑色，那么树的红黑结构变为：黑黑红。换句话说，从根结点到叶子结点的路径中，黑色结点增加了。<strong>这也是唯一一种会增加红黑树黑色结点层数的插入情景。</strong></p>\n</blockquote>\n<p><img src=\"/数据结构/Tree/Red05.jpeg\" alt=\"红黑树\"></p>\n<p><strong>场景五：插入节点的<code>父节点是红色</code>节点，且叔叔节点是空 (null) 节点或者是黑色节点</strong></p>\n<ul>\n<li>场景 5.1，插入节点 N 是父节点 P 的左节点且父节点 P 是祖父节点 PP 的左节点:<br>处理：父节点 P 变成红黑色，祖父节点变成红色，并以祖父节点 PP 为支点进行<code>右旋</code>；<br><img src=\"/数据结构/Tree/Red06.jpeg\" alt=\"红黑树\"></li>\n<li>场景 5.2，插入节点是父节点的右节点且父节点 P 是祖父节点 PP 的左节点:<br>处理：以插入节点的父节点 P 为支点进行<code>左旋</code>，转换到场景 5.1；<br><img src=\"/数据结构/Tree/Red07.jpeg\" alt=\"红黑树\"></li>\n<li>场景 5.3，插入节点 N 是父节点 P 的右子节点且父节点 P 是祖父节点 PP 的右节点:<br>处理：与场景 5.1 互为镜像，父节点 P 变成黑色，祖父节点变成红色，并以祖父节点 PP 为支点进行<code>左旋</code>；<br><img src=\"/数据结构/Tree/Red08.jpeg\" alt=\"红黑树\"></li>\n<li>场景 5.4，插入节点的父节点的左子节点，父节点是祖父节点的右子节点：<br>处理：与场景 5.2 互为镜像，以插入节点的父节点 P 为支点进行<code>右旋</code>，转换到场景 5.3；<br><img src=\"/数据结构/Tree/Red09.jpeg\" alt=\"红黑树\"></li>\n</ul>\n<h2 id=\"删除-1\"><a href=\"#删除-1\" class=\"headerlink\" title=\"删除\"></a>删除</h2><p>删除分为两部：<br>1.二叉搜索树的删除(见⬆️述二叉搜索树)<br>2.红黑树的删除调整。<br><img src=\"/数据结构/Tree/Red10.jpg\" alt=\"红黑树\"><br><strong>R是即将被替换到删除结点的位置的替代结点，在删除前，它还在原来所在位置参与树的子平衡，平衡后再替换到删除结点的位置，才算删除完成。R最终可以看作是删除的</strong></p>\n<p><strong>删除情景1：替换结点是<code>红色</code>结点</strong><br>由于替换结点时红色，删除也了不会影响红黑树的平衡。<br>处理：颜色变为删除结点的颜色</p>\n<p><strong>删除情景2：替换结点是<code>黑结</code>点</strong><br>当替换结点是黑色时，我们就不得不进行自平衡处理了。我们必须还得考虑替换结点是其父结点的左子结点还是右子结点，来做不同的旋转操作，使树重新平衡。</p>\n<ul>\n<li><p><strong>删除情景2.1</strong>：替换结点是其父结点的左子结点</p>\n<ul>\n<li><strong>删除情景2.1.1</strong>：替换结点的<code>兄弟结点是红结点</code><br>若兄弟结点是红结点，那么根据性质4，兄弟结点的父结点和子结点肯定为黑色，按下图处理，得到删除情景<strong>2.1.2.3</strong><br>处理：<ul>\n<li>将S设为黑色</li>\n<li>将P设为红色</li>\n<li>对P进行左旋，得到情景2.1.2.3<br><img src=\"/数据结构/Tree/Red11.jpg\" alt=\"红黑树\"></li>\n</ul>\n</li>\n<li><strong>删除情景2.1.2</strong>：替换结点的<code>兄弟结点是黑结点</code><br>当兄弟结点为黑时，其父结点和子结点的具体颜色也无法确定,此时又得考虑多种子情景。<ul>\n<li><strong>删除情景2.1.2.1</strong>：替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色<br>即将删除的左子树的一个黑色结点，显然左子树的黑色结点少1了，然而右子树又有红色结点，那么我们直接向右子树“借”个红结点来补充黑结点就好啦，此时肯定需要用旋转处理了。<br>处理：<ul>\n<li>将S的颜色设为P的颜色</li>\n<li>将P设为黑色</li>\n<li>将SR设为黑色</li>\n<li>对P进行左旋<br><img src=\"/数据结构/Tree/Red12.jpg\" alt=\"红黑树\"><br>平衡后的图怎么不满足红黑树的性质？<br>前文提醒过，R是即将替换的，它还参与树的自平衡，平衡后再替换到删除结点的位置，所以R最终可以看作是删除的。<br>另外图2.1.2.1是考虑到第一次替换和自底向上处理的情况，如果只考虑第一次替换的情况，根据红黑树性质，SL肯定是红色或为Nil，所以最终结果树是平衡的。</li>\n</ul>\n</li>\n<li><strong>删除情景2.1.2.2</strong>：替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点<br>兄弟结点所在的子树有红结点，我们总是可以向兄弟子树借个红结点过来，显然该情景可以转换为情景2.1.2.1<br>处理：<ul>\n<li>将S设为红色，将SL设为黑色</li>\n<li>对S进行右旋，得到情景2.1.2.1<br><img src=\"/数据结构/Tree/Red13.jpg\" alt=\"红黑树\"></li>\n</ul>\n</li>\n<li><strong>删除情景2.1.2.3</strong>：替换结点的兄弟结点的子结点都为黑结点<br>此次兄弟子树都没红结点“借”了，兄弟帮忙不了，找父母呗，这种情景我们把兄弟结点设为红色，再把父结点当作替代结点，自底向上处理，去找父结点的兄弟结点去“借”。<br>但为什么需要把兄弟结点设为红色呢？<br>显然是为了在P所在的子树中保证平衡（R即将删除，少了一个黑色结点，子树也需要少一个），后续的平衡工作交给父辈们考虑了，还是那句，当每棵子树都保持平衡时，最终整棵总是平衡的。<br>处理：将S设为红色,把P作为新的替换结点,重新进行删除结点情景处理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>删除情景2.2</strong>：替换结点是其父结点的右子结点（和上述操作相反）</p>\n<ul>\n<li><strong>删除情景2.2.1</strong>：替换结点的<code>兄弟结点是红结点</code><br>处理：<ul>\n<li>将S设为黑色</li>\n<li>将P设为红色</li>\n<li>对P进行右旋，得到情景2.2.2.3<br><img src=\"/数据结构/Tree/Red14.jpg\" alt=\"红黑树\"></li>\n</ul>\n</li>\n<li><strong>删除情景2.2.2</strong>：替换结点的<code>兄弟结点是黑结点</code><ul>\n<li><strong>删除情景2.2.2.1</strong>：替换结点的兄弟结点的左子结点是红结点，右子结点任意颜色<br>处理：<ul>\n<li>将S的颜色设为P的颜色</li>\n<li>将P设为黑色</li>\n<li>将SL设为黑色</li>\n<li>对P进行右旋<br><img src=\"/数据结构/Tree/Red15.jpg\" alt=\"红黑树\"></li>\n</ul>\n</li>\n<li><strong>删除情景2.2.2.2</strong>：替换结点的兄弟结点的左子结点为黑结点，右子结点为红结点<br>处理：<ul>\n<li>将S设为红色</li>\n<li>将SR设为黑色</li>\n<li>对S进行左旋，得到情景2.2.2.1<br><img src=\"/数据结构/Tree/Red16.jpg\" alt=\"红黑树\"></li>\n</ul>\n</li>\n<li><strong>删除情景2.2.2.3</strong>：替换结点的兄弟结点的子结点都为黑结点<br>处理：<ul>\n<li>将S设为红色,把P作为新的替换结点,重新进行删除结点情景处理<br><img src=\"/数据结构/Tree/Red17.jpg\" alt=\"红黑树\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>综上，红黑树删除后自平衡的处理可以总结为：</p>\n<ul>\n<li>自己能搞定的自消化（情景1）</li>\n<li>自己不能搞定的叫兄弟帮忙（除了情景1、情景2.1.2.3和情景2.2.2.3）</li>\n<li>兄弟都帮忙不了的，通过父母，找远方亲戚（情景2.1.2.3和情景2.2.2.3）</li>\n</ul>\n<p>请画出下图的删除自平衡处理过程。<br><img src=\"/数据结构/Tree/Req18.jpg\" alt=\"红黑树\">       </p>\n<p>参考：<a href=\"https://www.jianshu.com/p/e136ec79235c\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/e136ec79235c</a></p>\n"},{"title":"面试必备","date":"2020-03-05T09:22:00.000Z","author":"Guyuqing","copyright":true,"comments":0,"password":12345,"_content":"\n# Java基础\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ 基础 ------------------------</span>\n</div>\n\n## 基础\n### JDK 和 JRE 有什么区别？\n* JDK：Java 开发工具包，提供了 Java 的开发环境和运行环境（包括JRE）。\n* JRE：Java 运行环境\n\n### == 和 equals 的区别是什么？\n* **==：** 基本类型：比较的是值是否相同；引用类型：比较的是引用的地址是否相同；\n* **equals**：equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较\n\n总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。\n\n### 为什么重写了equals方法，就要重写hashCode方法？\n不是必须，只是建议。虽然可以不重写hashCode，但是会对集合造成影响。\n比如hashMap，如果equals判断相同的key，但是hashCode不同，也就是内存中的地址不同，那么进行如下操作，就不会被覆盖，而是被put两次\nhashMap.put(\"k\",\"v1\")，hashMap.put(\"k\":\"v2\")\n\n###  final 在 Java 中有什么作用？\n* final 修饰的类叫最终类，该类不能被继承。\n* final 修饰的方法不能被重写。\n* final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。\n\n### Java基础的数据类型有哪些？\n基础类型有 8 种：byte、boolean、char、short、int、float、long、double\n\n### Java 中操作字符串都有哪些类？它们之间有什么区别？\n操作字符串的类有：String、StringBuffer、StringBuilder。\nString：\n    * 声明的是不可变的对象，它的底层是一个用final修饰的字符数组，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象\n    * String 对象赋值之后就会在字符串常量池中缓存，如果下次创建会判定常量池是否已经有缓存对象，如果有的话直接返回该引用给创建者。\nStringBuffer： 可以在原有对象的基础上进行操作，线程安全的，性能高于StringBuilder\nStringBuilder： 可以在原有对象的基础上进行操作，非线程安全的\n\n### String和StringBuilder 的区别？\njdk1.5：string 对象时恒定不变的,stringBuider对象表示的字符串是可变的。所以在字符串频繁修改的情况下stringBuider效率\njdk1.8: 编译器利用String的可变配套类(StringBuilder)帮我们做了优化，编译器自动调用StringBuilder.apend()方法添加。因此在拼接字符串小于500左右时，两个对象效率相同。\n\n\n### 接口和抽象类有什么区别？\n设计目的：\n    * 接口的设计目的，是对类的行为进行约束，也就是提供一种机制，可以强制要求不同的类具有相同的行为。\n    * 抽象类的设计目的，是代码复用。\n相同：\n    * 都不能被实例化\n    * 都能包含抽象的方法\n不同：\n    * 在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。\n    * 抽象类中的成员变量可以是各种类型的；而接口中的成员变量只能是public static final类型的；\n    * 抽象类可以有静态代码块和静态方法；接口中不能含有静态代码块以及静态方法\n    * 一个类只能继承一个抽象类，而一个类却可以实现多个接口。　　\n\n### 请列举你所知道的Object类的方法并简要说明。\n* getClass():用于返回当前运行时对象的Class对象\n* equals():用于比较两个对象的地址是否相同，即两个引用是否指向同一个对象；\n* clone():用于创建并返回当前对象的一份拷贝\n* toString():返回类的名字@实例的哈希码的16进制字符串；\n* notify():唤醒等待队列中的其中一个线程\n* notifyAll():唤醒线程等待队列中的所有线程；\n* wait(long timeout):让一个线程等待一段时间。\n* finalize()：用于释放资源，可以覆盖此方法实现资源清理工作。GC在回收对象之前调用该方法，但是无法确定该方法具体什么时候被调用\n\n### 类的加载顺序\n* 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)\n* 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )\n* 父类非静态代码块( 包括非静态初始化块，非静态属性 )\n* 父类构造函数\n* 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )\n* 子类构造函数\n\n### 对象在堆上要分配多大内存？\n1. java对象的属性---不固定\n2. 对象头---固定12 byte\n3. 数据对齐（64位虚拟机要求对象大小是8的整数倍，不够就补齐）\n\n64位jvm中，一个仅包含一个boolean属性的对象，大小是16 byte，12byte对象头，1byte数据，3byte填充数据\n\n### 对象有几种状态？\n1. 无状态 刚new出来的时候  biased_lock:0 | lock: 10\n2. 偏向锁 biased_lock:1 | lock: 10\n3. 轻量级锁\n4. 重量级锁\n5. 无引用，被gc标记\n\n### 什么是对象头？\n所有对象通用的一部分结构。\n由两部分组成：\n1. mark word \n    * 32 bits jvm 占 32 bits\n        * hashcode：25｜ age：4｜ biased_lock(偏向锁)：1 | lock(同步状态) : 2 \n    * 64 bits jvm 占 64 bits\n        * ![](Interview/head.png)\n        * 无状态下，在未调用过hashcode函数时，对象头hashcode位置都为0，调用过hashcode函数计算之后才会保存。\n2. klass pointer 指向类.class的指针\n    * 64 bits jvm 开启指针压缩占 32 bits 不开启占 64 bits\n    \n### 解释一下对象创建过程？\n假设有一个对象T,有一个属性m=8，那么在new 这个对象时先在堆中申请空间，\n然后属性半初始化也就是m=0，然后再调用构造方法将m修改为8，然后将引用变量t指向堆中的地址。\n\n### DCL与volatile的问题？\nvolatile 的作用是线程的可见性和禁止了指令重排序。\n在单例模式中，未了保证多线程的安全性，采用了DCL（Double-Check-Locking）方式，\n那么在线程1创建对象X的时候，对象先半初始化，再调用构造方法，线程2再去判断X对象等不等于空，\n如果此时发生指令重排序，对象先半初始化，线程2再去判断X对象等不等于空，再调用构造方法，会导致线程2拿到了半初始化的对象。\n所以需要volatile来禁止指令重排。\n\n### 对象在内存中的存储布局？\n对象头、实例数据和对齐填充\n\n### 对象怎么定位？\n引用->堆内存的对象->方法区常量。\n\n### 对象怎么分配？\n开始new一个对象\n    *尝试在栈上分配？\n        * 可以在栈上分配，在pop时结束生命周期\n        * 若一个对象的引用逃出了方法或者线程，在方法调用过程中传递对象的引用到另一个方法，或栈空间不够大。则不能在栈上分配。\n            * 对象是否够大？\n                * 足够大，老年代分配，full gc时结束生命周期\n                * 不够大，尝试 tlab 分配？\n                    * tlab空间是否足够？\n                        * 足够，tlab（线程本地空间）分配到eden，\n                        * 不足，共享空间分配到eden\n                    * young gc-> 幸存者区-> 老年代-> full gc 结束生命周期\n                    \n一般的对象分配内存，都是在新生代进行空间申请的。在多个线程都在申请空间时，每次对象分配都必须进行同步。竞争激烈的场合分配的效率又会进一步下降。TLAB是一个存在于eden区的线程独享内存区域，主要用于降低在新生代分配对象时的内存竞争，提升对象分配的效率。\n      \n\n### Object o = new Object() 在内存中占多少字节？\n对象的引用o 4 byte\nObject 的 mark word 占 8 byte\nklass pointer 若开启指针压缩占 4 byte，不开启压缩占 8 byte\n对象的属性大小不确定。\n\n\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ 集合 ------------------------</span>\n</div>\n\n## 集合\n\n###  HashSet 的底层实现是什么?\nHashSet 的实现是依赖于 HashMap 的，HashSet 的值都是存储 在 HashMap 中的。在 HashSet 的构造法中会初始化一个 HashMap 对象\nHashSet 不允许值重复，因此，HashSet 的值是作为 HashMap 的 key 存储在 HashMap 中的，当存储的值已经存在时返回 false。\n\n###  Iterator 和 ListIterator 的区别是什么?\n* Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。\n* Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。\nListIterator 实现了 Iterator 接口，并包含其他的功能，比如:增加元素，替换元 素，获取前一个和后一个元素的索引，等等。\n\n### 数组 (Array) 和列表 (ArrayList) 有什么区别?\n* Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。\n* Array 大小是固定的，ArrayList 的大小是动态变化的。\n* ArrayList 处理固定大小的基本数据类型的时候，这种方式相对比较慢。\n\n###  Comparable 和 Comparator 接口是干什么的?\n**Comparable**：只包含一个 compareTo() 方法，这个方法可以个 给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于 已经存在的对象。\n**Comparator**：包含 compare() 和 equals() 两个方法。\n    * compare() 方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小 于，等于，大于第二个参数。\n    * equals() 方法需要一个对象作为参数，它用来决定输入 参数是否和 comparator 相等。\n    \n### Collection 和 Collections 的区别？\n**Collection**：是集合类的上级接口, 继承与它的接口主要是 set 和 list。\n**Collections**： 类是针对集合类的一个帮助类. 它提供一系列的静态方法对各种集合的搜 索, 排序, 线程安全化等操作。\n\n### ArrayList 和 Vector 的区别？\n**相同**：\n    * 都实现了 List 接口(List 接口继承了 Collection 接口)\n    * 都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组\n    * 允许重复\n\n**区别**：\n    * Vector 是线程安全的，ArrayList 是线程序不安全的。\n**数据增长**:\n    * 相同：ArrayList 与 Vector 都可以设置初始的空间大小\n    * 不同：Vector 还可以设置增长的空间大小，而 ArrayList 没有提供设置增长空间的方法。\n           Vector 默认增加原来的 1 倍，ArrayList 增加原来的 0.5 倍。\n           \n### 快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么?\nIterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。\n\njava.util 包下面的所有的集合类都是快速失败的，迭代器会抛出 ConcurrentModificationException 异常\njava.util.concurrent 包下面的所有的类都是安全失败的。安全失败的迭代器永远不会抛出这样的异常。\n\n\n    \n### List、Map、Set 三个接口，存取元素时，各有什么特点?\n这样的题属于随意发挥题:这样的题比较考水平，两个方面的水平:一是要真正明白 这些内容，二是要有较强的总结和表述能力。如果你明白，但表述不清楚，在别人那 里则等同于不明白。\n\n首先List与Set\n相同：\n    * 都是单列元素的集合，有一个相同的父类 Collection\n不同：\n    * List 元素可以重复，Set不可以\n    * List 可以按index取元素，Set只能逐一遍历\n    * List 是有序集合。\n\nMap 是双列集合，要存储一对 key/value，不能存储重复的 key。\n\n###  HashMap 的工作原理是什么?\nHashMap 1.8是 **数组 + 链表 + 红黑树** 实现的。\n* 负载因子（loadFactor）：0.75f\n* 容量（capacity）：16\n* 扩容阈值（threshold）：loadFactor * capacity\n* 转化成树的链表阈值（TREEIFY_THRESHOLD）：8\n* 转化成树的最小容量（MIN_TREEIFY_CAPACITY）：64\nJava 中的 HashMap 是以键值对 (key-value) 的形式存储元素的，我们把一对(key-value)称为Node。\nHashMap 需要 一个 hash 函数，当调用 put() 方法的时候，HashMap 会计算 key 的 hash 值，然后把键值对存储在集合中合适的索引上。 \n如果索引上已经存在了Node，发生哈希冲突。\n    * 如果索引上的结构是**链表**，则在链表中遍历，如果有相同的key，value 会被更新成新值，否则遍历到链表尾部，插入新的(key-value) ，size+1\n        * 如果链表的长度大于**转化成树的链表阈值（TREEIFY_THRESHOLD）** 并且，hashMap的容量大于**转化成树的最小容量（MIN_TREEIFY_CAPACITY）** 则转换成`红黑树`。\n    * 如果索引上的结构是**红黑树**，则在红黑树中遍历，如果有相同的key，value 会被更新成新值，否则插入红黑树，size+1。\n    \n如果 size > threshold 则进行扩容。\n    * 当原来的容量已经达到最大容量的时候，将阈值设置为Integer.MAX_VALUE，这样就不会再发生重构的情况\n    * 将新的阈值设置为旧的阈值的两倍, 新的容量设置为旧容量的2倍。\n    * 根据新容量新建一个Node数组，将旧数组中的元素全部取出，重新映射到新数组中\n    \n### hashMap 容量为什么是 2 的幂次？\n为了**加快哈希计算**以及**减少哈希冲突**。\n为什么可以加快计算？\n我们都知道为了找到 KEY 的位置在哈希表的哪个槽里面，需要计算 **hash(KEY) % 数组长度**\n但是 % 计算比 & 慢很多，所以用 & 代替 %，为了保证 & 的计算结果等于 % 的结果需要把 length 减 1，也就是 **hash(KEY) & (length - 1)**\n证明：当length 为2的幂次时，m % length = m & (length-1)\n     m 可以分成两部分 x（length的正数倍） 和 y（剩余部分） 因此 y的范围为 0 <= y <length\n     m % length = (x + y)% length = x % length + y % length = 0 + y % length = y\n     假设y 是 5 二进制 0101，length 为 8 二进制 1000 ，length -1 二进制 0111\n     0101&0111 = 0101 刚好将 5取出，因此成立\n\n为什么可以减少冲突？\n假设现在数组的长度 length 可能是偶数也可能是奇数。\nlength 为偶数时，length-1 为奇数，奇数的二进制最后一位是 1，这样便保证了 hash &(length-1) 的最后一位可能为 0，也可能为 1（这取决于 h 的值），即 & 运算后的结果可能为偶数，也可能为奇数，**这样便可以保证散列的均匀性。**\nlength 为奇数的话，很明显 length-1 为偶数，它的最后一位是 0，这样 hash & (length-1) 的最后一位肯定为 0，即只能为偶数，这样任何 hash 值都只会被散列到数组的偶数下标位置上，这便**浪费了近一半的空间**\n\n    \n### ConcurrentHashMap 的工作原理是什么什么？\n* JDK1.7:\n    ConcurrentHashMap采用了**数组+Segment+分段锁**的方式实现。\n    Segment：类似于HashMap的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表,同时又是一个ReentrantLock（Segment继承了ReentrantLock）。\n    ![](Interview/concurrentHashMap1.7.jpg)\n    从上面的结构我们可以了解到，ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作。\n    第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部。\n* JDK1.8:\n    采用了数组+链表+红黑树实现.**彻底放弃了Segment转而采用的是Node，其设计思想也不再是JDK1.7中的分段锁思想。**\n    Java8 ConcurrentHashMap结构基本上和Java8的HashMap一样，原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。\n\n### HashTable 、ConcurrentHashMap 和 hashMap 的区别？\nhashTable 默认初始容量是11，hashMap 和 ConcurrentHashMap 默认初始容量是16，\nHashTable 在put和get方法上用了 synchronized 。ConcurrentHashMap 对每个node节点使用 synchronized\n\n### LinkedHashMap 工作原理？\nLinkedHashMap基于hashMap的基础上，对每个键值对(Node节点)多维护了一个before和after指针，每次插入时维护双向链表。\nLinkedHashMap有序，可分为插入顺序和访问顺序两种。\n如果是访问顺序，那put和get操作已存在的Entry时，都会把Entry移动到双向链表的表尾(其实是先删除再插入)。\n\n### TreeMap 工作原理？\n底层红黑树实现。\nTreeMap有序是通过Comparator来进行比较的，如果comparator为null，那么就使用自然顺序\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ 异常 ------------------------</span>\n</div>\n\n## 异常\n### Java中的异常有哪几类？\n异常类有分为编译时异常和运行时异常\n常见的编译时异常：\n    * IOException\n    * SQLException\n    * parseException\n    \n常见的运行时异常（RuntimeException）：\n    * NullPointerException: 空指针异常,一般出现于数组,空对象的变量和方法\n    * ArrayIndexOutOfBoundsException: 数组越界异常\n    * NoClassDefFoundException: java运行时系统找不到所引用的类\n    * NumberFormatException: 数据格式异常\n    * OutOfMemoryException: 内存溢出异常\n    * ArithmeticException: 算数异常,一般在被除数是0中\n    * IllegalArgumentException: 非法参数异常\n    \n\n### Error 和 Exception 区别是什么？\nError 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；\nException 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。\n\n### 运行时异常和编译时异常区别是什么？\n运行时异常：编译器不会对运行时异常进行检测，没有 try-catch，方法签名中也没有 throws 关键字声明，编译依然可以通过。如果出现了 RuntimeException, 那一定是程序员的错误\n编译时异常：如果没有 try-catch，且方法签名中也没有用 throws 关键字声明可能抛出的异常，则编译无法通过。这类异常通常为应用环境中的错误，即外部错误，非应用程序本身错误，如文件找不到等。\n\n### throw 和 throws 的区别是什么？\n**throw** 关键字用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。\n**throws** 关键字用在方法签名处，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。\n\n\n### Java内存溢出是什么？\n内存溢出分三种情况。\n* OutOfMemoryError： PermGen space 元空间\n    这个区域主要用来保存加来的Class的一些信息，在程序运行期间属于永久占用的，Java的GC不会对他进行释放，所以如果启动的程序加载的信息比较大，超出了这个空间的大小，就会发生溢出错误；\n    解决的办法无非就是增加空间分配了——增加java虚拟机中的XX:PermSize和XX:MaxPermSize参数的大小，其中XX:PermSize是初始永久保存区域大小，XX:MaxPermSize是最大永久保存区域大小。\n* OutOfMemoryError：Java heap space \n    heap 是Java内存中的堆区，主要用来存放对象，当对象太多超出了空间大小，GC又来不及释放的时候，就会发生溢出错误。\n    一般来说，当已存在对象没有引用(即不可达)的时候，GC就会定时的来回收对象，释放空间。但是因为程序的设计问题，导致对象可达但是又没有用(即前文提到的内存泄露)，当这种情况越来越多的时候，问题就来了。\n    针对这个问题，我们需要做一下两点： 1、检查程序，减少大量重复创建对象的死循环，减少内存泄露。 2、增加Java虚拟机中Xms（初始堆大小）和Xmx（最大堆大小）参数的大小。\n* StackOverFlowError\n    stack是Java内存中的栈空间，主要用来存放方法中的变量，参数等临时性的数据的，发生溢出一般是因为分配空间太小，或是执行的方法递归层数太多创建了占用了太多栈帧导致溢出。\n    针对这个问题，除了修改配置参数-Xss参数增加线程栈大小之外，优化程序是尤其重要。\n\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ 反射 ------------------------</span>\n</div>\n\n## 反射\n### 什么是反射？\n反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；\n这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。\n\n\n### 什么是 Java 序列化？什么情况下需要序列化？\nJava 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。\n以下情况需要使用 Java 序列化：\n* 想把的内存中的对象状态保存到一个文件中或者数据库中时候；\n* 想用套接字在网络上传送对象的时候；\n* 想通过RMI（远程方法调用）传输对象的时候。\n\n\n### 动态代理是什么？有哪些应用？\n动态代理是运行时动态生成代理类。\n\n动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。\n\n### 怎么实现动态代理？\nJDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。\n\n### JDK 动态代理为什么只能基于接口？\njava的代理对象自动继承了Proxy，又因为JAVA是单继承的，所以目标对象只能实现接口不能继承。\n    \n    \n\n\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ JVM ------------------------</span>\n</div>\n\n## JVM\n### 什么是JVM？什么是hotspot？\nJVM ------- 规范/标准\nhotspot --- 产品/实现\n\n### 说一下 JVM 的主要组成部分？及其作用？\n![](Interview/1.png)\n* 类加载器（ClassLoader）\n* 运行时数据区（Runtime Data Area）\n* 执行引擎（Execution Engine）\n* 本地库接口（Native Interface）\n\n组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，\n           运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，\n           因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，\n           而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。\n\n### 说一下类装载的执行过程？\n![](Interview/2.png)\n类装载分为以下 5 个步骤：\n1. **加载**：将.class文件从磁盘读到内存\n    * 通过类的全限定名(com.xxx.xxx)+类加载器确定唯一的类，来获取定义此类的二进制字节流\n    * 将这个类字节流代表的静态存储结构转为方法区的运行时数据结构\n    * 在堆中生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口。\n2. **检查**：检查加载的 class 文件的正确性；\n    * 文件格式验证:验证字节流是否符合 Class 文件的规范，如 主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.\n    * 元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。\n    * 字节码验证:是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如:方法中的类型转换是否正确，跳转指令是否正确等。\n    * 符号引用验证:基于方法区的存储结构验证，发生在解析中，是否可以将符号引用成功解析为直接引用。\n3. **准备**：给类中的静态变量分配内存空间；\n    * public static int value = 123; //此时在准备阶段过后的初始值为0而不是123，在初始化过程才会被赋值为123\n    * public static final int value = 123;//value的值在准备阶段过后就是123。\n4. **解析**：虚拟机将常量池中的符号引用替换成直接引用的过程。**符号引用就理解为一个标示，而在直接引用直接指向内存中的地址**；\n5. **初始化**：对静态变量和静态代码块执行初始化工作。\n\n\n### 类加载器的种类？\n![](Interview/3.png)\n* 启动类加载器(Bootstrap ClassLoader)：负责加载JRE的核心类库，如JRE目标下的rt.jar，charsets.jar等\n* 扩展类加载器(Extension ClassLoader)：负责加载JRE扩展目录ext中jar类包\n* 系统类加载器(Application ClassLoader)：负责加载ClassPath路径下的类包\n* 用户自定义加载器(User ClassLoader)：负责加载用户自定义路径下的类包\n\n### 什么是双亲委派模型？\n![](Interview/4.png)\n如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。\n           \n### 双亲委派模式的优势?\n* 沙箱安全机制:比如自己写的String.class类不会被加载，这样可以防止核心库被随意篡改\n* 避免类的重复加载:当父ClassLoader已经加载了该类的时候，就不需要子ClassLoader再加载一次   \n\n### 为什么要打破双亲委派模式?\n例如：tomcat \nTomcat是个web容器,可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。 \n如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加载器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。\n           \n###  JVM 运行时数据区？\n![](Interview/5.png)\n* 程序计数器（Program Counter Register）: 前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；\n* Java 虚拟机栈（Java Virtual Machine Stacks）: 用于存储局部变量表、操作数栈、动态链接、方法出口等信息；\n* 本地方法栈（Native Method Stack）: 与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；\n* Java 堆（Java Heap）: Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；\n* 方法区（Methed Area）: 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。\n\n\n### Java 中都有哪些引用类型？\n* 强引用：通常我们使用new操作符创建一个对象时所返回的引用即为强引用\n* 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。\n* 弱引用：有用但不是必须的对象，在下一次GC时会被回收。\n* 虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。\n\n### Java 堆的结构是什么样子的?\n![](Interview/6.jpeg)\n堆空间一般分为新生代、老年代。\n\n### 什么是新生代？\n新生代分为两部分:`伊甸区`(Eden space)和`幸存者区`(Survivor space)，所有的类都是在伊甸区被new出来的。\n幸存区(Survivor space):分为From和To区,TO区永远保持空。\n当Eden区的空间用完是，程序又需要创建对象，JVM的垃圾回收器将Eden区进行垃圾回收(`Minor GC`)，将Eden区中的不再被其它对象应用的对象进行销毁。\n然后将Eden区中剩余的对象移到From Survivor区。若From Survivor区也满了，再对该区进行垃圾回收，然后移动到To Survivor区，From区为空后，将To和From区转换，保证To区为空，并且对象年龄加一。\n当对象年龄默认加到15（因为**对象头只有4个bits**是存对象年龄，最大为15）时将剩下的对象移到老年代。\n\n### 什么是老年代？\n新生代经过多次GC仍然存货的对象移动到老年区。\n若老年代也满了，这时候将发生Major GC(也可以叫`Full GC`)， 进行老年区的内存清理。\n若老年区执行了Full GC之后发现依然无法进行对象的保存，就会抛出 OOM(OutOfMemoryError)异常.\n\n### Survivor区 到 老年代有什么条件？\n对象年龄到15，才会移动到老年代。因为**对象头只有4个bits**是存对象年龄，最大为15\n\n### JVM 有哪些垃圾回收算法？\n* **标记-清除算法**：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。\n* **标记-整理算法**：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。\n* **复制算法**：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。\n* **分代算法**：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。\n\n### JVM 有哪些垃圾回收器？\n* Serial：最早的单线程串行垃圾回收器。**新生代采用复制算法，老年代采用标记-整理算法。**\n* Serial Old：Serial 垃圾回收器的老年代版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。采用**标记-整理**算法。\n* ParNew：是 Serial 的多线程版本。**新生代采用复制算法，老年代采用标记-整理算法。**\n* Parallel： 是 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。**新生代采用复制算法，老年代采用标记-整理算法。**\n* Parallel Old： 是 Parallel 老年代版本，，Parallel Old 使用的是**标记-整理**的内存回收算法。\n* CMS：一种以获得最短停顿时间为目标的收集器，第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作。是一种**标记-清除**算法实现\n    * 初始标记(CMS initial mark): 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 \n    * 并发标记(CMS concurrent mark): **同时开启GC和用户线程**，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\n    * 重新标记(CMS remark): 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶 段时间短\n    * 并发清除(CMS concurrent sweep): 开启用户线程，同时GC线程开始对为标记的区域做清扫。\n* G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。G1从整体来看是基于**标记整理**算法实现的收集器;从局部上来看是基于**标记复制**算法实现的\n\n### 堆栈的区别？\n* 功能方面：堆是用来存放对象的，栈是用来执行程序的。\n* 共享性：堆是线程共享的，栈是线程私有的。\n* 空间大小：堆大小远远大于栈。\n\n### 怎么判断对象是否可以被回收？\n**引用计数器**：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；\n**可达性分析**：这个算法的基本思想就是通过一系列的称为\"GC Roots\"的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象时不可用的。\n    * `GC Roots根节点`:类加载器、Thread、虚拟机栈的局部变量表、static成员、常量引用、本地方法栈的变量等等.\n\n\n### JVM 调优的工具？\nJDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。\n* jconsole：用于对 JVM 中的内存、线程和类等进行监控；\n* jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。\n\n### JVM 调优的参数都有哪些？\n-Xms2g：初始化推大小为 2g；\n-Xmx2g：堆最大内存为 2g；\n-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；\n-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；\n–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；\n-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；\n-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；\n-XX:+PrintGC：开启打印 gc 信息；\n-XX:+PrintGCDetails：打印 gc 详细信息。\n\n### Java 中会存在内存泄漏吗？\n所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。\n长生命周期的对象持有短生命周期对 象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需 要，但是因为长生命周期对象持有它的引用而导致不能被回收。\n\n### finalize() 方法什么时候被调用?\n垃圾回收器(garbage colector)决定回收某对象时，就会运行该 对象的 finalize() 方法 但是在 Java 中很不幸，如果内存总是充 足的，那么垃圾回收可能永远不会进行，也就是说 filalize() 可能 永远不被执行，显然指望它做收尾工作是靠不住的。 那么 finalize() 究竟是做什么的呢? 它最主要的用途是回收特殊渠道申请的内存。Java 程序有垃圾回收器，所以一般情况下内存问题 不用程序员操心。但有一种 JNI(Java Native Interface)调用 non-Java 程序(C 或 C++)， finalize() 的工作就是回收这部分的内存。\n\n### 深拷贝和浅拷贝区别是什么？\n* 浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制，指向同一个地址。\n* 深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。\n\n###  如何实现对象克隆？\n* 实现 Cloneable 接口并重写 Object 类中的 clone() 方法。\n* 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ 多线程 ------------------------</span>\n</div>\n\n## 多线程\n\n### 什么是线程安全？\n如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 \n\n### 如何保证线程安全？\n* synchronized关键字 \n* 用Lock锁\n* volatile+CAS【单纯的volatile是轻量级的同步机制**保证可见性但是不具备原子性**所以要配合CAS来实现线程安全】\n* atomic原子类\n\n###  哪些集合类是线程安全的？\nVector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。\n\n### 并行和并发有什么区别?\n* 并行：多个处理器或多核处理器同时处理多个任务。( 两个队列和一台咖啡机 )\n* 并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。( 两个队列和两台咖啡机 )\n\n### 线程和进程的区别?\n一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。\n\n### 守护线程是什么?\n守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。\n\n### 创建线程有哪几种方式?\n* 继承 Thread 重写 run 方法；\n* 实现 Runnable 接口；\n* 实现 Callable 接口。(可以获取线程执行之后的返回值)\n* 线程池\n\n### Runnable和Callable的区别?\n* Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。\n* Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。\n* call方法可以抛出异常，run方法不可以。\n* 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。\n\n### 线程有哪些状态?\n* NEW 尚未启动\n* RUNNABLE 正在执行中\n* BLOCKED 阻塞的（被同步锁或者IO锁阻塞）\n* WAITING 永久等待状态\n* TIMED_WAITING 等待指定的时间重新被唤醒的状态\n* TERMINATED 执行完成\n\n![](Interview/01.jpeg)\n\n### sleep() 和 wait() 有什么区别?\n* 类的不同：sleep() 来自 Thread，wait() 来自 Object。\n* 释放锁：sleep() 不释放锁；wait() 释放锁。\n* 用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。\n\n### sleep() 和 yield() 区别？\n* sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield() 方法只会给相同优先级或更高优先级的线程以运行的机会； \n* 线程执行 sleep() 方法后转入阻塞（blocked）状态，而执行 yield() 方法后转入就绪（Runnable）状态； \n* sleep() 方法声明抛出InterruptedException，而 yield() 方法没有声明任何异常； \n* sleep() 方法比 yield() 方法（跟操作系统相关）具有更好的可移植性。\n\n### notify()和 notifyAll()有什么区别？\n* notifyAll: 会唤醒所有的线程,会将全部线程由等待池移到锁池,然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争\n* notify: 唤醒一个线程,具体唤醒哪一个线程由虚拟机控制。\n\n### 线程的 run() 和 start() 有什么区别？\nstart() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。\n\n### park() 的作用\nLockSupport类中的 park(Object blocker) 表示**阻塞指定线程**，参数blocker当前线程对象，使线程进入等待状态，释放cpu,并不会抛出中断异常\nunpark(Thread thread) 唤醒指定线程，参数thread指定线程对象 \n\n\n### `创建线程池有哪几种方式？`\n1. public static ExecutorService newCachedThreadPool() 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程，但是在之前构造的线程可用时将重用它们。\n2. public static ExecutorService newFixedThreadPool(int nThreads)  创建一个定长线程池，可控制线程最大并发数，以共享的无界队列方式来运行线程，超出的线程会在队列中等待。\n3. public static ExecutorService newSingleThreadExecutor() 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，以无界队列方式来运行线程，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n4. public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 创建一个周期线程池，支持定时及周期性任务执行。\n5. public static ExecutorService newWorkStealingPool() 创建持有足够线程的线程池来支持给定的并行级别，并通过使用多个队列，减少竞争，它需要穿一个并行级别的参数，如果不传，则被设定为默认的CPU数量，这个线程池实际上是ForkJoinPool的扩展，适合使用在很耗时的任务中，能够合理的使用CPU进行并行操作。\n\n### 线程池流程？\n![](Interview/threadPoll.png)\n\n### 线程池中 submit() 和 execute() 方法有什么区别？\n* execute()：只能执行 Runnable 类型的任务。\n* submit()：可以执行 Runnable 和 Callable 类型的任务。\n\n### 什么是CAS？\n全称Compare and swap，比较并交换。\nCAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存值修改为 B \njava 的 CAS 利用的的是 unsafe（该类都是基于JVM对操作系统进行的操作，因此是unsafe）这个类提供的 CAS 操作\nunsafe 的CAS 依赖了的 JVM 针对不同的操作系统实现的 Atomic::cmpxchg\nAtomic::cmpxchg 的实现使用了汇编的 cas 操作，并使用 cpu 硬件提供的 lock信号保证其原子性\n\n### CAS有什么问题？\nABA问题。\n举个例子：\n假设有一个遵循CAS原理的提款机，小灰有100元存款，要用这个提款机来提款50元。\n由于提款机硬件出了点小问题，小灰的提款操作被同时提交两次，开启了两个线程，两个线程都是获取当前值100元，要更新成50元。\n理想情况下，应该一个线程更新成功，另一个线程更新失败，小灰的存款只被扣一次。\n线程1首先执行成功，把余额从100改成50。线程2因为某种原因阻塞了。这时候，小灰的妈妈刚好给小灰汇款50元。\n线程2仍然是阻塞状态，线程3执行成功，把余额从50改成100。\n线程2恢复运行，由于阻塞之前已经获得了“当前值”100，并且经过compare检测，此时存款实际值也是100，所以成功把变量值100更新成了50。\n小灰凭空少了50元钱。\n\n解决方案：\n使用携带版本的号的AtomicStampedReference\n\n### 什么是AQS？\nAbstractQueuedSynchronizer，抽象队列同步器\nAQS就是一个并发包的基础组件，是一个抽象类，用来实现各种锁，各种同步组件的。\n它包含了state变量、加锁线程、等待队列等并发中的核心组件。常见的实现类有:ReentrantLock等。\n\n### AQS原理？\n* AQS对象内部有一个核心的变量叫做**state**，是int类型的，代表了加锁的状态，初始状态下，这个state的值是0。\n* AQS内部还有一个关键变量，用来记录**当前加锁的是哪个线程**，初始化状态下，这个变量是null。\n* AQS内部还有一个**等待队列**，专门放那些加锁失败的线程\n\n当 线程1 尝试进行加锁，用CAS操作将state值从0变为1。如果CAS操作成功，将当前加锁线程设置成自己。\n线程1 **可重入加锁时，每次判断当前加锁线程是否是自己，是的话state+1**\n当 线程2 尝试获取锁，用CAS操作将state值从0变为1，失败！！！然后检查当前加锁线程是否是自己，那当然不是。\n线程2 会将自己放入AQS中的一个等待队列，等待 线程1 释放锁之后，自己就可以重新尝试加锁了。\n线程1 释放锁就是将state变量的值递减1，将当前加锁线程设置成null。\n接下来，会从**等待队列的队头唤醒** 线程2 重新尝试加锁。\n重复上述过程。\n\n### ReentrantLock 原理？\nReentrantLock 可是分为公平锁和非公平锁，默认的构造函数是非公平锁\n公平锁：当判断到锁状态字段state == 0 时，不会立马将当前线程设置为该锁的占用线程，而是去判断是在此线程之前是否有其他线程在等待这个锁，然后再CAS操作获取锁\n非公平锁：没有判断是否有在此之前的排队线程，而是直接CAS操作进行获锁，此多个线程之间同时争用一把锁的时候，谁先获取到就变得随机了\n加锁过程：\n线程A，首先获取state的值判断是否为0，若state == 0。\n    * 判断是自己是否需要排队\n        * 若需要排队，也就是 队列的 head != tail 也就是队列已初始化了 并且 （head.next !=null 或 head.next.thread != 当前线程）\n            * 将head.next 指向A，A.pre 指向head。\n            * 判断A是否是排队的第一个线程\n        * 若不需要排队，尝试进行加锁，用CAS操作将state值从0变为1。\n            * 如果CAS操作成功，将当前加锁线程设置成自己。\n            * 如果CAS操作失败，会检查当前加锁线程是否是自己。\n                * 若是当前线程，就是重入锁，将state++。\n                * 若不是当前线程，将线程放入等待队列。\n                    * 如果队列为空，初始化一个thread=null的node作为队列的头head，将head.next 指向A，A.pre 指向head。\n            * 判断A是否是排队的第一个线程\n                * 如果A.pre == head ,表示A是排队的第一个线程，自旋两次尝试加锁，将A.pre 的ws值改为-1，若还失败则使用park()进行线程阻塞。\n                * 如果不是，则直接使用park()进行线程阻塞。\n\n释放锁：\n将state变量的值递减1，如果state == 0，将当前加锁线程设置成null。\n如果队列不为空，将队列的head节点的ws值改为0，然后用unpark()唤醒 head.next也就是A线程，\n然后将队列的head设置为A，A节点的thread设置为null。\n\n\n\n\n### 什么是锁？\n锁(lock)或互斥(mutex)是一种同步机制，用于在有许多执行线程的环境中强制对资源的访问限制。锁旨在强制实施互斥排他、并发控制策略。\n锁的作用就是保证多线程同步执行。\n\n\n### Java中有哪些锁？\n公平锁、非公平锁、读写锁、共享锁、互斥锁、自旋锁、偏向锁、轻量级锁、重量级锁等等。\n\n### 什么是死锁？\n线程A持有独占锁资源a，并尝试去获取独占锁资源b\n同时，线程B持有独占锁资源b，并尝试去获取独占锁资源a\n这样线程A和线程B相互持有对方需要的锁，从而发生阻塞，最终变为死锁。\n\n### 死锁发生的必要条件？\n* 互斥条件：一个资源每次只能被一个进程使用。\n* 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。\n* 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。\n* 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。\n\n### 怎么防止死锁？\n* 尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。\n* 尽量使用 Java. util. concurrent 并发类代替自己手写锁。\n* 尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。\n* 尽量减少同步的代码块。\n\n### 当一个线程进入一个对象的一个 synchronized 方法后，其它线程是否可进入此对象的其它方法?\n* 其他方法前是否加了 synchronized 关键字，如果没加，则能。\n* 如果这个方法内部调用了 wait，则可以进入其他 synchronized 方法。\n\n### synchronized(l){XX}是锁了代码块还是对象？怎么实现？\n锁了对象l，那么是对l做了什么来表示l被锁了呢？上锁就是改变了对象头。\n\n### 线程调度(优先级)\n与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线 程获取 CPU 资源的概率较大，优先级低的并非没机会执行。\n线程的优先级用 1-10 之 间的整数表示，数值越大优先级越高，默认的优先级为 5。 在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。\n\n### 什么是线程饥饿？\n线程饥饿是另一种活跃性问题，也可以使程序无法执行下去。\n如果一个线程因为处理器时间全部被其他线程抢走而得不到处理器运行时间，这种状态被称之为`饥饿`\n一般是由高优先级线程吞噬所有的低优先级线程的处理器时间引起的。\n\n### 什么是活锁？\n这两个线程虽然都没有停止运行，但是却无法向下执行，这种情况就是所谓的活锁。\n举个例子，两个人在走廊上碰见，大家都互相很有礼貌，互相礼让，A从左到右，B也从从左转向右，发现又挡住了地方，继续转换方向，但又碰到了，反反复复，一直没有机会运行下去。\n* 当所有线程在序中执行 Object.wait(0)，参数为 0 的 wait 方法。程序将发生 活锁直到在相应的对象上有线程调用 Object.notify() 或者 Object.notifyAll()。\n\n### Volatile关键字的作用？\n让其他线程能够马上感知到某一线程多某个变量的修改\n* 保证可见性:对共享变量的修改，其他的线程马上能感知到\n* 保证有序性:禁止重排序（编译阶段、指令优化阶段）volatile之前的代码不能调整到他的后面，volatile之后的代码不能调整到他的前面\n\n### volatile 能使得一个非原子操作变成原子操作吗?\n在 Java 中除了 long 和 double 之外的所有基本类型的读和赋值，都是原子性操作。\n而 64 位的 long 和 double 变量由于会被 JVM 当作两个分离的 32 位来进行操 作，所以不具有原子性，会产生字撕裂问题。但是当你定义 long 或 double 变量时， 如果使用 volatile 关键字，就会获到**(只有简单的赋值与返回操作的)**原子性。\n不能保证其他情况的原子性。\n\n###  synchronized 和 volatile 的区别是什么？\n* volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。\n* volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。\n* volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。\n\n### synchronized 和 Lock 有什么区别？\n* synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。\n* synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。\n* 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。\n\n### synchronized 和 ReentrantLock 区别是什么？\n* ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；\n* ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；\n* ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。\n\n性能区别：由于线程执行是交替执行。\njdk1.6 synchronized 是重量级锁，要频繁调用操作系统函数，交替执行，从用户态转到内核态效率低。\njdk1.8 synchronized 增加了偏向锁和轻量级锁，也是在jdk层面解决，所以和 ReentrantLock 性能差不多。\nReentrantLock 将线程交替执行放到jdk层面解决，所以比1.6的synchronized效率高\n如果线程是单线程或者线程是交替执行，那么ReentrantLock队列不会进行初始化，不会发送阻塞，都在jdk层面运行。而1.6 synchronized需要调用os操作更改锁对象状态，然后进入同步块。\n\n###  synchronized 底层实现原理？\nsynchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。\n\n### 什么是Monitor？\nMonitor其实是一种同步工具，也可以说是一种同步机制，它通常被描述为一个对象,也常被翻译为“监视器\\管程”,每个对象都会有一个 monitor\n* 某一线程占有一个对象的时候，先看该对象的 monitor 的计数器是不是0，如果是0表示这个对象还没有线程占有，这个时候线程占有这个对象，并且对这个对象的monitor+1；如果不为0，表示这个对象已经被其他线程占有，这个线程等待。当线程释放占有权的时候，monitor-1；\n* 同一线程可以对同一对象进行多次加锁，+1，+1，体现了重入性\n\n### 多线程中 synchronized 锁升级的原理是什么？\n在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。\n\n### 什么是偏向锁？\n当线程请求到锁对象后，将锁对象的状态标志位改为01，即偏向模式。然后使用CAS操作将线程的threadid记录在锁对象的Mark Word中。以后该线程可以直接进入同步块，连CAS操作都不需要。但是，一旦有第二条线程需要竞争锁，那么偏向模式立即结束，进入轻量级锁的状态。\n\n### 什么是轻量级锁？\n从偏向锁的状态发生竞争后，会锁膨胀变成轻量级锁。\n轻量级锁是在内存有一个锁记录，当某个线程获取到锁后，会将锁记录保存到线程内存中，同时将原本的锁记录指向它的线程内存中的备份锁记录位置。其他线程判断锁记录已经指向了其他线程，因此会进入自旋状态。达到一定的次数或时间后，会膨胀变成重量级锁。\n\n### 悲观锁和乐观锁的概念？\n* 乐观锁：乐观地认为所有的并发操作都是线程安全的，不需要加锁来处理。但为了保证数据没有被修改，会通过CAS操作来进行判定和替换。\n* 悲观锁：悲观地认为所有的并发操作都是线程不安全的，都需要加锁来保证线程安全\n\n###  ThreadLocal 是什么？有哪些使用场景？\nThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。\n\nThreadLocal 的经典使用场景是数据库连接和 session 管理等。\n\n### ThreadLocal原理？\n* 每个Thread维护着一个ThreadLocalMap的引用\n* ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储\n* 调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值是传递进来的对象\n* 调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象\n* ThreadLocal本身并不存储值，它只是作为一个key来让线程从ThreadLocalMap获取value。\n\n### ThreadLocal缺点？\n由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏。\nThreadLocal由于真正存储数据的ThreadLocalMap只单纯地采取了数组的形式来存储数据，因此出现hash冲突时会为hash值就增加一个固定的大小0x61c88647进行线性寻找位置，会导致大量的hash冲突，造成很高的资源消耗。\n\n### 什么是CyclicBarrier？\n栅栏(Barrier)类似于闭锁，他能阻塞一组线程直到某个事件发生后再全部同时执行。CyclicBarrier 字面意思是回环栅栏，回环的意思是它能够被重复利用，当然前提是在所有线程释放了以后。\n\n### 什么是CountDownLatch？\nCountDownLatch也叫闭锁,使得一(多)个主线程必须等待其他线程完成操作后再执行.\nCountDownLatch内部维护一个计数器(父类的int state),主线程先执行await方法，如果此时计数器大于0，则阻塞等待。当一个线程完成任务后，计数器值减1。直到计数器为0时，表示所有的线程已经完成任务，等待的主线程被唤醒继续执行。\n\n### CyclicBarrier 和 CountDownLatch 的区别？\n* CyclicBarrier 是所有线程必须同时到达栅栏位置，才能继续执行。它用于等待其他线程，并且能够重置使用。\n* CountDownLatch 用于等待事件，是一次性对象，一旦进入终止状态，就不能被重置。\n* CountDownLatch 通常阻塞的是主线程，开锁以后主线程才继续执行。\n* CyclicBarrier 阻塞的是子线程，到达栅栏位置后，每个线程还可以继续做自己后续的事情。\n\n## IO\n\n### 字节流和字符流？\n![](Interview/io.png)\n字节流：以字节（8bit）为单位，能处理所有类型的数据\n字符流：以字符为单位，根据码表映射字符，一次可能读多个字节，只能处理字符类型的数据。\nInputStreamReader:字节到字符的桥梁\nOutputStreamWriter:字符到字节的桥梁\n\n\n### NIO是什么？\nNIO（Non-blocking I/O，在Java领域，也称为New I/O），是一种同步非阻塞的I/O模型。\n说到NIO就得先从传统BIO（Blocking I/O）说起。\nBIO：传统的网络通讯模型，就是BIO，同步阻塞IO\n它其实就是服务端创建一个ServerSocket， 然后就是客户端用一个Socket去连接服务端的那个ServerSocket， ServerSocket接收到了一个的连接请求就创建一个Socket和一个线程去跟那个Socket进行通讯。\n服务端会在等待连接、等待读取或者等待写入时发生阻塞。\n这种方式的缺点：每次一个客户端接入，都需要在服务端创建一个线程来服务这个客户端。\n这样大量客户端来的时候，就会造成服务端的线程数量可能达到了几千甚至几万，这样就可能会造成服务端过载过高，最后崩溃死掉。\n因此我们要在BIO的基础上进行改进。\n\n假设一个单线程的Socket服务，那么它会在accept()也就是等待客户端连接时阻塞，当有客户端A连接时，服务端会等待read()服务端发来的的数据。\n首先，如果可以让read（）不阻塞，那么在客户端A连接之后，如果读到数据，就进行逻辑操作，如果没读到数据，我们就继续等待下一个客户端连接\n那么此时有客户端B连接，这时A发送数据，就接受不到数据了，所以我们再增加一个list保存socket连接，\n也就是在A连接之后，我们就用list保存这个socket连接，然后轮询这个list，看看有没有客户端发送数据，有就处理，然后继续等待下一个客户端连接。\n此时 accept（）操作还是阻塞的，在没有客户端连接时，还是接收不到数据。\n如果可以让accept（）不阻塞，在没有客户端连接的时候，也进行轮询这个list，看看有没有客户端发送数据。\n这样就实现了一个简单的nio。\njava的nio就是将上述操作中的轮询操作交给操作系统来进行了。\n\n\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ Spring ------------------------</span>\n</div>\n\n# Spring\n\n## 基础\n### 为什么要使用 spring？\n* spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。\n* spring 提供了事务支持，使得事务操作变的更加方便。\n* spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。\n* 更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis 等。\n\n### spring 有哪些主要模块？\n* spring core：框架的最基础部分，提供 ioc 和依赖注入特性。\n* spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。\n* spring dao：Data Access Object 提供了JDBC的抽象层。\n* spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。\n* spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。\n* spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。\n\n### spring mvc流程\n![](Interview/springmvc.png)\n\n## AOP\n### 什么是 aop？\naop 是面向切面编程，可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。\naop的应用场景：日志记录、权限验证、效率检查、事务管理、exception\n\n### AOP术语？\n* 切面(Aspect)：切面是通知和切点的结合，通知和切点共同定义了切面的全部内容\n* 连接点(Join point)：目标对象中的方法。\n* 通知(Advice)：定义了切面是做什么以及何时使用。\n* 切点(Pointcut)：表示连接点的集合。（PointCut是JoinPoint的谓语，这是一个动作，主要是告诉通知连接点在哪里，切点表达式决定 JoinPoint 的数量）\n* 目标对象(Target object)：目标对象 原始对象\n* aop代理(AOP proxy)：代理对象  包含了原始对象的代码和增加后的代码的那个对象\n* 织入(Weaving)：把代理逻辑加入到目标对象上的过程\n\n### AOP实现原理？\n通过动态代理实现。动态代理又分为jdk动态代理和cglib动态代理。\n* jdk动态代理：主要通过Proxy.newProxyInstance()和InvocationHandler这两个类和方法实现\n    * 实现过程\n        * 实现InvocationHandler接口，重写invoke()方法\n        * 调用Proxy.newProxyInsatnce(classloader,interfaces,handler)方法生成代理类\n            * 生成的代理类为$Proxy0 extends Proxy implements Person\n            * 因为已经继承了Proxy,所以java动态代理只能对接口进行代理\n    * 总结： 代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。\n\n\n## IOC\n### 什么是 ioc？\n控制反转，将你设计好的对象交给容器控制，可以用来减低计算机代码之间的耦合度。\n\n### 什么是DI？\nDI是依赖注入，是实现IOC的一种方式。\n\n###  spring 常用的注入方式有哪些？\n* setter 属性注入\n* 构造方法注入\n* 注解方式注入\n\n###  spring 中的 bean 是线程安全的吗？\nspring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。\n实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。\n* 有状态就是有数据存储功能。\n* 无状态就是不会保存数据。\n\n###  spring 自动装配 bean 有哪些方式？\n* no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。\n* byName：它根据 bean 的名称注入对象依赖项。\n* byType：它根据类型注入对象依赖项。\n* constructor：通过构造函数来注入依赖项，需要设置大量的参数。\n\n\n### Spring beanFactory 和 factoryBean 的区别？\n**beanFactory** 是Spring容器的顶层接口，用于管理Bean的一个工厂。 在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。\n**FactoryBean** 这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean，它能在需要的时候生产一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。\n\n通常情况下，bean 无须自己实现工厂模式，Spring 容器担任了工厂的 角色；但少数情况下，容器中的 bean 本身就是工厂，作用是产生其他 bean 实例。由工厂 bean 产生的其他 bean 实例，不再由 Spring 容器产生，因此与普通 bean 的配置不同，不再需要提供 class 元素。\n\n\n### BeanFactory和ApplicationContext是什么关系？\n![](Interview/applicationContext.jpg)\n最主要的区别是BeanFactory是延迟加载，ApplicationContext是即时加载。\n\n### spring 支持几种 bean 的作用域？\n* singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；\n* prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；\n* Web 环境下的作用域：\n* request：每次 http 请求都会创建一个 bean；\n* session：同一个 http session 共享一个 bean 实例；\n* global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。\n\n\n### spring bean 容器的生命周期是什么样的？\n1. Spring 容器根据配置中的 bean 定义，通过构造方法反射来实例化 bean。\n2. Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。\n3. 如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。\n4. 如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。\n5. 如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。\n6. 如果为 bean 指定了 init 方法（ <bean> 的 init-method 属性），那么将调用它。\n7. 最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。\n8. 如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。\n9. 如果为 bean 指定了 destroy 方法（ <bean> 的 destroy-method 属性），那么将调用它。\n\n![](Interview/bean.png)\n1：实例化一个ApplicationContext的对象；\n2：调用bean工厂后置处理器完成扫描；\n3：循环解析扫描出来的类信息；\n4：实例化一个BeanDefinition对象来存储解析出来的信息；\n5：把实例化好的beanDefinition对象put到beanDefinitionMap当中缓存起来，以便后面实例化bean；\n6：再次调用bean工厂后置处理器；\n7：当然spring还会干很多事情，比如国际化，比如注册BeanPostProcessor等等，如果我们只关心如何实例化一个bean的话那么这一步就是spring调用finishBeanFactoryInitialization方法来实例化单例的bean，实例化之前spring要做验证，需要遍历所有扫描出来的类，依次判断这个bean是否Lazy，是否prototype，是否abstract等等；\n8：如果验证完成spring在实例化一个bean之前需要推断构造方法，因为spring实例化对象是通过构造方法反射，故而需要知道用哪个构造方法；\n9：推断完构造方法之后spring调用构造方法反射实例化一个对象；注意我这里说的是对象、对象、对象；这个时候对象已经实例化出来了，但是并不是一个完整的bean，最简单的体现是这个时候实例化出来的对象属性是没有注入，所以不是一个完整的bean；\n10：spring处理合并后的beanDefinition(合并？是spring当中非常重要的一块内容)；\n11：判断是否支持循环依赖，如果支持则提前把一个工厂存入singletonFactories——map；\n12：判断是否需要完成属性注入\n13：如果需要完成属性注入，则开始注入属性\n14：判断bean的类型回调Aware接口\n15：调用生命周期回调方法\n16：如果需要代理则完成代理\n17：put到单例池——bean完成——存在spring容器当中\n\n### Spring中的aware接口什么作用？\nBeanNameAware接口是为了让自身Bean能够感知到，获取到自身在Spring容器中的id属性，也就是beanName；\n其他的Aware接口也是为了能够感知到自身的一些属性。\n比如实现了ApplicationContextAware接口的类，能够获取到ApplicationContext。\n实现了BeanFactoryAware接口的类，能够获取到BeanFactory对象。\n\n\n### Spring 在什么时候完成的依赖注入？\n在初始化的时候。也就是在new AnnotationConfigApplicationContext的时候\n\n### Spring中的循环依赖是怎么解决的？\nspring 单例情况下是支持循环依赖的。\n假设A对象和B对象循环依赖，那么在初始化时会经历如下步骤：\n创建A -> 实例化A -> 填充A的属性 -> getBean(B) -> 创建B -> 实例化B -> 填充B的属性-> getBean(A)\n-> 若二级缓存中存在，将从二级缓存工厂中生产出的A放入三级缓存->从三级缓存中获取A->。。。\n\n### @Resource 和 @Autowired 的区别？\n* 默认装配类型不一样：\n    * @Autowired默认按type装配：默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。\n    * @Resource 默认按照名称进行装配：当找不到与名称匹配的bean才会按照类型装配\n* bean 在初始化时 调用的后置处理器不一样，\n    * @Autowired 调用的是 AutowiredAnnotationBeanPostProcessor()\n    * @Resource 调用的是 CommonAnnotationBeanPostProcessor()\n\n### Spring 三级缓存？\n每一级缓存都是一个map。\n一级：singletonObjects 单例池，主要存放单例 bean\n二级：singletonFactories 主要存放ObjectFactory类型工厂对象\n三级：earlySingletonObjects 从工厂中获取的spring 对象，也就是半成品bean\n三级缓存存在的意义是防止工厂重复执行对对象的操作，提高性能。\n \n### @Qualifier 注解有什么用？\n当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。\n\n\n### 什么是事务传播行为？\n事务传播行为（propagation behavior）指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何运行。\n例如：methodA方法调用methodB方法时，methodB是继续在调用者methodA的事务中运行呢，还是为自己开启一个新事务运行，这就是由methodB的事务传播行为决定的。\n\n* PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，这是最常见的选择，也是**Spring默认的事务传播行为。**\n    * methodA 调用 methodB时，设置B为当前传播行为，A未开启事物，B在自己的事物中运行，A开启事物，则B加入A的事物，若A发生异常，则B会进行回滚操作。\n* PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。\n    * A开启事物，B也创建自己的事物，若A发生异常，B不影响。\n* PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。\n    * A未开启事物，则B以非事物方式执行，若A发生异常，B不影响；若A开启事物，则B加入A的事物，若A发生异常，则B会进行回滚操作。\n* PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。\n    * A未开启事物，则直接抛出异常；若A开启事物，则B加入A的事物，若A发生异常，则B会进行回滚操作。\n* PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\n    * 无论A开不开启事物，B都以非事物方式执行   \n* PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。\n    * A未开启事物，则B以非事物方式执行；A开启事物，则抛出异常；\n* PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。\n    * A未开启事物，B在自己的事物中运行；若A开启事物，则在嵌套事物中执行，若A抛出异常，则B会回滚。\n\n\n\n\n\n\n\n\n\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>---------------- 计算机网络 ----------------</span>\n</div>\n\n# 计算机网络\n\n## 基础\n\n###  OSI 的七层模型都有哪些？\n![](Interview/osi.jpeg)\n* 物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。\n* 数据链路层：负责建立和管理节点间的链路。\n* 网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。\n* 传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。\n* 会话层：向两个实体的表示层提供建立和使用连接的方法。\n* 表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。\n* 应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。\n\n## http协议\nHyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协\n\n### HTTP的特性\n* HTTP构建于TCP/IP协议之上，默认端口号是80\n* HTTP是无连接无状态的\n    + 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n    + 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n\n### HTTP状态码\n{% note info %}\n    1xx：指示信息--表示请求已接收，继续处理\n    2xx：成功--表示请求已被成功接收、理解、接受\n    3xx：重定向--要完成请求必须进行更进一步的操作\n    4xx：客户端错误--请求有语法错误或请求无法实现\n    5xx：服务器端错误--服务器未能实现合法的请求\n{% endnote %}\n\n200 OK //客户端请求成功\n301 Moved Permanently //永久重定向。\n302 Found //暂时重定向。\n400 Bad Request //客户端请求有语法错误，不能被服务器所理解\n401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 \n403 Forbidden //服务器收到请求，但是拒绝提供服务\n404 Not Found //请求资源不存在，eg：输入了错误的URL\n500 Internal Server Error //服务器发生不可预期的错误\n503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常\n\n### HTTP 请求/响应的步骤？\n* **1、客户端连接到Web服务器**\n    一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.oakcms.cn。\n* **2、发送HTTP请求**\n    通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。\n* **3、服务器接受请求并返回HTTP响应**\n    Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。\n* **4、释放连接TCP连接**\n    若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;\n* **5、客户端浏览器解析HTML内容**\n    客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。\n\n### 浏览器请求过程？\n* 1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;\n* 2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;\n* 3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP三次握手的第三个报文的数据发送给服务器;\n* 4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;\n* 5、释放 TCP连接;\n* 6、浏览器将该 html 文本并显示内容;\n\n###  get 和 post 请求有哪些区别？\n从原理性看：\n* 根据HTTP规范，GET用于信息获取，而且应该是安全和幂等的\n* 根据HTTP规范，POST请求表示可能修改服务器上资源的请求\n\n从表面上看：\n* GET请求的数据会附在URL后面，POST的数据放在HTTP包体，POST安全性比GET安全性高\n* GET请求会被浏览器主动缓存，并且传递参数有大小限制，POST没有。\n\n## TCP／UDP协议\n\n###  tcp 和 udp的区别？\ntcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。\n区别如下：\n* tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；\n* tcp 提供可靠的服务（数据传输），udp 无法保证；\n* tcp 面向字节流，udp 面向报文；\n* tcp 数据传输慢，udp 数据传输快；\n\n### tcp协议是100%可靠的么？\nTCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。\n\n### 三次握手\n三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。\n![](Interview/Handshake.png)\n* 第一次握手(SYN=1, seq=x):\n  客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。\n  发送完毕后，客户端进入 `SYN_SEND` 状态。\n* 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):\n  服务器发回确认包(`ACK`)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 \n  发送完毕后，服务器端进入 `SYN_RCVD` 状态。\n* 第三次握手(ACK=1，seq=x+1,ACKnum=y+1)\n  客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1\n  发送完毕后，客户端进入 `ESTABLISHED` 状态，当服务器端接收到这个包时，也进入 `ESTABLISHED` 状态，TCP 握手结束。\n\n#### 为什么需要三次握手，两次不行吗？\n如果是用两次握手，则会出现下面这种情况：\n如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。\n客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端\n此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接。\n**因此**：不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，`浪费资源`。\n\n#### 什么是半连接队列？\n服务器第一次收到客户端的 SYN 之后，就会处于 `SYN_RCVD` 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为`半连接队列`。\n\n当然还有一个`全连接队列`，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。\n\n#### ISN(Initial Sequence Number)是固定的吗？\n当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，`每4ms加1` 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。\n\n三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。\n\n#### 三次握手过程中可以携带数据吗？\n其实第三次握手的时候，是可以携带数据的。但是，**第一次、第二次握手不可以携带数据**\n\n第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。\n\n#### SYN攻击是什么？\n在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.\n\nSYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。\n\n\n### 四次挥手\nTCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。\n![](Interview/wave.png)\n* 第一次挥手(FIN=1，seq=x)\n  假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。\n  发送完毕后，客户端进入 `FIN_WAIT_1` 状态。\n* 第二次挥手(ACK=1，ACKnum=x+1)\n  服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。\n  发送完毕后，服务器端进入 `CLOSE_WAIT` 状态，客户端接收到这个确认包之后，进入 `FIN_WAIT_2` 状态，等待服务器端关闭连接。\n* 第三次挥手(FIN=1，seq=y)\n  服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。\n  发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后一个ACK\n* 第四次挥手(ACK=1，ACKnum=y+1)\n  客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 `TIME_WAIT` 状态，等待可能出现的要求重传的 ACK 包。\n  服务器端接收到这个确认包之后，关闭连接，进入 `CLOSED` 状态。\n  客户端等待了某个固定时间（`两个最大段生命周期`，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED` 状态。\n\n#### 挥手为什么需要四次？\n因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。\n但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，\"你发的FIN报文我收到了\"。\n只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。\n\n#### 2MSL等待状态\nTIME_WAIT状态也成为2MSL等待状态。它是任何报文段被丢弃前在网络内的最长时间。\n* 保证客户端发送的最后一个ACK报文段能够到达服务端。 \n  这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态。\n* 防止“已失效的连接请求报文段”出现在本连接中。\n   客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。\n\n\n### 滑动窗口\nTCP协议里窗口机制有2种：一种是固定的窗口大小；一种是滑动的窗口。\n这个窗口大小就是我们一次传输几个数据。 \n对所有数据帧按顺序赋予编号，发送方在发送过程中始终保持着一个发送窗口，只有落在发送窗口内的帧才允许被发送； \n同时接收方也维持着一个接收窗口，只有落在接收窗口内的帧才允许接收。\n这样通过调整发送方窗口和接收方窗口的大小可以实现`流量控制`。\n**每个TCP/IP主机支持全双工数据传输，因此TCP有两个滑动窗口：一个用于接收数据，另一个用于发送数据。**\n![](Interview/slidingWindow%20%20.png)\n* 首先是**第一次发送数据这个时候的窗口大小是根据链路带宽的大小来决定的**。我们假设这个时候窗口的大小是3。\n* 这个时候接受方收到数据以后会对数据进行确认告诉发送方我下次希望手到的是数据是多少。这里我们看到接收方发送的ACK=3(这是发送方发送序列2的回答确认，下一次接收方期望接收到的是3序列信号)。\n* 这个时候发送方收到这个数据以后就知道我第一次发送的3个数据对方只收到了2个。就知道第3个数据对方没有收到。下次在发送的时候就从第3个数据开始发。这个时候窗口大小就变成了2 。 \n* 看到接收方发送的ACK是5就表示他下一次希望收到的数据是5，发送方就知道我刚才发送的2个数据对方收了这个时候开始发送第5个数据。\n\n只有在接收窗口向前滑动时（与此同时也发送了确认），发送窗口才有可能向前滑动。 当发送窗口和接收窗口的大小都等于1时，就是停止等待协议。\n\n### 如果已经建立了连接，但是客户端突然出现故障了怎么办？\nTCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。\n\n### 拥塞控制和流量控制的区别？\n* 拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。\n* 流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。\n\n### TCP确认延迟机制？\n接收方在收到数据后，并不会立即回复ACK,而是延迟一定时间。一般ACK延迟发送的时间为200ms，但这个200ms并非收到数据后需要延迟的时间。系统有一个固定的定时器每隔200ms会来检查是否需要发送ACK包。\n1. ACK是可以合并的，也就是指如果连续收到两个TCP包，并不一定需要ACK两次，只要回复最终的ACK就可以了，可以降低网络流量。\n2. 如果接收方有数据要发送，那么就会在发送数据的TCP数据包里，带上ACK信息。这样做，可以避免大量的ACK以一个单独的TCP包发送，减少了网络流量。\n\n\n### TCP拥塞控制机制？\n* 慢启动：\n    TCP在连接过程的三次握手完成后，开始传数据，并不是一开始向网络通道中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞\n    而是根据初始的cwnd大小逐步增加发送的数据量，cwnd初始化为1个最大报文段(MSS)大小（这个值可配置不一定是1个MSS）；每当有一个报文段被确认，cwnd大小指数增长。 \n    开始 —> cwnd = 1 \n    1个RTT(往返延迟)后 —> cwnd = 2*1 = 2 \n    2个RTT后 —> cwnd = 2*2= 4 \n    3个RTT后 —> cwnd = 4*2 = 8\n    \n* 拥塞避免\n    cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，一旦cwnd>=ssthresh（大多数TCP的实现，通常大小都是65536），慢启动过程结束，拥塞避免阶段开始；\n    此时窗口大小不再呈指数上升，而是以加法增加，避免增长过快导致网络拥塞。\n    拥塞发生：当发生丢包进行数据包重传时，表示网络已经拥塞。分两种情况进行处理：\n        * 等到RTO（重传超时时间）超时，重传数据包\n        * sshthresh = cwnd /2，cwnd 重置为 1\n* 快重传\n    对于接收方来说，如果接收方收到一个失序的报文段，就立即回送一个 ACK 给发送方\n    当发送方收到了3个重复的ACK时，则发送方快速重传丢失的包（所谓失序的报文是指，用户没有按照顺序收到TCP报文段，比如接收方收到了报文 M1, M2, M4，那么M4就称为失序报文，也就是M3被丢失），而不必等待M3的重传计时器到期\n* 快恢复\n    一旦出现超时重传，或者收到第三个重复的 ack 时（快重传），TCP 会把慢启动门限 ssthresh 的值设置为 cwnd 值的一半，同时 cwnd = ssthresh\n\n\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>---------------- 设计模式 ----------------</span>\n</div>\n\n# 设计模式\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>---------------- MyBatis ----------------</span>\n</div>\n\n# MyBatis\n## 什么是 MyBatis?\nMyBatis 是一个可以自定义 SQL、存储过程和高级映射的持久层框架。\n\n##  MyBatis 中 #{}和 ${}的区别是什么？\n\\#{}是预编译处理，${}是字符替换。 \n\n在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。\nMybatis 在处理${}时，就是把${}替换成变量的值。\n\n## MyBatis 有几种分页方式？\n**逻辑分页**： 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。\n\n**物理分页**： 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。\n\n## MyBatis 逻辑分页和物理分页的区别是什么？\n* 逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。\n* 物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。\n\n## RowBounds 是一次性查询全部结果吗？为什么？\nRowBounds 表面是在“所有”数据中检索数据，其实**并非是一次性查询**出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。\n\n##  MyBatis 是否支持延迟加载？延迟加载的原理是什么？\nMyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。\n延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。\n比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。\n\n## `说一下 MyBatis 的一级缓存和二级缓存？`\n![](Interview/mybatisCache.jpg)\n* 一级缓存：是SqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。\n* 二级缓存：是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。。\n开启二级缓存数据查询流程：二级缓存 -> 一级缓存 -> 数据库。\n缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>---------------- Kafka ----------------</span>\n</div>\n\n# Kafka\n\n## kafka 流程？\n![](Interview/kafka.png)\n* 生产者：可以声明主题Topic、分区Partition、键 Key以及值 Value，主题和值是必须要声明的，分区和键可以不用指定。拥有相同key的消息将会被写到同一分区，若没有指定key则由分区器分配。\n* topic：Topic中数据是顺序不可变序列，采用log追加方式写入，Topic的数据可存储在多个partition中。\n* partition：每个 Partition 中的消息都是有序的，生产的消息被不断追加到 Partition log 上，其中的每一个消息都被赋予了一个唯一的 offset 值。 因此数据不会因消费而丢失，所以只要consumer指定offset，一个消息可被不同的consumer多次消费。kafka中只能保证partition中记录是有序的，而不保证topic中不同partition的顺序。\n* Replication：同一个 partition 可能会有多个 replication，需要在这些 replication 之间选出一个 leader，producer 和 consumer 只与这个 leader 交互，其它 replication 作为 follower 从 leader 中复制数据。\n* 消费者：订阅topic是以一个消费组来订阅的，一个消费组里面可以有多个消费者。**一个partition，只能被消费组里的一个消费者消费**，但是可以同时被多个消费组消费。\n\n## kafka 可以脱离 zookeeper 单独使用吗？为什么？\nkafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。\n\n##  kafka 有几种数据保留的策略？\nkafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。\n\n##  kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？\n这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。\n\n## 什么情况会导致 kafka 运行变慢？\n* cpu 性能瓶颈\n* 磁盘读写瓶颈\n* 网络瓶颈\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>---------------- MySQL ----------------</span>\n</div>\n\n# MySQL\n\n## 基础\n### 数据库的三范式是什么？\n* 第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。\n* 第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。\n* 第三范式：任何非主属性不依赖于其它非主属性。\nhttps://zhuanlan.zhihu.com/p/92991575\n\n### char 和 varchar 的区别是什么？\n* char(n) ：**固定长度类型**，比如订阅 char(10)，当你输入\"abc\"三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。\n* varchar(n) ：**可变长度**，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。\nchat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。\n所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。\n\n### float 和 double 的区别是什么？\n* float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。\n* double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。\n\n###  MySQL 常用的引擎？\n* InnoDB 引擎：mysql 5.1 后默认的数据库引擎，提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。\n              MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。\n              但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。\n              由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。\n* MyIASM 引擎：不提供事务的支持，也不支持行级锁和外键。。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。\n              MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。\n              所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。\n\n### 如何做 MySQL 的性能优化？\n* 为搜索字段创建索引。\n* 避免使用 select *，列出需要查询的字段。\n* 垂直分割分表。\n* 选择正确的存储引擎。\n\n### left join、right join、inner join的区别\n* left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 \n* right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录\n* inner join(等值连接) 只返回两个表中联结字段相等的行\n\n## innodb\n\n### innodb 体系结构？\n![](Interview/innodb-Architecture.png)\n\n### 什么是redo log？\n当数据库对数据做修改的时候，需要把数据页从磁盘读到buffer pool中，然后在buffer pool中进行修改，那么这个时候buffer pool中的数据页就与磁盘上的数据页内容不一致，称buffer pool的数据页为dirty page 脏数据。\n如果发生非正常的DB服务重启，那么这些数据并没有同步到磁盘文件中（注意，同步到磁盘文件是个随机IO），会发生数据丢失。\n如果这个时候，能够有一个文件，当缓冲池中的data page变更结束后，把相应修改记录记录到这个文件（注意，记录日志是顺序IO），那么当DB服务发生crash的情况，恢复DB的时候，也可以根据这个文件的记录内容，重新应用到磁盘文件，数据保持一致。\n这个文件就是redo log ，用于记录 数据修改后的记录，顺序记录。\n![](Interview/redo-buffer.png)\n重做日志支持以下三种情况触发刷新：\n    * Master Thread每一秒将重做日志缓冲刷新到重做日志文件\n    * 每次事务提交时将重做日志缓冲刷新到重做日志文件\n    * 当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件\n\n\n### 什么是undo log？\nundo日志用于存放数据修改被修改前的值。\n假设修改表中 id=1 的行数据，把Name=’B’ 修改为Name = ‘B2’ ，那么undo日志就会用来存放Name=’B’的记录，如果这个修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。\n\n### undo 和 redo 事物实现过程？\n事务B要将字段A的值由原来的1修改为3，要将B的值由原来的2修改为4，redo日志记录的是：\n```text\n假设有A、B两个数据，值分别为1,2.\n1. 事务B开始\n2. 记录A=1到undo log\n3. 修改A=3\n4. 记录A=3到 redo log\n5. 记录B=2到 undo log\n6. 修改B=4\n7. 记录B=4到redo log\n8. 将redo log写入磁盘\n9. 事务提交，将数据写入磁盘\n10.事物B结束\n```\n如果上面事务B回滚（当做新的事务C），则redo记录的是：\n```text\n1. 事务C开始\n2. 记录A=1到undo log\n3. 修改A=3\n4. 记录A=3到 redo log\n5. 记录B=2到 undo log\n6. 修改B=4\n7. 记录B=4到redo log\n   <!--回滚-->\n8. 修改B=2\n9. 记录B=2到redo log\n10.修改A=1\n11.记录A=1到redo log\n12.将redo log写入磁盘\n13.事务提交，将数据写入磁盘\n14.事物C结束\n```\n\n### Double write解决了什么问题?\n* 数据库IO的最小单位是16K（MySQL默认，oracle是8K）\n* 文件系统IO的最小单位是4K（也有1K的）\n* 磁盘IO的最小单位是512字节\n\n一个数据页的大小是16K，假设在把内存中的脏页写到数据库的时候，写了8K突然宕机了，也就是说前8K数据是新的，后8K是旧的，那么磁盘数据库这个数据页就是不完整的，是一个坏掉的数据页，这种情况被称为部分写失效\n\n### 为什么 redo log 不需要 doublewrite 的支持？\n因为 redo log 写入的单位就是 512 字节，也就是磁盘 IO 的最小单位，所以无所谓数据损坏。\n\n### 页断裂可不可以通过 redo log 来进行恢复呢？\nredo记录的是对页的修改，只能恢复校验完整（还没写）的页，不能修复坏掉的数据页，所以这个数据就丢失了，可能会造成数据不一致，所以需要double write。\n\n### 两次写工作流程？\n![](Interview/doublewrite.png)\ndoublewrite由两部分组成，一部分为内存中的doublewrite buffer，其大小为2MB，另一部分是磁盘上共享表空间(ibdata x)中连续的128个页，即2个区(extent)，大小也是2M。\n1. 当一系列机制触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先拷贝至内存中的doublewrite buffer中；\n2. 接着从两次写缓冲区分两次写入磁盘共享表空间中(连续存储，顺序写，性能很高)，每次写1MB；\n3. 待第二步完成后，再将doublewrite buffer中的脏页数据写入实际的各个表空间文件(离散写)；(脏页数据固化后，即进行标记对应doublewrite数据可覆盖) \n\n### 为什么 double write 可以解决页断裂？\n1. 磁盘还未写，此时可以通过 redo log 恢复；\n2. 磁盘正在进行从内存到共享表空间的写，此时数据文件中的页还没开始被写入，因此也同样可以通过 redo log 恢复；\n3. 磁盘正在写数据文件，此时共享表空间已经写完，可以从共享表空间拷贝页的副本到数据文件实现恢复。\n\n\n## 事物\n### 什么是事务？\n一个事务是可以被看作一个单元的一系列SQL语句的集合。它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。\n\n### 事务的特性（ACID） 是什么？\n* Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。\n* Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。\n* Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。\n* Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n\n### 数据库的事务隔离级别？\n* READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。\n* READ-COMMITTED：提交读，读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。（会造成幻读、不可重复读）。\n* REPEATABLE-READ：可重复读，默认级别。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。（会造成幻读）。\n* SERIALIZABLE：序列化，代价最高最可靠的隔离级别，这个事务执行的时候不允许别的事务并发执行。事务只能一个接着一个地执行。该隔离级别能防止脏读、不可重复读、幻读。\n\n> **脏读** ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。\n> **不可重复读** ：事务A读取数据后，事务B执行更新操作，使A无法再次读取结果。\n> **幻读**：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。\n> **丢失修改**：两个事务A，B读入同一数据并修改，B提交的结果被A破坏了，导致B的修改丢失。\n\n## 锁\n### 从数据库系统的角度来看分为几种？\n1. 共享锁（S）\n    共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。\n2. 更新锁（U）\n    更新锁可以防止通常形式的死锁。一般更新模式由一个事务组成，此事务读取记录，获取资源（页或行）的共享锁，然后修改行，此操作要求锁转换为排它锁。\n3. 排他锁（X）\n    排它锁可以防止并发事务对资源进行访问。其它事务不能读取或修改排它锁锁定的数据。\n4. 意向锁\n    意向锁就是说在屋（比如代表一个表）门口设置一个标识，说明屋子里有人（比如代表某些记录）被锁住了。另一个人想知道屋子里是否有人被锁，不用进屋子里一个一个的去查，直接看门口标识就行了。\n     * 意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得**该表的IS锁**\n     * 意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得**该表的IX锁。**\n     * 意向共享排他锁（SIX）：对一个数据对象加 SIX锁，表示对它加 S锁，再加IX锁，即 SIX=S+IX。例如对某个表加 SIX锁，则表示该事务要读整个表（所以要对该表加 S锁），同时会更新个别元组（所以要对该表加 IX锁）。\n     \n    当一个表中的某一行被加上排他锁后，该表就不能再被加表锁。数据库程序如何知道该表不能被加表锁？一种方式是逐条的判断该表的每一条记录是否已经有排他锁，另一种方式是直接在表这一层级检查表本身是否有意向锁，不需要逐条判断。显然后者效率高。\n\n### 什么是悲观锁？\n悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。\n* 悲观锁的流程\n    * 在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。 \n    * 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。\n    * 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。\n    * 其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。\n* 优点与不足\n    悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。\n    但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；\n    另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载,还有会降低了并行性.\n    一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数\n    \n### 什么是乐观锁？\n乐观锁 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。\n相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。\n* 实现方式\n    * 对记录加版本号：在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。\n    * 对记录加时间戳：在数据初始化时使用时间戳（timestamp），在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK。\n    * 对将要更新的数据进行提前读取、事后对比。\n\n### 什么是锁的粒度？\n锁的粒度就是指锁的生效范围，就是说是行锁，还是页锁，还是整表锁. 锁的粒度同样既可以由数据库自动管理，也可以通过手工指定hint来管理。\n\n### 封锁协议？\n![](Interview/sqllock.gif)\n* 一级封锁协议：对应READ-UNCOMMITTED 隔离级别，本质是在事务A中修改完数据M后，立刻对这个数据M加上共享锁(S锁)（当事务A继续修改数据M的时候，先释放掉S锁，再修改数据，再加上S锁），根据S锁的特性，事务B可以读到事务A修改后的数据(无论事务A是否提交，因为是共享锁，随时随地都能查到数据A修改后的结果)，事务B不能去修改数据M，直到事务A提交，释放掉S锁。\n    * 缺点：丢失更新。脏读。不可重复读。幻读。\n* 二级封锁协议：对应READ-COMMITTED隔离级别，本质是事务A在修改数据M后立刻加X锁，事务B不能修改数据M，同时不能查询到最新的数据M(避免脏读)，查询到的数据M是上一个版本(Innodb MVCC快照)的。\n    * 缺点：丢失更新。不可重复读。幻读。\n* 三级封锁协议：对应REPEATABLE-READ隔离级别,本质是二级封锁协议基础上，对读到的数据M瞬间加上共享锁M，直到事务结束才释放（保证了其他事务没办法修改该数据），这个级别是MySql 5.5 默认的隔离级别。\n    * 缺点：丢失更新。幻读。\n* 最强封锁协议：对应Serialization隔离级别，本质是从MVCC并发控制退化到基于锁的并发控制，对事务中所有读取操作加S锁，写操作加X锁，这样可以避免脏读，不可重复读，幻读，更新丢失，开销也最大，会造成读写冲突，并发程度也最低。\n\n## MySQL 的行锁和表锁？\nMyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。\n* 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。\n* 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。\n\n## 说一下乐观锁和悲观锁？\n* 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。\n* 悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。\n\n数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。\n\n\n## 索引\n### B+tree和Btree的区别？\nbtree是每个节点都保存数据，而b+tree只有叶子节点保存数据，并且每个叶子节点都有指向前后叶子节点的指针。\n\n### InnoDB索引原理？\n数据库中的B+树索引可以分为**聚集索引和辅助索引**。\n聚集索引(主键索引)：按照每张表的主键构造一颗B+树，同时叶子结点存放的即为整张表的行纪录数据也称为数据页。\n辅助索引(非聚集索引)：按照每张表的索引构造一颗B+树，叶子节点存放该行数据的主键。\n\n当通过索引数据来查找数据的时候，存储引擎会遍历辅助索引并且通过叶级别的指针获取到指向主键索引的的主键，然后再通过主键索引来找到一个完整的记录；\n\n### 性别为什么不能作为数据库索引?\n对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。\n在使用普通索引查询时，会先加载普通索引，通过普通索引查询到实际行的主键。再使用主键通过聚集索引查询相应的行。以此循环查询所有的行。\n若直接全量搜索聚集索引，则不需要在普通索引和聚集索引中来回切换。\n相比两种操作的总开销可能扫描全表效率更高。\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ Redis ------------------------</span>\n</div>\n\n# Redis\n## Redis 是什么？都有哪些使用场景？\nRedis 是一个使用 C 语言开发的高速缓存数据库。\nRedis 使用场景：\n* 记录帖子点赞数、点击数、评论数；\n* 缓存近期热帖；\n* 缓存文章详情信息；\n* 记录用户会话信息。\n\n## Redis 有哪些功能？\n* 数据缓存功能\n* 分布式锁的功能\n* 支持数据持久化\n* 支持事务\n* 支持消息队列\n\n## Redis 支持的数据类型有哪些？\n![](Interview/redis-shujujiegou.png)\nRedis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。\n\n\n## Redis 为什么是单线程的？\n因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。\n关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。\n\n## Redis 单机数据库的好处？\n* 纯内存\n* 单线程，避免频繁上下文切换\n* 采用`非阻塞IO多路复用？`\n\n## Redis 持久化有几种方式？\n* RDB（Redis Database）：默认持久化方式，按一定的时间周期把内存的数据以快照的形式保存到硬盘的二进制文件\n    * 优点：\n        * 只有一个dump.rdb 方便持久化\n        * 容灾性好，一个文件可以保存到安全的磁盘\n        * 性能最大化，fork子进程来完成写操作，让主进程继续处理命令，IO最大化\n        * 数据集大时，比AOF的效率高\n    * 缺点：\n        * 数据安全性低，RDB隔一段时间就会进行持久化，如果持久化之间发生故障，会发生数据丢失\n* AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中，当redis重启会重新执行文件保存的写命令来重建数据库\n    * 优点：\n        * 数据安全，aof可以配置为每进行一次命令就记录到AOF文件中\n        * 通过append模式写文件，即使中途服务器宕机，可以通过redis-check-aof工具进行恢复\n        * rewrite模式：fork一个子进程进行AOF重写\n    * 缺点：AOF文件比RDB文件大，且恢复速度慢，数据集大时比RDB效率低。\n    \n两种模式同时开启，数据恢复优先选择AOF。\n\n\n## 怎么保证缓存和数据库数据的一致性？\n* 合理设置缓存的过期时间。\n* 新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。\n              \n\n## Redis 淘汰策略有哪些？\n* volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。\n* volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。\n* volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。\n* allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。\n* allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。\n* no-enviction（驱逐）：禁止驱逐数据。\n\n## Redis 过期策略？\n* redis默认每100ms随机抽取进行检查是否有过期的key\n* 在获取某个key时会检查，这个key如果设置了过期时间那么是否过期了，如果过期则删除\n\n## 什么是缓存雪崩？\n由于原有缓存失效，新缓存未到期间，原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成压力，严重会导致数据库宕机，整个系统崩溃\n**解决方法**：考虑用加锁或队列的方式来保证不会有大量线程对数据库一次性进行读写。或将缓存失效时间分散开\n\n## 什么是缓存穿透？\n数据在数据库中没有，自然在缓存中也不会有，这就导致用户查询时缓存中找不到，都要去数据库再查一遍\n解决方法：\n    1. 布隆过滤器，将所有可能存在的数据哈希到足够大的bitmap中，一个一定不存在的数据会被bitmap拦截\n    2. 如果查询数据为空（不管数据不存在还是系统故障）仍把这个空结果进行缓存\n\n## 什么是缓存预热？\n系统上线后将相关的缓存数据直接加载到缓存系统\n解决方法：\n    * 数据量不大，项目启动时自动进行加载\n    * 定时刷新缓存\n\n## Redis 常见的性能问题有哪些？该如何解决？\n* 主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。\n* Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。\n\n## Redis 主从复制？\n用户可执行slaveof命令或设置slaveof选项让一个服务器去复制另一个服务器\n* 旧版复制\n    * 同步sync：用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态\n        * 从服务器向主服务器发送sync命令\n        * 收到sync命令的主服务器执行**bgsave**在后台生成RDB文件，并用一个缓冲区记录从现在开始执行的所有写命令\n        * 当主服务器bgsave执行完毕时，主服务器会将RDB文件发送给从服务器，从服务器接收并载入rdb，将自己的数据库状态更新至主服务器执行bgsave时的数据状态\n        * 主服务器将缓冲区中写命令发送给从服务器，从服务器执行写命令，更新状态\n    * 命令传播：由于主服务器的数据库状态被修改，导致主从状态不一致时让主从服务器的数据库重新回到一致\n        * 主服务器会将自己执行的写命令发送给从服务器执行，从而使主从状态一致\n    * 缺陷：在断线后重复制的效率非常低，需要执行sync命令全量生成并加载rdb文件\n* 新版复制：使用psync代替sync，可以**部分同步**和**全部同步**\n    * 全部同步：sync \n    * 部分同步：psync\n        * 主服务器的复制偏移量和从服务器的复制偏移量\n            * 主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N\n            * 从服务器收到N子节数据时就将自己的复制偏移量的值加N\n        * 主服务器的复制积压缓冲区\n            * 主服务器维护的一个固定长度先进先出队列，大小1M\n            * 当主服务器命令传播时，还会将写命令入队到复制缓冲里，并且复制缓冲会为队列中每字节记录复制偏移量\n            * 当从服务器重新连上主服务器，从会通过psync将自己的offset发给主服务器\n                * 如果offset之后的数据仍在复制积压缓冲里，执行部分重同步\n                * 否则执行完整重同步\n        * 服务器的运行ID\n            * 当从服务器对主服务器进行初次复制时，主会将自己的运行ID传给从服务器，从服务器保存起来\n            * 当从服务器断线重连，从服务器向当前连接的主发送之前保存的运行ID\n                * 如果和当前主服务器的ID相同，则可以尝试执行部分重同步\n                * 否则执行完整重同步\n## 哨兵模式sentinel？\nsentinel是高可用的解决方案，由一个或多个sentinel实例组成的sentinel系统，可以监视任意多个主从服务器，并在被监视的主服务器进入下线时，将从升为主服务器\n* 启动哨兵\n    * 初始化服务器：sentinel并不使用数据库，初始化不会加载RDB或AOF\n    * 使用sentinel专用代码、初始化sentinel状态、初始化sentinel状态的masters属性\n    * 创建连向主服务器的异步网络连接\n        * 命令连接，向主服务器发送命令并接收命令回复\n        * 订阅连接，专门用于订阅主服务器的__sentinel__:hello 频道\n* 获取主服务器信息：默认每十秒一次，通过命令连接向被监视的主服务器发送INFO命令，并通过分析回复来获取状态，可以获取到主服务器信息，以及主服务器下所有从服务器信息\n* 获取从服务器信息：根据INFO命令回复\n* 向主从服务器发送信息：每两秒一次向服务器__sentinel__:hello频道发送一条信息\n* 接收主从服务器的频道信息\n* 更新sentinels字典\n* 创建连向其他sentinel的命令连接\n* 检测主观下线：每秒向所有与它创建了命令连接的实例发送PING，并通过返回的PING命令回复判断是否在线\n* 检测客观下线：\n    * 当一个主服务器主观下线后，为了确保主服务器真下线了，会向同样监视这服务器的其他sentinel进行询问\n    * 当认为主服务器进入下线状态的sentinel数量超过配置中设置的quorum参数值，就进入客观下线状态\n* 选举领头sentinel：当一个服务器客观下线时，监视该服务器的sentinel会选举出一个领头sentinel，并由领头进行故障转移\n    * 选举方式：\n        * 监视同一主服务器的在线sentinel都有资格\n        * 每次选举无论成功与否，配置纪元的值都会自增一次\n        * 在一个配置纪元里，所有sentinel都有一次将某个sentinel设置为局部头的机会，并且一旦设置不可更改\n        * 每个发现主服务器进入客观下线的sentinel都会要求其他sentinel将自己设为局部头\n        * 设置局部头的规则是先到先得，之后接收到的所有设置要求都会被拒绝\n        * 如果有某个sentinel被半数以上设置成了局部头，那么就成为领头\n        * 在给定时限内，没有一个被选举为领头，那么将在一段时间后再次选举\n* 故障转移：\n    * 选出新的主服务器：从已下线主服务器的所有从服务器列表中筛选\n        * 删除列表中所有处于下线或者断线状态的从服务器\n        * 删除列表中5s内没有回复过领头sentinel的info命令的从服务器\n        * 删除所有与已下线服务器连接断开超过down-after-milliseconds*10毫秒的从服务器\n        * 根据从服务器优先级排序，相同优先级按照从服务器复制偏移量排序，相同偏移量按运行ID最小排序\n        * 向选出的从服务器发送SLAVEOF no one命令升级为主服务器 \n    * 修改从服务器的赋值目标\n        * 向其他从服务器发送slaveof命令，让他们复制新主服务器\n    * 将旧的主服务器变成从服务器\n        * 当旧的主服务器重新上线时，会向他发出slaveof命令，让他变成从服务器\n          \n## redis集群？\nRedis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。\n* 节点：一个redis集训由多个节点构成\n    * 启动节点：redis 启动时会根据cluster-enabled配置是否为yes决定是否开启集训模式\n    * 集群数据结构：\n        * clusterNode：保存了节点的创建时间、名称、配置纪元、ip、端口号等\n        * clusterLink：保存了连接**节点**所需的套接字描述符、输入缓冲区、输出缓冲区\n        * redisClient：保存了连接**客户端**所需的套接字描述符、输入缓冲区、输出缓冲区\n    * 节点之间建立连接：通过cluster meet节点之间握手\n        * 节点A会为节点B创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。\n        * 节点A将根据CLUSTER MEET命令给定的IP地址和端口号，向节点B发送一条MEET消息（message）\n        * 节点B将接收到节点A发送的MEET消息，节点B会为节点A创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。\n        * 节点B将向节点A返回一条PONG消息。\n        * 节点A将接收到节点B返回的PONG消息，通过这条PONG消息节点A可以知道节点B已经成功地接收到了自己发送的MEET消息。\n        * 节点A将向节点B返回一条PING消息。\n        * 节点B将接收到节点A返回的PING消息，通过这条PING消息节点B可以知道节点A已经成功地接收到了自己返回的PONG消息，握手完成。\n        \n* 槽指派：集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。\n    * 记录节点的槽指派信息：clusterNode结构的slots属性和numslot属性记录了节点负责处理哪些槽\n        * slots属性是包含16384位的二进制数组，对应索引i上的值为1那么表示节点负责处理槽i。\n    * 传播节点的槽指派信息：将自己的slots数组通过消息发送给集群中的其他节点，以此来告知其他节点自己目前负责处理哪些槽。\n    * 记录集群中所有的槽指派信息：clusterState结构中的slots数组记录了集群中所有16384个槽的指派信息，slots数组包含16384个项，每个数组项都是一个指向clusterNode结构的指针\n* 在集训中执行命令：客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己\n    * 如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令。\n    * 如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，指引客户端转向（redirect）至正确的节点，并再次发送之前想要执行的命令\n* 重新分片：Redis集群的重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点\n* ASK错误：在进行重新分片期间：属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对则保存在目标节点里面，当客户端向源节点发送一个与数据库键有关的命令，若此时数据不在原节点上，返回ASK并指引客户端转向目标节点。\n* 复制与故障转移：\n    * 设置从节点：向一个节点发送命令CLUSTER REPLICATE <node_id>，让接收命令的节点称为node_id的从节点\n    * 故障检测：\n        * 集群中的每个节点都会定期地向集群中的其他节点发送PING消息，如果没有在规定时间返回PONG消息，那么该节点会被疑似下线。\n        * 集群中的各个节点会通过互相发送消息的方式来交换集群中各个节点的状态信息，来确认某个节点是疑似下线还是已下线。\n        * 当一个主节点A通过消息得知主节点B认为主节点C进入了疑似下线状态时，会记录主节点C的状态。\n        * 当集群中半数以上的主节点都将某节点疑似下线，那么这个主节点被标记为已下线。\n        * 将主节点x标记为已下线的节点会向集群广播一条关于主节点x的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点x标记为已下线。\n    * 故障转移：当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移\n        * 选举新的主节点\n            * 集群的配置纪元是一个自增计数器，它的初始值为0。\n            * 当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被增一\n            * 对于每个配置纪元，集群里每个负责处理槽的主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得主节点的投票。\n            * 当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票\n            * 如果一个主节点具有投票权（它正在负责处理槽），并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示这个主节点支持从节点成为新的主节点。\n            * 如果集群里有N个具有投票权的主节点，那么当一个从节点收集到大于等于N/2+1张支持票时，这个从节点就会当选为新的主节点。\n            * 如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。\n        * 被选中的从节点会执行SLAVEOF no one命令，成为新的主节点\n        * 新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。\n        * 新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。\n        * 新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成\n\n\n# zookeeper \n它是一个分布式服务框架，主要用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务，集群管理、分布式应用配置项的管理等。\n简单来说：zk是一个拥有文件系统特点的数据库；zk是一个解决了数据一致性问题的分布式数据库；zk是一个具有发布和订阅功能的分布式数据库。\n\n# 算法\n\n## 排序\n\n### 各种排序算法的时间复杂度以及稳定性？\n![](Interview/sort.png)\n\n### 冒泡排序\n* 算法原理：相邻的数据进行两两比较，小(大)数放在前面，大(小)数放在后面，这样一趟下来，最小(大)的数就被排在了第一位，第二趟也是如此，如此类推，直到所有的数据排序完成。\n* 时间复杂度：最坏：O(n2) 最好: O(n) 平均: O(n2) 空间复杂度：O(1) 稳定性： 稳定\n\n### 选择排序\n* 算法原理：先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n* 时间复杂度：最坏：O(n2) 最好: O(n) 平均: O(n2) 空间复杂度：O(1) 稳定性： 稳定\n\n### 直接插入排序\n* 算法原理：每次将一个待排序的数据按照其关键字的大小插入到前面已经排序好的数据中的适当位置，直到全部数据排序完成。\n* 时间复杂度：最坏：O(n2) 最好: O(n) 平均: O(n2) 空间复杂度：O(1) 稳定性： 稳定\n\n### 快速排序\n* 算法原理：\n  * 从数列中挑出一个元素作为基准数。\n  * 分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。\n  * 再对左右区间递归执行第二步，直至各区间只有一个数。\n* 时间复杂度：最坏：O(n2) 最好: O(nlogn) 平均: O(nlogn) 空间复杂度：O(logn) 稳定性： 不稳定 \n\n### 归并排序\n* 算法原理：将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。\n* 时间复杂度：最坏：O(nlogn) 最好: O(n) 平均: O(nlogn) 空间复杂度：O(1) 稳定性： 稳定 \n\n### 堆排序\n* 算法原理：堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。\n* 时间复杂度：最坏：O(nlogn) 最好: O(nlogn) 平均: O(nlogn) 空间复杂度：O(1) 稳定性： 不稳定 \n\n```java\n\t/*\n\t *\n\t * 堆排序（升序排列）-建立最大堆\n\t * @param array\n\t */\n\n\tpublic static void heapSortAsc(int[] a) {\n\t\tint len = a.length;\n\t\tfor (int i = len / 2 - 1; i >= 0; i--) {\n\t\t\tmaxHeapDown(a, i, len - 1);\n\t\t}\n\t\tfor (int i = len - 1; i > 0; i--) {//堆顶和末尾交换\n\t\t\tswap(a, i, 0);\n\t\t\tmaxHeapDown(a, 0, i - 1);\n\t\t}\n\t}\n\n\tpublic static void maxHeapDown(int[] a, int start, int end) {//自顶向下调整成为最大堆\n\t\tint son = start * 2 + 1;//左儿子\n\t\tint root = a[start];\n\n\t\tfor (; son <= end; start = son, son = 2 * son + 1) {\n\t\t\tif (son < end && a[son] < a[son + 1]) {\n\t\t\t\tson++;//右儿子\n\t\t\t}\n\t\t\tif (root >= a[son]) break;\n\t\t\telse {\n\t\t\t\tswap(a, start, son);\n\t\t\t}\n\t\t}\n\t}\n```\n\n## 负载均衡算法\n### 完全随机\n对所有机器随机选择\n缺点：服务器有好有坏，处理能力是不同的，我们希望性能好的服务器多处理些请求，性能差的服务器少处理一些请求。\n### 加权随机\n为每台服务器设置了权重，权重大的服务器获得的概率大一些，权重小的服务器获得的概率小一些。\n### 完全轮询\n按顺序一个一个执行\n### 普通加权轮询\n有三个节点{a, b, c}，他们的权重分别是{a=5, b=1, c=1}。发送7次请求，a会被分配5次，b会被分配1次，c会被分配1次。\n轮训所有节点，找到一个最大权重节点；选中的节点权重-1；直到减到0，恢复该节点原始权重，继续轮询；\n\n### 平滑加权轮询\n![](Interview/load.png)\n选中的服务器非固定权重：固定权重-各个服务器的权重之和\n其他服务器非固定权重 = 固定权重。\n每一轮将当前有效权重**最大**的实例减去所有实例的权重和，且变量 currentPos 指向此位\n将每个实例的 非固定权重 都加上 固定权重\n\n### 一致性hash算法\n普通的hash算法：如果我们采用普通的hash算法进行路由，将数据映射到具体的节点上，如key%N，key是数据的key，N是机器节点数，如果有一个机器加入或退出这个集群，则所有的数据映射都无效了，如果是持久化存储则要做数据迁移，如果是分布式缓存，则其他缓存就失效了。\n![](Interview/hash.jpg)\n一致性hash算法：\n    * 环形hash空间：按照常用的hash算法来将对应的key哈希到一个具有2^32次方个节点的空间中，即0 ~ (2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。\n    * 映射服务器节点：将各个服务器使用Hash进行一个哈希，具体可以选择服务器的ip或唯一主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。\n    * 映射数据：对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上,然后从数据所在位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。\n    * 服务器的删除与添加\n        * 如果此时NodeC宕机了，此时Object A、B、D不会受到影响，只有Object C会重新分配到Node D上面去，而其他数据对象不会发生变化\n        * 如果在环境中新增一台服务器Node X，通过hash算法将Node X映射到环中，通过按顺时针迁移的规则，那么Object C被迁移到了Node X中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。\n\n平衡性问题：当服务器节点比较少的时候，会出现一个问题，就是此时必然造成大量数据集中到一个节点上面，极少数数据集中到另外的节点上面。\n为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以先确定每个物理节点关联的虚拟节点数量，然后在ip或者主机名后面增加编号。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：\n![](Interview/hash2.jpg)\n\n\n## 大数据问题\n### 给一个超过100G大小的log file,log中存着IP地址 ，设计算法找到出现次数最多的IP地址？\n但凡是大数据的问题，都可通过切分来解决它。\n如果我们将其分成1000个小文件，每个文件大概就是500M左右的样子，现在计算机肯定轻轻 松松就能装下。\n那么，问题又来了，怎样才能保证相同的IP被分到同一个文件中呢？\n这里我想到的是哈希切分，使用相同的散列函数（如 BKDRHash）将所有IP地址转换为一个整数key，再利用 index=key%1000就可将相同IP分到同一个文件。\n\n\n## 智商题\n\n\n# 扩展\n## 分布式ID解决方案\n1. 基于UUID:对于数据库来说用作业务主键ID，它不仅是太长还是字符串，存储性能差查询也很耗时，所以不推荐用作分布式ID。\n    * 优点：生成足够简单，本地生成无网络消耗，具有唯一性\n    * 缺点：无序的字符串，不具备趋势自增特性;没有具体的业务含义;长度过长16 字节128位，36位长度的字符串，存储以及查询对MySQL的性能消耗较大，MySQL官方明确建议主键要尽量越短越好，作为数据库主键 UUID 的无序性会导致数据位置频繁变动，严重影响性能。\n2. 基于单数据库自增ID\n    * 优点：实现简单，ID单调自增，数值类型查询速度快\n    * 缺点：DB单点存在宕机风险，无法扛住高并发场景\n3. 基于数据库集群模式:那这样还会有个问题，两个MySQL实例的自增ID都从1开始，会生成重复的ID怎么办？\n    * 操作：设置起始值和自增步长\n    * 优点：解决DB单点问题\n    * 缺点：不利于后续扩容，新增第三台MySQL实例需要人工修改一、二两台MySQL实例的起始值和步长。\n4. 基于Redis模式:利用redis的 incr命令实现ID的原子性自增\n    * 缺点：RDB会定时打一个快照进行持久化，假如连续自增但redis没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。\n    * 缺点：AOF会对每条写命令进行持久化，即使Redis挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致Redis重启恢复的数据时间过长。\n5. 基于数据库的号段模式：从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存\n    * 数据库中存储 **当前最大id**, **号段的步长**\n    * 多业务端可能同时操作，所以采用版本号version乐观锁方式更新，\n    * 优点：这种分布式ID生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。\n    * 缺点：id为连续号段，可能会被枚举，安全性不足；服务器出现问题重启，部分在内存中的号段会丢失。\n    * 优化方式：双buffer机制，在号段用完前并发获取下一个号段\n7. 基于雪花算法（Snowflake）模式\n    * 组成：Snowflake ID组成结构：正数位（占1比特）+ 时间戳（占41比特）+ 机器ID（占5比特）+ 数据中心（占5比特）+ 自增值（占12比特），总共64比特组成的一个Long类型。\n        * 第一个bit位（1bit）：Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0。\n        * 时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L << 41) / (1000L * 60 * 60 * 24 * 365) = 69年\n        * 工作机器id（10bit）：也被叫做workId，这个可以灵活配置，机房或者机器号组合都可以。\n        * 序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID\n    * 操作：当序列号部分超过4096时，等待下一毫秒；当目前时间戳小于最后一次的时间戳时，时钟回拨，报错！！\n    * 优点：解除对db的依赖；需要人工配置工作id；只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。\n    * 缺点：依赖时间戳，存在机器时钟回拨\n8. 百度（uid-generator）:自动生成workId\n    * 组成：正数位（占1比特） + 时间秒（占28位）+ workId（占22比特）+ 自增值（占13位）；\n    * 操作：依赖db，在服务器启动的时候，根据hostName，port，type和 date 插入db中取出对应的自增di作为workId。\n    * CachedUidGenerator：采用RingBuffer环状数组，初始时按填充时的时间戳填充ring数组，取id时顺序从数组中取，异步填充数组。\n9. 美团(Leaf): 基于ZooKeeper的顺序Id生成workId\n    \n    \n\n\n# 参考\nhttps://www.cnblogs.com/bailing80/p/11443409.html","source":"_posts/Interview.md","raw":"---\ntitle: 面试必备\ndate: 2020-03-05 17:22:00\ntags:\n    - JAVA\n    - 面试\ncategories: JAVA\nauthor: Guyuqing\ncopyright: true\ncomments: false\npassword: 12345\n---\n\n# Java基础\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ 基础 ------------------------</span>\n</div>\n\n## 基础\n### JDK 和 JRE 有什么区别？\n* JDK：Java 开发工具包，提供了 Java 的开发环境和运行环境（包括JRE）。\n* JRE：Java 运行环境\n\n### == 和 equals 的区别是什么？\n* **==：** 基本类型：比较的是值是否相同；引用类型：比较的是引用的地址是否相同；\n* **equals**：equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较\n\n总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。\n\n### 为什么重写了equals方法，就要重写hashCode方法？\n不是必须，只是建议。虽然可以不重写hashCode，但是会对集合造成影响。\n比如hashMap，如果equals判断相同的key，但是hashCode不同，也就是内存中的地址不同，那么进行如下操作，就不会被覆盖，而是被put两次\nhashMap.put(\"k\",\"v1\")，hashMap.put(\"k\":\"v2\")\n\n###  final 在 Java 中有什么作用？\n* final 修饰的类叫最终类，该类不能被继承。\n* final 修饰的方法不能被重写。\n* final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。\n\n### Java基础的数据类型有哪些？\n基础类型有 8 种：byte、boolean、char、short、int、float、long、double\n\n### Java 中操作字符串都有哪些类？它们之间有什么区别？\n操作字符串的类有：String、StringBuffer、StringBuilder。\nString：\n    * 声明的是不可变的对象，它的底层是一个用final修饰的字符数组，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象\n    * String 对象赋值之后就会在字符串常量池中缓存，如果下次创建会判定常量池是否已经有缓存对象，如果有的话直接返回该引用给创建者。\nStringBuffer： 可以在原有对象的基础上进行操作，线程安全的，性能高于StringBuilder\nStringBuilder： 可以在原有对象的基础上进行操作，非线程安全的\n\n### String和StringBuilder 的区别？\njdk1.5：string 对象时恒定不变的,stringBuider对象表示的字符串是可变的。所以在字符串频繁修改的情况下stringBuider效率\njdk1.8: 编译器利用String的可变配套类(StringBuilder)帮我们做了优化，编译器自动调用StringBuilder.apend()方法添加。因此在拼接字符串小于500左右时，两个对象效率相同。\n\n\n### 接口和抽象类有什么区别？\n设计目的：\n    * 接口的设计目的，是对类的行为进行约束，也就是提供一种机制，可以强制要求不同的类具有相同的行为。\n    * 抽象类的设计目的，是代码复用。\n相同：\n    * 都不能被实例化\n    * 都能包含抽象的方法\n不同：\n    * 在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。\n    * 抽象类中的成员变量可以是各种类型的；而接口中的成员变量只能是public static final类型的；\n    * 抽象类可以有静态代码块和静态方法；接口中不能含有静态代码块以及静态方法\n    * 一个类只能继承一个抽象类，而一个类却可以实现多个接口。　　\n\n### 请列举你所知道的Object类的方法并简要说明。\n* getClass():用于返回当前运行时对象的Class对象\n* equals():用于比较两个对象的地址是否相同，即两个引用是否指向同一个对象；\n* clone():用于创建并返回当前对象的一份拷贝\n* toString():返回类的名字@实例的哈希码的16进制字符串；\n* notify():唤醒等待队列中的其中一个线程\n* notifyAll():唤醒线程等待队列中的所有线程；\n* wait(long timeout):让一个线程等待一段时间。\n* finalize()：用于释放资源，可以覆盖此方法实现资源清理工作。GC在回收对象之前调用该方法，但是无法确定该方法具体什么时候被调用\n\n### 类的加载顺序\n* 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)\n* 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )\n* 父类非静态代码块( 包括非静态初始化块，非静态属性 )\n* 父类构造函数\n* 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )\n* 子类构造函数\n\n### 对象在堆上要分配多大内存？\n1. java对象的属性---不固定\n2. 对象头---固定12 byte\n3. 数据对齐（64位虚拟机要求对象大小是8的整数倍，不够就补齐）\n\n64位jvm中，一个仅包含一个boolean属性的对象，大小是16 byte，12byte对象头，1byte数据，3byte填充数据\n\n### 对象有几种状态？\n1. 无状态 刚new出来的时候  biased_lock:0 | lock: 10\n2. 偏向锁 biased_lock:1 | lock: 10\n3. 轻量级锁\n4. 重量级锁\n5. 无引用，被gc标记\n\n### 什么是对象头？\n所有对象通用的一部分结构。\n由两部分组成：\n1. mark word \n    * 32 bits jvm 占 32 bits\n        * hashcode：25｜ age：4｜ biased_lock(偏向锁)：1 | lock(同步状态) : 2 \n    * 64 bits jvm 占 64 bits\n        * ![](Interview/head.png)\n        * 无状态下，在未调用过hashcode函数时，对象头hashcode位置都为0，调用过hashcode函数计算之后才会保存。\n2. klass pointer 指向类.class的指针\n    * 64 bits jvm 开启指针压缩占 32 bits 不开启占 64 bits\n    \n### 解释一下对象创建过程？\n假设有一个对象T,有一个属性m=8，那么在new 这个对象时先在堆中申请空间，\n然后属性半初始化也就是m=0，然后再调用构造方法将m修改为8，然后将引用变量t指向堆中的地址。\n\n### DCL与volatile的问题？\nvolatile 的作用是线程的可见性和禁止了指令重排序。\n在单例模式中，未了保证多线程的安全性，采用了DCL（Double-Check-Locking）方式，\n那么在线程1创建对象X的时候，对象先半初始化，再调用构造方法，线程2再去判断X对象等不等于空，\n如果此时发生指令重排序，对象先半初始化，线程2再去判断X对象等不等于空，再调用构造方法，会导致线程2拿到了半初始化的对象。\n所以需要volatile来禁止指令重排。\n\n### 对象在内存中的存储布局？\n对象头、实例数据和对齐填充\n\n### 对象怎么定位？\n引用->堆内存的对象->方法区常量。\n\n### 对象怎么分配？\n开始new一个对象\n    *尝试在栈上分配？\n        * 可以在栈上分配，在pop时结束生命周期\n        * 若一个对象的引用逃出了方法或者线程，在方法调用过程中传递对象的引用到另一个方法，或栈空间不够大。则不能在栈上分配。\n            * 对象是否够大？\n                * 足够大，老年代分配，full gc时结束生命周期\n                * 不够大，尝试 tlab 分配？\n                    * tlab空间是否足够？\n                        * 足够，tlab（线程本地空间）分配到eden，\n                        * 不足，共享空间分配到eden\n                    * young gc-> 幸存者区-> 老年代-> full gc 结束生命周期\n                    \n一般的对象分配内存，都是在新生代进行空间申请的。在多个线程都在申请空间时，每次对象分配都必须进行同步。竞争激烈的场合分配的效率又会进一步下降。TLAB是一个存在于eden区的线程独享内存区域，主要用于降低在新生代分配对象时的内存竞争，提升对象分配的效率。\n      \n\n### Object o = new Object() 在内存中占多少字节？\n对象的引用o 4 byte\nObject 的 mark word 占 8 byte\nklass pointer 若开启指针压缩占 4 byte，不开启压缩占 8 byte\n对象的属性大小不确定。\n\n\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ 集合 ------------------------</span>\n</div>\n\n## 集合\n\n###  HashSet 的底层实现是什么?\nHashSet 的实现是依赖于 HashMap 的，HashSet 的值都是存储 在 HashMap 中的。在 HashSet 的构造法中会初始化一个 HashMap 对象\nHashSet 不允许值重复，因此，HashSet 的值是作为 HashMap 的 key 存储在 HashMap 中的，当存储的值已经存在时返回 false。\n\n###  Iterator 和 ListIterator 的区别是什么?\n* Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。\n* Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。\nListIterator 实现了 Iterator 接口，并包含其他的功能，比如:增加元素，替换元 素，获取前一个和后一个元素的索引，等等。\n\n### 数组 (Array) 和列表 (ArrayList) 有什么区别?\n* Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。\n* Array 大小是固定的，ArrayList 的大小是动态变化的。\n* ArrayList 处理固定大小的基本数据类型的时候，这种方式相对比较慢。\n\n###  Comparable 和 Comparator 接口是干什么的?\n**Comparable**：只包含一个 compareTo() 方法，这个方法可以个 给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于 已经存在的对象。\n**Comparator**：包含 compare() 和 equals() 两个方法。\n    * compare() 方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小 于，等于，大于第二个参数。\n    * equals() 方法需要一个对象作为参数，它用来决定输入 参数是否和 comparator 相等。\n    \n### Collection 和 Collections 的区别？\n**Collection**：是集合类的上级接口, 继承与它的接口主要是 set 和 list。\n**Collections**： 类是针对集合类的一个帮助类. 它提供一系列的静态方法对各种集合的搜 索, 排序, 线程安全化等操作。\n\n### ArrayList 和 Vector 的区别？\n**相同**：\n    * 都实现了 List 接口(List 接口继承了 Collection 接口)\n    * 都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组\n    * 允许重复\n\n**区别**：\n    * Vector 是线程安全的，ArrayList 是线程序不安全的。\n**数据增长**:\n    * 相同：ArrayList 与 Vector 都可以设置初始的空间大小\n    * 不同：Vector 还可以设置增长的空间大小，而 ArrayList 没有提供设置增长空间的方法。\n           Vector 默认增加原来的 1 倍，ArrayList 增加原来的 0.5 倍。\n           \n### 快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么?\nIterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。\n\njava.util 包下面的所有的集合类都是快速失败的，迭代器会抛出 ConcurrentModificationException 异常\njava.util.concurrent 包下面的所有的类都是安全失败的。安全失败的迭代器永远不会抛出这样的异常。\n\n\n    \n### List、Map、Set 三个接口，存取元素时，各有什么特点?\n这样的题属于随意发挥题:这样的题比较考水平，两个方面的水平:一是要真正明白 这些内容，二是要有较强的总结和表述能力。如果你明白，但表述不清楚，在别人那 里则等同于不明白。\n\n首先List与Set\n相同：\n    * 都是单列元素的集合，有一个相同的父类 Collection\n不同：\n    * List 元素可以重复，Set不可以\n    * List 可以按index取元素，Set只能逐一遍历\n    * List 是有序集合。\n\nMap 是双列集合，要存储一对 key/value，不能存储重复的 key。\n\n###  HashMap 的工作原理是什么?\nHashMap 1.8是 **数组 + 链表 + 红黑树** 实现的。\n* 负载因子（loadFactor）：0.75f\n* 容量（capacity）：16\n* 扩容阈值（threshold）：loadFactor * capacity\n* 转化成树的链表阈值（TREEIFY_THRESHOLD）：8\n* 转化成树的最小容量（MIN_TREEIFY_CAPACITY）：64\nJava 中的 HashMap 是以键值对 (key-value) 的形式存储元素的，我们把一对(key-value)称为Node。\nHashMap 需要 一个 hash 函数，当调用 put() 方法的时候，HashMap 会计算 key 的 hash 值，然后把键值对存储在集合中合适的索引上。 \n如果索引上已经存在了Node，发生哈希冲突。\n    * 如果索引上的结构是**链表**，则在链表中遍历，如果有相同的key，value 会被更新成新值，否则遍历到链表尾部，插入新的(key-value) ，size+1\n        * 如果链表的长度大于**转化成树的链表阈值（TREEIFY_THRESHOLD）** 并且，hashMap的容量大于**转化成树的最小容量（MIN_TREEIFY_CAPACITY）** 则转换成`红黑树`。\n    * 如果索引上的结构是**红黑树**，则在红黑树中遍历，如果有相同的key，value 会被更新成新值，否则插入红黑树，size+1。\n    \n如果 size > threshold 则进行扩容。\n    * 当原来的容量已经达到最大容量的时候，将阈值设置为Integer.MAX_VALUE，这样就不会再发生重构的情况\n    * 将新的阈值设置为旧的阈值的两倍, 新的容量设置为旧容量的2倍。\n    * 根据新容量新建一个Node数组，将旧数组中的元素全部取出，重新映射到新数组中\n    \n### hashMap 容量为什么是 2 的幂次？\n为了**加快哈希计算**以及**减少哈希冲突**。\n为什么可以加快计算？\n我们都知道为了找到 KEY 的位置在哈希表的哪个槽里面，需要计算 **hash(KEY) % 数组长度**\n但是 % 计算比 & 慢很多，所以用 & 代替 %，为了保证 & 的计算结果等于 % 的结果需要把 length 减 1，也就是 **hash(KEY) & (length - 1)**\n证明：当length 为2的幂次时，m % length = m & (length-1)\n     m 可以分成两部分 x（length的正数倍） 和 y（剩余部分） 因此 y的范围为 0 <= y <length\n     m % length = (x + y)% length = x % length + y % length = 0 + y % length = y\n     假设y 是 5 二进制 0101，length 为 8 二进制 1000 ，length -1 二进制 0111\n     0101&0111 = 0101 刚好将 5取出，因此成立\n\n为什么可以减少冲突？\n假设现在数组的长度 length 可能是偶数也可能是奇数。\nlength 为偶数时，length-1 为奇数，奇数的二进制最后一位是 1，这样便保证了 hash &(length-1) 的最后一位可能为 0，也可能为 1（这取决于 h 的值），即 & 运算后的结果可能为偶数，也可能为奇数，**这样便可以保证散列的均匀性。**\nlength 为奇数的话，很明显 length-1 为偶数，它的最后一位是 0，这样 hash & (length-1) 的最后一位肯定为 0，即只能为偶数，这样任何 hash 值都只会被散列到数组的偶数下标位置上，这便**浪费了近一半的空间**\n\n    \n### ConcurrentHashMap 的工作原理是什么什么？\n* JDK1.7:\n    ConcurrentHashMap采用了**数组+Segment+分段锁**的方式实现。\n    Segment：类似于HashMap的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表,同时又是一个ReentrantLock（Segment继承了ReentrantLock）。\n    ![](Interview/concurrentHashMap1.7.jpg)\n    从上面的结构我们可以了解到，ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作。\n    第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部。\n* JDK1.8:\n    采用了数组+链表+红黑树实现.**彻底放弃了Segment转而采用的是Node，其设计思想也不再是JDK1.7中的分段锁思想。**\n    Java8 ConcurrentHashMap结构基本上和Java8的HashMap一样，原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。\n\n### HashTable 、ConcurrentHashMap 和 hashMap 的区别？\nhashTable 默认初始容量是11，hashMap 和 ConcurrentHashMap 默认初始容量是16，\nHashTable 在put和get方法上用了 synchronized 。ConcurrentHashMap 对每个node节点使用 synchronized\n\n### LinkedHashMap 工作原理？\nLinkedHashMap基于hashMap的基础上，对每个键值对(Node节点)多维护了一个before和after指针，每次插入时维护双向链表。\nLinkedHashMap有序，可分为插入顺序和访问顺序两种。\n如果是访问顺序，那put和get操作已存在的Entry时，都会把Entry移动到双向链表的表尾(其实是先删除再插入)。\n\n### TreeMap 工作原理？\n底层红黑树实现。\nTreeMap有序是通过Comparator来进行比较的，如果comparator为null，那么就使用自然顺序\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ 异常 ------------------------</span>\n</div>\n\n## 异常\n### Java中的异常有哪几类？\n异常类有分为编译时异常和运行时异常\n常见的编译时异常：\n    * IOException\n    * SQLException\n    * parseException\n    \n常见的运行时异常（RuntimeException）：\n    * NullPointerException: 空指针异常,一般出现于数组,空对象的变量和方法\n    * ArrayIndexOutOfBoundsException: 数组越界异常\n    * NoClassDefFoundException: java运行时系统找不到所引用的类\n    * NumberFormatException: 数据格式异常\n    * OutOfMemoryException: 内存溢出异常\n    * ArithmeticException: 算数异常,一般在被除数是0中\n    * IllegalArgumentException: 非法参数异常\n    \n\n### Error 和 Exception 区别是什么？\nError 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；\nException 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。\n\n### 运行时异常和编译时异常区别是什么？\n运行时异常：编译器不会对运行时异常进行检测，没有 try-catch，方法签名中也没有 throws 关键字声明，编译依然可以通过。如果出现了 RuntimeException, 那一定是程序员的错误\n编译时异常：如果没有 try-catch，且方法签名中也没有用 throws 关键字声明可能抛出的异常，则编译无法通过。这类异常通常为应用环境中的错误，即外部错误，非应用程序本身错误，如文件找不到等。\n\n### throw 和 throws 的区别是什么？\n**throw** 关键字用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。\n**throws** 关键字用在方法签名处，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。\n\n\n### Java内存溢出是什么？\n内存溢出分三种情况。\n* OutOfMemoryError： PermGen space 元空间\n    这个区域主要用来保存加来的Class的一些信息，在程序运行期间属于永久占用的，Java的GC不会对他进行释放，所以如果启动的程序加载的信息比较大，超出了这个空间的大小，就会发生溢出错误；\n    解决的办法无非就是增加空间分配了——增加java虚拟机中的XX:PermSize和XX:MaxPermSize参数的大小，其中XX:PermSize是初始永久保存区域大小，XX:MaxPermSize是最大永久保存区域大小。\n* OutOfMemoryError：Java heap space \n    heap 是Java内存中的堆区，主要用来存放对象，当对象太多超出了空间大小，GC又来不及释放的时候，就会发生溢出错误。\n    一般来说，当已存在对象没有引用(即不可达)的时候，GC就会定时的来回收对象，释放空间。但是因为程序的设计问题，导致对象可达但是又没有用(即前文提到的内存泄露)，当这种情况越来越多的时候，问题就来了。\n    针对这个问题，我们需要做一下两点： 1、检查程序，减少大量重复创建对象的死循环，减少内存泄露。 2、增加Java虚拟机中Xms（初始堆大小）和Xmx（最大堆大小）参数的大小。\n* StackOverFlowError\n    stack是Java内存中的栈空间，主要用来存放方法中的变量，参数等临时性的数据的，发生溢出一般是因为分配空间太小，或是执行的方法递归层数太多创建了占用了太多栈帧导致溢出。\n    针对这个问题，除了修改配置参数-Xss参数增加线程栈大小之外，优化程序是尤其重要。\n\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ 反射 ------------------------</span>\n</div>\n\n## 反射\n### 什么是反射？\n反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；\n这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。\n\n\n### 什么是 Java 序列化？什么情况下需要序列化？\nJava 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。\n以下情况需要使用 Java 序列化：\n* 想把的内存中的对象状态保存到一个文件中或者数据库中时候；\n* 想用套接字在网络上传送对象的时候；\n* 想通过RMI（远程方法调用）传输对象的时候。\n\n\n### 动态代理是什么？有哪些应用？\n动态代理是运行时动态生成代理类。\n\n动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。\n\n### 怎么实现动态代理？\nJDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。\n\n### JDK 动态代理为什么只能基于接口？\njava的代理对象自动继承了Proxy，又因为JAVA是单继承的，所以目标对象只能实现接口不能继承。\n    \n    \n\n\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ JVM ------------------------</span>\n</div>\n\n## JVM\n### 什么是JVM？什么是hotspot？\nJVM ------- 规范/标准\nhotspot --- 产品/实现\n\n### 说一下 JVM 的主要组成部分？及其作用？\n![](Interview/1.png)\n* 类加载器（ClassLoader）\n* 运行时数据区（Runtime Data Area）\n* 执行引擎（Execution Engine）\n* 本地库接口（Native Interface）\n\n组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，\n           运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，\n           因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，\n           而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。\n\n### 说一下类装载的执行过程？\n![](Interview/2.png)\n类装载分为以下 5 个步骤：\n1. **加载**：将.class文件从磁盘读到内存\n    * 通过类的全限定名(com.xxx.xxx)+类加载器确定唯一的类，来获取定义此类的二进制字节流\n    * 将这个类字节流代表的静态存储结构转为方法区的运行时数据结构\n    * 在堆中生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口。\n2. **检查**：检查加载的 class 文件的正确性；\n    * 文件格式验证:验证字节流是否符合 Class 文件的规范，如 主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.\n    * 元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。\n    * 字节码验证:是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如:方法中的类型转换是否正确，跳转指令是否正确等。\n    * 符号引用验证:基于方法区的存储结构验证，发生在解析中，是否可以将符号引用成功解析为直接引用。\n3. **准备**：给类中的静态变量分配内存空间；\n    * public static int value = 123; //此时在准备阶段过后的初始值为0而不是123，在初始化过程才会被赋值为123\n    * public static final int value = 123;//value的值在准备阶段过后就是123。\n4. **解析**：虚拟机将常量池中的符号引用替换成直接引用的过程。**符号引用就理解为一个标示，而在直接引用直接指向内存中的地址**；\n5. **初始化**：对静态变量和静态代码块执行初始化工作。\n\n\n### 类加载器的种类？\n![](Interview/3.png)\n* 启动类加载器(Bootstrap ClassLoader)：负责加载JRE的核心类库，如JRE目标下的rt.jar，charsets.jar等\n* 扩展类加载器(Extension ClassLoader)：负责加载JRE扩展目录ext中jar类包\n* 系统类加载器(Application ClassLoader)：负责加载ClassPath路径下的类包\n* 用户自定义加载器(User ClassLoader)：负责加载用户自定义路径下的类包\n\n### 什么是双亲委派模型？\n![](Interview/4.png)\n如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。\n           \n### 双亲委派模式的优势?\n* 沙箱安全机制:比如自己写的String.class类不会被加载，这样可以防止核心库被随意篡改\n* 避免类的重复加载:当父ClassLoader已经加载了该类的时候，就不需要子ClassLoader再加载一次   \n\n### 为什么要打破双亲委派模式?\n例如：tomcat \nTomcat是个web容器,可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。 \n如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加载器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。\n           \n###  JVM 运行时数据区？\n![](Interview/5.png)\n* 程序计数器（Program Counter Register）: 前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；\n* Java 虚拟机栈（Java Virtual Machine Stacks）: 用于存储局部变量表、操作数栈、动态链接、方法出口等信息；\n* 本地方法栈（Native Method Stack）: 与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；\n* Java 堆（Java Heap）: Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；\n* 方法区（Methed Area）: 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。\n\n\n### Java 中都有哪些引用类型？\n* 强引用：通常我们使用new操作符创建一个对象时所返回的引用即为强引用\n* 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。\n* 弱引用：有用但不是必须的对象，在下一次GC时会被回收。\n* 虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。\n\n### Java 堆的结构是什么样子的?\n![](Interview/6.jpeg)\n堆空间一般分为新生代、老年代。\n\n### 什么是新生代？\n新生代分为两部分:`伊甸区`(Eden space)和`幸存者区`(Survivor space)，所有的类都是在伊甸区被new出来的。\n幸存区(Survivor space):分为From和To区,TO区永远保持空。\n当Eden区的空间用完是，程序又需要创建对象，JVM的垃圾回收器将Eden区进行垃圾回收(`Minor GC`)，将Eden区中的不再被其它对象应用的对象进行销毁。\n然后将Eden区中剩余的对象移到From Survivor区。若From Survivor区也满了，再对该区进行垃圾回收，然后移动到To Survivor区，From区为空后，将To和From区转换，保证To区为空，并且对象年龄加一。\n当对象年龄默认加到15（因为**对象头只有4个bits**是存对象年龄，最大为15）时将剩下的对象移到老年代。\n\n### 什么是老年代？\n新生代经过多次GC仍然存货的对象移动到老年区。\n若老年代也满了，这时候将发生Major GC(也可以叫`Full GC`)， 进行老年区的内存清理。\n若老年区执行了Full GC之后发现依然无法进行对象的保存，就会抛出 OOM(OutOfMemoryError)异常.\n\n### Survivor区 到 老年代有什么条件？\n对象年龄到15，才会移动到老年代。因为**对象头只有4个bits**是存对象年龄，最大为15\n\n### JVM 有哪些垃圾回收算法？\n* **标记-清除算法**：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。\n* **标记-整理算法**：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。\n* **复制算法**：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。\n* **分代算法**：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。\n\n### JVM 有哪些垃圾回收器？\n* Serial：最早的单线程串行垃圾回收器。**新生代采用复制算法，老年代采用标记-整理算法。**\n* Serial Old：Serial 垃圾回收器的老年代版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。采用**标记-整理**算法。\n* ParNew：是 Serial 的多线程版本。**新生代采用复制算法，老年代采用标记-整理算法。**\n* Parallel： 是 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。**新生代采用复制算法，老年代采用标记-整理算法。**\n* Parallel Old： 是 Parallel 老年代版本，，Parallel Old 使用的是**标记-整理**的内存回收算法。\n* CMS：一种以获得最短停顿时间为目标的收集器，第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作。是一种**标记-清除**算法实现\n    * 初始标记(CMS initial mark): 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 \n    * 并发标记(CMS concurrent mark): **同时开启GC和用户线程**，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\n    * 重新标记(CMS remark): 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶 段时间短\n    * 并发清除(CMS concurrent sweep): 开启用户线程，同时GC线程开始对为标记的区域做清扫。\n* G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。G1从整体来看是基于**标记整理**算法实现的收集器;从局部上来看是基于**标记复制**算法实现的\n\n### 堆栈的区别？\n* 功能方面：堆是用来存放对象的，栈是用来执行程序的。\n* 共享性：堆是线程共享的，栈是线程私有的。\n* 空间大小：堆大小远远大于栈。\n\n### 怎么判断对象是否可以被回收？\n**引用计数器**：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；\n**可达性分析**：这个算法的基本思想就是通过一系列的称为\"GC Roots\"的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象时不可用的。\n    * `GC Roots根节点`:类加载器、Thread、虚拟机栈的局部变量表、static成员、常量引用、本地方法栈的变量等等.\n\n\n### JVM 调优的工具？\nJDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。\n* jconsole：用于对 JVM 中的内存、线程和类等进行监控；\n* jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。\n\n### JVM 调优的参数都有哪些？\n-Xms2g：初始化推大小为 2g；\n-Xmx2g：堆最大内存为 2g；\n-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；\n-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；\n–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；\n-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；\n-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；\n-XX:+PrintGC：开启打印 gc 信息；\n-XX:+PrintGCDetails：打印 gc 详细信息。\n\n### Java 中会存在内存泄漏吗？\n所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。\n长生命周期的对象持有短生命周期对 象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需 要，但是因为长生命周期对象持有它的引用而导致不能被回收。\n\n### finalize() 方法什么时候被调用?\n垃圾回收器(garbage colector)决定回收某对象时，就会运行该 对象的 finalize() 方法 但是在 Java 中很不幸，如果内存总是充 足的，那么垃圾回收可能永远不会进行，也就是说 filalize() 可能 永远不被执行，显然指望它做收尾工作是靠不住的。 那么 finalize() 究竟是做什么的呢? 它最主要的用途是回收特殊渠道申请的内存。Java 程序有垃圾回收器，所以一般情况下内存问题 不用程序员操心。但有一种 JNI(Java Native Interface)调用 non-Java 程序(C 或 C++)， finalize() 的工作就是回收这部分的内存。\n\n### 深拷贝和浅拷贝区别是什么？\n* 浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制，指向同一个地址。\n* 深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。\n\n###  如何实现对象克隆？\n* 实现 Cloneable 接口并重写 Object 类中的 clone() 方法。\n* 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ 多线程 ------------------------</span>\n</div>\n\n## 多线程\n\n### 什么是线程安全？\n如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 \n\n### 如何保证线程安全？\n* synchronized关键字 \n* 用Lock锁\n* volatile+CAS【单纯的volatile是轻量级的同步机制**保证可见性但是不具备原子性**所以要配合CAS来实现线程安全】\n* atomic原子类\n\n###  哪些集合类是线程安全的？\nVector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。\n\n### 并行和并发有什么区别?\n* 并行：多个处理器或多核处理器同时处理多个任务。( 两个队列和一台咖啡机 )\n* 并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。( 两个队列和两台咖啡机 )\n\n### 线程和进程的区别?\n一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。\n\n### 守护线程是什么?\n守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。\n\n### 创建线程有哪几种方式?\n* 继承 Thread 重写 run 方法；\n* 实现 Runnable 接口；\n* 实现 Callable 接口。(可以获取线程执行之后的返回值)\n* 线程池\n\n### Runnable和Callable的区别?\n* Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。\n* Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。\n* call方法可以抛出异常，run方法不可以。\n* 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。\n\n### 线程有哪些状态?\n* NEW 尚未启动\n* RUNNABLE 正在执行中\n* BLOCKED 阻塞的（被同步锁或者IO锁阻塞）\n* WAITING 永久等待状态\n* TIMED_WAITING 等待指定的时间重新被唤醒的状态\n* TERMINATED 执行完成\n\n![](Interview/01.jpeg)\n\n### sleep() 和 wait() 有什么区别?\n* 类的不同：sleep() 来自 Thread，wait() 来自 Object。\n* 释放锁：sleep() 不释放锁；wait() 释放锁。\n* 用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。\n\n### sleep() 和 yield() 区别？\n* sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield() 方法只会给相同优先级或更高优先级的线程以运行的机会； \n* 线程执行 sleep() 方法后转入阻塞（blocked）状态，而执行 yield() 方法后转入就绪（Runnable）状态； \n* sleep() 方法声明抛出InterruptedException，而 yield() 方法没有声明任何异常； \n* sleep() 方法比 yield() 方法（跟操作系统相关）具有更好的可移植性。\n\n### notify()和 notifyAll()有什么区别？\n* notifyAll: 会唤醒所有的线程,会将全部线程由等待池移到锁池,然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争\n* notify: 唤醒一个线程,具体唤醒哪一个线程由虚拟机控制。\n\n### 线程的 run() 和 start() 有什么区别？\nstart() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。\n\n### park() 的作用\nLockSupport类中的 park(Object blocker) 表示**阻塞指定线程**，参数blocker当前线程对象，使线程进入等待状态，释放cpu,并不会抛出中断异常\nunpark(Thread thread) 唤醒指定线程，参数thread指定线程对象 \n\n\n### `创建线程池有哪几种方式？`\n1. public static ExecutorService newCachedThreadPool() 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程，但是在之前构造的线程可用时将重用它们。\n2. public static ExecutorService newFixedThreadPool(int nThreads)  创建一个定长线程池，可控制线程最大并发数，以共享的无界队列方式来运行线程，超出的线程会在队列中等待。\n3. public static ExecutorService newSingleThreadExecutor() 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，以无界队列方式来运行线程，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n4. public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 创建一个周期线程池，支持定时及周期性任务执行。\n5. public static ExecutorService newWorkStealingPool() 创建持有足够线程的线程池来支持给定的并行级别，并通过使用多个队列，减少竞争，它需要穿一个并行级别的参数，如果不传，则被设定为默认的CPU数量，这个线程池实际上是ForkJoinPool的扩展，适合使用在很耗时的任务中，能够合理的使用CPU进行并行操作。\n\n### 线程池流程？\n![](Interview/threadPoll.png)\n\n### 线程池中 submit() 和 execute() 方法有什么区别？\n* execute()：只能执行 Runnable 类型的任务。\n* submit()：可以执行 Runnable 和 Callable 类型的任务。\n\n### 什么是CAS？\n全称Compare and swap，比较并交换。\nCAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存值修改为 B \njava 的 CAS 利用的的是 unsafe（该类都是基于JVM对操作系统进行的操作，因此是unsafe）这个类提供的 CAS 操作\nunsafe 的CAS 依赖了的 JVM 针对不同的操作系统实现的 Atomic::cmpxchg\nAtomic::cmpxchg 的实现使用了汇编的 cas 操作，并使用 cpu 硬件提供的 lock信号保证其原子性\n\n### CAS有什么问题？\nABA问题。\n举个例子：\n假设有一个遵循CAS原理的提款机，小灰有100元存款，要用这个提款机来提款50元。\n由于提款机硬件出了点小问题，小灰的提款操作被同时提交两次，开启了两个线程，两个线程都是获取当前值100元，要更新成50元。\n理想情况下，应该一个线程更新成功，另一个线程更新失败，小灰的存款只被扣一次。\n线程1首先执行成功，把余额从100改成50。线程2因为某种原因阻塞了。这时候，小灰的妈妈刚好给小灰汇款50元。\n线程2仍然是阻塞状态，线程3执行成功，把余额从50改成100。\n线程2恢复运行，由于阻塞之前已经获得了“当前值”100，并且经过compare检测，此时存款实际值也是100，所以成功把变量值100更新成了50。\n小灰凭空少了50元钱。\n\n解决方案：\n使用携带版本的号的AtomicStampedReference\n\n### 什么是AQS？\nAbstractQueuedSynchronizer，抽象队列同步器\nAQS就是一个并发包的基础组件，是一个抽象类，用来实现各种锁，各种同步组件的。\n它包含了state变量、加锁线程、等待队列等并发中的核心组件。常见的实现类有:ReentrantLock等。\n\n### AQS原理？\n* AQS对象内部有一个核心的变量叫做**state**，是int类型的，代表了加锁的状态，初始状态下，这个state的值是0。\n* AQS内部还有一个关键变量，用来记录**当前加锁的是哪个线程**，初始化状态下，这个变量是null。\n* AQS内部还有一个**等待队列**，专门放那些加锁失败的线程\n\n当 线程1 尝试进行加锁，用CAS操作将state值从0变为1。如果CAS操作成功，将当前加锁线程设置成自己。\n线程1 **可重入加锁时，每次判断当前加锁线程是否是自己，是的话state+1**\n当 线程2 尝试获取锁，用CAS操作将state值从0变为1，失败！！！然后检查当前加锁线程是否是自己，那当然不是。\n线程2 会将自己放入AQS中的一个等待队列，等待 线程1 释放锁之后，自己就可以重新尝试加锁了。\n线程1 释放锁就是将state变量的值递减1，将当前加锁线程设置成null。\n接下来，会从**等待队列的队头唤醒** 线程2 重新尝试加锁。\n重复上述过程。\n\n### ReentrantLock 原理？\nReentrantLock 可是分为公平锁和非公平锁，默认的构造函数是非公平锁\n公平锁：当判断到锁状态字段state == 0 时，不会立马将当前线程设置为该锁的占用线程，而是去判断是在此线程之前是否有其他线程在等待这个锁，然后再CAS操作获取锁\n非公平锁：没有判断是否有在此之前的排队线程，而是直接CAS操作进行获锁，此多个线程之间同时争用一把锁的时候，谁先获取到就变得随机了\n加锁过程：\n线程A，首先获取state的值判断是否为0，若state == 0。\n    * 判断是自己是否需要排队\n        * 若需要排队，也就是 队列的 head != tail 也就是队列已初始化了 并且 （head.next !=null 或 head.next.thread != 当前线程）\n            * 将head.next 指向A，A.pre 指向head。\n            * 判断A是否是排队的第一个线程\n        * 若不需要排队，尝试进行加锁，用CAS操作将state值从0变为1。\n            * 如果CAS操作成功，将当前加锁线程设置成自己。\n            * 如果CAS操作失败，会检查当前加锁线程是否是自己。\n                * 若是当前线程，就是重入锁，将state++。\n                * 若不是当前线程，将线程放入等待队列。\n                    * 如果队列为空，初始化一个thread=null的node作为队列的头head，将head.next 指向A，A.pre 指向head。\n            * 判断A是否是排队的第一个线程\n                * 如果A.pre == head ,表示A是排队的第一个线程，自旋两次尝试加锁，将A.pre 的ws值改为-1，若还失败则使用park()进行线程阻塞。\n                * 如果不是，则直接使用park()进行线程阻塞。\n\n释放锁：\n将state变量的值递减1，如果state == 0，将当前加锁线程设置成null。\n如果队列不为空，将队列的head节点的ws值改为0，然后用unpark()唤醒 head.next也就是A线程，\n然后将队列的head设置为A，A节点的thread设置为null。\n\n\n\n\n### 什么是锁？\n锁(lock)或互斥(mutex)是一种同步机制，用于在有许多执行线程的环境中强制对资源的访问限制。锁旨在强制实施互斥排他、并发控制策略。\n锁的作用就是保证多线程同步执行。\n\n\n### Java中有哪些锁？\n公平锁、非公平锁、读写锁、共享锁、互斥锁、自旋锁、偏向锁、轻量级锁、重量级锁等等。\n\n### 什么是死锁？\n线程A持有独占锁资源a，并尝试去获取独占锁资源b\n同时，线程B持有独占锁资源b，并尝试去获取独占锁资源a\n这样线程A和线程B相互持有对方需要的锁，从而发生阻塞，最终变为死锁。\n\n### 死锁发生的必要条件？\n* 互斥条件：一个资源每次只能被一个进程使用。\n* 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。\n* 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。\n* 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。\n\n### 怎么防止死锁？\n* 尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。\n* 尽量使用 Java. util. concurrent 并发类代替自己手写锁。\n* 尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。\n* 尽量减少同步的代码块。\n\n### 当一个线程进入一个对象的一个 synchronized 方法后，其它线程是否可进入此对象的其它方法?\n* 其他方法前是否加了 synchronized 关键字，如果没加，则能。\n* 如果这个方法内部调用了 wait，则可以进入其他 synchronized 方法。\n\n### synchronized(l){XX}是锁了代码块还是对象？怎么实现？\n锁了对象l，那么是对l做了什么来表示l被锁了呢？上锁就是改变了对象头。\n\n### 线程调度(优先级)\n与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线 程获取 CPU 资源的概率较大，优先级低的并非没机会执行。\n线程的优先级用 1-10 之 间的整数表示，数值越大优先级越高，默认的优先级为 5。 在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。\n\n### 什么是线程饥饿？\n线程饥饿是另一种活跃性问题，也可以使程序无法执行下去。\n如果一个线程因为处理器时间全部被其他线程抢走而得不到处理器运行时间，这种状态被称之为`饥饿`\n一般是由高优先级线程吞噬所有的低优先级线程的处理器时间引起的。\n\n### 什么是活锁？\n这两个线程虽然都没有停止运行，但是却无法向下执行，这种情况就是所谓的活锁。\n举个例子，两个人在走廊上碰见，大家都互相很有礼貌，互相礼让，A从左到右，B也从从左转向右，发现又挡住了地方，继续转换方向，但又碰到了，反反复复，一直没有机会运行下去。\n* 当所有线程在序中执行 Object.wait(0)，参数为 0 的 wait 方法。程序将发生 活锁直到在相应的对象上有线程调用 Object.notify() 或者 Object.notifyAll()。\n\n### Volatile关键字的作用？\n让其他线程能够马上感知到某一线程多某个变量的修改\n* 保证可见性:对共享变量的修改，其他的线程马上能感知到\n* 保证有序性:禁止重排序（编译阶段、指令优化阶段）volatile之前的代码不能调整到他的后面，volatile之后的代码不能调整到他的前面\n\n### volatile 能使得一个非原子操作变成原子操作吗?\n在 Java 中除了 long 和 double 之外的所有基本类型的读和赋值，都是原子性操作。\n而 64 位的 long 和 double 变量由于会被 JVM 当作两个分离的 32 位来进行操 作，所以不具有原子性，会产生字撕裂问题。但是当你定义 long 或 double 变量时， 如果使用 volatile 关键字，就会获到**(只有简单的赋值与返回操作的)**原子性。\n不能保证其他情况的原子性。\n\n###  synchronized 和 volatile 的区别是什么？\n* volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。\n* volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。\n* volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。\n\n### synchronized 和 Lock 有什么区别？\n* synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。\n* synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。\n* 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。\n\n### synchronized 和 ReentrantLock 区别是什么？\n* ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；\n* ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；\n* ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。\n\n性能区别：由于线程执行是交替执行。\njdk1.6 synchronized 是重量级锁，要频繁调用操作系统函数，交替执行，从用户态转到内核态效率低。\njdk1.8 synchronized 增加了偏向锁和轻量级锁，也是在jdk层面解决，所以和 ReentrantLock 性能差不多。\nReentrantLock 将线程交替执行放到jdk层面解决，所以比1.6的synchronized效率高\n如果线程是单线程或者线程是交替执行，那么ReentrantLock队列不会进行初始化，不会发送阻塞，都在jdk层面运行。而1.6 synchronized需要调用os操作更改锁对象状态，然后进入同步块。\n\n###  synchronized 底层实现原理？\nsynchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。\n\n### 什么是Monitor？\nMonitor其实是一种同步工具，也可以说是一种同步机制，它通常被描述为一个对象,也常被翻译为“监视器\\管程”,每个对象都会有一个 monitor\n* 某一线程占有一个对象的时候，先看该对象的 monitor 的计数器是不是0，如果是0表示这个对象还没有线程占有，这个时候线程占有这个对象，并且对这个对象的monitor+1；如果不为0，表示这个对象已经被其他线程占有，这个线程等待。当线程释放占有权的时候，monitor-1；\n* 同一线程可以对同一对象进行多次加锁，+1，+1，体现了重入性\n\n### 多线程中 synchronized 锁升级的原理是什么？\n在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。\n\n### 什么是偏向锁？\n当线程请求到锁对象后，将锁对象的状态标志位改为01，即偏向模式。然后使用CAS操作将线程的threadid记录在锁对象的Mark Word中。以后该线程可以直接进入同步块，连CAS操作都不需要。但是，一旦有第二条线程需要竞争锁，那么偏向模式立即结束，进入轻量级锁的状态。\n\n### 什么是轻量级锁？\n从偏向锁的状态发生竞争后，会锁膨胀变成轻量级锁。\n轻量级锁是在内存有一个锁记录，当某个线程获取到锁后，会将锁记录保存到线程内存中，同时将原本的锁记录指向它的线程内存中的备份锁记录位置。其他线程判断锁记录已经指向了其他线程，因此会进入自旋状态。达到一定的次数或时间后，会膨胀变成重量级锁。\n\n### 悲观锁和乐观锁的概念？\n* 乐观锁：乐观地认为所有的并发操作都是线程安全的，不需要加锁来处理。但为了保证数据没有被修改，会通过CAS操作来进行判定和替换。\n* 悲观锁：悲观地认为所有的并发操作都是线程不安全的，都需要加锁来保证线程安全\n\n###  ThreadLocal 是什么？有哪些使用场景？\nThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。\n\nThreadLocal 的经典使用场景是数据库连接和 session 管理等。\n\n### ThreadLocal原理？\n* 每个Thread维护着一个ThreadLocalMap的引用\n* ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储\n* 调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值是传递进来的对象\n* 调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象\n* ThreadLocal本身并不存储值，它只是作为一个key来让线程从ThreadLocalMap获取value。\n\n### ThreadLocal缺点？\n由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏。\nThreadLocal由于真正存储数据的ThreadLocalMap只单纯地采取了数组的形式来存储数据，因此出现hash冲突时会为hash值就增加一个固定的大小0x61c88647进行线性寻找位置，会导致大量的hash冲突，造成很高的资源消耗。\n\n### 什么是CyclicBarrier？\n栅栏(Barrier)类似于闭锁，他能阻塞一组线程直到某个事件发生后再全部同时执行。CyclicBarrier 字面意思是回环栅栏，回环的意思是它能够被重复利用，当然前提是在所有线程释放了以后。\n\n### 什么是CountDownLatch？\nCountDownLatch也叫闭锁,使得一(多)个主线程必须等待其他线程完成操作后再执行.\nCountDownLatch内部维护一个计数器(父类的int state),主线程先执行await方法，如果此时计数器大于0，则阻塞等待。当一个线程完成任务后，计数器值减1。直到计数器为0时，表示所有的线程已经完成任务，等待的主线程被唤醒继续执行。\n\n### CyclicBarrier 和 CountDownLatch 的区别？\n* CyclicBarrier 是所有线程必须同时到达栅栏位置，才能继续执行。它用于等待其他线程，并且能够重置使用。\n* CountDownLatch 用于等待事件，是一次性对象，一旦进入终止状态，就不能被重置。\n* CountDownLatch 通常阻塞的是主线程，开锁以后主线程才继续执行。\n* CyclicBarrier 阻塞的是子线程，到达栅栏位置后，每个线程还可以继续做自己后续的事情。\n\n## IO\n\n### 字节流和字符流？\n![](Interview/io.png)\n字节流：以字节（8bit）为单位，能处理所有类型的数据\n字符流：以字符为单位，根据码表映射字符，一次可能读多个字节，只能处理字符类型的数据。\nInputStreamReader:字节到字符的桥梁\nOutputStreamWriter:字符到字节的桥梁\n\n\n### NIO是什么？\nNIO（Non-blocking I/O，在Java领域，也称为New I/O），是一种同步非阻塞的I/O模型。\n说到NIO就得先从传统BIO（Blocking I/O）说起。\nBIO：传统的网络通讯模型，就是BIO，同步阻塞IO\n它其实就是服务端创建一个ServerSocket， 然后就是客户端用一个Socket去连接服务端的那个ServerSocket， ServerSocket接收到了一个的连接请求就创建一个Socket和一个线程去跟那个Socket进行通讯。\n服务端会在等待连接、等待读取或者等待写入时发生阻塞。\n这种方式的缺点：每次一个客户端接入，都需要在服务端创建一个线程来服务这个客户端。\n这样大量客户端来的时候，就会造成服务端的线程数量可能达到了几千甚至几万，这样就可能会造成服务端过载过高，最后崩溃死掉。\n因此我们要在BIO的基础上进行改进。\n\n假设一个单线程的Socket服务，那么它会在accept()也就是等待客户端连接时阻塞，当有客户端A连接时，服务端会等待read()服务端发来的的数据。\n首先，如果可以让read（）不阻塞，那么在客户端A连接之后，如果读到数据，就进行逻辑操作，如果没读到数据，我们就继续等待下一个客户端连接\n那么此时有客户端B连接，这时A发送数据，就接受不到数据了，所以我们再增加一个list保存socket连接，\n也就是在A连接之后，我们就用list保存这个socket连接，然后轮询这个list，看看有没有客户端发送数据，有就处理，然后继续等待下一个客户端连接。\n此时 accept（）操作还是阻塞的，在没有客户端连接时，还是接收不到数据。\n如果可以让accept（）不阻塞，在没有客户端连接的时候，也进行轮询这个list，看看有没有客户端发送数据。\n这样就实现了一个简单的nio。\njava的nio就是将上述操作中的轮询操作交给操作系统来进行了。\n\n\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ Spring ------------------------</span>\n</div>\n\n# Spring\n\n## 基础\n### 为什么要使用 spring？\n* spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。\n* spring 提供了事务支持，使得事务操作变的更加方便。\n* spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。\n* 更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis 等。\n\n### spring 有哪些主要模块？\n* spring core：框架的最基础部分，提供 ioc 和依赖注入特性。\n* spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。\n* spring dao：Data Access Object 提供了JDBC的抽象层。\n* spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。\n* spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。\n* spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。\n\n### spring mvc流程\n![](Interview/springmvc.png)\n\n## AOP\n### 什么是 aop？\naop 是面向切面编程，可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。\naop的应用场景：日志记录、权限验证、效率检查、事务管理、exception\n\n### AOP术语？\n* 切面(Aspect)：切面是通知和切点的结合，通知和切点共同定义了切面的全部内容\n* 连接点(Join point)：目标对象中的方法。\n* 通知(Advice)：定义了切面是做什么以及何时使用。\n* 切点(Pointcut)：表示连接点的集合。（PointCut是JoinPoint的谓语，这是一个动作，主要是告诉通知连接点在哪里，切点表达式决定 JoinPoint 的数量）\n* 目标对象(Target object)：目标对象 原始对象\n* aop代理(AOP proxy)：代理对象  包含了原始对象的代码和增加后的代码的那个对象\n* 织入(Weaving)：把代理逻辑加入到目标对象上的过程\n\n### AOP实现原理？\n通过动态代理实现。动态代理又分为jdk动态代理和cglib动态代理。\n* jdk动态代理：主要通过Proxy.newProxyInstance()和InvocationHandler这两个类和方法实现\n    * 实现过程\n        * 实现InvocationHandler接口，重写invoke()方法\n        * 调用Proxy.newProxyInsatnce(classloader,interfaces,handler)方法生成代理类\n            * 生成的代理类为$Proxy0 extends Proxy implements Person\n            * 因为已经继承了Proxy,所以java动态代理只能对接口进行代理\n    * 总结： 代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。\n\n\n## IOC\n### 什么是 ioc？\n控制反转，将你设计好的对象交给容器控制，可以用来减低计算机代码之间的耦合度。\n\n### 什么是DI？\nDI是依赖注入，是实现IOC的一种方式。\n\n###  spring 常用的注入方式有哪些？\n* setter 属性注入\n* 构造方法注入\n* 注解方式注入\n\n###  spring 中的 bean 是线程安全的吗？\nspring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。\n实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。\n* 有状态就是有数据存储功能。\n* 无状态就是不会保存数据。\n\n###  spring 自动装配 bean 有哪些方式？\n* no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。\n* byName：它根据 bean 的名称注入对象依赖项。\n* byType：它根据类型注入对象依赖项。\n* constructor：通过构造函数来注入依赖项，需要设置大量的参数。\n\n\n### Spring beanFactory 和 factoryBean 的区别？\n**beanFactory** 是Spring容器的顶层接口，用于管理Bean的一个工厂。 在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。\n**FactoryBean** 这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean，它能在需要的时候生产一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。\n\n通常情况下，bean 无须自己实现工厂模式，Spring 容器担任了工厂的 角色；但少数情况下，容器中的 bean 本身就是工厂，作用是产生其他 bean 实例。由工厂 bean 产生的其他 bean 实例，不再由 Spring 容器产生，因此与普通 bean 的配置不同，不再需要提供 class 元素。\n\n\n### BeanFactory和ApplicationContext是什么关系？\n![](Interview/applicationContext.jpg)\n最主要的区别是BeanFactory是延迟加载，ApplicationContext是即时加载。\n\n### spring 支持几种 bean 的作用域？\n* singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；\n* prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；\n* Web 环境下的作用域：\n* request：每次 http 请求都会创建一个 bean；\n* session：同一个 http session 共享一个 bean 实例；\n* global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。\n\n\n### spring bean 容器的生命周期是什么样的？\n1. Spring 容器根据配置中的 bean 定义，通过构造方法反射来实例化 bean。\n2. Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。\n3. 如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。\n4. 如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。\n5. 如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。\n6. 如果为 bean 指定了 init 方法（ <bean> 的 init-method 属性），那么将调用它。\n7. 最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。\n8. 如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。\n9. 如果为 bean 指定了 destroy 方法（ <bean> 的 destroy-method 属性），那么将调用它。\n\n![](Interview/bean.png)\n1：实例化一个ApplicationContext的对象；\n2：调用bean工厂后置处理器完成扫描；\n3：循环解析扫描出来的类信息；\n4：实例化一个BeanDefinition对象来存储解析出来的信息；\n5：把实例化好的beanDefinition对象put到beanDefinitionMap当中缓存起来，以便后面实例化bean；\n6：再次调用bean工厂后置处理器；\n7：当然spring还会干很多事情，比如国际化，比如注册BeanPostProcessor等等，如果我们只关心如何实例化一个bean的话那么这一步就是spring调用finishBeanFactoryInitialization方法来实例化单例的bean，实例化之前spring要做验证，需要遍历所有扫描出来的类，依次判断这个bean是否Lazy，是否prototype，是否abstract等等；\n8：如果验证完成spring在实例化一个bean之前需要推断构造方法，因为spring实例化对象是通过构造方法反射，故而需要知道用哪个构造方法；\n9：推断完构造方法之后spring调用构造方法反射实例化一个对象；注意我这里说的是对象、对象、对象；这个时候对象已经实例化出来了，但是并不是一个完整的bean，最简单的体现是这个时候实例化出来的对象属性是没有注入，所以不是一个完整的bean；\n10：spring处理合并后的beanDefinition(合并？是spring当中非常重要的一块内容)；\n11：判断是否支持循环依赖，如果支持则提前把一个工厂存入singletonFactories——map；\n12：判断是否需要完成属性注入\n13：如果需要完成属性注入，则开始注入属性\n14：判断bean的类型回调Aware接口\n15：调用生命周期回调方法\n16：如果需要代理则完成代理\n17：put到单例池——bean完成——存在spring容器当中\n\n### Spring中的aware接口什么作用？\nBeanNameAware接口是为了让自身Bean能够感知到，获取到自身在Spring容器中的id属性，也就是beanName；\n其他的Aware接口也是为了能够感知到自身的一些属性。\n比如实现了ApplicationContextAware接口的类，能够获取到ApplicationContext。\n实现了BeanFactoryAware接口的类，能够获取到BeanFactory对象。\n\n\n### Spring 在什么时候完成的依赖注入？\n在初始化的时候。也就是在new AnnotationConfigApplicationContext的时候\n\n### Spring中的循环依赖是怎么解决的？\nspring 单例情况下是支持循环依赖的。\n假设A对象和B对象循环依赖，那么在初始化时会经历如下步骤：\n创建A -> 实例化A -> 填充A的属性 -> getBean(B) -> 创建B -> 实例化B -> 填充B的属性-> getBean(A)\n-> 若二级缓存中存在，将从二级缓存工厂中生产出的A放入三级缓存->从三级缓存中获取A->。。。\n\n### @Resource 和 @Autowired 的区别？\n* 默认装配类型不一样：\n    * @Autowired默认按type装配：默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。\n    * @Resource 默认按照名称进行装配：当找不到与名称匹配的bean才会按照类型装配\n* bean 在初始化时 调用的后置处理器不一样，\n    * @Autowired 调用的是 AutowiredAnnotationBeanPostProcessor()\n    * @Resource 调用的是 CommonAnnotationBeanPostProcessor()\n\n### Spring 三级缓存？\n每一级缓存都是一个map。\n一级：singletonObjects 单例池，主要存放单例 bean\n二级：singletonFactories 主要存放ObjectFactory类型工厂对象\n三级：earlySingletonObjects 从工厂中获取的spring 对象，也就是半成品bean\n三级缓存存在的意义是防止工厂重复执行对对象的操作，提高性能。\n \n### @Qualifier 注解有什么用？\n当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。\n\n\n### 什么是事务传播行为？\n事务传播行为（propagation behavior）指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何运行。\n例如：methodA方法调用methodB方法时，methodB是继续在调用者methodA的事务中运行呢，还是为自己开启一个新事务运行，这就是由methodB的事务传播行为决定的。\n\n* PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，这是最常见的选择，也是**Spring默认的事务传播行为。**\n    * methodA 调用 methodB时，设置B为当前传播行为，A未开启事物，B在自己的事物中运行，A开启事物，则B加入A的事物，若A发生异常，则B会进行回滚操作。\n* PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。\n    * A开启事物，B也创建自己的事物，若A发生异常，B不影响。\n* PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。\n    * A未开启事物，则B以非事物方式执行，若A发生异常，B不影响；若A开启事物，则B加入A的事物，若A发生异常，则B会进行回滚操作。\n* PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。\n    * A未开启事物，则直接抛出异常；若A开启事物，则B加入A的事物，若A发生异常，则B会进行回滚操作。\n* PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\n    * 无论A开不开启事物，B都以非事物方式执行   \n* PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。\n    * A未开启事物，则B以非事物方式执行；A开启事物，则抛出异常；\n* PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。\n    * A未开启事物，B在自己的事物中运行；若A开启事物，则在嵌套事物中执行，若A抛出异常，则B会回滚。\n\n\n\n\n\n\n\n\n\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>---------------- 计算机网络 ----------------</span>\n</div>\n\n# 计算机网络\n\n## 基础\n\n###  OSI 的七层模型都有哪些？\n![](Interview/osi.jpeg)\n* 物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。\n* 数据链路层：负责建立和管理节点间的链路。\n* 网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。\n* 传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。\n* 会话层：向两个实体的表示层提供建立和使用连接的方法。\n* 表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。\n* 应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。\n\n## http协议\nHyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协\n\n### HTTP的特性\n* HTTP构建于TCP/IP协议之上，默认端口号是80\n* HTTP是无连接无状态的\n    + 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n    + 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n\n### HTTP状态码\n{% note info %}\n    1xx：指示信息--表示请求已接收，继续处理\n    2xx：成功--表示请求已被成功接收、理解、接受\n    3xx：重定向--要完成请求必须进行更进一步的操作\n    4xx：客户端错误--请求有语法错误或请求无法实现\n    5xx：服务器端错误--服务器未能实现合法的请求\n{% endnote %}\n\n200 OK //客户端请求成功\n301 Moved Permanently //永久重定向。\n302 Found //暂时重定向。\n400 Bad Request //客户端请求有语法错误，不能被服务器所理解\n401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 \n403 Forbidden //服务器收到请求，但是拒绝提供服务\n404 Not Found //请求资源不存在，eg：输入了错误的URL\n500 Internal Server Error //服务器发生不可预期的错误\n503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常\n\n### HTTP 请求/响应的步骤？\n* **1、客户端连接到Web服务器**\n    一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.oakcms.cn。\n* **2、发送HTTP请求**\n    通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。\n* **3、服务器接受请求并返回HTTP响应**\n    Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。\n* **4、释放连接TCP连接**\n    若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;\n* **5、客户端浏览器解析HTML内容**\n    客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。\n\n### 浏览器请求过程？\n* 1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;\n* 2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;\n* 3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP三次握手的第三个报文的数据发送给服务器;\n* 4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;\n* 5、释放 TCP连接;\n* 6、浏览器将该 html 文本并显示内容;\n\n###  get 和 post 请求有哪些区别？\n从原理性看：\n* 根据HTTP规范，GET用于信息获取，而且应该是安全和幂等的\n* 根据HTTP规范，POST请求表示可能修改服务器上资源的请求\n\n从表面上看：\n* GET请求的数据会附在URL后面，POST的数据放在HTTP包体，POST安全性比GET安全性高\n* GET请求会被浏览器主动缓存，并且传递参数有大小限制，POST没有。\n\n## TCP／UDP协议\n\n###  tcp 和 udp的区别？\ntcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。\n区别如下：\n* tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；\n* tcp 提供可靠的服务（数据传输），udp 无法保证；\n* tcp 面向字节流，udp 面向报文；\n* tcp 数据传输慢，udp 数据传输快；\n\n### tcp协议是100%可靠的么？\nTCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。\n\n### 三次握手\n三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。\n![](Interview/Handshake.png)\n* 第一次握手(SYN=1, seq=x):\n  客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。\n  发送完毕后，客户端进入 `SYN_SEND` 状态。\n* 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):\n  服务器发回确认包(`ACK`)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 \n  发送完毕后，服务器端进入 `SYN_RCVD` 状态。\n* 第三次握手(ACK=1，seq=x+1,ACKnum=y+1)\n  客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1\n  发送完毕后，客户端进入 `ESTABLISHED` 状态，当服务器端接收到这个包时，也进入 `ESTABLISHED` 状态，TCP 握手结束。\n\n#### 为什么需要三次握手，两次不行吗？\n如果是用两次握手，则会出现下面这种情况：\n如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。\n客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端\n此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接。\n**因此**：不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，`浪费资源`。\n\n#### 什么是半连接队列？\n服务器第一次收到客户端的 SYN 之后，就会处于 `SYN_RCVD` 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为`半连接队列`。\n\n当然还有一个`全连接队列`，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。\n\n#### ISN(Initial Sequence Number)是固定的吗？\n当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，`每4ms加1` 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。\n\n三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。\n\n#### 三次握手过程中可以携带数据吗？\n其实第三次握手的时候，是可以携带数据的。但是，**第一次、第二次握手不可以携带数据**\n\n第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。\n\n#### SYN攻击是什么？\n在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.\n\nSYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。\n\n\n### 四次挥手\nTCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。\n![](Interview/wave.png)\n* 第一次挥手(FIN=1，seq=x)\n  假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。\n  发送完毕后，客户端进入 `FIN_WAIT_1` 状态。\n* 第二次挥手(ACK=1，ACKnum=x+1)\n  服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。\n  发送完毕后，服务器端进入 `CLOSE_WAIT` 状态，客户端接收到这个确认包之后，进入 `FIN_WAIT_2` 状态，等待服务器端关闭连接。\n* 第三次挥手(FIN=1，seq=y)\n  服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。\n  发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后一个ACK\n* 第四次挥手(ACK=1，ACKnum=y+1)\n  客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 `TIME_WAIT` 状态，等待可能出现的要求重传的 ACK 包。\n  服务器端接收到这个确认包之后，关闭连接，进入 `CLOSED` 状态。\n  客户端等待了某个固定时间（`两个最大段生命周期`，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED` 状态。\n\n#### 挥手为什么需要四次？\n因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。\n但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，\"你发的FIN报文我收到了\"。\n只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。\n\n#### 2MSL等待状态\nTIME_WAIT状态也成为2MSL等待状态。它是任何报文段被丢弃前在网络内的最长时间。\n* 保证客户端发送的最后一个ACK报文段能够到达服务端。 \n  这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态。\n* 防止“已失效的连接请求报文段”出现在本连接中。\n   客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。\n\n\n### 滑动窗口\nTCP协议里窗口机制有2种：一种是固定的窗口大小；一种是滑动的窗口。\n这个窗口大小就是我们一次传输几个数据。 \n对所有数据帧按顺序赋予编号，发送方在发送过程中始终保持着一个发送窗口，只有落在发送窗口内的帧才允许被发送； \n同时接收方也维持着一个接收窗口，只有落在接收窗口内的帧才允许接收。\n这样通过调整发送方窗口和接收方窗口的大小可以实现`流量控制`。\n**每个TCP/IP主机支持全双工数据传输，因此TCP有两个滑动窗口：一个用于接收数据，另一个用于发送数据。**\n![](Interview/slidingWindow%20%20.png)\n* 首先是**第一次发送数据这个时候的窗口大小是根据链路带宽的大小来决定的**。我们假设这个时候窗口的大小是3。\n* 这个时候接受方收到数据以后会对数据进行确认告诉发送方我下次希望手到的是数据是多少。这里我们看到接收方发送的ACK=3(这是发送方发送序列2的回答确认，下一次接收方期望接收到的是3序列信号)。\n* 这个时候发送方收到这个数据以后就知道我第一次发送的3个数据对方只收到了2个。就知道第3个数据对方没有收到。下次在发送的时候就从第3个数据开始发。这个时候窗口大小就变成了2 。 \n* 看到接收方发送的ACK是5就表示他下一次希望收到的数据是5，发送方就知道我刚才发送的2个数据对方收了这个时候开始发送第5个数据。\n\n只有在接收窗口向前滑动时（与此同时也发送了确认），发送窗口才有可能向前滑动。 当发送窗口和接收窗口的大小都等于1时，就是停止等待协议。\n\n### 如果已经建立了连接，但是客户端突然出现故障了怎么办？\nTCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。\n\n### 拥塞控制和流量控制的区别？\n* 拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。\n* 流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。\n\n### TCP确认延迟机制？\n接收方在收到数据后，并不会立即回复ACK,而是延迟一定时间。一般ACK延迟发送的时间为200ms，但这个200ms并非收到数据后需要延迟的时间。系统有一个固定的定时器每隔200ms会来检查是否需要发送ACK包。\n1. ACK是可以合并的，也就是指如果连续收到两个TCP包，并不一定需要ACK两次，只要回复最终的ACK就可以了，可以降低网络流量。\n2. 如果接收方有数据要发送，那么就会在发送数据的TCP数据包里，带上ACK信息。这样做，可以避免大量的ACK以一个单独的TCP包发送，减少了网络流量。\n\n\n### TCP拥塞控制机制？\n* 慢启动：\n    TCP在连接过程的三次握手完成后，开始传数据，并不是一开始向网络通道中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞\n    而是根据初始的cwnd大小逐步增加发送的数据量，cwnd初始化为1个最大报文段(MSS)大小（这个值可配置不一定是1个MSS）；每当有一个报文段被确认，cwnd大小指数增长。 \n    开始 —> cwnd = 1 \n    1个RTT(往返延迟)后 —> cwnd = 2*1 = 2 \n    2个RTT后 —> cwnd = 2*2= 4 \n    3个RTT后 —> cwnd = 4*2 = 8\n    \n* 拥塞避免\n    cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，一旦cwnd>=ssthresh（大多数TCP的实现，通常大小都是65536），慢启动过程结束，拥塞避免阶段开始；\n    此时窗口大小不再呈指数上升，而是以加法增加，避免增长过快导致网络拥塞。\n    拥塞发生：当发生丢包进行数据包重传时，表示网络已经拥塞。分两种情况进行处理：\n        * 等到RTO（重传超时时间）超时，重传数据包\n        * sshthresh = cwnd /2，cwnd 重置为 1\n* 快重传\n    对于接收方来说，如果接收方收到一个失序的报文段，就立即回送一个 ACK 给发送方\n    当发送方收到了3个重复的ACK时，则发送方快速重传丢失的包（所谓失序的报文是指，用户没有按照顺序收到TCP报文段，比如接收方收到了报文 M1, M2, M4，那么M4就称为失序报文，也就是M3被丢失），而不必等待M3的重传计时器到期\n* 快恢复\n    一旦出现超时重传，或者收到第三个重复的 ack 时（快重传），TCP 会把慢启动门限 ssthresh 的值设置为 cwnd 值的一半，同时 cwnd = ssthresh\n\n\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>---------------- 设计模式 ----------------</span>\n</div>\n\n# 设计模式\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>---------------- MyBatis ----------------</span>\n</div>\n\n# MyBatis\n## 什么是 MyBatis?\nMyBatis 是一个可以自定义 SQL、存储过程和高级映射的持久层框架。\n\n##  MyBatis 中 #{}和 ${}的区别是什么？\n\\#{}是预编译处理，${}是字符替换。 \n\n在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。\nMybatis 在处理${}时，就是把${}替换成变量的值。\n\n## MyBatis 有几种分页方式？\n**逻辑分页**： 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。\n\n**物理分页**： 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。\n\n## MyBatis 逻辑分页和物理分页的区别是什么？\n* 逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。\n* 物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。\n\n## RowBounds 是一次性查询全部结果吗？为什么？\nRowBounds 表面是在“所有”数据中检索数据，其实**并非是一次性查询**出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。\n\n##  MyBatis 是否支持延迟加载？延迟加载的原理是什么？\nMyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。\n延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。\n比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。\n\n## `说一下 MyBatis 的一级缓存和二级缓存？`\n![](Interview/mybatisCache.jpg)\n* 一级缓存：是SqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。\n* 二级缓存：是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。。\n开启二级缓存数据查询流程：二级缓存 -> 一级缓存 -> 数据库。\n缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>---------------- Kafka ----------------</span>\n</div>\n\n# Kafka\n\n## kafka 流程？\n![](Interview/kafka.png)\n* 生产者：可以声明主题Topic、分区Partition、键 Key以及值 Value，主题和值是必须要声明的，分区和键可以不用指定。拥有相同key的消息将会被写到同一分区，若没有指定key则由分区器分配。\n* topic：Topic中数据是顺序不可变序列，采用log追加方式写入，Topic的数据可存储在多个partition中。\n* partition：每个 Partition 中的消息都是有序的，生产的消息被不断追加到 Partition log 上，其中的每一个消息都被赋予了一个唯一的 offset 值。 因此数据不会因消费而丢失，所以只要consumer指定offset，一个消息可被不同的consumer多次消费。kafka中只能保证partition中记录是有序的，而不保证topic中不同partition的顺序。\n* Replication：同一个 partition 可能会有多个 replication，需要在这些 replication 之间选出一个 leader，producer 和 consumer 只与这个 leader 交互，其它 replication 作为 follower 从 leader 中复制数据。\n* 消费者：订阅topic是以一个消费组来订阅的，一个消费组里面可以有多个消费者。**一个partition，只能被消费组里的一个消费者消费**，但是可以同时被多个消费组消费。\n\n## kafka 可以脱离 zookeeper 单独使用吗？为什么？\nkafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。\n\n##  kafka 有几种数据保留的策略？\nkafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。\n\n##  kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？\n这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。\n\n## 什么情况会导致 kafka 运行变慢？\n* cpu 性能瓶颈\n* 磁盘读写瓶颈\n* 网络瓶颈\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>---------------- MySQL ----------------</span>\n</div>\n\n# MySQL\n\n## 基础\n### 数据库的三范式是什么？\n* 第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。\n* 第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。\n* 第三范式：任何非主属性不依赖于其它非主属性。\nhttps://zhuanlan.zhihu.com/p/92991575\n\n### char 和 varchar 的区别是什么？\n* char(n) ：**固定长度类型**，比如订阅 char(10)，当你输入\"abc\"三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。\n* varchar(n) ：**可变长度**，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。\nchat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。\n所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。\n\n### float 和 double 的区别是什么？\n* float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。\n* double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。\n\n###  MySQL 常用的引擎？\n* InnoDB 引擎：mysql 5.1 后默认的数据库引擎，提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。\n              MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。\n              但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。\n              由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。\n* MyIASM 引擎：不提供事务的支持，也不支持行级锁和外键。。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。\n              MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。\n              所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。\n\n### 如何做 MySQL 的性能优化？\n* 为搜索字段创建索引。\n* 避免使用 select *，列出需要查询的字段。\n* 垂直分割分表。\n* 选择正确的存储引擎。\n\n### left join、right join、inner join的区别\n* left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 \n* right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录\n* inner join(等值连接) 只返回两个表中联结字段相等的行\n\n## innodb\n\n### innodb 体系结构？\n![](Interview/innodb-Architecture.png)\n\n### 什么是redo log？\n当数据库对数据做修改的时候，需要把数据页从磁盘读到buffer pool中，然后在buffer pool中进行修改，那么这个时候buffer pool中的数据页就与磁盘上的数据页内容不一致，称buffer pool的数据页为dirty page 脏数据。\n如果发生非正常的DB服务重启，那么这些数据并没有同步到磁盘文件中（注意，同步到磁盘文件是个随机IO），会发生数据丢失。\n如果这个时候，能够有一个文件，当缓冲池中的data page变更结束后，把相应修改记录记录到这个文件（注意，记录日志是顺序IO），那么当DB服务发生crash的情况，恢复DB的时候，也可以根据这个文件的记录内容，重新应用到磁盘文件，数据保持一致。\n这个文件就是redo log ，用于记录 数据修改后的记录，顺序记录。\n![](Interview/redo-buffer.png)\n重做日志支持以下三种情况触发刷新：\n    * Master Thread每一秒将重做日志缓冲刷新到重做日志文件\n    * 每次事务提交时将重做日志缓冲刷新到重做日志文件\n    * 当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件\n\n\n### 什么是undo log？\nundo日志用于存放数据修改被修改前的值。\n假设修改表中 id=1 的行数据，把Name=’B’ 修改为Name = ‘B2’ ，那么undo日志就会用来存放Name=’B’的记录，如果这个修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。\n\n### undo 和 redo 事物实现过程？\n事务B要将字段A的值由原来的1修改为3，要将B的值由原来的2修改为4，redo日志记录的是：\n```text\n假设有A、B两个数据，值分别为1,2.\n1. 事务B开始\n2. 记录A=1到undo log\n3. 修改A=3\n4. 记录A=3到 redo log\n5. 记录B=2到 undo log\n6. 修改B=4\n7. 记录B=4到redo log\n8. 将redo log写入磁盘\n9. 事务提交，将数据写入磁盘\n10.事物B结束\n```\n如果上面事务B回滚（当做新的事务C），则redo记录的是：\n```text\n1. 事务C开始\n2. 记录A=1到undo log\n3. 修改A=3\n4. 记录A=3到 redo log\n5. 记录B=2到 undo log\n6. 修改B=4\n7. 记录B=4到redo log\n   <!--回滚-->\n8. 修改B=2\n9. 记录B=2到redo log\n10.修改A=1\n11.记录A=1到redo log\n12.将redo log写入磁盘\n13.事务提交，将数据写入磁盘\n14.事物C结束\n```\n\n### Double write解决了什么问题?\n* 数据库IO的最小单位是16K（MySQL默认，oracle是8K）\n* 文件系统IO的最小单位是4K（也有1K的）\n* 磁盘IO的最小单位是512字节\n\n一个数据页的大小是16K，假设在把内存中的脏页写到数据库的时候，写了8K突然宕机了，也就是说前8K数据是新的，后8K是旧的，那么磁盘数据库这个数据页就是不完整的，是一个坏掉的数据页，这种情况被称为部分写失效\n\n### 为什么 redo log 不需要 doublewrite 的支持？\n因为 redo log 写入的单位就是 512 字节，也就是磁盘 IO 的最小单位，所以无所谓数据损坏。\n\n### 页断裂可不可以通过 redo log 来进行恢复呢？\nredo记录的是对页的修改，只能恢复校验完整（还没写）的页，不能修复坏掉的数据页，所以这个数据就丢失了，可能会造成数据不一致，所以需要double write。\n\n### 两次写工作流程？\n![](Interview/doublewrite.png)\ndoublewrite由两部分组成，一部分为内存中的doublewrite buffer，其大小为2MB，另一部分是磁盘上共享表空间(ibdata x)中连续的128个页，即2个区(extent)，大小也是2M。\n1. 当一系列机制触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先拷贝至内存中的doublewrite buffer中；\n2. 接着从两次写缓冲区分两次写入磁盘共享表空间中(连续存储，顺序写，性能很高)，每次写1MB；\n3. 待第二步完成后，再将doublewrite buffer中的脏页数据写入实际的各个表空间文件(离散写)；(脏页数据固化后，即进行标记对应doublewrite数据可覆盖) \n\n### 为什么 double write 可以解决页断裂？\n1. 磁盘还未写，此时可以通过 redo log 恢复；\n2. 磁盘正在进行从内存到共享表空间的写，此时数据文件中的页还没开始被写入，因此也同样可以通过 redo log 恢复；\n3. 磁盘正在写数据文件，此时共享表空间已经写完，可以从共享表空间拷贝页的副本到数据文件实现恢复。\n\n\n## 事物\n### 什么是事务？\n一个事务是可以被看作一个单元的一系列SQL语句的集合。它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。\n\n### 事务的特性（ACID） 是什么？\n* Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。\n* Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。\n* Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。\n* Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n\n### 数据库的事务隔离级别？\n* READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。\n* READ-COMMITTED：提交读，读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。（会造成幻读、不可重复读）。\n* REPEATABLE-READ：可重复读，默认级别。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。（会造成幻读）。\n* SERIALIZABLE：序列化，代价最高最可靠的隔离级别，这个事务执行的时候不允许别的事务并发执行。事务只能一个接着一个地执行。该隔离级别能防止脏读、不可重复读、幻读。\n\n> **脏读** ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。\n> **不可重复读** ：事务A读取数据后，事务B执行更新操作，使A无法再次读取结果。\n> **幻读**：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。\n> **丢失修改**：两个事务A，B读入同一数据并修改，B提交的结果被A破坏了，导致B的修改丢失。\n\n## 锁\n### 从数据库系统的角度来看分为几种？\n1. 共享锁（S）\n    共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。\n2. 更新锁（U）\n    更新锁可以防止通常形式的死锁。一般更新模式由一个事务组成，此事务读取记录，获取资源（页或行）的共享锁，然后修改行，此操作要求锁转换为排它锁。\n3. 排他锁（X）\n    排它锁可以防止并发事务对资源进行访问。其它事务不能读取或修改排它锁锁定的数据。\n4. 意向锁\n    意向锁就是说在屋（比如代表一个表）门口设置一个标识，说明屋子里有人（比如代表某些记录）被锁住了。另一个人想知道屋子里是否有人被锁，不用进屋子里一个一个的去查，直接看门口标识就行了。\n     * 意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得**该表的IS锁**\n     * 意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得**该表的IX锁。**\n     * 意向共享排他锁（SIX）：对一个数据对象加 SIX锁，表示对它加 S锁，再加IX锁，即 SIX=S+IX。例如对某个表加 SIX锁，则表示该事务要读整个表（所以要对该表加 S锁），同时会更新个别元组（所以要对该表加 IX锁）。\n     \n    当一个表中的某一行被加上排他锁后，该表就不能再被加表锁。数据库程序如何知道该表不能被加表锁？一种方式是逐条的判断该表的每一条记录是否已经有排他锁，另一种方式是直接在表这一层级检查表本身是否有意向锁，不需要逐条判断。显然后者效率高。\n\n### 什么是悲观锁？\n悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。\n* 悲观锁的流程\n    * 在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。 \n    * 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。\n    * 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。\n    * 其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。\n* 优点与不足\n    悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。\n    但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；\n    另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载,还有会降低了并行性.\n    一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数\n    \n### 什么是乐观锁？\n乐观锁 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。\n相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。\n* 实现方式\n    * 对记录加版本号：在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。\n    * 对记录加时间戳：在数据初始化时使用时间戳（timestamp），在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK。\n    * 对将要更新的数据进行提前读取、事后对比。\n\n### 什么是锁的粒度？\n锁的粒度就是指锁的生效范围，就是说是行锁，还是页锁，还是整表锁. 锁的粒度同样既可以由数据库自动管理，也可以通过手工指定hint来管理。\n\n### 封锁协议？\n![](Interview/sqllock.gif)\n* 一级封锁协议：对应READ-UNCOMMITTED 隔离级别，本质是在事务A中修改完数据M后，立刻对这个数据M加上共享锁(S锁)（当事务A继续修改数据M的时候，先释放掉S锁，再修改数据，再加上S锁），根据S锁的特性，事务B可以读到事务A修改后的数据(无论事务A是否提交，因为是共享锁，随时随地都能查到数据A修改后的结果)，事务B不能去修改数据M，直到事务A提交，释放掉S锁。\n    * 缺点：丢失更新。脏读。不可重复读。幻读。\n* 二级封锁协议：对应READ-COMMITTED隔离级别，本质是事务A在修改数据M后立刻加X锁，事务B不能修改数据M，同时不能查询到最新的数据M(避免脏读)，查询到的数据M是上一个版本(Innodb MVCC快照)的。\n    * 缺点：丢失更新。不可重复读。幻读。\n* 三级封锁协议：对应REPEATABLE-READ隔离级别,本质是二级封锁协议基础上，对读到的数据M瞬间加上共享锁M，直到事务结束才释放（保证了其他事务没办法修改该数据），这个级别是MySql 5.5 默认的隔离级别。\n    * 缺点：丢失更新。幻读。\n* 最强封锁协议：对应Serialization隔离级别，本质是从MVCC并发控制退化到基于锁的并发控制，对事务中所有读取操作加S锁，写操作加X锁，这样可以避免脏读，不可重复读，幻读，更新丢失，开销也最大，会造成读写冲突，并发程度也最低。\n\n## MySQL 的行锁和表锁？\nMyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。\n* 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。\n* 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。\n\n## 说一下乐观锁和悲观锁？\n* 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。\n* 悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。\n\n数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。\n\n\n## 索引\n### B+tree和Btree的区别？\nbtree是每个节点都保存数据，而b+tree只有叶子节点保存数据，并且每个叶子节点都有指向前后叶子节点的指针。\n\n### InnoDB索引原理？\n数据库中的B+树索引可以分为**聚集索引和辅助索引**。\n聚集索引(主键索引)：按照每张表的主键构造一颗B+树，同时叶子结点存放的即为整张表的行纪录数据也称为数据页。\n辅助索引(非聚集索引)：按照每张表的索引构造一颗B+树，叶子节点存放该行数据的主键。\n\n当通过索引数据来查找数据的时候，存储引擎会遍历辅助索引并且通过叶级别的指针获取到指向主键索引的的主键，然后再通过主键索引来找到一个完整的记录；\n\n### 性别为什么不能作为数据库索引?\n对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。\n在使用普通索引查询时，会先加载普通索引，通过普通索引查询到实际行的主键。再使用主键通过聚集索引查询相应的行。以此循环查询所有的行。\n若直接全量搜索聚集索引，则不需要在普通索引和聚集索引中来回切换。\n相比两种操作的总开销可能扫描全表效率更高。\n\n\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ Redis ------------------------</span>\n</div>\n\n# Redis\n## Redis 是什么？都有哪些使用场景？\nRedis 是一个使用 C 语言开发的高速缓存数据库。\nRedis 使用场景：\n* 记录帖子点赞数、点击数、评论数；\n* 缓存近期热帖；\n* 缓存文章详情信息；\n* 记录用户会话信息。\n\n## Redis 有哪些功能？\n* 数据缓存功能\n* 分布式锁的功能\n* 支持数据持久化\n* 支持事务\n* 支持消息队列\n\n## Redis 支持的数据类型有哪些？\n![](Interview/redis-shujujiegou.png)\nRedis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。\n\n\n## Redis 为什么是单线程的？\n因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。\n关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。\n\n## Redis 单机数据库的好处？\n* 纯内存\n* 单线程，避免频繁上下文切换\n* 采用`非阻塞IO多路复用？`\n\n## Redis 持久化有几种方式？\n* RDB（Redis Database）：默认持久化方式，按一定的时间周期把内存的数据以快照的形式保存到硬盘的二进制文件\n    * 优点：\n        * 只有一个dump.rdb 方便持久化\n        * 容灾性好，一个文件可以保存到安全的磁盘\n        * 性能最大化，fork子进程来完成写操作，让主进程继续处理命令，IO最大化\n        * 数据集大时，比AOF的效率高\n    * 缺点：\n        * 数据安全性低，RDB隔一段时间就会进行持久化，如果持久化之间发生故障，会发生数据丢失\n* AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中，当redis重启会重新执行文件保存的写命令来重建数据库\n    * 优点：\n        * 数据安全，aof可以配置为每进行一次命令就记录到AOF文件中\n        * 通过append模式写文件，即使中途服务器宕机，可以通过redis-check-aof工具进行恢复\n        * rewrite模式：fork一个子进程进行AOF重写\n    * 缺点：AOF文件比RDB文件大，且恢复速度慢，数据集大时比RDB效率低。\n    \n两种模式同时开启，数据恢复优先选择AOF。\n\n\n## 怎么保证缓存和数据库数据的一致性？\n* 合理设置缓存的过期时间。\n* 新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。\n              \n\n## Redis 淘汰策略有哪些？\n* volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。\n* volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。\n* volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。\n* allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。\n* allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。\n* no-enviction（驱逐）：禁止驱逐数据。\n\n## Redis 过期策略？\n* redis默认每100ms随机抽取进行检查是否有过期的key\n* 在获取某个key时会检查，这个key如果设置了过期时间那么是否过期了，如果过期则删除\n\n## 什么是缓存雪崩？\n由于原有缓存失效，新缓存未到期间，原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成压力，严重会导致数据库宕机，整个系统崩溃\n**解决方法**：考虑用加锁或队列的方式来保证不会有大量线程对数据库一次性进行读写。或将缓存失效时间分散开\n\n## 什么是缓存穿透？\n数据在数据库中没有，自然在缓存中也不会有，这就导致用户查询时缓存中找不到，都要去数据库再查一遍\n解决方法：\n    1. 布隆过滤器，将所有可能存在的数据哈希到足够大的bitmap中，一个一定不存在的数据会被bitmap拦截\n    2. 如果查询数据为空（不管数据不存在还是系统故障）仍把这个空结果进行缓存\n\n## 什么是缓存预热？\n系统上线后将相关的缓存数据直接加载到缓存系统\n解决方法：\n    * 数据量不大，项目启动时自动进行加载\n    * 定时刷新缓存\n\n## Redis 常见的性能问题有哪些？该如何解决？\n* 主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。\n* Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。\n\n## Redis 主从复制？\n用户可执行slaveof命令或设置slaveof选项让一个服务器去复制另一个服务器\n* 旧版复制\n    * 同步sync：用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态\n        * 从服务器向主服务器发送sync命令\n        * 收到sync命令的主服务器执行**bgsave**在后台生成RDB文件，并用一个缓冲区记录从现在开始执行的所有写命令\n        * 当主服务器bgsave执行完毕时，主服务器会将RDB文件发送给从服务器，从服务器接收并载入rdb，将自己的数据库状态更新至主服务器执行bgsave时的数据状态\n        * 主服务器将缓冲区中写命令发送给从服务器，从服务器执行写命令，更新状态\n    * 命令传播：由于主服务器的数据库状态被修改，导致主从状态不一致时让主从服务器的数据库重新回到一致\n        * 主服务器会将自己执行的写命令发送给从服务器执行，从而使主从状态一致\n    * 缺陷：在断线后重复制的效率非常低，需要执行sync命令全量生成并加载rdb文件\n* 新版复制：使用psync代替sync，可以**部分同步**和**全部同步**\n    * 全部同步：sync \n    * 部分同步：psync\n        * 主服务器的复制偏移量和从服务器的复制偏移量\n            * 主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N\n            * 从服务器收到N子节数据时就将自己的复制偏移量的值加N\n        * 主服务器的复制积压缓冲区\n            * 主服务器维护的一个固定长度先进先出队列，大小1M\n            * 当主服务器命令传播时，还会将写命令入队到复制缓冲里，并且复制缓冲会为队列中每字节记录复制偏移量\n            * 当从服务器重新连上主服务器，从会通过psync将自己的offset发给主服务器\n                * 如果offset之后的数据仍在复制积压缓冲里，执行部分重同步\n                * 否则执行完整重同步\n        * 服务器的运行ID\n            * 当从服务器对主服务器进行初次复制时，主会将自己的运行ID传给从服务器，从服务器保存起来\n            * 当从服务器断线重连，从服务器向当前连接的主发送之前保存的运行ID\n                * 如果和当前主服务器的ID相同，则可以尝试执行部分重同步\n                * 否则执行完整重同步\n## 哨兵模式sentinel？\nsentinel是高可用的解决方案，由一个或多个sentinel实例组成的sentinel系统，可以监视任意多个主从服务器，并在被监视的主服务器进入下线时，将从升为主服务器\n* 启动哨兵\n    * 初始化服务器：sentinel并不使用数据库，初始化不会加载RDB或AOF\n    * 使用sentinel专用代码、初始化sentinel状态、初始化sentinel状态的masters属性\n    * 创建连向主服务器的异步网络连接\n        * 命令连接，向主服务器发送命令并接收命令回复\n        * 订阅连接，专门用于订阅主服务器的__sentinel__:hello 频道\n* 获取主服务器信息：默认每十秒一次，通过命令连接向被监视的主服务器发送INFO命令，并通过分析回复来获取状态，可以获取到主服务器信息，以及主服务器下所有从服务器信息\n* 获取从服务器信息：根据INFO命令回复\n* 向主从服务器发送信息：每两秒一次向服务器__sentinel__:hello频道发送一条信息\n* 接收主从服务器的频道信息\n* 更新sentinels字典\n* 创建连向其他sentinel的命令连接\n* 检测主观下线：每秒向所有与它创建了命令连接的实例发送PING，并通过返回的PING命令回复判断是否在线\n* 检测客观下线：\n    * 当一个主服务器主观下线后，为了确保主服务器真下线了，会向同样监视这服务器的其他sentinel进行询问\n    * 当认为主服务器进入下线状态的sentinel数量超过配置中设置的quorum参数值，就进入客观下线状态\n* 选举领头sentinel：当一个服务器客观下线时，监视该服务器的sentinel会选举出一个领头sentinel，并由领头进行故障转移\n    * 选举方式：\n        * 监视同一主服务器的在线sentinel都有资格\n        * 每次选举无论成功与否，配置纪元的值都会自增一次\n        * 在一个配置纪元里，所有sentinel都有一次将某个sentinel设置为局部头的机会，并且一旦设置不可更改\n        * 每个发现主服务器进入客观下线的sentinel都会要求其他sentinel将自己设为局部头\n        * 设置局部头的规则是先到先得，之后接收到的所有设置要求都会被拒绝\n        * 如果有某个sentinel被半数以上设置成了局部头，那么就成为领头\n        * 在给定时限内，没有一个被选举为领头，那么将在一段时间后再次选举\n* 故障转移：\n    * 选出新的主服务器：从已下线主服务器的所有从服务器列表中筛选\n        * 删除列表中所有处于下线或者断线状态的从服务器\n        * 删除列表中5s内没有回复过领头sentinel的info命令的从服务器\n        * 删除所有与已下线服务器连接断开超过down-after-milliseconds*10毫秒的从服务器\n        * 根据从服务器优先级排序，相同优先级按照从服务器复制偏移量排序，相同偏移量按运行ID最小排序\n        * 向选出的从服务器发送SLAVEOF no one命令升级为主服务器 \n    * 修改从服务器的赋值目标\n        * 向其他从服务器发送slaveof命令，让他们复制新主服务器\n    * 将旧的主服务器变成从服务器\n        * 当旧的主服务器重新上线时，会向他发出slaveof命令，让他变成从服务器\n          \n## redis集群？\nRedis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。\n* 节点：一个redis集训由多个节点构成\n    * 启动节点：redis 启动时会根据cluster-enabled配置是否为yes决定是否开启集训模式\n    * 集群数据结构：\n        * clusterNode：保存了节点的创建时间、名称、配置纪元、ip、端口号等\n        * clusterLink：保存了连接**节点**所需的套接字描述符、输入缓冲区、输出缓冲区\n        * redisClient：保存了连接**客户端**所需的套接字描述符、输入缓冲区、输出缓冲区\n    * 节点之间建立连接：通过cluster meet节点之间握手\n        * 节点A会为节点B创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。\n        * 节点A将根据CLUSTER MEET命令给定的IP地址和端口号，向节点B发送一条MEET消息（message）\n        * 节点B将接收到节点A发送的MEET消息，节点B会为节点A创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。\n        * 节点B将向节点A返回一条PONG消息。\n        * 节点A将接收到节点B返回的PONG消息，通过这条PONG消息节点A可以知道节点B已经成功地接收到了自己发送的MEET消息。\n        * 节点A将向节点B返回一条PING消息。\n        * 节点B将接收到节点A返回的PING消息，通过这条PING消息节点B可以知道节点A已经成功地接收到了自己返回的PONG消息，握手完成。\n        \n* 槽指派：集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。\n    * 记录节点的槽指派信息：clusterNode结构的slots属性和numslot属性记录了节点负责处理哪些槽\n        * slots属性是包含16384位的二进制数组，对应索引i上的值为1那么表示节点负责处理槽i。\n    * 传播节点的槽指派信息：将自己的slots数组通过消息发送给集群中的其他节点，以此来告知其他节点自己目前负责处理哪些槽。\n    * 记录集群中所有的槽指派信息：clusterState结构中的slots数组记录了集群中所有16384个槽的指派信息，slots数组包含16384个项，每个数组项都是一个指向clusterNode结构的指针\n* 在集训中执行命令：客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己\n    * 如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令。\n    * 如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，指引客户端转向（redirect）至正确的节点，并再次发送之前想要执行的命令\n* 重新分片：Redis集群的重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点\n* ASK错误：在进行重新分片期间：属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对则保存在目标节点里面，当客户端向源节点发送一个与数据库键有关的命令，若此时数据不在原节点上，返回ASK并指引客户端转向目标节点。\n* 复制与故障转移：\n    * 设置从节点：向一个节点发送命令CLUSTER REPLICATE <node_id>，让接收命令的节点称为node_id的从节点\n    * 故障检测：\n        * 集群中的每个节点都会定期地向集群中的其他节点发送PING消息，如果没有在规定时间返回PONG消息，那么该节点会被疑似下线。\n        * 集群中的各个节点会通过互相发送消息的方式来交换集群中各个节点的状态信息，来确认某个节点是疑似下线还是已下线。\n        * 当一个主节点A通过消息得知主节点B认为主节点C进入了疑似下线状态时，会记录主节点C的状态。\n        * 当集群中半数以上的主节点都将某节点疑似下线，那么这个主节点被标记为已下线。\n        * 将主节点x标记为已下线的节点会向集群广播一条关于主节点x的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点x标记为已下线。\n    * 故障转移：当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移\n        * 选举新的主节点\n            * 集群的配置纪元是一个自增计数器，它的初始值为0。\n            * 当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被增一\n            * 对于每个配置纪元，集群里每个负责处理槽的主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得主节点的投票。\n            * 当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票\n            * 如果一个主节点具有投票权（它正在负责处理槽），并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示这个主节点支持从节点成为新的主节点。\n            * 如果集群里有N个具有投票权的主节点，那么当一个从节点收集到大于等于N/2+1张支持票时，这个从节点就会当选为新的主节点。\n            * 如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。\n        * 被选中的从节点会执行SLAVEOF no one命令，成为新的主节点\n        * 新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。\n        * 新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。\n        * 新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成\n\n\n# zookeeper \n它是一个分布式服务框架，主要用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务，集群管理、分布式应用配置项的管理等。\n简单来说：zk是一个拥有文件系统特点的数据库；zk是一个解决了数据一致性问题的分布式数据库；zk是一个具有发布和订阅功能的分布式数据库。\n\n# 算法\n\n## 排序\n\n### 各种排序算法的时间复杂度以及稳定性？\n![](Interview/sort.png)\n\n### 冒泡排序\n* 算法原理：相邻的数据进行两两比较，小(大)数放在前面，大(小)数放在后面，这样一趟下来，最小(大)的数就被排在了第一位，第二趟也是如此，如此类推，直到所有的数据排序完成。\n* 时间复杂度：最坏：O(n2) 最好: O(n) 平均: O(n2) 空间复杂度：O(1) 稳定性： 稳定\n\n### 选择排序\n* 算法原理：先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n* 时间复杂度：最坏：O(n2) 最好: O(n) 平均: O(n2) 空间复杂度：O(1) 稳定性： 稳定\n\n### 直接插入排序\n* 算法原理：每次将一个待排序的数据按照其关键字的大小插入到前面已经排序好的数据中的适当位置，直到全部数据排序完成。\n* 时间复杂度：最坏：O(n2) 最好: O(n) 平均: O(n2) 空间复杂度：O(1) 稳定性： 稳定\n\n### 快速排序\n* 算法原理：\n  * 从数列中挑出一个元素作为基准数。\n  * 分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。\n  * 再对左右区间递归执行第二步，直至各区间只有一个数。\n* 时间复杂度：最坏：O(n2) 最好: O(nlogn) 平均: O(nlogn) 空间复杂度：O(logn) 稳定性： 不稳定 \n\n### 归并排序\n* 算法原理：将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。\n* 时间复杂度：最坏：O(nlogn) 最好: O(n) 平均: O(nlogn) 空间复杂度：O(1) 稳定性： 稳定 \n\n### 堆排序\n* 算法原理：堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。\n* 时间复杂度：最坏：O(nlogn) 最好: O(nlogn) 平均: O(nlogn) 空间复杂度：O(1) 稳定性： 不稳定 \n\n```java\n\t/*\n\t *\n\t * 堆排序（升序排列）-建立最大堆\n\t * @param array\n\t */\n\n\tpublic static void heapSortAsc(int[] a) {\n\t\tint len = a.length;\n\t\tfor (int i = len / 2 - 1; i >= 0; i--) {\n\t\t\tmaxHeapDown(a, i, len - 1);\n\t\t}\n\t\tfor (int i = len - 1; i > 0; i--) {//堆顶和末尾交换\n\t\t\tswap(a, i, 0);\n\t\t\tmaxHeapDown(a, 0, i - 1);\n\t\t}\n\t}\n\n\tpublic static void maxHeapDown(int[] a, int start, int end) {//自顶向下调整成为最大堆\n\t\tint son = start * 2 + 1;//左儿子\n\t\tint root = a[start];\n\n\t\tfor (; son <= end; start = son, son = 2 * son + 1) {\n\t\t\tif (son < end && a[son] < a[son + 1]) {\n\t\t\t\tson++;//右儿子\n\t\t\t}\n\t\t\tif (root >= a[son]) break;\n\t\t\telse {\n\t\t\t\tswap(a, start, son);\n\t\t\t}\n\t\t}\n\t}\n```\n\n## 负载均衡算法\n### 完全随机\n对所有机器随机选择\n缺点：服务器有好有坏，处理能力是不同的，我们希望性能好的服务器多处理些请求，性能差的服务器少处理一些请求。\n### 加权随机\n为每台服务器设置了权重，权重大的服务器获得的概率大一些，权重小的服务器获得的概率小一些。\n### 完全轮询\n按顺序一个一个执行\n### 普通加权轮询\n有三个节点{a, b, c}，他们的权重分别是{a=5, b=1, c=1}。发送7次请求，a会被分配5次，b会被分配1次，c会被分配1次。\n轮训所有节点，找到一个最大权重节点；选中的节点权重-1；直到减到0，恢复该节点原始权重，继续轮询；\n\n### 平滑加权轮询\n![](Interview/load.png)\n选中的服务器非固定权重：固定权重-各个服务器的权重之和\n其他服务器非固定权重 = 固定权重。\n每一轮将当前有效权重**最大**的实例减去所有实例的权重和，且变量 currentPos 指向此位\n将每个实例的 非固定权重 都加上 固定权重\n\n### 一致性hash算法\n普通的hash算法：如果我们采用普通的hash算法进行路由，将数据映射到具体的节点上，如key%N，key是数据的key，N是机器节点数，如果有一个机器加入或退出这个集群，则所有的数据映射都无效了，如果是持久化存储则要做数据迁移，如果是分布式缓存，则其他缓存就失效了。\n![](Interview/hash.jpg)\n一致性hash算法：\n    * 环形hash空间：按照常用的hash算法来将对应的key哈希到一个具有2^32次方个节点的空间中，即0 ~ (2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。\n    * 映射服务器节点：将各个服务器使用Hash进行一个哈希，具体可以选择服务器的ip或唯一主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。\n    * 映射数据：对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上,然后从数据所在位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。\n    * 服务器的删除与添加\n        * 如果此时NodeC宕机了，此时Object A、B、D不会受到影响，只有Object C会重新分配到Node D上面去，而其他数据对象不会发生变化\n        * 如果在环境中新增一台服务器Node X，通过hash算法将Node X映射到环中，通过按顺时针迁移的规则，那么Object C被迁移到了Node X中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。\n\n平衡性问题：当服务器节点比较少的时候，会出现一个问题，就是此时必然造成大量数据集中到一个节点上面，极少数数据集中到另外的节点上面。\n为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以先确定每个物理节点关联的虚拟节点数量，然后在ip或者主机名后面增加编号。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：\n![](Interview/hash2.jpg)\n\n\n## 大数据问题\n### 给一个超过100G大小的log file,log中存着IP地址 ，设计算法找到出现次数最多的IP地址？\n但凡是大数据的问题，都可通过切分来解决它。\n如果我们将其分成1000个小文件，每个文件大概就是500M左右的样子，现在计算机肯定轻轻 松松就能装下。\n那么，问题又来了，怎样才能保证相同的IP被分到同一个文件中呢？\n这里我想到的是哈希切分，使用相同的散列函数（如 BKDRHash）将所有IP地址转换为一个整数key，再利用 index=key%1000就可将相同IP分到同一个文件。\n\n\n## 智商题\n\n\n# 扩展\n## 分布式ID解决方案\n1. 基于UUID:对于数据库来说用作业务主键ID，它不仅是太长还是字符串，存储性能差查询也很耗时，所以不推荐用作分布式ID。\n    * 优点：生成足够简单，本地生成无网络消耗，具有唯一性\n    * 缺点：无序的字符串，不具备趋势自增特性;没有具体的业务含义;长度过长16 字节128位，36位长度的字符串，存储以及查询对MySQL的性能消耗较大，MySQL官方明确建议主键要尽量越短越好，作为数据库主键 UUID 的无序性会导致数据位置频繁变动，严重影响性能。\n2. 基于单数据库自增ID\n    * 优点：实现简单，ID单调自增，数值类型查询速度快\n    * 缺点：DB单点存在宕机风险，无法扛住高并发场景\n3. 基于数据库集群模式:那这样还会有个问题，两个MySQL实例的自增ID都从1开始，会生成重复的ID怎么办？\n    * 操作：设置起始值和自增步长\n    * 优点：解决DB单点问题\n    * 缺点：不利于后续扩容，新增第三台MySQL实例需要人工修改一、二两台MySQL实例的起始值和步长。\n4. 基于Redis模式:利用redis的 incr命令实现ID的原子性自增\n    * 缺点：RDB会定时打一个快照进行持久化，假如连续自增但redis没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。\n    * 缺点：AOF会对每条写命令进行持久化，即使Redis挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致Redis重启恢复的数据时间过长。\n5. 基于数据库的号段模式：从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存\n    * 数据库中存储 **当前最大id**, **号段的步长**\n    * 多业务端可能同时操作，所以采用版本号version乐观锁方式更新，\n    * 优点：这种分布式ID生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。\n    * 缺点：id为连续号段，可能会被枚举，安全性不足；服务器出现问题重启，部分在内存中的号段会丢失。\n    * 优化方式：双buffer机制，在号段用完前并发获取下一个号段\n7. 基于雪花算法（Snowflake）模式\n    * 组成：Snowflake ID组成结构：正数位（占1比特）+ 时间戳（占41比特）+ 机器ID（占5比特）+ 数据中心（占5比特）+ 自增值（占12比特），总共64比特组成的一个Long类型。\n        * 第一个bit位（1bit）：Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0。\n        * 时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L << 41) / (1000L * 60 * 60 * 24 * 365) = 69年\n        * 工作机器id（10bit）：也被叫做workId，这个可以灵活配置，机房或者机器号组合都可以。\n        * 序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID\n    * 操作：当序列号部分超过4096时，等待下一毫秒；当目前时间戳小于最后一次的时间戳时，时钟回拨，报错！！\n    * 优点：解除对db的依赖；需要人工配置工作id；只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。\n    * 缺点：依赖时间戳，存在机器时钟回拨\n8. 百度（uid-generator）:自动生成workId\n    * 组成：正数位（占1比特） + 时间秒（占28位）+ workId（占22比特）+ 自增值（占13位）；\n    * 操作：依赖db，在服务器启动的时候，根据hostName，port，type和 date 插入db中取出对应的自增di作为workId。\n    * CachedUidGenerator：采用RingBuffer环状数组，初始时按填充时的时间戳填充ring数组，取id时顺序从数组中取，异步填充数组。\n9. 美团(Leaf): 基于ZooKeeper的顺序Id生成workId\n    \n    \n\n\n# 参考\nhttps://www.cnblogs.com/bailing80/p/11443409.html","slug":"Interview","published":1,"updated":"2020-03-30T16:00:53.083Z","layout":"post","photos":[],"link":"","_id":"ck8fb4ann0079k2o52rrhwwcc","content":"<h1 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h1><div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ 基础 ------------------------</span>\n</div>\n\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"JDK-和-JRE-有什么区别？\"><a href=\"#JDK-和-JRE-有什么区别？\" class=\"headerlink\" title=\"JDK 和 JRE 有什么区别？\"></a>JDK 和 JRE 有什么区别？</h3><ul>\n<li>JDK：Java 开发工具包，提供了 Java 的开发环境和运行环境（包括JRE）。</li>\n<li>JRE：Java 运行环境</li>\n</ul>\n<h3 id=\"和-equals-的区别是什么？\"><a href=\"#和-equals-的区别是什么？\" class=\"headerlink\" title=\"== 和 equals 的区别是什么？\"></a>== 和 equals 的区别是什么？</h3><ul>\n<li><strong>==：</strong> 基本类型：比较的是值是否相同；引用类型：比较的是引用的地址是否相同；</li>\n<li><strong>equals</strong>：equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较</li>\n</ul>\n<p>总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>\n<h3 id=\"为什么重写了equals方法，就要重写hashCode方法？\"><a href=\"#为什么重写了equals方法，就要重写hashCode方法？\" class=\"headerlink\" title=\"为什么重写了equals方法，就要重写hashCode方法？\"></a>为什么重写了equals方法，就要重写hashCode方法？</h3><p>不是必须，只是建议。虽然可以不重写hashCode，但是会对集合造成影响。<br>比如hashMap，如果equals判断相同的key，但是hashCode不同，也就是内存中的地址不同，那么进行如下操作，就不会被覆盖，而是被put两次<br>hashMap.put(“k”,”v1”)，hashMap.put(“k”:”v2”)</p>\n<h3 id=\"final-在-Java-中有什么作用？\"><a href=\"#final-在-Java-中有什么作用？\" class=\"headerlink\" title=\"final 在 Java 中有什么作用？\"></a>final 在 Java 中有什么作用？</h3><ul>\n<li>final 修饰的类叫最终类，该类不能被继承。</li>\n<li>final 修饰的方法不能被重写。</li>\n<li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li>\n</ul>\n<h3 id=\"Java基础的数据类型有哪些？\"><a href=\"#Java基础的数据类型有哪些？\" class=\"headerlink\" title=\"Java基础的数据类型有哪些？\"></a>Java基础的数据类型有哪些？</h3><p>基础类型有 8 种：byte、boolean、char、short、int、float、long、double</p>\n<h3 id=\"Java-中操作字符串都有哪些类？它们之间有什么区别？\"><a href=\"#Java-中操作字符串都有哪些类？它们之间有什么区别？\" class=\"headerlink\" title=\"Java 中操作字符串都有哪些类？它们之间有什么区别？\"></a>Java 中操作字符串都有哪些类？它们之间有什么区别？</h3><p>操作字符串的类有：String、StringBuffer、StringBuilder。<br>String：<br>    * 声明的是不可变的对象，它的底层是一个用final修饰的字符数组，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象<br>    * String 对象赋值之后就会在字符串常量池中缓存，如果下次创建会判定常量池是否已经有缓存对象，如果有的话直接返回该引用给创建者。<br>StringBuffer： 可以在原有对象的基础上进行操作，线程安全的，性能高于StringBuilder<br>StringBuilder： 可以在原有对象的基础上进行操作，非线程安全的</p>\n<h3 id=\"String和StringBuilder-的区别？\"><a href=\"#String和StringBuilder-的区别？\" class=\"headerlink\" title=\"String和StringBuilder 的区别？\"></a>String和StringBuilder 的区别？</h3><p>jdk1.5：string 对象时恒定不变的,stringBuider对象表示的字符串是可变的。所以在字符串频繁修改的情况下stringBuider效率<br>jdk1.8: 编译器利用String的可变配套类(StringBuilder)帮我们做了优化，编译器自动调用StringBuilder.apend()方法添加。因此在拼接字符串小于500左右时，两个对象效率相同。</p>\n<h3 id=\"接口和抽象类有什么区别？\"><a href=\"#接口和抽象类有什么区别？\" class=\"headerlink\" title=\"接口和抽象类有什么区别？\"></a>接口和抽象类有什么区别？</h3><p>设计目的：<br>    * 接口的设计目的，是对类的行为进行约束，也就是提供一种机制，可以强制要求不同的类具有相同的行为。<br>    * 抽象类的设计目的，是代码复用。<br>相同：<br>    * 都不能被实例化<br>    * 都能包含抽象的方法<br>不同：<br>    * 在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。<br>    * 抽象类中的成员变量可以是各种类型的；而接口中的成员变量只能是public static final类型的；<br>    * 抽象类可以有静态代码块和静态方法；接口中不能含有静态代码块以及静态方法<br>    * 一个类只能继承一个抽象类，而一个类却可以实现多个接口。　　</p>\n<h3 id=\"请列举你所知道的Object类的方法并简要说明。\"><a href=\"#请列举你所知道的Object类的方法并简要说明。\" class=\"headerlink\" title=\"请列举你所知道的Object类的方法并简要说明。\"></a>请列举你所知道的Object类的方法并简要说明。</h3><ul>\n<li>getClass():用于返回当前运行时对象的Class对象</li>\n<li>equals():用于比较两个对象的地址是否相同，即两个引用是否指向同一个对象；</li>\n<li>clone():用于创建并返回当前对象的一份拷贝</li>\n<li>toString():返回类的名字@实例的哈希码的16进制字符串；</li>\n<li>notify():唤醒等待队列中的其中一个线程</li>\n<li>notifyAll():唤醒线程等待队列中的所有线程；</li>\n<li>wait(long timeout):让一个线程等待一段时间。</li>\n<li>finalize()：用于释放资源，可以覆盖此方法实现资源清理工作。GC在回收对象之前调用该方法，但是无法确定该方法具体什么时候被调用</li>\n</ul>\n<h3 id=\"类的加载顺序\"><a href=\"#类的加载顺序\" class=\"headerlink\" title=\"类的加载顺序\"></a>类的加载顺序</h3><ul>\n<li>父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)</li>\n<li>子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )</li>\n<li>父类非静态代码块( 包括非静态初始化块，非静态属性 )</li>\n<li>父类构造函数</li>\n<li>子类非静态代码块 ( 包括非静态初始化块，非静态属性 )</li>\n<li>子类构造函数</li>\n</ul>\n<h3 id=\"对象在堆上要分配多大内存？\"><a href=\"#对象在堆上要分配多大内存？\" class=\"headerlink\" title=\"对象在堆上要分配多大内存？\"></a>对象在堆上要分配多大内存？</h3><ol>\n<li>java对象的属性—不固定</li>\n<li>对象头—固定12 byte</li>\n<li>数据对齐（64位虚拟机要求对象大小是8的整数倍，不够就补齐）</li>\n</ol>\n<p>64位jvm中，一个仅包含一个boolean属性的对象，大小是16 byte，12byte对象头，1byte数据，3byte填充数据</p>\n<h3 id=\"对象有几种状态？\"><a href=\"#对象有几种状态？\" class=\"headerlink\" title=\"对象有几种状态？\"></a>对象有几种状态？</h3><ol>\n<li>无状态 刚new出来的时候  biased_lock:0 | lock: 10</li>\n<li>偏向锁 biased_lock:1 | lock: 10</li>\n<li>轻量级锁</li>\n<li>重量级锁</li>\n<li>无引用，被gc标记</li>\n</ol>\n<h3 id=\"什么是对象头？\"><a href=\"#什么是对象头？\" class=\"headerlink\" title=\"什么是对象头？\"></a>什么是对象头？</h3><p>所有对象通用的一部分结构。<br>由两部分组成：</p>\n<ol>\n<li>mark word <ul>\n<li>32 bits jvm 占 32 bits<ul>\n<li>hashcode：25｜ age：4｜ biased_lock(偏向锁)：1 | lock(同步状态) : 2 </li>\n</ul>\n</li>\n<li>64 bits jvm 占 64 bits<ul>\n<li><img src=\"/JAVA/Interview/head.png\" alt=\"\"></li>\n<li>无状态下，在未调用过hashcode函数时，对象头hashcode位置都为0，调用过hashcode函数计算之后才会保存。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>klass pointer 指向类.class的指针<ul>\n<li>64 bits jvm 开启指针压缩占 32 bits 不开启占 64 bits</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"解释一下对象创建过程？\"><a href=\"#解释一下对象创建过程？\" class=\"headerlink\" title=\"解释一下对象创建过程？\"></a>解释一下对象创建过程？</h3><p>假设有一个对象T,有一个属性m=8，那么在new 这个对象时先在堆中申请空间，<br>然后属性半初始化也就是m=0，然后再调用构造方法将m修改为8，然后将引用变量t指向堆中的地址。</p>\n<h3 id=\"DCL与volatile的问题？\"><a href=\"#DCL与volatile的问题？\" class=\"headerlink\" title=\"DCL与volatile的问题？\"></a>DCL与volatile的问题？</h3><p>volatile 的作用是线程的可见性和禁止了指令重排序。<br>在单例模式中，未了保证多线程的安全性，采用了DCL（Double-Check-Locking）方式，<br>那么在线程1创建对象X的时候，对象先半初始化，再调用构造方法，线程2再去判断X对象等不等于空，<br>如果此时发生指令重排序，对象先半初始化，线程2再去判断X对象等不等于空，再调用构造方法，会导致线程2拿到了半初始化的对象。<br>所以需要volatile来禁止指令重排。</p>\n<h3 id=\"对象在内存中的存储布局？\"><a href=\"#对象在内存中的存储布局？\" class=\"headerlink\" title=\"对象在内存中的存储布局？\"></a>对象在内存中的存储布局？</h3><p>对象头、实例数据和对齐填充</p>\n<h3 id=\"对象怎么定位？\"><a href=\"#对象怎么定位？\" class=\"headerlink\" title=\"对象怎么定位？\"></a>对象怎么定位？</h3><p>引用-&gt;堆内存的对象-&gt;方法区常量。</p>\n<h3 id=\"对象怎么分配？\"><a href=\"#对象怎么分配？\" class=\"headerlink\" title=\"对象怎么分配？\"></a>对象怎么分配？</h3><p>开始new一个对象<br>    *尝试在栈上分配？<br>        * 可以在栈上分配，在pop时结束生命周期<br>        * 若一个对象的引用逃出了方法或者线程，在方法调用过程中传递对象的引用到另一个方法，或栈空间不够大。则不能在栈上分配。<br>            * 对象是否够大？<br>                * 足够大，老年代分配，full gc时结束生命周期<br>                * 不够大，尝试 tlab 分配？<br>                    * tlab空间是否足够？<br>                        * 足够，tlab（线程本地空间）分配到eden，<br>                        * 不足，共享空间分配到eden<br>                    * young gc-&gt; 幸存者区-&gt; 老年代-&gt; full gc 结束生命周期</p>\n<p>一般的对象分配内存，都是在新生代进行空间申请的。在多个线程都在申请空间时，每次对象分配都必须进行同步。竞争激烈的场合分配的效率又会进一步下降。TLAB是一个存在于eden区的线程独享内存区域，主要用于降低在新生代分配对象时的内存竞争，提升对象分配的效率。</p>\n<h3 id=\"Object-o-new-Object-在内存中占多少字节？\"><a href=\"#Object-o-new-Object-在内存中占多少字节？\" class=\"headerlink\" title=\"Object o = new Object() 在内存中占多少字节？\"></a>Object o = new Object() 在内存中占多少字节？</h3><p>对象的引用o 4 byte<br>Object 的 mark word 占 8 byte<br>klass pointer 若开启指针压缩占 4 byte，不开启压缩占 8 byte<br>对象的属性大小不确定。</p>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ 集合 ------------------------</span>\n</div>\n\n<h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><h3 id=\"HashSet-的底层实现是什么\"><a href=\"#HashSet-的底层实现是什么\" class=\"headerlink\" title=\"HashSet 的底层实现是什么?\"></a>HashSet 的底层实现是什么?</h3><p>HashSet 的实现是依赖于 HashMap 的，HashSet 的值都是存储 在 HashMap 中的。在 HashSet 的构造法中会初始化一个 HashMap 对象<br>HashSet 不允许值重复，因此，HashSet 的值是作为 HashMap 的 key 存储在 HashMap 中的，当存储的值已经存在时返回 false。</p>\n<h3 id=\"Iterator-和-ListIterator-的区别是什么\"><a href=\"#Iterator-和-ListIterator-的区别是什么\" class=\"headerlink\" title=\"Iterator 和 ListIterator 的区别是什么?\"></a>Iterator 和 ListIterator 的区别是什么?</h3><ul>\n<li>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。</li>\n<li>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。<br>ListIterator 实现了 Iterator 接口，并包含其他的功能，比如:增加元素，替换元 素，获取前一个和后一个元素的索引，等等。</li>\n</ul>\n<h3 id=\"数组-Array-和列表-ArrayList-有什么区别\"><a href=\"#数组-Array-和列表-ArrayList-有什么区别\" class=\"headerlink\" title=\"数组 (Array) 和列表 (ArrayList) 有什么区别?\"></a>数组 (Array) 和列表 (ArrayList) 有什么区别?</h3><ul>\n<li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</li>\n<li>Array 大小是固定的，ArrayList 的大小是动态变化的。</li>\n<li>ArrayList 处理固定大小的基本数据类型的时候，这种方式相对比较慢。</li>\n</ul>\n<h3 id=\"Comparable-和-Comparator-接口是干什么的\"><a href=\"#Comparable-和-Comparator-接口是干什么的\" class=\"headerlink\" title=\"Comparable 和 Comparator 接口是干什么的?\"></a>Comparable 和 Comparator 接口是干什么的?</h3><p><strong>Comparable</strong>：只包含一个 compareTo() 方法，这个方法可以个 给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于 已经存在的对象。<br><strong>Comparator</strong>：包含 compare() 和 equals() 两个方法。<br>    * compare() 方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小 于，等于，大于第二个参数。<br>    * equals() 方法需要一个对象作为参数，它用来决定输入 参数是否和 comparator 相等。</p>\n<h3 id=\"Collection-和-Collections-的区别？\"><a href=\"#Collection-和-Collections-的区别？\" class=\"headerlink\" title=\"Collection 和 Collections 的区别？\"></a>Collection 和 Collections 的区别？</h3><p><strong>Collection</strong>：是集合类的上级接口, 继承与它的接口主要是 set 和 list。<br><strong>Collections</strong>： 类是针对集合类的一个帮助类. 它提供一系列的静态方法对各种集合的搜 索, 排序, 线程安全化等操作。</p>\n<h3 id=\"ArrayList-和-Vector-的区别？\"><a href=\"#ArrayList-和-Vector-的区别？\" class=\"headerlink\" title=\"ArrayList 和 Vector 的区别？\"></a>ArrayList 和 Vector 的区别？</h3><p><strong>相同</strong>：<br>    * 都实现了 List 接口(List 接口继承了 Collection 接口)<br>    * 都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组<br>    * 允许重复</p>\n<p><strong>区别</strong>：<br>    * Vector 是线程安全的，ArrayList 是线程序不安全的。<br><strong>数据增长</strong>:<br>    * 相同：ArrayList 与 Vector 都可以设置初始的空间大小<br>    * 不同：Vector 还可以设置增长的空间大小，而 ArrayList 没有提供设置增长空间的方法。<br>           Vector 默认增加原来的 1 倍，ArrayList 增加原来的 0.5 倍。</p>\n<h3 id=\"快速失败-fail-fast-和安全失败-fail-safe-的区别是什么\"><a href=\"#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么\" class=\"headerlink\" title=\"快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么?\"></a>快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么?</h3><p>Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。</p>\n<p>java.util 包下面的所有的集合类都是快速失败的，迭代器会抛出 ConcurrentModificationException 异常<br>java.util.concurrent 包下面的所有的类都是安全失败的。安全失败的迭代器永远不会抛出这样的异常。</p>\n<h3 id=\"List、Map、Set-三个接口，存取元素时，各有什么特点\"><a href=\"#List、Map、Set-三个接口，存取元素时，各有什么特点\" class=\"headerlink\" title=\"List、Map、Set 三个接口，存取元素时，各有什么特点?\"></a>List、Map、Set 三个接口，存取元素时，各有什么特点?</h3><p>这样的题属于随意发挥题:这样的题比较考水平，两个方面的水平:一是要真正明白 这些内容，二是要有较强的总结和表述能力。如果你明白，但表述不清楚，在别人那 里则等同于不明白。</p>\n<p>首先List与Set<br>相同：<br>    * 都是单列元素的集合，有一个相同的父类 Collection<br>不同：<br>    * List 元素可以重复，Set不可以<br>    * List 可以按index取元素，Set只能逐一遍历<br>    * List 是有序集合。</p>\n<p>Map 是双列集合，要存储一对 key/value，不能存储重复的 key。</p>\n<h3 id=\"HashMap-的工作原理是什么\"><a href=\"#HashMap-的工作原理是什么\" class=\"headerlink\" title=\"HashMap 的工作原理是什么?\"></a>HashMap 的工作原理是什么?</h3><p>HashMap 1.8是 <strong>数组 + 链表 + 红黑树</strong> 实现的。</p>\n<ul>\n<li>负载因子（loadFactor）：0.75f</li>\n<li>容量（capacity）：16</li>\n<li>扩容阈值（threshold）：loadFactor * capacity</li>\n<li>转化成树的链表阈值（TREEIFY_THRESHOLD）：8</li>\n<li>转化成树的最小容量（MIN_TREEIFY_CAPACITY）：64<br>Java 中的 HashMap 是以键值对 (key-value) 的形式存储元素的，我们把一对(key-value)称为Node。<br>HashMap 需要 一个 hash 函数，当调用 put() 方法的时候，HashMap 会计算 key 的 hash 值，然后把键值对存储在集合中合适的索引上。<br>如果索引上已经存在了Node，发生哈希冲突。<ul>\n<li>如果索引上的结构是<strong>链表</strong>，则在链表中遍历，如果有相同的key，value 会被更新成新值，否则遍历到链表尾部，插入新的(key-value) ，size+1<ul>\n<li>如果链表的长度大于<strong>转化成树的链表阈值（TREEIFY_THRESHOLD）</strong> 并且，hashMap的容量大于<strong>转化成树的最小容量（MIN_TREEIFY_CAPACITY）</strong> 则转换成<code>红黑树</code>。</li>\n</ul>\n</li>\n<li>如果索引上的结构是<strong>红黑树</strong>，则在红黑树中遍历，如果有相同的key，value 会被更新成新值，否则插入红黑树，size+1。</li>\n</ul>\n</li>\n</ul>\n<p>如果 size &gt; threshold 则进行扩容。<br>    * 当原来的容量已经达到最大容量的时候，将阈值设置为Integer.MAX_VALUE，这样就不会再发生重构的情况<br>    * 将新的阈值设置为旧的阈值的两倍, 新的容量设置为旧容量的2倍。<br>    * 根据新容量新建一个Node数组，将旧数组中的元素全部取出，重新映射到新数组中</p>\n<h3 id=\"hashMap-容量为什么是-2-的幂次？\"><a href=\"#hashMap-容量为什么是-2-的幂次？\" class=\"headerlink\" title=\"hashMap 容量为什么是 2 的幂次？\"></a>hashMap 容量为什么是 2 的幂次？</h3><p>为了<strong>加快哈希计算</strong>以及<strong>减少哈希冲突</strong>。<br>为什么可以加快计算？<br>我们都知道为了找到 KEY 的位置在哈希表的哪个槽里面，需要计算 <strong>hash(KEY) % 数组长度</strong><br>但是 % 计算比 &amp; 慢很多，所以用 &amp; 代替 %，为了保证 &amp; 的计算结果等于 % 的结果需要把 length 减 1，也就是 <strong>hash(KEY) &amp; (length - 1)</strong><br>证明：当length 为2的幂次时，m % length = m &amp; (length-1)<br>     m 可以分成两部分 x（length的正数倍） 和 y（剩余部分） 因此 y的范围为 0 &lt;= y &lt;length<br>     m % length = (x + y)% length = x % length + y % length = 0 + y % length = y<br>     假设y 是 5 二进制 0101，length 为 8 二进制 1000 ，length -1 二进制 0111<br>     0101&amp;0111 = 0101 刚好将 5取出，因此成立</p>\n<p>为什么可以减少冲突？<br>假设现在数组的长度 length 可能是偶数也可能是奇数。<br>length 为偶数时，length-1 为奇数，奇数的二进制最后一位是 1，这样便保证了 hash &amp;(length-1) 的最后一位可能为 0，也可能为 1（这取决于 h 的值），即 &amp; 运算后的结果可能为偶数，也可能为奇数，<strong>这样便可以保证散列的均匀性。</strong><br>length 为奇数的话，很明显 length-1 为偶数，它的最后一位是 0，这样 hash &amp; (length-1) 的最后一位肯定为 0，即只能为偶数，这样任何 hash 值都只会被散列到数组的偶数下标位置上，这便<strong>浪费了近一半的空间</strong></p>\n<h3 id=\"ConcurrentHashMap-的工作原理是什么什么？\"><a href=\"#ConcurrentHashMap-的工作原理是什么什么？\" class=\"headerlink\" title=\"ConcurrentHashMap 的工作原理是什么什么？\"></a>ConcurrentHashMap 的工作原理是什么什么？</h3><ul>\n<li>JDK1.7:<br>  ConcurrentHashMap采用了<strong>数组+Segment+分段锁</strong>的方式实现。<br>  Segment：类似于HashMap的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表,同时又是一个ReentrantLock（Segment继承了ReentrantLock）。<br>  <img src=\"/JAVA/Interview/concurrentHashMap1.7.jpg\" alt=\"\"><br>  从上面的结构我们可以了解到，ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作。<br>  第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部。</li>\n<li>JDK1.8:<br>  采用了数组+链表+红黑树实现.<strong>彻底放弃了Segment转而采用的是Node，其设计思想也不再是JDK1.7中的分段锁思想。</strong><br>  Java8 ConcurrentHashMap结构基本上和Java8的HashMap一样，原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。</li>\n</ul>\n<h3 id=\"HashTable-、ConcurrentHashMap-和-hashMap-的区别？\"><a href=\"#HashTable-、ConcurrentHashMap-和-hashMap-的区别？\" class=\"headerlink\" title=\"HashTable 、ConcurrentHashMap 和 hashMap 的区别？\"></a>HashTable 、ConcurrentHashMap 和 hashMap 的区别？</h3><p>hashTable 默认初始容量是11，hashMap 和 ConcurrentHashMap 默认初始容量是16，<br>HashTable 在put和get方法上用了 synchronized 。ConcurrentHashMap 对每个node节点使用 synchronized</p>\n<h3 id=\"LinkedHashMap-工作原理？\"><a href=\"#LinkedHashMap-工作原理？\" class=\"headerlink\" title=\"LinkedHashMap 工作原理？\"></a>LinkedHashMap 工作原理？</h3><p>LinkedHashMap基于hashMap的基础上，对每个键值对(Node节点)多维护了一个before和after指针，每次插入时维护双向链表。<br>LinkedHashMap有序，可分为插入顺序和访问顺序两种。<br>如果是访问顺序，那put和get操作已存在的Entry时，都会把Entry移动到双向链表的表尾(其实是先删除再插入)。</p>\n<h3 id=\"TreeMap-工作原理？\"><a href=\"#TreeMap-工作原理？\" class=\"headerlink\" title=\"TreeMap 工作原理？\"></a>TreeMap 工作原理？</h3><p>底层红黑树实现。<br>TreeMap有序是通过Comparator来进行比较的，如果comparator为null，那么就使用自然顺序</p>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ 异常 ------------------------</span>\n</div>\n\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><h3 id=\"Java中的异常有哪几类？\"><a href=\"#Java中的异常有哪几类？\" class=\"headerlink\" title=\"Java中的异常有哪几类？\"></a>Java中的异常有哪几类？</h3><p>异常类有分为编译时异常和运行时异常<br>常见的编译时异常：<br>    * IOException<br>    * SQLException<br>    * parseException</p>\n<p>常见的运行时异常（RuntimeException）：<br>    * NullPointerException: 空指针异常,一般出现于数组,空对象的变量和方法<br>    * ArrayIndexOutOfBoundsException: 数组越界异常<br>    * NoClassDefFoundException: java运行时系统找不到所引用的类<br>    * NumberFormatException: 数据格式异常<br>    * OutOfMemoryException: 内存溢出异常<br>    * ArithmeticException: 算数异常,一般在被除数是0中<br>    * IllegalArgumentException: 非法参数异常</p>\n<h3 id=\"Error-和-Exception-区别是什么？\"><a href=\"#Error-和-Exception-区别是什么？\" class=\"headerlink\" title=\"Error 和 Exception 区别是什么？\"></a>Error 和 Exception 区别是什么？</h3><p>Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；<br>Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。</p>\n<h3 id=\"运行时异常和编译时异常区别是什么？\"><a href=\"#运行时异常和编译时异常区别是什么？\" class=\"headerlink\" title=\"运行时异常和编译时异常区别是什么？\"></a>运行时异常和编译时异常区别是什么？</h3><p>运行时异常：编译器不会对运行时异常进行检测，没有 try-catch，方法签名中也没有 throws 关键字声明，编译依然可以通过。如果出现了 RuntimeException, 那一定是程序员的错误<br>编译时异常：如果没有 try-catch，且方法签名中也没有用 throws 关键字声明可能抛出的异常，则编译无法通过。这类异常通常为应用环境中的错误，即外部错误，非应用程序本身错误，如文件找不到等。</p>\n<h3 id=\"throw-和-throws-的区别是什么？\"><a href=\"#throw-和-throws-的区别是什么？\" class=\"headerlink\" title=\"throw 和 throws 的区别是什么？\"></a>throw 和 throws 的区别是什么？</h3><p><strong>throw</strong> 关键字用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。<br><strong>throws</strong> 关键字用在方法签名处，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</p>\n<h3 id=\"Java内存溢出是什么？\"><a href=\"#Java内存溢出是什么？\" class=\"headerlink\" title=\"Java内存溢出是什么？\"></a>Java内存溢出是什么？</h3><p>内存溢出分三种情况。</p>\n<ul>\n<li>OutOfMemoryError： PermGen space 元空间<br>  这个区域主要用来保存加来的Class的一些信息，在程序运行期间属于永久占用的，Java的GC不会对他进行释放，所以如果启动的程序加载的信息比较大，超出了这个空间的大小，就会发生溢出错误；<br>  解决的办法无非就是增加空间分配了——增加java虚拟机中的XX:PermSize和XX:MaxPermSize参数的大小，其中XX:PermSize是初始永久保存区域大小，XX:MaxPermSize是最大永久保存区域大小。</li>\n<li>OutOfMemoryError：Java heap space<br>  heap 是Java内存中的堆区，主要用来存放对象，当对象太多超出了空间大小，GC又来不及释放的时候，就会发生溢出错误。<br>  一般来说，当已存在对象没有引用(即不可达)的时候，GC就会定时的来回收对象，释放空间。但是因为程序的设计问题，导致对象可达但是又没有用(即前文提到的内存泄露)，当这种情况越来越多的时候，问题就来了。<br>  针对这个问题，我们需要做一下两点： 1、检查程序，减少大量重复创建对象的死循环，减少内存泄露。 2、增加Java虚拟机中Xms（初始堆大小）和Xmx（最大堆大小）参数的大小。</li>\n<li>StackOverFlowError<br>  stack是Java内存中的栈空间，主要用来存放方法中的变量，参数等临时性的数据的，发生溢出一般是因为分配空间太小，或是执行的方法递归层数太多创建了占用了太多栈帧导致溢出。<br>  针对这个问题，除了修改配置参数-Xss参数增加线程栈大小之外，优化程序是尤其重要。</li>\n</ul>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ 反射 ------------------------</span>\n</div>\n\n<h2 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h2><h3 id=\"什么是反射？\"><a href=\"#什么是反射？\" class=\"headerlink\" title=\"什么是反射？\"></a>什么是反射？</h3><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；<br>这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p>\n<h3 id=\"什么是-Java-序列化？什么情况下需要序列化？\"><a href=\"#什么是-Java-序列化？什么情况下需要序列化？\" class=\"headerlink\" title=\"什么是 Java 序列化？什么情况下需要序列化？\"></a>什么是 Java 序列化？什么情况下需要序列化？</h3><p>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。<br>以下情况需要使用 Java 序列化：</p>\n<ul>\n<li>想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li>\n<li>想用套接字在网络上传送对象的时候；</li>\n<li>想通过RMI（远程方法调用）传输对象的时候。</li>\n</ul>\n<h3 id=\"动态代理是什么？有哪些应用？\"><a href=\"#动态代理是什么？有哪些应用？\" class=\"headerlink\" title=\"动态代理是什么？有哪些应用？\"></a>动态代理是什么？有哪些应用？</h3><p>动态代理是运行时动态生成代理类。</p>\n<p>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</p>\n<h3 id=\"怎么实现动态代理？\"><a href=\"#怎么实现动态代理？\" class=\"headerlink\" title=\"怎么实现动态代理？\"></a>怎么实现动态代理？</h3><p>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</p>\n<h3 id=\"JDK-动态代理为什么只能基于接口？\"><a href=\"#JDK-动态代理为什么只能基于接口？\" class=\"headerlink\" title=\"JDK 动态代理为什么只能基于接口？\"></a>JDK 动态代理为什么只能基于接口？</h3><p>java的代理对象自动继承了Proxy，又因为JAVA是单继承的，所以目标对象只能实现接口不能继承。</p>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ JVM ------------------------</span>\n</div>\n\n<h2 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h2><h3 id=\"什么是JVM？什么是hotspot？\"><a href=\"#什么是JVM？什么是hotspot？\" class=\"headerlink\" title=\"什么是JVM？什么是hotspot？\"></a>什么是JVM？什么是hotspot？</h3><p>JVM ——- 规范/标准<br>hotspot — 产品/实现</p>\n<h3 id=\"说一下-JVM-的主要组成部分？及其作用？\"><a href=\"#说一下-JVM-的主要组成部分？及其作用？\" class=\"headerlink\" title=\"说一下 JVM 的主要组成部分？及其作用？\"></a>说一下 JVM 的主要组成部分？及其作用？</h3><p><img src=\"/JAVA/Interview/1.png\" alt=\"\"></p>\n<ul>\n<li>类加载器（ClassLoader）</li>\n<li>运行时数据区（Runtime Data Area）</li>\n<li>执行引擎（Execution Engine）</li>\n<li>本地库接口（Native Interface）</li>\n</ul>\n<p>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，<br>           运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，<br>           因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，<br>           而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p>\n<h3 id=\"说一下类装载的执行过程？\"><a href=\"#说一下类装载的执行过程？\" class=\"headerlink\" title=\"说一下类装载的执行过程？\"></a>说一下类装载的执行过程？</h3><p><img src=\"/JAVA/Interview/2.png\" alt=\"\"><br>类装载分为以下 5 个步骤：</p>\n<ol>\n<li><strong>加载</strong>：将.class文件从磁盘读到内存<ul>\n<li>通过类的全限定名(com.xxx.xxx)+类加载器确定唯一的类，来获取定义此类的二进制字节流</li>\n<li>将这个类字节流代表的静态存储结构转为方法区的运行时数据结构</li>\n<li>在堆中生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口。</li>\n</ul>\n</li>\n<li><strong>检查</strong>：检查加载的 class 文件的正确性；<ul>\n<li>文件格式验证:验证字节流是否符合 Class 文件的规范，如 主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.</li>\n<li>元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。</li>\n<li>字节码验证:是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如:方法中的类型转换是否正确，跳转指令是否正确等。</li>\n<li>符号引用验证:基于方法区的存储结构验证，发生在解析中，是否可以将符号引用成功解析为直接引用。</li>\n</ul>\n</li>\n<li><strong>准备</strong>：给类中的静态变量分配内存空间；<ul>\n<li>public static int value = 123; //此时在准备阶段过后的初始值为0而不是123，在初始化过程才会被赋值为123</li>\n<li>public static final int value = 123;//value的值在准备阶段过后就是123。</li>\n</ul>\n</li>\n<li><strong>解析</strong>：虚拟机将常量池中的符号引用替换成直接引用的过程。<strong>符号引用就理解为一个标示，而在直接引用直接指向内存中的地址</strong>；</li>\n<li><strong>初始化</strong>：对静态变量和静态代码块执行初始化工作。</li>\n</ol>\n<h3 id=\"类加载器的种类？\"><a href=\"#类加载器的种类？\" class=\"headerlink\" title=\"类加载器的种类？\"></a>类加载器的种类？</h3><p><img src=\"/JAVA/Interview/3.png\" alt=\"\"></p>\n<ul>\n<li>启动类加载器(Bootstrap ClassLoader)：负责加载JRE的核心类库，如JRE目标下的rt.jar，charsets.jar等</li>\n<li>扩展类加载器(Extension ClassLoader)：负责加载JRE扩展目录ext中jar类包</li>\n<li>系统类加载器(Application ClassLoader)：负责加载ClassPath路径下的类包</li>\n<li>用户自定义加载器(User ClassLoader)：负责加载用户自定义路径下的类包</li>\n</ul>\n<h3 id=\"什么是双亲委派模型？\"><a href=\"#什么是双亲委派模型？\" class=\"headerlink\" title=\"什么是双亲委派模型？\"></a>什么是双亲委派模型？</h3><p><img src=\"/JAVA/Interview/4.png\" alt=\"\"><br>如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p>\n<h3 id=\"双亲委派模式的优势\"><a href=\"#双亲委派模式的优势\" class=\"headerlink\" title=\"双亲委派模式的优势?\"></a>双亲委派模式的优势?</h3><ul>\n<li>沙箱安全机制:比如自己写的String.class类不会被加载，这样可以防止核心库被随意篡改</li>\n<li>避免类的重复加载:当父ClassLoader已经加载了该类的时候，就不需要子ClassLoader再加载一次   </li>\n</ul>\n<h3 id=\"为什么要打破双亲委派模式\"><a href=\"#为什么要打破双亲委派模式\" class=\"headerlink\" title=\"为什么要打破双亲委派模式?\"></a>为什么要打破双亲委派模式?</h3><p>例如：tomcat<br>Tomcat是个web容器,可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。<br>如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加载器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。</p>\n<h3 id=\"JVM-运行时数据区？\"><a href=\"#JVM-运行时数据区？\" class=\"headerlink\" title=\"JVM 运行时数据区？\"></a>JVM 运行时数据区？</h3><p><img src=\"/JAVA/Interview/5.png\" alt=\"\"></p>\n<ul>\n<li>程序计数器（Program Counter Register）: 前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</li>\n<li>Java 虚拟机栈（Java Virtual Machine Stacks）: 用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</li>\n<li>本地方法栈（Native Method Stack）: 与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</li>\n<li>Java 堆（Java Heap）: Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</li>\n<li>方法区（Methed Area）: 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li>\n</ul>\n<h3 id=\"Java-中都有哪些引用类型？\"><a href=\"#Java-中都有哪些引用类型？\" class=\"headerlink\" title=\"Java 中都有哪些引用类型？\"></a>Java 中都有哪些引用类型？</h3><ul>\n<li>强引用：通常我们使用new操作符创建一个对象时所返回的引用即为强引用</li>\n<li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</li>\n<li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li>\n<li>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</li>\n</ul>\n<h3 id=\"Java-堆的结构是什么样子的\"><a href=\"#Java-堆的结构是什么样子的\" class=\"headerlink\" title=\"Java 堆的结构是什么样子的?\"></a>Java 堆的结构是什么样子的?</h3><p><img src=\"/JAVA/Interview/6.jpeg\" alt=\"\"><br>堆空间一般分为新生代、老年代。</p>\n<h3 id=\"什么是新生代？\"><a href=\"#什么是新生代？\" class=\"headerlink\" title=\"什么是新生代？\"></a>什么是新生代？</h3><p>新生代分为两部分:<code>伊甸区</code>(Eden space)和<code>幸存者区</code>(Survivor space)，所有的类都是在伊甸区被new出来的。<br>幸存区(Survivor space):分为From和To区,TO区永远保持空。<br>当Eden区的空间用完是，程序又需要创建对象，JVM的垃圾回收器将Eden区进行垃圾回收(<code>Minor GC</code>)，将Eden区中的不再被其它对象应用的对象进行销毁。<br>然后将Eden区中剩余的对象移到From Survivor区。若From Survivor区也满了，再对该区进行垃圾回收，然后移动到To Survivor区，From区为空后，将To和From区转换，保证To区为空，并且对象年龄加一。<br>当对象年龄默认加到15（因为<strong>对象头只有4个bits</strong>是存对象年龄，最大为15）时将剩下的对象移到老年代。</p>\n<h3 id=\"什么是老年代？\"><a href=\"#什么是老年代？\" class=\"headerlink\" title=\"什么是老年代？\"></a>什么是老年代？</h3><p>新生代经过多次GC仍然存货的对象移动到老年区。<br>若老年代也满了，这时候将发生Major GC(也可以叫<code>Full GC</code>)， 进行老年区的内存清理。<br>若老年区执行了Full GC之后发现依然无法进行对象的保存，就会抛出 OOM(OutOfMemoryError)异常.</p>\n<h3 id=\"Survivor区-到-老年代有什么条件？\"><a href=\"#Survivor区-到-老年代有什么条件？\" class=\"headerlink\" title=\"Survivor区 到 老年代有什么条件？\"></a>Survivor区 到 老年代有什么条件？</h3><p>对象年龄到15，才会移动到老年代。因为<strong>对象头只有4个bits</strong>是存对象年龄，最大为15</p>\n<h3 id=\"JVM-有哪些垃圾回收算法？\"><a href=\"#JVM-有哪些垃圾回收算法？\" class=\"headerlink\" title=\"JVM 有哪些垃圾回收算法？\"></a>JVM 有哪些垃圾回收算法？</h3><ul>\n<li><strong>标记-清除算法</strong>：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</li>\n<li><strong>标记-整理算法</strong>：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li>\n<li><strong>复制算法</strong>：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li>\n<li><strong>分代算法</strong>：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</li>\n</ul>\n<h3 id=\"JVM-有哪些垃圾回收器？\"><a href=\"#JVM-有哪些垃圾回收器？\" class=\"headerlink\" title=\"JVM 有哪些垃圾回收器？\"></a>JVM 有哪些垃圾回收器？</h3><ul>\n<li>Serial：最早的单线程串行垃圾回收器。<strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></li>\n<li>Serial Old：Serial 垃圾回收器的老年代版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。采用<strong>标记-整理</strong>算法。</li>\n<li>ParNew：是 Serial 的多线程版本。<strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></li>\n<li>Parallel： 是 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。<strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></li>\n<li>Parallel Old： 是 Parallel 老年代版本，，Parallel Old 使用的是<strong>标记-整理</strong>的内存回收算法。</li>\n<li>CMS：一种以获得最短停顿时间为目标的收集器，第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作。是一种<strong>标记-清除</strong>算法实现<ul>\n<li>初始标记(CMS initial mark): 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 </li>\n<li>并发标记(CMS concurrent mark): <strong>同时开启GC和用户线程</strong>，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>\n<li>重新标记(CMS remark): 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶 段时间短</li>\n<li>并发清除(CMS concurrent sweep): 开启用户线程，同时GC线程开始对为标记的区域做清扫。</li>\n</ul>\n</li>\n<li>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。G1从整体来看是基于<strong>标记整理</strong>算法实现的收集器;从局部上来看是基于<strong>标记复制</strong>算法实现的</li>\n</ul>\n<h3 id=\"堆栈的区别？\"><a href=\"#堆栈的区别？\" class=\"headerlink\" title=\"堆栈的区别？\"></a>堆栈的区别？</h3><ul>\n<li>功能方面：堆是用来存放对象的，栈是用来执行程序的。</li>\n<li>共享性：堆是线程共享的，栈是线程私有的。</li>\n<li>空间大小：堆大小远远大于栈。</li>\n</ul>\n<h3 id=\"怎么判断对象是否可以被回收？\"><a href=\"#怎么判断对象是否可以被回收？\" class=\"headerlink\" title=\"怎么判断对象是否可以被回收？\"></a>怎么判断对象是否可以被回收？</h3><p><strong>引用计数器</strong>：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；<br><strong>可达性分析</strong>：这个算法的基本思想就是通过一系列的称为”GC Roots”的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象时不可用的。<br>    * <code>GC Roots根节点</code>:类加载器、Thread、虚拟机栈的局部变量表、static成员、常量引用、本地方法栈的变量等等.</p>\n<h3 id=\"JVM-调优的工具？\"><a href=\"#JVM-调优的工具？\" class=\"headerlink\" title=\"JVM 调优的工具？\"></a>JVM 调优的工具？</h3><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>\n<ul>\n<li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li>\n<li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li>\n</ul>\n<h3 id=\"JVM-调优的参数都有哪些？\"><a href=\"#JVM-调优的参数都有哪些？\" class=\"headerlink\" title=\"JVM 调优的参数都有哪些？\"></a>JVM 调优的参数都有哪些？</h3><p>-Xms2g：初始化推大小为 2g；<br>-Xmx2g：堆最大内存为 2g；<br>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；<br>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；<br>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br>-XX:+PrintGC：开启打印 gc 信息；<br>-XX:+PrintGCDetails：打印 gc 详细信息。</p>\n<h3 id=\"Java-中会存在内存泄漏吗？\"><a href=\"#Java-中会存在内存泄漏吗？\" class=\"headerlink\" title=\"Java 中会存在内存泄漏吗？\"></a>Java 中会存在内存泄漏吗？</h3><p>所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。<br>长生命周期的对象持有短生命周期对 象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需 要，但是因为长生命周期对象持有它的引用而导致不能被回收。</p>\n<h3 id=\"finalize-方法什么时候被调用\"><a href=\"#finalize-方法什么时候被调用\" class=\"headerlink\" title=\"finalize() 方法什么时候被调用?\"></a>finalize() 方法什么时候被调用?</h3><p>垃圾回收器(garbage colector)决定回收某对象时，就会运行该 对象的 finalize() 方法 但是在 Java 中很不幸，如果内存总是充 足的，那么垃圾回收可能永远不会进行，也就是说 filalize() 可能 永远不被执行，显然指望它做收尾工作是靠不住的。 那么 finalize() 究竟是做什么的呢? 它最主要的用途是回收特殊渠道申请的内存。Java 程序有垃圾回收器，所以一般情况下内存问题 不用程序员操心。但有一种 JNI(Java Native Interface)调用 non-Java 程序(C 或 C++)， finalize() 的工作就是回收这部分的内存。</p>\n<h3 id=\"深拷贝和浅拷贝区别是什么？\"><a href=\"#深拷贝和浅拷贝区别是什么？\" class=\"headerlink\" title=\"深拷贝和浅拷贝区别是什么？\"></a>深拷贝和浅拷贝区别是什么？</h3><ul>\n<li>浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制，指向同一个地址。</li>\n<li>深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。</li>\n</ul>\n<h3 id=\"如何实现对象克隆？\"><a href=\"#如何实现对象克隆？\" class=\"headerlink\" title=\"如何实现对象克隆？\"></a>如何实现对象克隆？</h3><ul>\n<li>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。</li>\n<li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</li>\n</ul>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ 多线程 ------------------------</span>\n</div>\n\n<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><h3 id=\"什么是线程安全？\"><a href=\"#什么是线程安全？\" class=\"headerlink\" title=\"什么是线程安全？\"></a>什么是线程安全？</h3><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 </p>\n<h3 id=\"如何保证线程安全？\"><a href=\"#如何保证线程安全？\" class=\"headerlink\" title=\"如何保证线程安全？\"></a>如何保证线程安全？</h3><ul>\n<li>synchronized关键字 </li>\n<li>用Lock锁</li>\n<li>volatile+CAS【单纯的volatile是轻量级的同步机制<strong>保证可见性但是不具备原子性</strong>所以要配合CAS来实现线程安全】</li>\n<li>atomic原子类</li>\n</ul>\n<h3 id=\"哪些集合类是线程安全的？\"><a href=\"#哪些集合类是线程安全的？\" class=\"headerlink\" title=\"哪些集合类是线程安全的？\"></a>哪些集合类是线程安全的？</h3><p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p>\n<h3 id=\"并行和并发有什么区别\"><a href=\"#并行和并发有什么区别\" class=\"headerlink\" title=\"并行和并发有什么区别?\"></a>并行和并发有什么区别?</h3><ul>\n<li>并行：多个处理器或多核处理器同时处理多个任务。( 两个队列和一台咖啡机 )</li>\n<li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。( 两个队列和两台咖啡机 )</li>\n</ul>\n<h3 id=\"线程和进程的区别\"><a href=\"#线程和进程的区别\" class=\"headerlink\" title=\"线程和进程的区别?\"></a>线程和进程的区别?</h3><p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p>\n<h3 id=\"守护线程是什么\"><a href=\"#守护线程是什么\" class=\"headerlink\" title=\"守护线程是什么?\"></a>守护线程是什么?</h3><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p>\n<h3 id=\"创建线程有哪几种方式\"><a href=\"#创建线程有哪几种方式\" class=\"headerlink\" title=\"创建线程有哪几种方式?\"></a>创建线程有哪几种方式?</h3><ul>\n<li>继承 Thread 重写 run 方法；</li>\n<li>实现 Runnable 接口；</li>\n<li>实现 Callable 接口。(可以获取线程执行之后的返回值)</li>\n<li>线程池</li>\n</ul>\n<h3 id=\"Runnable和Callable的区别\"><a href=\"#Runnable和Callable的区别\" class=\"headerlink\" title=\"Runnable和Callable的区别?\"></a>Runnable和Callable的区别?</h3><ul>\n<li>Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。</li>\n<li>Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。</li>\n<li>call方法可以抛出异常，run方法不可以。</li>\n<li>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li>\n</ul>\n<h3 id=\"线程有哪些状态\"><a href=\"#线程有哪些状态\" class=\"headerlink\" title=\"线程有哪些状态?\"></a>线程有哪些状态?</h3><ul>\n<li>NEW 尚未启动</li>\n<li>RUNNABLE 正在执行中</li>\n<li>BLOCKED 阻塞的（被同步锁或者IO锁阻塞）</li>\n<li>WAITING 永久等待状态</li>\n<li>TIMED_WAITING 等待指定的时间重新被唤醒的状态</li>\n<li>TERMINATED 执行完成</li>\n</ul>\n<p><img src=\"/JAVA/Interview/01.jpeg\" alt=\"\"></p>\n<h3 id=\"sleep-和-wait-有什么区别\"><a href=\"#sleep-和-wait-有什么区别\" class=\"headerlink\" title=\"sleep() 和 wait() 有什么区别?\"></a>sleep() 和 wait() 有什么区别?</h3><ul>\n<li>类的不同：sleep() 来自 Thread，wait() 来自 Object。</li>\n<li>释放锁：sleep() 不释放锁；wait() 释放锁。</li>\n<li>用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。</li>\n</ul>\n<h3 id=\"sleep-和-yield-区别？\"><a href=\"#sleep-和-yield-区别？\" class=\"headerlink\" title=\"sleep() 和 yield() 区别？\"></a>sleep() 和 yield() 区别？</h3><ul>\n<li>sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield() 方法只会给相同优先级或更高优先级的线程以运行的机会； </li>\n<li>线程执行 sleep() 方法后转入阻塞（blocked）状态，而执行 yield() 方法后转入就绪（Runnable）状态； </li>\n<li>sleep() 方法声明抛出InterruptedException，而 yield() 方法没有声明任何异常； </li>\n<li>sleep() 方法比 yield() 方法（跟操作系统相关）具有更好的可移植性。</li>\n</ul>\n<h3 id=\"notify-和-notifyAll-有什么区别？\"><a href=\"#notify-和-notifyAll-有什么区别？\" class=\"headerlink\" title=\"notify()和 notifyAll()有什么区别？\"></a>notify()和 notifyAll()有什么区别？</h3><ul>\n<li>notifyAll: 会唤醒所有的线程,会将全部线程由等待池移到锁池,然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争</li>\n<li>notify: 唤醒一个线程,具体唤醒哪一个线程由虚拟机控制。</li>\n</ul>\n<h3 id=\"线程的-run-和-start-有什么区别？\"><a href=\"#线程的-run-和-start-有什么区别？\" class=\"headerlink\" title=\"线程的 run() 和 start() 有什么区别？\"></a>线程的 run() 和 start() 有什么区别？</h3><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p>\n<h3 id=\"park-的作用\"><a href=\"#park-的作用\" class=\"headerlink\" title=\"park() 的作用\"></a>park() 的作用</h3><p>LockSupport类中的 park(Object blocker) 表示<strong>阻塞指定线程</strong>，参数blocker当前线程对象，使线程进入等待状态，释放cpu,并不会抛出中断异常<br>unpark(Thread thread) 唤醒指定线程，参数thread指定线程对象 </p>\n<h3 id=\"创建线程池有哪几种方式？\"><a href=\"#创建线程池有哪几种方式？\" class=\"headerlink\" title=\"创建线程池有哪几种方式？\"></a><code>创建线程池有哪几种方式？</code></h3><ol>\n<li>public static ExecutorService newCachedThreadPool() 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程，但是在之前构造的线程可用时将重用它们。</li>\n<li>public static ExecutorService newFixedThreadPool(int nThreads)  创建一个定长线程池，可控制线程最大并发数，以共享的无界队列方式来运行线程，超出的线程会在队列中等待。</li>\n<li>public static ExecutorService newSingleThreadExecutor() 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，以无界队列方式来运行线程，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li>\n<li>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 创建一个周期线程池，支持定时及周期性任务执行。</li>\n<li>public static ExecutorService newWorkStealingPool() 创建持有足够线程的线程池来支持给定的并行级别，并通过使用多个队列，减少竞争，它需要穿一个并行级别的参数，如果不传，则被设定为默认的CPU数量，这个线程池实际上是ForkJoinPool的扩展，适合使用在很耗时的任务中，能够合理的使用CPU进行并行操作。</li>\n</ol>\n<h3 id=\"线程池流程？\"><a href=\"#线程池流程？\" class=\"headerlink\" title=\"线程池流程？\"></a>线程池流程？</h3><p><img src=\"/JAVA/Interview/threadPoll.png\" alt=\"\"></p>\n<h3 id=\"线程池中-submit-和-execute-方法有什么区别？\"><a href=\"#线程池中-submit-和-execute-方法有什么区别？\" class=\"headerlink\" title=\"线程池中 submit() 和 execute() 方法有什么区别？\"></a>线程池中 submit() 和 execute() 方法有什么区别？</h3><ul>\n<li>execute()：只能执行 Runnable 类型的任务。</li>\n<li>submit()：可以执行 Runnable 和 Callable 类型的任务。</li>\n</ul>\n<h3 id=\"什么是CAS？\"><a href=\"#什么是CAS？\" class=\"headerlink\" title=\"什么是CAS？\"></a>什么是CAS？</h3><p>全称Compare and swap，比较并交换。<br>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存值修改为 B<br>java 的 CAS 利用的的是 unsafe（该类都是基于JVM对操作系统进行的操作，因此是unsafe）这个类提供的 CAS 操作<br>unsafe 的CAS 依赖了的 JVM 针对不同的操作系统实现的 Atomic::cmpxchg<br>Atomic::cmpxchg 的实现使用了汇编的 cas 操作，并使用 cpu 硬件提供的 lock信号保证其原子性</p>\n<h3 id=\"CAS有什么问题？\"><a href=\"#CAS有什么问题？\" class=\"headerlink\" title=\"CAS有什么问题？\"></a>CAS有什么问题？</h3><p>ABA问题。<br>举个例子：<br>假设有一个遵循CAS原理的提款机，小灰有100元存款，要用这个提款机来提款50元。<br>由于提款机硬件出了点小问题，小灰的提款操作被同时提交两次，开启了两个线程，两个线程都是获取当前值100元，要更新成50元。<br>理想情况下，应该一个线程更新成功，另一个线程更新失败，小灰的存款只被扣一次。<br>线程1首先执行成功，把余额从100改成50。线程2因为某种原因阻塞了。这时候，小灰的妈妈刚好给小灰汇款50元。<br>线程2仍然是阻塞状态，线程3执行成功，把余额从50改成100。<br>线程2恢复运行，由于阻塞之前已经获得了“当前值”100，并且经过compare检测，此时存款实际值也是100，所以成功把变量值100更新成了50。<br>小灰凭空少了50元钱。</p>\n<p>解决方案：<br>使用携带版本的号的AtomicStampedReference</p>\n<h3 id=\"什么是AQS？\"><a href=\"#什么是AQS？\" class=\"headerlink\" title=\"什么是AQS？\"></a>什么是AQS？</h3><p>AbstractQueuedSynchronizer，抽象队列同步器<br>AQS就是一个并发包的基础组件，是一个抽象类，用来实现各种锁，各种同步组件的。<br>它包含了state变量、加锁线程、等待队列等并发中的核心组件。常见的实现类有:ReentrantLock等。</p>\n<h3 id=\"AQS原理？\"><a href=\"#AQS原理？\" class=\"headerlink\" title=\"AQS原理？\"></a>AQS原理？</h3><ul>\n<li>AQS对象内部有一个核心的变量叫做<strong>state</strong>，是int类型的，代表了加锁的状态，初始状态下，这个state的值是0。</li>\n<li>AQS内部还有一个关键变量，用来记录<strong>当前加锁的是哪个线程</strong>，初始化状态下，这个变量是null。</li>\n<li>AQS内部还有一个<strong>等待队列</strong>，专门放那些加锁失败的线程</li>\n</ul>\n<p>当 线程1 尝试进行加锁，用CAS操作将state值从0变为1。如果CAS操作成功，将当前加锁线程设置成自己。<br>线程1 <strong>可重入加锁时，每次判断当前加锁线程是否是自己，是的话state+1</strong><br>当 线程2 尝试获取锁，用CAS操作将state值从0变为1，失败！！！然后检查当前加锁线程是否是自己，那当然不是。<br>线程2 会将自己放入AQS中的一个等待队列，等待 线程1 释放锁之后，自己就可以重新尝试加锁了。<br>线程1 释放锁就是将state变量的值递减1，将当前加锁线程设置成null。<br>接下来，会从<strong>等待队列的队头唤醒</strong> 线程2 重新尝试加锁。<br>重复上述过程。</p>\n<h3 id=\"ReentrantLock-原理？\"><a href=\"#ReentrantLock-原理？\" class=\"headerlink\" title=\"ReentrantLock 原理？\"></a>ReentrantLock 原理？</h3><p>ReentrantLock 可是分为公平锁和非公平锁，默认的构造函数是非公平锁<br>公平锁：当判断到锁状态字段state == 0 时，不会立马将当前线程设置为该锁的占用线程，而是去判断是在此线程之前是否有其他线程在等待这个锁，然后再CAS操作获取锁<br>非公平锁：没有判断是否有在此之前的排队线程，而是直接CAS操作进行获锁，此多个线程之间同时争用一把锁的时候，谁先获取到就变得随机了<br>加锁过程：<br>线程A，首先获取state的值判断是否为0，若state == 0。<br>    * 判断是自己是否需要排队<br>        * 若需要排队，也就是 队列的 head != tail 也就是队列已初始化了 并且 （head.next !=null 或 head.next.thread != 当前线程）<br>            * 将head.next 指向A，A.pre 指向head。<br>            * 判断A是否是排队的第一个线程<br>        * 若不需要排队，尝试进行加锁，用CAS操作将state值从0变为1。<br>            * 如果CAS操作成功，将当前加锁线程设置成自己。<br>            * 如果CAS操作失败，会检查当前加锁线程是否是自己。<br>                * 若是当前线程，就是重入锁，将state++。<br>                * 若不是当前线程，将线程放入等待队列。<br>                    * 如果队列为空，初始化一个thread=null的node作为队列的头head，将head.next 指向A，A.pre 指向head。<br>            * 判断A是否是排队的第一个线程<br>                * 如果A.pre == head ,表示A是排队的第一个线程，自旋两次尝试加锁，将A.pre 的ws值改为-1，若还失败则使用park()进行线程阻塞。<br>                * 如果不是，则直接使用park()进行线程阻塞。</p>\n<p>释放锁：<br>将state变量的值递减1，如果state == 0，将当前加锁线程设置成null。<br>如果队列不为空，将队列的head节点的ws值改为0，然后用unpark()唤醒 head.next也就是A线程，<br>然后将队列的head设置为A，A节点的thread设置为null。</p>\n<h3 id=\"什么是锁？\"><a href=\"#什么是锁？\" class=\"headerlink\" title=\"什么是锁？\"></a>什么是锁？</h3><p>锁(lock)或互斥(mutex)是一种同步机制，用于在有许多执行线程的环境中强制对资源的访问限制。锁旨在强制实施互斥排他、并发控制策略。<br>锁的作用就是保证多线程同步执行。</p>\n<h3 id=\"Java中有哪些锁？\"><a href=\"#Java中有哪些锁？\" class=\"headerlink\" title=\"Java中有哪些锁？\"></a>Java中有哪些锁？</h3><p>公平锁、非公平锁、读写锁、共享锁、互斥锁、自旋锁、偏向锁、轻量级锁、重量级锁等等。</p>\n<h3 id=\"什么是死锁？\"><a href=\"#什么是死锁？\" class=\"headerlink\" title=\"什么是死锁？\"></a>什么是死锁？</h3><p>线程A持有独占锁资源a，并尝试去获取独占锁资源b<br>同时，线程B持有独占锁资源b，并尝试去获取独占锁资源a<br>这样线程A和线程B相互持有对方需要的锁，从而发生阻塞，最终变为死锁。</p>\n<h3 id=\"死锁发生的必要条件？\"><a href=\"#死锁发生的必要条件？\" class=\"headerlink\" title=\"死锁发生的必要条件？\"></a>死锁发生的必要条件？</h3><ul>\n<li>互斥条件：一个资源每次只能被一个进程使用。</li>\n<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>\n<li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li>\n<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>\n</ul>\n<h3 id=\"怎么防止死锁？\"><a href=\"#怎么防止死锁？\" class=\"headerlink\" title=\"怎么防止死锁？\"></a>怎么防止死锁？</h3><ul>\n<li>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li>\n<li>尽量使用 Java. util. concurrent 并发类代替自己手写锁。</li>\n<li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li>\n<li>尽量减少同步的代码块。</li>\n</ul>\n<h3 id=\"当一个线程进入一个对象的一个-synchronized-方法后，其它线程是否可进入此对象的其它方法\"><a href=\"#当一个线程进入一个对象的一个-synchronized-方法后，其它线程是否可进入此对象的其它方法\" class=\"headerlink\" title=\"当一个线程进入一个对象的一个 synchronized 方法后，其它线程是否可进入此对象的其它方法?\"></a>当一个线程进入一个对象的一个 synchronized 方法后，其它线程是否可进入此对象的其它方法?</h3><ul>\n<li>其他方法前是否加了 synchronized 关键字，如果没加，则能。</li>\n<li>如果这个方法内部调用了 wait，则可以进入其他 synchronized 方法。</li>\n</ul>\n<h3 id=\"synchronized-l-XX-是锁了代码块还是对象？怎么实现？\"><a href=\"#synchronized-l-XX-是锁了代码块还是对象？怎么实现？\" class=\"headerlink\" title=\"synchronized(l){XX}是锁了代码块还是对象？怎么实现？\"></a>synchronized(l){XX}是锁了代码块还是对象？怎么实现？</h3><p>锁了对象l，那么是对l做了什么来表示l被锁了呢？上锁就是改变了对象头。</p>\n<h3 id=\"线程调度-优先级\"><a href=\"#线程调度-优先级\" class=\"headerlink\" title=\"线程调度(优先级)\"></a>线程调度(优先级)</h3><p>与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线 程获取 CPU 资源的概率较大，优先级低的并非没机会执行。<br>线程的优先级用 1-10 之 间的整数表示，数值越大优先级越高，默认的优先级为 5。 在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。</p>\n<h3 id=\"什么是线程饥饿？\"><a href=\"#什么是线程饥饿？\" class=\"headerlink\" title=\"什么是线程饥饿？\"></a>什么是线程饥饿？</h3><p>线程饥饿是另一种活跃性问题，也可以使程序无法执行下去。<br>如果一个线程因为处理器时间全部被其他线程抢走而得不到处理器运行时间，这种状态被称之为<code>饥饿</code><br>一般是由高优先级线程吞噬所有的低优先级线程的处理器时间引起的。</p>\n<h3 id=\"什么是活锁？\"><a href=\"#什么是活锁？\" class=\"headerlink\" title=\"什么是活锁？\"></a>什么是活锁？</h3><p>这两个线程虽然都没有停止运行，但是却无法向下执行，这种情况就是所谓的活锁。<br>举个例子，两个人在走廊上碰见，大家都互相很有礼貌，互相礼让，A从左到右，B也从从左转向右，发现又挡住了地方，继续转换方向，但又碰到了，反反复复，一直没有机会运行下去。</p>\n<ul>\n<li>当所有线程在序中执行 Object.wait(0)，参数为 0 的 wait 方法。程序将发生 活锁直到在相应的对象上有线程调用 Object.notify() 或者 Object.notifyAll()。</li>\n</ul>\n<h3 id=\"Volatile关键字的作用？\"><a href=\"#Volatile关键字的作用？\" class=\"headerlink\" title=\"Volatile关键字的作用？\"></a>Volatile关键字的作用？</h3><p>让其他线程能够马上感知到某一线程多某个变量的修改</p>\n<ul>\n<li>保证可见性:对共享变量的修改，其他的线程马上能感知到</li>\n<li>保证有序性:禁止重排序（编译阶段、指令优化阶段）volatile之前的代码不能调整到他的后面，volatile之后的代码不能调整到他的前面</li>\n</ul>\n<h3 id=\"volatile-能使得一个非原子操作变成原子操作吗\"><a href=\"#volatile-能使得一个非原子操作变成原子操作吗\" class=\"headerlink\" title=\"volatile 能使得一个非原子操作变成原子操作吗?\"></a>volatile 能使得一个非原子操作变成原子操作吗?</h3><p>在 Java 中除了 long 和 double 之外的所有基本类型的读和赋值，都是原子性操作。<br>而 64 位的 long 和 double 变量由于会被 JVM 当作两个分离的 32 位来进行操 作，所以不具有原子性，会产生字撕裂问题。但是当你定义 long 或 double 变量时， 如果使用 volatile 关键字，就会获到<strong>(只有简单的赋值与返回操作的)</strong>原子性。<br>不能保证其他情况的原子性。</p>\n<h3 id=\"synchronized-和-volatile-的区别是什么？\"><a href=\"#synchronized-和-volatile-的区别是什么？\" class=\"headerlink\" title=\"synchronized 和 volatile 的区别是什么？\"></a>synchronized 和 volatile 的区别是什么？</h3><ul>\n<li>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</li>\n<li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li>\n<li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li>\n</ul>\n<h3 id=\"synchronized-和-Lock-有什么区别？\"><a href=\"#synchronized-和-Lock-有什么区别？\" class=\"headerlink\" title=\"synchronized 和 Lock 有什么区别？\"></a>synchronized 和 Lock 有什么区别？</h3><ul>\n<li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li>\n<li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li>\n<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>\n</ul>\n<h3 id=\"synchronized-和-ReentrantLock-区别是什么？\"><a href=\"#synchronized-和-ReentrantLock-区别是什么？\" class=\"headerlink\" title=\"synchronized 和 ReentrantLock 区别是什么？\"></a>synchronized 和 ReentrantLock 区别是什么？</h3><ul>\n<li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li>\n<li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li>\n<li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</li>\n</ul>\n<p>性能区别：由于线程执行是交替执行。<br>jdk1.6 synchronized 是重量级锁，要频繁调用操作系统函数，交替执行，从用户态转到内核态效率低。<br>jdk1.8 synchronized 增加了偏向锁和轻量级锁，也是在jdk层面解决，所以和 ReentrantLock 性能差不多。<br>ReentrantLock 将线程交替执行放到jdk层面解决，所以比1.6的synchronized效率高<br>如果线程是单线程或者线程是交替执行，那么ReentrantLock队列不会进行初始化，不会发送阻塞，都在jdk层面运行。而1.6 synchronized需要调用os操作更改锁对象状态，然后进入同步块。</p>\n<h3 id=\"synchronized-底层实现原理？\"><a href=\"#synchronized-底层实现原理？\" class=\"headerlink\" title=\"synchronized 底层实现原理？\"></a>synchronized 底层实现原理？</h3><p>synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p>\n<h3 id=\"什么是Monitor？\"><a href=\"#什么是Monitor？\" class=\"headerlink\" title=\"什么是Monitor？\"></a>什么是Monitor？</h3><p>Monitor其实是一种同步工具，也可以说是一种同步机制，它通常被描述为一个对象,也常被翻译为“监视器\\管程”,每个对象都会有一个 monitor</p>\n<ul>\n<li>某一线程占有一个对象的时候，先看该对象的 monitor 的计数器是不是0，如果是0表示这个对象还没有线程占有，这个时候线程占有这个对象，并且对这个对象的monitor+1；如果不为0，表示这个对象已经被其他线程占有，这个线程等待。当线程释放占有权的时候，monitor-1；</li>\n<li>同一线程可以对同一对象进行多次加锁，+1，+1，体现了重入性</li>\n</ul>\n<h3 id=\"多线程中-synchronized-锁升级的原理是什么？\"><a href=\"#多线程中-synchronized-锁升级的原理是什么？\" class=\"headerlink\" title=\"多线程中 synchronized 锁升级的原理是什么？\"></a>多线程中 synchronized 锁升级的原理是什么？</h3><p>在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>\n<h3 id=\"什么是偏向锁？\"><a href=\"#什么是偏向锁？\" class=\"headerlink\" title=\"什么是偏向锁？\"></a>什么是偏向锁？</h3><p>当线程请求到锁对象后，将锁对象的状态标志位改为01，即偏向模式。然后使用CAS操作将线程的threadid记录在锁对象的Mark Word中。以后该线程可以直接进入同步块，连CAS操作都不需要。但是，一旦有第二条线程需要竞争锁，那么偏向模式立即结束，进入轻量级锁的状态。</p>\n<h3 id=\"什么是轻量级锁？\"><a href=\"#什么是轻量级锁？\" class=\"headerlink\" title=\"什么是轻量级锁？\"></a>什么是轻量级锁？</h3><p>从偏向锁的状态发生竞争后，会锁膨胀变成轻量级锁。<br>轻量级锁是在内存有一个锁记录，当某个线程获取到锁后，会将锁记录保存到线程内存中，同时将原本的锁记录指向它的线程内存中的备份锁记录位置。其他线程判断锁记录已经指向了其他线程，因此会进入自旋状态。达到一定的次数或时间后，会膨胀变成重量级锁。</p>\n<h3 id=\"悲观锁和乐观锁的概念？\"><a href=\"#悲观锁和乐观锁的概念？\" class=\"headerlink\" title=\"悲观锁和乐观锁的概念？\"></a>悲观锁和乐观锁的概念？</h3><ul>\n<li>乐观锁：乐观地认为所有的并发操作都是线程安全的，不需要加锁来处理。但为了保证数据没有被修改，会通过CAS操作来进行判定和替换。</li>\n<li>悲观锁：悲观地认为所有的并发操作都是线程不安全的，都需要加锁来保证线程安全</li>\n</ul>\n<h3 id=\"ThreadLocal-是什么？有哪些使用场景？\"><a href=\"#ThreadLocal-是什么？有哪些使用场景？\" class=\"headerlink\" title=\"ThreadLocal 是什么？有哪些使用场景？\"></a>ThreadLocal 是什么？有哪些使用场景？</h3><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>\n<p>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p>\n<h3 id=\"ThreadLocal原理？\"><a href=\"#ThreadLocal原理？\" class=\"headerlink\" title=\"ThreadLocal原理？\"></a>ThreadLocal原理？</h3><ul>\n<li>每个Thread维护着一个ThreadLocalMap的引用</li>\n<li>ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储</li>\n<li>调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值是传递进来的对象</li>\n<li>调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象</li>\n<li>ThreadLocal本身并不存储值，它只是作为一个key来让线程从ThreadLocalMap获取value。</li>\n</ul>\n<h3 id=\"ThreadLocal缺点？\"><a href=\"#ThreadLocal缺点？\" class=\"headerlink\" title=\"ThreadLocal缺点？\"></a>ThreadLocal缺点？</h3><p>由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏。<br>ThreadLocal由于真正存储数据的ThreadLocalMap只单纯地采取了数组的形式来存储数据，因此出现hash冲突时会为hash值就增加一个固定的大小0x61c88647进行线性寻找位置，会导致大量的hash冲突，造成很高的资源消耗。</p>\n<h3 id=\"什么是CyclicBarrier？\"><a href=\"#什么是CyclicBarrier？\" class=\"headerlink\" title=\"什么是CyclicBarrier？\"></a>什么是CyclicBarrier？</h3><p>栅栏(Barrier)类似于闭锁，他能阻塞一组线程直到某个事件发生后再全部同时执行。CyclicBarrier 字面意思是回环栅栏，回环的意思是它能够被重复利用，当然前提是在所有线程释放了以后。</p>\n<h3 id=\"什么是CountDownLatch？\"><a href=\"#什么是CountDownLatch？\" class=\"headerlink\" title=\"什么是CountDownLatch？\"></a>什么是CountDownLatch？</h3><p>CountDownLatch也叫闭锁,使得一(多)个主线程必须等待其他线程完成操作后再执行.<br>CountDownLatch内部维护一个计数器(父类的int state),主线程先执行await方法，如果此时计数器大于0，则阻塞等待。当一个线程完成任务后，计数器值减1。直到计数器为0时，表示所有的线程已经完成任务，等待的主线程被唤醒继续执行。</p>\n<h3 id=\"CyclicBarrier-和-CountDownLatch-的区别？\"><a href=\"#CyclicBarrier-和-CountDownLatch-的区别？\" class=\"headerlink\" title=\"CyclicBarrier 和 CountDownLatch 的区别？\"></a>CyclicBarrier 和 CountDownLatch 的区别？</h3><ul>\n<li>CyclicBarrier 是所有线程必须同时到达栅栏位置，才能继续执行。它用于等待其他线程，并且能够重置使用。</li>\n<li>CountDownLatch 用于等待事件，是一次性对象，一旦进入终止状态，就不能被重置。</li>\n<li>CountDownLatch 通常阻塞的是主线程，开锁以后主线程才继续执行。</li>\n<li>CyclicBarrier 阻塞的是子线程，到达栅栏位置后，每个线程还可以继续做自己后续的事情。</li>\n</ul>\n<h2 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h2><h3 id=\"字节流和字符流？\"><a href=\"#字节流和字符流？\" class=\"headerlink\" title=\"字节流和字符流？\"></a>字节流和字符流？</h3><p><img src=\"/JAVA/Interview/io.png\" alt=\"\"><br>字节流：以字节（8bit）为单位，能处理所有类型的数据<br>字符流：以字符为单位，根据码表映射字符，一次可能读多个字节，只能处理字符类型的数据。<br>InputStreamReader:字节到字符的桥梁<br>OutputStreamWriter:字符到字节的桥梁</p>\n<h3 id=\"NIO是什么？\"><a href=\"#NIO是什么？\" class=\"headerlink\" title=\"NIO是什么？\"></a>NIO是什么？</h3><p>NIO（Non-blocking I/O，在Java领域，也称为New I/O），是一种同步非阻塞的I/O模型。<br>说到NIO就得先从传统BIO（Blocking I/O）说起。<br>BIO：传统的网络通讯模型，就是BIO，同步阻塞IO<br>它其实就是服务端创建一个ServerSocket， 然后就是客户端用一个Socket去连接服务端的那个ServerSocket， ServerSocket接收到了一个的连接请求就创建一个Socket和一个线程去跟那个Socket进行通讯。<br>服务端会在等待连接、等待读取或者等待写入时发生阻塞。<br>这种方式的缺点：每次一个客户端接入，都需要在服务端创建一个线程来服务这个客户端。<br>这样大量客户端来的时候，就会造成服务端的线程数量可能达到了几千甚至几万，这样就可能会造成服务端过载过高，最后崩溃死掉。<br>因此我们要在BIO的基础上进行改进。</p>\n<p>假设一个单线程的Socket服务，那么它会在accept()也就是等待客户端连接时阻塞，当有客户端A连接时，服务端会等待read()服务端发来的的数据。<br>首先，如果可以让read（）不阻塞，那么在客户端A连接之后，如果读到数据，就进行逻辑操作，如果没读到数据，我们就继续等待下一个客户端连接<br>那么此时有客户端B连接，这时A发送数据，就接受不到数据了，所以我们再增加一个list保存socket连接，<br>也就是在A连接之后，我们就用list保存这个socket连接，然后轮询这个list，看看有没有客户端发送数据，有就处理，然后继续等待下一个客户端连接。<br>此时 accept（）操作还是阻塞的，在没有客户端连接时，还是接收不到数据。<br>如果可以让accept（）不阻塞，在没有客户端连接的时候，也进行轮询这个list，看看有没有客户端发送数据。<br>这样就实现了一个简单的nio。<br>java的nio就是将上述操作中的轮询操作交给操作系统来进行了。</p>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ Spring ------------------------</span>\n</div>\n\n<h1 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h1><h2 id=\"基础-1\"><a href=\"#基础-1\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"为什么要使用-spring？\"><a href=\"#为什么要使用-spring？\" class=\"headerlink\" title=\"为什么要使用 spring？\"></a>为什么要使用 spring？</h3><ul>\n<li>spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。</li>\n<li>spring 提供了事务支持，使得事务操作变的更加方便。</li>\n<li>spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。</li>\n<li>更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis 等。</li>\n</ul>\n<h3 id=\"spring-有哪些主要模块？\"><a href=\"#spring-有哪些主要模块？\" class=\"headerlink\" title=\"spring 有哪些主要模块？\"></a>spring 有哪些主要模块？</h3><ul>\n<li>spring core：框架的最基础部分，提供 ioc 和依赖注入特性。</li>\n<li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</li>\n<li>spring dao：Data Access Object 提供了JDBC的抽象层。</li>\n<li>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</li>\n<li>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</li>\n<li>spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。</li>\n</ul>\n<h3 id=\"spring-mvc流程\"><a href=\"#spring-mvc流程\" class=\"headerlink\" title=\"spring mvc流程\"></a>spring mvc流程</h3><p><img src=\"/JAVA/Interview/springmvc.png\" alt=\"\"></p>\n<h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><h3 id=\"什么是-aop？\"><a href=\"#什么是-aop？\" class=\"headerlink\" title=\"什么是 aop？\"></a>什么是 aop？</h3><p>aop 是面向切面编程，可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。<br>aop的应用场景：日志记录、权限验证、效率检查、事务管理、exception</p>\n<h3 id=\"AOP术语？\"><a href=\"#AOP术语？\" class=\"headerlink\" title=\"AOP术语？\"></a>AOP术语？</h3><ul>\n<li>切面(Aspect)：切面是通知和切点的结合，通知和切点共同定义了切面的全部内容</li>\n<li>连接点(Join point)：目标对象中的方法。</li>\n<li>通知(Advice)：定义了切面是做什么以及何时使用。</li>\n<li>切点(Pointcut)：表示连接点的集合。（PointCut是JoinPoint的谓语，这是一个动作，主要是告诉通知连接点在哪里，切点表达式决定 JoinPoint 的数量）</li>\n<li>目标对象(Target object)：目标对象 原始对象</li>\n<li>aop代理(AOP proxy)：代理对象  包含了原始对象的代码和增加后的代码的那个对象</li>\n<li>织入(Weaving)：把代理逻辑加入到目标对象上的过程</li>\n</ul>\n<h3 id=\"AOP实现原理？\"><a href=\"#AOP实现原理？\" class=\"headerlink\" title=\"AOP实现原理？\"></a>AOP实现原理？</h3><p>通过动态代理实现。动态代理又分为jdk动态代理和cglib动态代理。</p>\n<ul>\n<li>jdk动态代理：主要通过Proxy.newProxyInstance()和InvocationHandler这两个类和方法实现<ul>\n<li>实现过程<ul>\n<li>实现InvocationHandler接口，重写invoke()方法</li>\n<li>调用Proxy.newProxyInsatnce(classloader,interfaces,handler)方法生成代理类<ul>\n<li>生成的代理类为$Proxy0 extends Proxy implements Person</li>\n<li>因为已经继承了Proxy,所以java动态代理只能对接口进行代理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>总结： 代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h2><h3 id=\"什么是-ioc？\"><a href=\"#什么是-ioc？\" class=\"headerlink\" title=\"什么是 ioc？\"></a>什么是 ioc？</h3><p>控制反转，将你设计好的对象交给容器控制，可以用来减低计算机代码之间的耦合度。</p>\n<h3 id=\"什么是DI？\"><a href=\"#什么是DI？\" class=\"headerlink\" title=\"什么是DI？\"></a>什么是DI？</h3><p>DI是依赖注入，是实现IOC的一种方式。</p>\n<h3 id=\"spring-常用的注入方式有哪些？\"><a href=\"#spring-常用的注入方式有哪些？\" class=\"headerlink\" title=\"spring 常用的注入方式有哪些？\"></a>spring 常用的注入方式有哪些？</h3><ul>\n<li>setter 属性注入</li>\n<li>构造方法注入</li>\n<li>注解方式注入</li>\n</ul>\n<h3 id=\"spring-中的-bean-是线程安全的吗？\"><a href=\"#spring-中的-bean-是线程安全的吗？\" class=\"headerlink\" title=\"spring 中的 bean 是线程安全的吗？\"></a>spring 中的 bean 是线程安全的吗？</h3><p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。<br>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p>\n<ul>\n<li>有状态就是有数据存储功能。</li>\n<li>无状态就是不会保存数据。</li>\n</ul>\n<h3 id=\"spring-自动装配-bean-有哪些方式？\"><a href=\"#spring-自动装配-bean-有哪些方式？\" class=\"headerlink\" title=\"spring 自动装配 bean 有哪些方式？\"></a>spring 自动装配 bean 有哪些方式？</h3><ul>\n<li>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。</li>\n<li>byName：它根据 bean 的名称注入对象依赖项。</li>\n<li>byType：它根据类型注入对象依赖项。</li>\n<li>constructor：通过构造函数来注入依赖项，需要设置大量的参数。</li>\n</ul>\n<h3 id=\"Spring-beanFactory-和-factoryBean-的区别？\"><a href=\"#Spring-beanFactory-和-factoryBean-的区别？\" class=\"headerlink\" title=\"Spring beanFactory 和 factoryBean 的区别？\"></a>Spring beanFactory 和 factoryBean 的区别？</h3><p><strong>beanFactory</strong> 是Spring容器的顶层接口，用于管理Bean的一个工厂。 在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。<br><strong>FactoryBean</strong> 这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean，它能在需要的时候生产一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。</p>\n<p>通常情况下，bean 无须自己实现工厂模式，Spring 容器担任了工厂的 角色；但少数情况下，容器中的 bean 本身就是工厂，作用是产生其他 bean 实例。由工厂 bean 产生的其他 bean 实例，不再由 Spring 容器产生，因此与普通 bean 的配置不同，不再需要提供 class 元素。</p>\n<h3 id=\"BeanFactory和ApplicationContext是什么关系？\"><a href=\"#BeanFactory和ApplicationContext是什么关系？\" class=\"headerlink\" title=\"BeanFactory和ApplicationContext是什么关系？\"></a>BeanFactory和ApplicationContext是什么关系？</h3><p><img src=\"/JAVA/Interview/applicationContext.jpg\" alt=\"\"><br>最主要的区别是BeanFactory是延迟加载，ApplicationContext是即时加载。</p>\n<h3 id=\"spring-支持几种-bean-的作用域？\"><a href=\"#spring-支持几种-bean-的作用域？\" class=\"headerlink\" title=\"spring 支持几种 bean 的作用域？\"></a>spring 支持几种 bean 的作用域？</h3><ul>\n<li>singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；</li>\n<li>prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；</li>\n<li>Web 环境下的作用域：</li>\n<li>request：每次 http 请求都会创建一个 bean；</li>\n<li>session：同一个 http session 共享一个 bean 实例；</li>\n<li>global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。</li>\n</ul>\n<h3 id=\"spring-bean-容器的生命周期是什么样的？\"><a href=\"#spring-bean-容器的生命周期是什么样的？\" class=\"headerlink\" title=\"spring bean 容器的生命周期是什么样的？\"></a>spring bean 容器的生命周期是什么样的？</h3><ol>\n<li>Spring 容器根据配置中的 bean 定义，通过构造方法反射来实例化 bean。</li>\n<li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li>\n<li>如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。</li>\n<li>如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。</li>\n<li>如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。</li>\n<li>如果为 bean 指定了 init 方法（ <bean> 的 init-method 属性），那么将调用它。</bean></li>\n<li>最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。</li>\n<li>如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。</li>\n<li>如果为 bean 指定了 destroy 方法（ <bean> 的 destroy-method 属性），那么将调用它。</bean></li>\n</ol>\n<p><img src=\"/JAVA/Interview/bean.png\" alt=\"\"><br>1：实例化一个ApplicationContext的对象；<br>2：调用bean工厂后置处理器完成扫描；<br>3：循环解析扫描出来的类信息；<br>4：实例化一个BeanDefinition对象来存储解析出来的信息；<br>5：把实例化好的beanDefinition对象put到beanDefinitionMap当中缓存起来，以便后面实例化bean；<br>6：再次调用bean工厂后置处理器；<br>7：当然spring还会干很多事情，比如国际化，比如注册BeanPostProcessor等等，如果我们只关心如何实例化一个bean的话那么这一步就是spring调用finishBeanFactoryInitialization方法来实例化单例的bean，实例化之前spring要做验证，需要遍历所有扫描出来的类，依次判断这个bean是否Lazy，是否prototype，是否abstract等等；<br>8：如果验证完成spring在实例化一个bean之前需要推断构造方法，因为spring实例化对象是通过构造方法反射，故而需要知道用哪个构造方法；<br>9：推断完构造方法之后spring调用构造方法反射实例化一个对象；注意我这里说的是对象、对象、对象；这个时候对象已经实例化出来了，但是并不是一个完整的bean，最简单的体现是这个时候实例化出来的对象属性是没有注入，所以不是一个完整的bean；<br>10：spring处理合并后的beanDefinition(合并？是spring当中非常重要的一块内容)；<br>11：判断是否支持循环依赖，如果支持则提前把一个工厂存入singletonFactories——map；<br>12：判断是否需要完成属性注入<br>13：如果需要完成属性注入，则开始注入属性<br>14：判断bean的类型回调Aware接口<br>15：调用生命周期回调方法<br>16：如果需要代理则完成代理<br>17：put到单例池——bean完成——存在spring容器当中</p>\n<h3 id=\"Spring中的aware接口什么作用？\"><a href=\"#Spring中的aware接口什么作用？\" class=\"headerlink\" title=\"Spring中的aware接口什么作用？\"></a>Spring中的aware接口什么作用？</h3><p>BeanNameAware接口是为了让自身Bean能够感知到，获取到自身在Spring容器中的id属性，也就是beanName；<br>其他的Aware接口也是为了能够感知到自身的一些属性。<br>比如实现了ApplicationContextAware接口的类，能够获取到ApplicationContext。<br>实现了BeanFactoryAware接口的类，能够获取到BeanFactory对象。</p>\n<h3 id=\"Spring-在什么时候完成的依赖注入？\"><a href=\"#Spring-在什么时候完成的依赖注入？\" class=\"headerlink\" title=\"Spring 在什么时候完成的依赖注入？\"></a>Spring 在什么时候完成的依赖注入？</h3><p>在初始化的时候。也就是在new AnnotationConfigApplicationContext的时候</p>\n<h3 id=\"Spring中的循环依赖是怎么解决的？\"><a href=\"#Spring中的循环依赖是怎么解决的？\" class=\"headerlink\" title=\"Spring中的循环依赖是怎么解决的？\"></a>Spring中的循环依赖是怎么解决的？</h3><p>spring 单例情况下是支持循环依赖的。<br>假设A对象和B对象循环依赖，那么在初始化时会经历如下步骤：<br>创建A -&gt; 实例化A -&gt; 填充A的属性 -&gt; getBean(B) -&gt; 创建B -&gt; 实例化B -&gt; 填充B的属性-&gt; getBean(A)<br>-&gt; 若二级缓存中存在，将从二级缓存工厂中生产出的A放入三级缓存-&gt;从三级缓存中获取A-&gt;。。。</p>\n<h3 id=\"Resource-和-Autowired-的区别？\"><a href=\"#Resource-和-Autowired-的区别？\" class=\"headerlink\" title=\"@Resource 和 @Autowired 的区别？\"></a>@Resource 和 @Autowired 的区别？</h3><ul>\n<li>默认装配类型不一样：<ul>\n<li>@Autowired默认按type装配：默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。</li>\n<li>@Resource 默认按照名称进行装配：当找不到与名称匹配的bean才会按照类型装配</li>\n</ul>\n</li>\n<li>bean 在初始化时 调用的后置处理器不一样，<ul>\n<li>@Autowired 调用的是 AutowiredAnnotationBeanPostProcessor()</li>\n<li>@Resource 调用的是 CommonAnnotationBeanPostProcessor()</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Spring-三级缓存？\"><a href=\"#Spring-三级缓存？\" class=\"headerlink\" title=\"Spring 三级缓存？\"></a>Spring 三级缓存？</h3><p>每一级缓存都是一个map。<br>一级：singletonObjects 单例池，主要存放单例 bean<br>二级：singletonFactories 主要存放ObjectFactory类型工厂对象<br>三级：earlySingletonObjects 从工厂中获取的spring 对象，也就是半成品bean<br>三级缓存存在的意义是防止工厂重复执行对对象的操作，提高性能。</p>\n<h3 id=\"Qualifier-注解有什么用？\"><a href=\"#Qualifier-注解有什么用？\" class=\"headerlink\" title=\"@Qualifier 注解有什么用？\"></a>@Qualifier 注解有什么用？</h3><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p>\n<h3 id=\"什么是事务传播行为？\"><a href=\"#什么是事务传播行为？\" class=\"headerlink\" title=\"什么是事务传播行为？\"></a>什么是事务传播行为？</h3><p>事务传播行为（propagation behavior）指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何运行。<br>例如：methodA方法调用methodB方法时，methodB是继续在调用者methodA的事务中运行呢，还是为自己开启一个新事务运行，这就是由methodB的事务传播行为决定的。</p>\n<ul>\n<li>PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，这是最常见的选择，也是<strong>Spring默认的事务传播行为。</strong><ul>\n<li>methodA 调用 methodB时，设置B为当前传播行为，A未开启事物，B在自己的事物中运行，A开启事物，则B加入A的事物，若A发生异常，则B会进行回滚操作。</li>\n</ul>\n</li>\n<li>PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。<ul>\n<li>A开启事物，B也创建自己的事物，若A发生异常，B不影响。</li>\n</ul>\n</li>\n<li>PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。<ul>\n<li>A未开启事物，则B以非事物方式执行，若A发生异常，B不影响；若A开启事物，则B加入A的事物，若A发生异常，则B会进行回滚操作。</li>\n</ul>\n</li>\n<li>PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。<ul>\n<li>A未开启事物，则直接抛出异常；若A开启事物，则B加入A的事物，若A发生异常，则B会进行回滚操作。</li>\n</ul>\n</li>\n<li>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<ul>\n<li>无论A开不开启事物，B都以非事物方式执行   </li>\n</ul>\n</li>\n<li>PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。<ul>\n<li>A未开启事物，则B以非事物方式执行；A开启事物，则抛出异常；</li>\n</ul>\n</li>\n<li>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。<ul>\n<li>A未开启事物，B在自己的事物中运行；若A开启事物，则在嵌套事物中执行，若A抛出异常，则B会回滚。</li>\n</ul>\n</li>\n</ul>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>---------------- 计算机网络 ----------------</span>\n</div>\n\n<h1 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h1><h2 id=\"基础-2\"><a href=\"#基础-2\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"OSI-的七层模型都有哪些？\"><a href=\"#OSI-的七层模型都有哪些？\" class=\"headerlink\" title=\"OSI 的七层模型都有哪些？\"></a>OSI 的七层模型都有哪些？</h3><p><img src=\"/JAVA/Interview/osi.jpeg\" alt=\"\"></p>\n<ul>\n<li>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</li>\n<li>数据链路层：负责建立和管理节点间的链路。</li>\n<li>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。</li>\n<li>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。</li>\n<li>会话层：向两个实体的表示层提供建立和使用连接的方法。</li>\n<li>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。</li>\n<li>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</li>\n</ul>\n<h2 id=\"http协议\"><a href=\"#http协议\" class=\"headerlink\" title=\"http协议\"></a>http协议</h2><p>Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协</p>\n<h3 id=\"HTTP的特性\"><a href=\"#HTTP的特性\" class=\"headerlink\" title=\"HTTP的特性\"></a>HTTP的特性</h3><ul>\n<li>HTTP构建于TCP/IP协议之上，默认端口号是80</li>\n<li>HTTP是无连接无状态的<ul>\n<li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>\n<li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><div class=\"note info\"><p>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求</p></div>\n\n<p>200 OK //客户端请求成功<br>301 Moved Permanently //永久重定向。<br>302 Found //暂时重定向。<br>400 Bad Request //客户端请求有语法错误，不能被服务器所理解<br>401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<br>403 Forbidden //服务器收到请求，但是拒绝提供服务<br>404 Not Found //请求资源不存在，eg：输入了错误的URL<br>500 Internal Server Error //服务器发生不可预期的错误<br>503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>\n<h3 id=\"HTTP-请求-响应的步骤？\"><a href=\"#HTTP-请求-响应的步骤？\" class=\"headerlink\" title=\"HTTP 请求/响应的步骤？\"></a>HTTP 请求/响应的步骤？</h3><ul>\n<li><strong>1、客户端连接到Web服务器</strong><br>  一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href=\"http://www.oakcms.cn。\" target=\"_blank\" rel=\"noopener\">http://www.oakcms.cn。</a></li>\n<li><strong>2、发送HTTP请求</strong><br>  通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</li>\n<li><strong>3、服务器接受请求并返回HTTP响应</strong><br>  Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</li>\n<li><strong>4、释放连接TCP连接</strong><br>  若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</li>\n<li><strong>5、客户端浏览器解析HTML内容</strong><br>  客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</li>\n</ul>\n<h3 id=\"浏览器请求过程？\"><a href=\"#浏览器请求过程？\" class=\"headerlink\" title=\"浏览器请求过程？\"></a>浏览器请求过程？</h3><ul>\n<li>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</li>\n<li>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</li>\n<li>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP三次握手的第三个报文的数据发送给服务器;</li>\n<li>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</li>\n<li>5、释放 TCP连接;</li>\n<li>6、浏览器将该 html 文本并显示内容;</li>\n</ul>\n<h3 id=\"get-和-post-请求有哪些区别？\"><a href=\"#get-和-post-请求有哪些区别？\" class=\"headerlink\" title=\"get 和 post 请求有哪些区别？\"></a>get 和 post 请求有哪些区别？</h3><p>从原理性看：</p>\n<ul>\n<li>根据HTTP规范，GET用于信息获取，而且应该是安全和幂等的</li>\n<li>根据HTTP规范，POST请求表示可能修改服务器上资源的请求</li>\n</ul>\n<p>从表面上看：</p>\n<ul>\n<li>GET请求的数据会附在URL后面，POST的数据放在HTTP包体，POST安全性比GET安全性高</li>\n<li>GET请求会被浏览器主动缓存，并且传递参数有大小限制，POST没有。</li>\n</ul>\n<h2 id=\"TCP／UDP协议\"><a href=\"#TCP／UDP协议\" class=\"headerlink\" title=\"TCP／UDP协议\"></a>TCP／UDP协议</h2><h3 id=\"tcp-和-udp的区别？\"><a href=\"#tcp-和-udp的区别？\" class=\"headerlink\" title=\"tcp 和 udp的区别？\"></a>tcp 和 udp的区别？</h3><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。<br>区别如下：</p>\n<ul>\n<li>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；</li>\n<li>tcp 提供可靠的服务（数据传输），udp 无法保证；</li>\n<li>tcp 面向字节流，udp 面向报文；</li>\n<li>tcp 数据传输慢，udp 数据传输快；</li>\n</ul>\n<h3 id=\"tcp协议是100-可靠的么？\"><a href=\"#tcp协议是100-可靠的么？\" class=\"headerlink\" title=\"tcp协议是100%可靠的么？\"></a>tcp协议是100%可靠的么？</h3><p>TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。</p>\n<h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。<br><img src=\"/JAVA/Interview/Handshake.png\" alt=\"\"></p>\n<ul>\n<li>第一次握手(SYN=1, seq=x):<br>客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。<br>发送完毕后，客户端进入 <code>SYN_SEND</code> 状态。</li>\n<li>第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):<br>服务器发回确认包(<code>ACK</code>)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。<br>发送完毕后，服务器端进入 <code>SYN_RCVD</code> 状态。</li>\n<li>第三次握手(ACK=1，seq=x+1,ACKnum=y+1)<br>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1<br>发送完毕后，客户端进入 <code>ESTABLISHED</code> 状态，当服务器端接收到这个包时，也进入 <code>ESTABLISHED</code> 状态，TCP 握手结束。</li>\n</ul>\n<h4 id=\"为什么需要三次握手，两次不行吗？\"><a href=\"#为什么需要三次握手，两次不行吗？\" class=\"headerlink\" title=\"为什么需要三次握手，两次不行吗？\"></a>为什么需要三次握手，两次不行吗？</h4><p>如果是用两次握手，则会出现下面这种情况：<br>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。<br>客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端<br>此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接。<br><strong>因此</strong>：不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，<code>浪费资源</code>。</p>\n<h4 id=\"什么是半连接队列？\"><a href=\"#什么是半连接队列？\" class=\"headerlink\" title=\"什么是半连接队列？\"></a>什么是半连接队列？</h4><p>服务器第一次收到客户端的 SYN 之后，就会处于 <code>SYN_RCVD</code> 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<code>半连接队列</code>。</p>\n<p>当然还有一个<code>全连接队列</code>，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>\n<h4 id=\"ISN-Initial-Sequence-Number-是固定的吗？\"><a href=\"#ISN-Initial-Sequence-Number-是固定的吗？\" class=\"headerlink\" title=\"ISN(Initial Sequence Number)是固定的吗？\"></a>ISN(Initial Sequence Number)是固定的吗？</h4><p>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，<code>每4ms加1</code> 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。</p>\n<p>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p>\n<h4 id=\"三次握手过程中可以携带数据吗？\"><a href=\"#三次握手过程中可以携带数据吗？\" class=\"headerlink\" title=\"三次握手过程中可以携带数据吗？\"></a>三次握手过程中可以携带数据吗？</h4><p>其实第三次握手的时候，是可以携带数据的。但是，<strong>第一次、第二次握手不可以携带数据</strong></p>\n<p>第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</p>\n<h4 id=\"SYN攻击是什么？\"><a href=\"#SYN攻击是什么？\" class=\"headerlink\" title=\"SYN攻击是什么？\"></a>SYN攻击是什么？</h4><p>在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.</p>\n<p>SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p>\n<h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。<br><img src=\"/JAVA/Interview/wave.png\" alt=\"\"></p>\n<ul>\n<li>第一次挥手(FIN=1，seq=x)<br>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。<br>发送完毕后，客户端进入 <code>FIN_WAIT_1</code> 状态。</li>\n<li>第二次挥手(ACK=1，ACKnum=x+1)<br>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。<br>发送完毕后，服务器端进入 <code>CLOSE_WAIT</code> 状态，客户端接收到这个确认包之后，进入 <code>FIN_WAIT_2</code> 状态，等待服务器端关闭连接。</li>\n<li>第三次挥手(FIN=1，seq=y)<br>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。<br>发送完毕后，服务器端进入 <code>LAST_ACK</code> 状态，等待来自客户端的最后一个ACK</li>\n<li>第四次挥手(ACK=1，ACKnum=y+1)<br>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <code>TIME_WAIT</code> 状态，等待可能出现的要求重传的 ACK 包。<br>服务器端接收到这个确认包之后，关闭连接，进入 <code>CLOSED</code> 状态。<br>客户端等待了某个固定时间（<code>两个最大段生命周期</code>，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 <code>CLOSED</code> 状态。</li>\n</ul>\n<h4 id=\"挥手为什么需要四次？\"><a href=\"#挥手为什么需要四次？\" class=\"headerlink\" title=\"挥手为什么需要四次？\"></a>挥手为什么需要四次？</h4><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。<br>但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，”你发的FIN报文我收到了”。<br>只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p>\n<h4 id=\"2MSL等待状态\"><a href=\"#2MSL等待状态\" class=\"headerlink\" title=\"2MSL等待状态\"></a>2MSL等待状态</h4><p>TIME_WAIT状态也成为2MSL等待状态。它是任何报文段被丢弃前在网络内的最长时间。</p>\n<ul>\n<li>保证客户端发送的最后一个ACK报文段能够到达服务端。<br>这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态。</li>\n<li>防止“已失效的连接请求报文段”出现在本连接中。<br> 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li>\n</ul>\n<h3 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h3><p>TCP协议里窗口机制有2种：一种是固定的窗口大小；一种是滑动的窗口。<br>这个窗口大小就是我们一次传输几个数据。<br>对所有数据帧按顺序赋予编号，发送方在发送过程中始终保持着一个发送窗口，只有落在发送窗口内的帧才允许被发送；<br>同时接收方也维持着一个接收窗口，只有落在接收窗口内的帧才允许接收。<br>这样通过调整发送方窗口和接收方窗口的大小可以实现<code>流量控制</code>。<br><strong>每个TCP/IP主机支持全双工数据传输，因此TCP有两个滑动窗口：一个用于接收数据，另一个用于发送数据。</strong><br><img src=\"/JAVA/Interview/slidingWindow%20%20.png\" alt=\"\"></p>\n<ul>\n<li>首先是<strong>第一次发送数据这个时候的窗口大小是根据链路带宽的大小来决定的</strong>。我们假设这个时候窗口的大小是3。</li>\n<li>这个时候接受方收到数据以后会对数据进行确认告诉发送方我下次希望手到的是数据是多少。这里我们看到接收方发送的ACK=3(这是发送方发送序列2的回答确认，下一次接收方期望接收到的是3序列信号)。</li>\n<li>这个时候发送方收到这个数据以后就知道我第一次发送的3个数据对方只收到了2个。就知道第3个数据对方没有收到。下次在发送的时候就从第3个数据开始发。这个时候窗口大小就变成了2 。 </li>\n<li>看到接收方发送的ACK是5就表示他下一次希望收到的数据是5，发送方就知道我刚才发送的2个数据对方收了这个时候开始发送第5个数据。</li>\n</ul>\n<p>只有在接收窗口向前滑动时（与此同时也发送了确认），发送窗口才有可能向前滑动。 当发送窗口和接收窗口的大小都等于1时，就是停止等待协议。</p>\n<h3 id=\"如果已经建立了连接，但是客户端突然出现故障了怎么办？\"><a href=\"#如果已经建立了连接，但是客户端突然出现故障了怎么办？\" class=\"headerlink\" title=\"如果已经建立了连接，但是客户端突然出现故障了怎么办？\"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>\n<h3 id=\"拥塞控制和流量控制的区别？\"><a href=\"#拥塞控制和流量控制的区别？\" class=\"headerlink\" title=\"拥塞控制和流量控制的区别？\"></a>拥塞控制和流量控制的区别？</h3><ul>\n<li>拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。</li>\n<li>流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。</li>\n</ul>\n<h3 id=\"TCP确认延迟机制？\"><a href=\"#TCP确认延迟机制？\" class=\"headerlink\" title=\"TCP确认延迟机制？\"></a>TCP确认延迟机制？</h3><p>接收方在收到数据后，并不会立即回复ACK,而是延迟一定时间。一般ACK延迟发送的时间为200ms，但这个200ms并非收到数据后需要延迟的时间。系统有一个固定的定时器每隔200ms会来检查是否需要发送ACK包。</p>\n<ol>\n<li>ACK是可以合并的，也就是指如果连续收到两个TCP包，并不一定需要ACK两次，只要回复最终的ACK就可以了，可以降低网络流量。</li>\n<li>如果接收方有数据要发送，那么就会在发送数据的TCP数据包里，带上ACK信息。这样做，可以避免大量的ACK以一个单独的TCP包发送，减少了网络流量。</li>\n</ol>\n<h3 id=\"TCP拥塞控制机制？\"><a href=\"#TCP拥塞控制机制？\" class=\"headerlink\" title=\"TCP拥塞控制机制？\"></a>TCP拥塞控制机制？</h3><ul>\n<li><p>慢启动：<br>  TCP在连接过程的三次握手完成后，开始传数据，并不是一开始向网络通道中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞<br>  而是根据初始的cwnd大小逐步增加发送的数据量，cwnd初始化为1个最大报文段(MSS)大小（这个值可配置不一定是1个MSS）；每当有一个报文段被确认，cwnd大小指数增长。<br>  开始 —&gt; cwnd = 1<br>  1个RTT(往返延迟)后 —&gt; cwnd = 2<em>1 = 2<br>  2个RTT后 —&gt; cwnd = 2</em>2= 4<br>  3个RTT后 —&gt; cwnd = 4*2 = 8</p>\n</li>\n<li><p>拥塞避免<br>  cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，一旦cwnd&gt;=ssthresh（大多数TCP的实现，通常大小都是65536），慢启动过程结束，拥塞避免阶段开始；<br>  此时窗口大小不再呈指数上升，而是以加法增加，避免增长过快导致网络拥塞。<br>  拥塞发生：当发生丢包进行数据包重传时，表示网络已经拥塞。分两种情况进行处理：</p>\n<pre><code>* 等到RTO（重传超时时间）超时，重传数据包\n* sshthresh = cwnd /2，cwnd 重置为 1</code></pre></li>\n<li><p>快重传<br>  对于接收方来说，如果接收方收到一个失序的报文段，就立即回送一个 ACK 给发送方<br>  当发送方收到了3个重复的ACK时，则发送方快速重传丢失的包（所谓失序的报文是指，用户没有按照顺序收到TCP报文段，比如接收方收到了报文 M1, M2, M4，那么M4就称为失序报文，也就是M3被丢失），而不必等待M3的重传计时器到期</p>\n</li>\n<li><p>快恢复<br>  一旦出现超时重传，或者收到第三个重复的 ack 时（快重传），TCP 会把慢启动门限 ssthresh 的值设置为 cwnd 值的一半，同时 cwnd = ssthresh</p>\n</li>\n</ul>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>---------------- 设计模式 ----------------</span>\n</div>\n\n<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>---------------- MyBatis ----------------</span>\n</div>\n\n<h1 id=\"MyBatis\"><a href=\"#MyBatis\" class=\"headerlink\" title=\"MyBatis\"></a>MyBatis</h1><h2 id=\"什么是-MyBatis\"><a href=\"#什么是-MyBatis\" class=\"headerlink\" title=\"什么是 MyBatis?\"></a>什么是 MyBatis?</h2><p>MyBatis 是一个可以自定义 SQL、存储过程和高级映射的持久层框架。</p>\n<h2 id=\"MyBatis-中-和-的区别是什么？\"><a href=\"#MyBatis-中-和-的区别是什么？\" class=\"headerlink\" title=\"MyBatis 中 #{}和 ${}的区别是什么？\"></a>MyBatis 中 #{}和 ${}的区别是什么？</h2><p>#{}是预编译处理，${}是字符替换。 </p>\n<p>在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。<br>Mybatis 在处理${}时，就是把${}替换成变量的值。</p>\n<h2 id=\"MyBatis-有几种分页方式？\"><a href=\"#MyBatis-有几种分页方式？\" class=\"headerlink\" title=\"MyBatis 有几种分页方式？\"></a>MyBatis 有几种分页方式？</h2><p><strong>逻辑分页</strong>： 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。</p>\n<p><strong>物理分页</strong>： 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。</p>\n<h2 id=\"MyBatis-逻辑分页和物理分页的区别是什么？\"><a href=\"#MyBatis-逻辑分页和物理分页的区别是什么？\" class=\"headerlink\" title=\"MyBatis 逻辑分页和物理分页的区别是什么？\"></a>MyBatis 逻辑分页和物理分页的区别是什么？</h2><ul>\n<li>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。</li>\n<li>物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</li>\n</ul>\n<h2 id=\"RowBounds-是一次性查询全部结果吗？为什么？\"><a href=\"#RowBounds-是一次性查询全部结果吗？为什么？\" class=\"headerlink\" title=\"RowBounds 是一次性查询全部结果吗？为什么？\"></a>RowBounds 是一次性查询全部结果吗？为什么？</h2><p>RowBounds 表面是在“所有”数据中检索数据，其实<strong>并非是一次性查询</strong>出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。</p>\n<h2 id=\"MyBatis-是否支持延迟加载？延迟加载的原理是什么？\"><a href=\"#MyBatis-是否支持延迟加载？延迟加载的原理是什么？\" class=\"headerlink\" title=\"MyBatis 是否支持延迟加载？延迟加载的原理是什么？\"></a>MyBatis 是否支持延迟加载？延迟加载的原理是什么？</h2><p>MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。<br>延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。<br>比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。</p>\n<h2 id=\"说一下-MyBatis-的一级缓存和二级缓存？\"><a href=\"#说一下-MyBatis-的一级缓存和二级缓存？\" class=\"headerlink\" title=\"说一下 MyBatis 的一级缓存和二级缓存？\"></a><code>说一下 MyBatis 的一级缓存和二级缓存？</code></h2><p><img src=\"/JAVA/Interview/mybatisCache.jpg\" alt=\"\"></p>\n<ul>\n<li>一级缓存：是SqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。</li>\n<li>二级缓存：是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。。<br>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。<br>缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</li>\n</ul>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>---------------- Kafka ----------------</span>\n</div>\n\n<h1 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h1><h2 id=\"kafka-流程？\"><a href=\"#kafka-流程？\" class=\"headerlink\" title=\"kafka 流程？\"></a>kafka 流程？</h2><p><img src=\"/JAVA/Interview/kafka.png\" alt=\"\"></p>\n<ul>\n<li>生产者：可以声明主题Topic、分区Partition、键 Key以及值 Value，主题和值是必须要声明的，分区和键可以不用指定。拥有相同key的消息将会被写到同一分区，若没有指定key则由分区器分配。</li>\n<li>topic：Topic中数据是顺序不可变序列，采用log追加方式写入，Topic的数据可存储在多个partition中。</li>\n<li>partition：每个 Partition 中的消息都是有序的，生产的消息被不断追加到 Partition log 上，其中的每一个消息都被赋予了一个唯一的 offset 值。 因此数据不会因消费而丢失，所以只要consumer指定offset，一个消息可被不同的consumer多次消费。kafka中只能保证partition中记录是有序的，而不保证topic中不同partition的顺序。</li>\n<li>Replication：同一个 partition 可能会有多个 replication，需要在这些 replication 之间选出一个 leader，producer 和 consumer 只与这个 leader 交互，其它 replication 作为 follower 从 leader 中复制数据。</li>\n<li>消费者：订阅topic是以一个消费组来订阅的，一个消费组里面可以有多个消费者。<strong>一个partition，只能被消费组里的一个消费者消费</strong>，但是可以同时被多个消费组消费。</li>\n</ul>\n<h2 id=\"kafka-可以脱离-zookeeper-单独使用吗？为什么？\"><a href=\"#kafka-可以脱离-zookeeper-单独使用吗？为什么？\" class=\"headerlink\" title=\"kafka 可以脱离 zookeeper 单独使用吗？为什么？\"></a>kafka 可以脱离 zookeeper 单独使用吗？为什么？</h2><p>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</p>\n<h2 id=\"kafka-有几种数据保留的策略？\"><a href=\"#kafka-有几种数据保留的策略？\" class=\"headerlink\" title=\"kafka 有几种数据保留的策略？\"></a>kafka 有几种数据保留的策略？</h2><p>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</p>\n<h2 id=\"kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？\"><a href=\"#kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？\" class=\"headerlink\" title=\"kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？\"></a>kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</h2><p>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p>\n<h2 id=\"什么情况会导致-kafka-运行变慢？\"><a href=\"#什么情况会导致-kafka-运行变慢？\" class=\"headerlink\" title=\"什么情况会导致 kafka 运行变慢？\"></a>什么情况会导致 kafka 运行变慢？</h2><ul>\n<li>cpu 性能瓶颈</li>\n<li>磁盘读写瓶颈</li>\n<li>网络瓶颈</li>\n</ul>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>---------------- MySQL ----------------</span>\n</div>\n\n<h1 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h1><h2 id=\"基础-3\"><a href=\"#基础-3\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"数据库的三范式是什么？\"><a href=\"#数据库的三范式是什么？\" class=\"headerlink\" title=\"数据库的三范式是什么？\"></a>数据库的三范式是什么？</h3><ul>\n<li>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</li>\n<li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li>\n<li>第三范式：任何非主属性不依赖于其它非主属性。<br><a href=\"https://zhuanlan.zhihu.com/p/92991575\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/92991575</a></li>\n</ul>\n<h3 id=\"char-和-varchar-的区别是什么？\"><a href=\"#char-和-varchar-的区别是什么？\" class=\"headerlink\" title=\"char 和 varchar 的区别是什么？\"></a>char 和 varchar 的区别是什么？</h3><ul>\n<li>char(n) ：<strong>固定长度类型</strong>，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</li>\n<li>varchar(n) ：<strong>可变长度</strong>，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。<br>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。<br>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</li>\n</ul>\n<h3 id=\"float-和-double-的区别是什么？\"><a href=\"#float-和-double-的区别是什么？\" class=\"headerlink\" title=\"float 和 double 的区别是什么？\"></a>float 和 double 的区别是什么？</h3><ul>\n<li>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。</li>\n<li>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</li>\n</ul>\n<h3 id=\"MySQL-常用的引擎？\"><a href=\"#MySQL-常用的引擎？\" class=\"headerlink\" title=\"MySQL 常用的引擎？\"></a>MySQL 常用的引擎？</h3><ul>\n<li>InnoDB 引擎：mysql 5.1 后默认的数据库引擎，提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。<pre><code>MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。\n但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。\n由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</code></pre></li>\n<li>MyIASM 引擎：不提供事务的支持，也不支持行级锁和外键。。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。<pre><code>MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。\n所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</code></pre></li>\n</ul>\n<h3 id=\"如何做-MySQL-的性能优化？\"><a href=\"#如何做-MySQL-的性能优化？\" class=\"headerlink\" title=\"如何做 MySQL 的性能优化？\"></a>如何做 MySQL 的性能优化？</h3><ul>\n<li>为搜索字段创建索引。</li>\n<li>避免使用 select *，列出需要查询的字段。</li>\n<li>垂直分割分表。</li>\n<li>选择正确的存储引擎。</li>\n</ul>\n<h3 id=\"left-join、right-join、inner-join的区别\"><a href=\"#left-join、right-join、inner-join的区别\" class=\"headerlink\" title=\"left join、right join、inner join的区别\"></a>left join、right join、inner join的区别</h3><ul>\n<li>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 </li>\n<li>right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录</li>\n<li>inner join(等值连接) 只返回两个表中联结字段相等的行</li>\n</ul>\n<h2 id=\"innodb\"><a href=\"#innodb\" class=\"headerlink\" title=\"innodb\"></a>innodb</h2><h3 id=\"innodb-体系结构？\"><a href=\"#innodb-体系结构？\" class=\"headerlink\" title=\"innodb 体系结构？\"></a>innodb 体系结构？</h3><p><img src=\"/JAVA/Interview/innodb-Architecture.png\" alt=\"\"></p>\n<h3 id=\"什么是redo-log？\"><a href=\"#什么是redo-log？\" class=\"headerlink\" title=\"什么是redo log？\"></a>什么是redo log？</h3><p>当数据库对数据做修改的时候，需要把数据页从磁盘读到buffer pool中，然后在buffer pool中进行修改，那么这个时候buffer pool中的数据页就与磁盘上的数据页内容不一致，称buffer pool的数据页为dirty page 脏数据。<br>如果发生非正常的DB服务重启，那么这些数据并没有同步到磁盘文件中（注意，同步到磁盘文件是个随机IO），会发生数据丢失。<br>如果这个时候，能够有一个文件，当缓冲池中的data page变更结束后，把相应修改记录记录到这个文件（注意，记录日志是顺序IO），那么当DB服务发生crash的情况，恢复DB的时候，也可以根据这个文件的记录内容，重新应用到磁盘文件，数据保持一致。<br>这个文件就是redo log ，用于记录 数据修改后的记录，顺序记录。<br><img src=\"/JAVA/Interview/redo-buffer.png\" alt=\"\"><br>重做日志支持以下三种情况触发刷新：<br>    * Master Thread每一秒将重做日志缓冲刷新到重做日志文件<br>    * 每次事务提交时将重做日志缓冲刷新到重做日志文件<br>    * 当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件</p>\n<h3 id=\"什么是undo-log？\"><a href=\"#什么是undo-log？\" class=\"headerlink\" title=\"什么是undo log？\"></a>什么是undo log？</h3><p>undo日志用于存放数据修改被修改前的值。<br>假设修改表中 id=1 的行数据，把Name=’B’ 修改为Name = ‘B2’ ，那么undo日志就会用来存放Name=’B’的记录，如果这个修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。</p>\n<h3 id=\"undo-和-redo-事物实现过程？\"><a href=\"#undo-和-redo-事物实现过程？\" class=\"headerlink\" title=\"undo 和 redo 事物实现过程？\"></a>undo 和 redo 事物实现过程？</h3><p>事务B要将字段A的值由原来的1修改为3，要将B的值由原来的2修改为4，redo日志记录的是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">假设有A、B两个数据，值分别为1,2.</span><br><span class=\"line\">1. 事务B开始</span><br><span class=\"line\">2. 记录A=1到undo log</span><br><span class=\"line\">3. 修改A=3</span><br><span class=\"line\">4. 记录A=3到 redo log</span><br><span class=\"line\">5. 记录B=2到 undo log</span><br><span class=\"line\">6. 修改B=4</span><br><span class=\"line\">7. 记录B=4到redo log</span><br><span class=\"line\">8. 将redo log写入磁盘</span><br><span class=\"line\">9. 事务提交，将数据写入磁盘</span><br><span class=\"line\">10.事物B结束</span><br></pre></td></tr></table></figure>\n\n<p>如果上面事务B回滚（当做新的事务C），则redo记录的是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 事务C开始</span><br><span class=\"line\">2. 记录A=1到undo log</span><br><span class=\"line\">3. 修改A=3</span><br><span class=\"line\">4. 记录A=3到 redo log</span><br><span class=\"line\">5. 记录B=2到 undo log</span><br><span class=\"line\">6. 修改B=4</span><br><span class=\"line\">7. 记录B=4到redo log</span><br><span class=\"line\">   &lt;!--回滚--&gt;</span><br><span class=\"line\">8. 修改B=2</span><br><span class=\"line\">9. 记录B=2到redo log</span><br><span class=\"line\">10.修改A=1</span><br><span class=\"line\">11.记录A=1到redo log</span><br><span class=\"line\">12.将redo log写入磁盘</span><br><span class=\"line\">13.事务提交，将数据写入磁盘</span><br><span class=\"line\">14.事物C结束</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Double-write解决了什么问题\"><a href=\"#Double-write解决了什么问题\" class=\"headerlink\" title=\"Double write解决了什么问题?\"></a>Double write解决了什么问题?</h3><ul>\n<li>数据库IO的最小单位是16K（MySQL默认，oracle是8K）</li>\n<li>文件系统IO的最小单位是4K（也有1K的）</li>\n<li>磁盘IO的最小单位是512字节</li>\n</ul>\n<p>一个数据页的大小是16K，假设在把内存中的脏页写到数据库的时候，写了8K突然宕机了，也就是说前8K数据是新的，后8K是旧的，那么磁盘数据库这个数据页就是不完整的，是一个坏掉的数据页，这种情况被称为部分写失效</p>\n<h3 id=\"为什么-redo-log-不需要-doublewrite-的支持？\"><a href=\"#为什么-redo-log-不需要-doublewrite-的支持？\" class=\"headerlink\" title=\"为什么 redo log 不需要 doublewrite 的支持？\"></a>为什么 redo log 不需要 doublewrite 的支持？</h3><p>因为 redo log 写入的单位就是 512 字节，也就是磁盘 IO 的最小单位，所以无所谓数据损坏。</p>\n<h3 id=\"页断裂可不可以通过-redo-log-来进行恢复呢？\"><a href=\"#页断裂可不可以通过-redo-log-来进行恢复呢？\" class=\"headerlink\" title=\"页断裂可不可以通过 redo log 来进行恢复呢？\"></a>页断裂可不可以通过 redo log 来进行恢复呢？</h3><p>redo记录的是对页的修改，只能恢复校验完整（还没写）的页，不能修复坏掉的数据页，所以这个数据就丢失了，可能会造成数据不一致，所以需要double write。</p>\n<h3 id=\"两次写工作流程？\"><a href=\"#两次写工作流程？\" class=\"headerlink\" title=\"两次写工作流程？\"></a>两次写工作流程？</h3><p><img src=\"/JAVA/Interview/doublewrite.png\" alt=\"\"><br>doublewrite由两部分组成，一部分为内存中的doublewrite buffer，其大小为2MB，另一部分是磁盘上共享表空间(ibdata x)中连续的128个页，即2个区(extent)，大小也是2M。</p>\n<ol>\n<li>当一系列机制触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先拷贝至内存中的doublewrite buffer中；</li>\n<li>接着从两次写缓冲区分两次写入磁盘共享表空间中(连续存储，顺序写，性能很高)，每次写1MB；</li>\n<li>待第二步完成后，再将doublewrite buffer中的脏页数据写入实际的各个表空间文件(离散写)；(脏页数据固化后，即进行标记对应doublewrite数据可覆盖) </li>\n</ol>\n<h3 id=\"为什么-double-write-可以解决页断裂？\"><a href=\"#为什么-double-write-可以解决页断裂？\" class=\"headerlink\" title=\"为什么 double write 可以解决页断裂？\"></a>为什么 double write 可以解决页断裂？</h3><ol>\n<li>磁盘还未写，此时可以通过 redo log 恢复；</li>\n<li>磁盘正在进行从内存到共享表空间的写，此时数据文件中的页还没开始被写入，因此也同样可以通过 redo log 恢复；</li>\n<li>磁盘正在写数据文件，此时共享表空间已经写完，可以从共享表空间拷贝页的副本到数据文件实现恢复。</li>\n</ol>\n<h2 id=\"事物\"><a href=\"#事物\" class=\"headerlink\" title=\"事物\"></a>事物</h2><h3 id=\"什么是事务？\"><a href=\"#什么是事务？\" class=\"headerlink\" title=\"什么是事务？\"></a>什么是事务？</h3><p>一个事务是可以被看作一个单元的一系列SQL语句的集合。它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。</p>\n<h3 id=\"事务的特性（ACID）-是什么？\"><a href=\"#事务的特性（ACID）-是什么？\" class=\"headerlink\" title=\"事务的特性（ACID） 是什么？\"></a>事务的特性（ACID） 是什么？</h3><ul>\n<li>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>\n<li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li>\n<li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>\n<li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>\n</ul>\n<h3 id=\"数据库的事务隔离级别？\"><a href=\"#数据库的事务隔离级别？\" class=\"headerlink\" title=\"数据库的事务隔离级别？\"></a>数据库的事务隔离级别？</h3><ul>\n<li>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</li>\n<li>READ-COMMITTED：提交读，读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。（会造成幻读、不可重复读）。</li>\n<li>REPEATABLE-READ：可重复读，默认级别。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。（会造成幻读）。</li>\n<li>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，这个事务执行的时候不允许别的事务并发执行。事务只能一个接着一个地执行。该隔离级别能防止脏读、不可重复读、幻读。</li>\n</ul>\n<blockquote>\n<p><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。<br><strong>不可重复读</strong> ：事务A读取数据后，事务B执行更新操作，使A无法再次读取结果。<br><strong>幻读</strong>：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。<br><strong>丢失修改</strong>：两个事务A，B读入同一数据并修改，B提交的结果被A破坏了，导致B的修改丢失。</p>\n</blockquote>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><h3 id=\"从数据库系统的角度来看分为几种？\"><a href=\"#从数据库系统的角度来看分为几种？\" class=\"headerlink\" title=\"从数据库系统的角度来看分为几种？\"></a>从数据库系统的角度来看分为几种？</h3><ol>\n<li><p>共享锁（S）<br> 共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。</p>\n</li>\n<li><p>更新锁（U）<br> 更新锁可以防止通常形式的死锁。一般更新模式由一个事务组成，此事务读取记录，获取资源（页或行）的共享锁，然后修改行，此操作要求锁转换为排它锁。</p>\n</li>\n<li><p>排他锁（X）<br> 排它锁可以防止并发事务对资源进行访问。其它事务不能读取或修改排它锁锁定的数据。</p>\n</li>\n<li><p>意向锁<br> 意向锁就是说在屋（比如代表一个表）门口设置一个标识，说明屋子里有人（比如代表某些记录）被锁住了。另一个人想知道屋子里是否有人被锁，不用进屋子里一个一个的去查，直接看门口标识就行了。</p>\n<ul>\n<li><p>意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得<strong>该表的IS锁</strong></p>\n</li>\n<li><p>意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得<strong>该表的IX锁。</strong></p>\n</li>\n<li><p>意向共享排他锁（SIX）：对一个数据对象加 SIX锁，表示对它加 S锁，再加IX锁，即 SIX=S+IX。例如对某个表加 SIX锁，则表示该事务要读整个表（所以要对该表加 S锁），同时会更新个别元组（所以要对该表加 IX锁）。</p>\n<p>当一个表中的某一行被加上排他锁后，该表就不能再被加表锁。数据库程序如何知道该表不能被加表锁？一种方式是逐条的判断该表的每一条记录是否已经有排他锁，另一种方式是直接在表这一层级检查表本身是否有意向锁，不需要逐条判断。显然后者效率高。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"什么是悲观锁？\"><a href=\"#什么是悲观锁？\" class=\"headerlink\" title=\"什么是悲观锁？\"></a>什么是悲观锁？</h3><p>悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。</p>\n<ul>\n<li>悲观锁的流程<ul>\n<li>在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。 </li>\n<li>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。</li>\n<li>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</li>\n<li>其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</li>\n</ul>\n</li>\n<li>优点与不足<br>  悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。<br>  但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；<br>  另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载,还有会降低了并行性.<br>  一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数</li>\n</ul>\n<h3 id=\"什么是乐观锁？\"><a href=\"#什么是乐观锁？\" class=\"headerlink\" title=\"什么是乐观锁？\"></a>什么是乐观锁？</h3><p>乐观锁 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。<br>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</p>\n<ul>\n<li>实现方式<ul>\n<li>对记录加版本号：在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</li>\n<li>对记录加时间戳：在数据初始化时使用时间戳（timestamp），在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK。</li>\n<li>对将要更新的数据进行提前读取、事后对比。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"什么是锁的粒度？\"><a href=\"#什么是锁的粒度？\" class=\"headerlink\" title=\"什么是锁的粒度？\"></a>什么是锁的粒度？</h3><p>锁的粒度就是指锁的生效范围，就是说是行锁，还是页锁，还是整表锁. 锁的粒度同样既可以由数据库自动管理，也可以通过手工指定hint来管理。</p>\n<h3 id=\"封锁协议？\"><a href=\"#封锁协议？\" class=\"headerlink\" title=\"封锁协议？\"></a>封锁协议？</h3><p><img src=\"/JAVA/Interview/sqllock.gif\" alt=\"\"></p>\n<ul>\n<li>一级封锁协议：对应READ-UNCOMMITTED 隔离级别，本质是在事务A中修改完数据M后，立刻对这个数据M加上共享锁(S锁)（当事务A继续修改数据M的时候，先释放掉S锁，再修改数据，再加上S锁），根据S锁的特性，事务B可以读到事务A修改后的数据(无论事务A是否提交，因为是共享锁，随时随地都能查到数据A修改后的结果)，事务B不能去修改数据M，直到事务A提交，释放掉S锁。<ul>\n<li>缺点：丢失更新。脏读。不可重复读。幻读。</li>\n</ul>\n</li>\n<li>二级封锁协议：对应READ-COMMITTED隔离级别，本质是事务A在修改数据M后立刻加X锁，事务B不能修改数据M，同时不能查询到最新的数据M(避免脏读)，查询到的数据M是上一个版本(Innodb MVCC快照)的。<ul>\n<li>缺点：丢失更新。不可重复读。幻读。</li>\n</ul>\n</li>\n<li>三级封锁协议：对应REPEATABLE-READ隔离级别,本质是二级封锁协议基础上，对读到的数据M瞬间加上共享锁M，直到事务结束才释放（保证了其他事务没办法修改该数据），这个级别是MySql 5.5 默认的隔离级别。<ul>\n<li>缺点：丢失更新。幻读。</li>\n</ul>\n</li>\n<li>最强封锁协议：对应Serialization隔离级别，本质是从MVCC并发控制退化到基于锁的并发控制，对事务中所有读取操作加S锁，写操作加X锁，这样可以避免脏读，不可重复读，幻读，更新丢失，开销也最大，会造成读写冲突，并发程度也最低。</li>\n</ul>\n<h2 id=\"MySQL-的行锁和表锁？\"><a href=\"#MySQL-的行锁和表锁？\" class=\"headerlink\" title=\"MySQL 的行锁和表锁？\"></a>MySQL 的行锁和表锁？</h2><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p>\n<ul>\n<li>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</li>\n<li>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</li>\n</ul>\n<h2 id=\"说一下乐观锁和悲观锁？\"><a href=\"#说一下乐观锁和悲观锁？\" class=\"headerlink\" title=\"说一下乐观锁和悲观锁？\"></a>说一下乐观锁和悲观锁？</h2><ul>\n<li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</li>\n<li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</li>\n</ul>\n<p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p>\n<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><h3 id=\"B-tree和Btree的区别？\"><a href=\"#B-tree和Btree的区别？\" class=\"headerlink\" title=\"B+tree和Btree的区别？\"></a>B+tree和Btree的区别？</h3><p>btree是每个节点都保存数据，而b+tree只有叶子节点保存数据，并且每个叶子节点都有指向前后叶子节点的指针。</p>\n<h3 id=\"InnoDB索引原理？\"><a href=\"#InnoDB索引原理？\" class=\"headerlink\" title=\"InnoDB索引原理？\"></a>InnoDB索引原理？</h3><p>数据库中的B+树索引可以分为<strong>聚集索引和辅助索引</strong>。<br>聚集索引(主键索引)：按照每张表的主键构造一颗B+树，同时叶子结点存放的即为整张表的行纪录数据也称为数据页。<br>辅助索引(非聚集索引)：按照每张表的索引构造一颗B+树，叶子节点存放该行数据的主键。</p>\n<p>当通过索引数据来查找数据的时候，存储引擎会遍历辅助索引并且通过叶级别的指针获取到指向主键索引的的主键，然后再通过主键索引来找到一个完整的记录；</p>\n<h3 id=\"性别为什么不能作为数据库索引\"><a href=\"#性别为什么不能作为数据库索引\" class=\"headerlink\" title=\"性别为什么不能作为数据库索引?\"></a>性别为什么不能作为数据库索引?</h3><p>对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。<br>在使用普通索引查询时，会先加载普通索引，通过普通索引查询到实际行的主键。再使用主键通过聚集索引查询相应的行。以此循环查询所有的行。<br>若直接全量搜索聚集索引，则不需要在普通索引和聚集索引中来回切换。<br>相比两种操作的总开销可能扫描全表效率更高。</p>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ Redis ------------------------</span>\n</div>\n\n<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><h2 id=\"Redis-是什么？都有哪些使用场景？\"><a href=\"#Redis-是什么？都有哪些使用场景？\" class=\"headerlink\" title=\"Redis 是什么？都有哪些使用场景？\"></a>Redis 是什么？都有哪些使用场景？</h2><p>Redis 是一个使用 C 语言开发的高速缓存数据库。<br>Redis 使用场景：</p>\n<ul>\n<li>记录帖子点赞数、点击数、评论数；</li>\n<li>缓存近期热帖；</li>\n<li>缓存文章详情信息；</li>\n<li>记录用户会话信息。</li>\n</ul>\n<h2 id=\"Redis-有哪些功能？\"><a href=\"#Redis-有哪些功能？\" class=\"headerlink\" title=\"Redis 有哪些功能？\"></a>Redis 有哪些功能？</h2><ul>\n<li>数据缓存功能</li>\n<li>分布式锁的功能</li>\n<li>支持数据持久化</li>\n<li>支持事务</li>\n<li>支持消息队列</li>\n</ul>\n<h2 id=\"Redis-支持的数据类型有哪些？\"><a href=\"#Redis-支持的数据类型有哪些？\" class=\"headerlink\" title=\"Redis 支持的数据类型有哪些？\"></a>Redis 支持的数据类型有哪些？</h2><p><img src=\"/JAVA/Interview/redis-shujujiegou.png\" alt=\"\"><br>Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。</p>\n<h2 id=\"Redis-为什么是单线程的？\"><a href=\"#Redis-为什么是单线程的？\" class=\"headerlink\" title=\"Redis 为什么是单线程的？\"></a>Redis 为什么是单线程的？</h2><p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。<br>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>\n<h2 id=\"Redis-单机数据库的好处？\"><a href=\"#Redis-单机数据库的好处？\" class=\"headerlink\" title=\"Redis 单机数据库的好处？\"></a>Redis 单机数据库的好处？</h2><ul>\n<li>纯内存</li>\n<li>单线程，避免频繁上下文切换</li>\n<li>采用<code>非阻塞IO多路复用？</code></li>\n</ul>\n<h2 id=\"Redis-持久化有几种方式？\"><a href=\"#Redis-持久化有几种方式？\" class=\"headerlink\" title=\"Redis 持久化有几种方式？\"></a>Redis 持久化有几种方式？</h2><ul>\n<li>RDB（Redis Database）：默认持久化方式，按一定的时间周期把内存的数据以快照的形式保存到硬盘的二进制文件<ul>\n<li>优点：<ul>\n<li>只有一个dump.rdb 方便持久化</li>\n<li>容灾性好，一个文件可以保存到安全的磁盘</li>\n<li>性能最大化，fork子进程来完成写操作，让主进程继续处理命令，IO最大化</li>\n<li>数据集大时，比AOF的效率高</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>数据安全性低，RDB隔一段时间就会进行持久化，如果持久化之间发生故障，会发生数据丢失</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中，当redis重启会重新执行文件保存的写命令来重建数据库<ul>\n<li>优点：<ul>\n<li>数据安全，aof可以配置为每进行一次命令就记录到AOF文件中</li>\n<li>通过append模式写文件，即使中途服务器宕机，可以通过redis-check-aof工具进行恢复</li>\n<li>rewrite模式：fork一个子进程进行AOF重写</li>\n</ul>\n</li>\n<li>缺点：AOF文件比RDB文件大，且恢复速度慢，数据集大时比RDB效率低。</li>\n</ul>\n</li>\n</ul>\n<p>两种模式同时开启，数据恢复优先选择AOF。</p>\n<h2 id=\"怎么保证缓存和数据库数据的一致性？\"><a href=\"#怎么保证缓存和数据库数据的一致性？\" class=\"headerlink\" title=\"怎么保证缓存和数据库数据的一致性？\"></a>怎么保证缓存和数据库数据的一致性？</h2><ul>\n<li>合理设置缓存的过期时间。</li>\n<li>新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</li>\n</ul>\n<h2 id=\"Redis-淘汰策略有哪些？\"><a href=\"#Redis-淘汰策略有哪些？\" class=\"headerlink\" title=\"Redis 淘汰策略有哪些？\"></a>Redis 淘汰策略有哪些？</h2><ul>\n<li>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</li>\n<li>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</li>\n<li>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</li>\n<li>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</li>\n<li>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。</li>\n<li>no-enviction（驱逐）：禁止驱逐数据。</li>\n</ul>\n<h2 id=\"Redis-过期策略？\"><a href=\"#Redis-过期策略？\" class=\"headerlink\" title=\"Redis 过期策略？\"></a>Redis 过期策略？</h2><ul>\n<li>redis默认每100ms随机抽取进行检查是否有过期的key</li>\n<li>在获取某个key时会检查，这个key如果设置了过期时间那么是否过期了，如果过期则删除</li>\n</ul>\n<h2 id=\"什么是缓存雪崩？\"><a href=\"#什么是缓存雪崩？\" class=\"headerlink\" title=\"什么是缓存雪崩？\"></a>什么是缓存雪崩？</h2><p>由于原有缓存失效，新缓存未到期间，原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成压力，严重会导致数据库宕机，整个系统崩溃<br><strong>解决方法</strong>：考虑用加锁或队列的方式来保证不会有大量线程对数据库一次性进行读写。或将缓存失效时间分散开</p>\n<h2 id=\"什么是缓存穿透？\"><a href=\"#什么是缓存穿透？\" class=\"headerlink\" title=\"什么是缓存穿透？\"></a>什么是缓存穿透？</h2><p>数据在数据库中没有，自然在缓存中也不会有，这就导致用户查询时缓存中找不到，都要去数据库再查一遍<br>解决方法：<br>    1. 布隆过滤器，将所有可能存在的数据哈希到足够大的bitmap中，一个一定不存在的数据会被bitmap拦截<br>    2. 如果查询数据为空（不管数据不存在还是系统故障）仍把这个空结果进行缓存</p>\n<h2 id=\"什么是缓存预热？\"><a href=\"#什么是缓存预热？\" class=\"headerlink\" title=\"什么是缓存预热？\"></a>什么是缓存预热？</h2><p>系统上线后将相关的缓存数据直接加载到缓存系统<br>解决方法：<br>    * 数据量不大，项目启动时自动进行加载<br>    * 定时刷新缓存</p>\n<h2 id=\"Redis-常见的性能问题有哪些？该如何解决？\"><a href=\"#Redis-常见的性能问题有哪些？该如何解决？\" class=\"headerlink\" title=\"Redis 常见的性能问题有哪些？该如何解决？\"></a>Redis 常见的性能问题有哪些？该如何解决？</h2><ul>\n<li>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。</li>\n<li>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</li>\n</ul>\n<h2 id=\"Redis-主从复制？\"><a href=\"#Redis-主从复制？\" class=\"headerlink\" title=\"Redis 主从复制？\"></a>Redis 主从复制？</h2><p>用户可执行slaveof命令或设置slaveof选项让一个服务器去复制另一个服务器</p>\n<ul>\n<li>旧版复制<ul>\n<li>同步sync：用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态<ul>\n<li>从服务器向主服务器发送sync命令</li>\n<li>收到sync命令的主服务器执行<strong>bgsave</strong>在后台生成RDB文件，并用一个缓冲区记录从现在开始执行的所有写命令</li>\n<li>当主服务器bgsave执行完毕时，主服务器会将RDB文件发送给从服务器，从服务器接收并载入rdb，将自己的数据库状态更新至主服务器执行bgsave时的数据状态</li>\n<li>主服务器将缓冲区中写命令发送给从服务器，从服务器执行写命令，更新状态</li>\n</ul>\n</li>\n<li>命令传播：由于主服务器的数据库状态被修改，导致主从状态不一致时让主从服务器的数据库重新回到一致<ul>\n<li>主服务器会将自己执行的写命令发送给从服务器执行，从而使主从状态一致</li>\n</ul>\n</li>\n<li>缺陷：在断线后重复制的效率非常低，需要执行sync命令全量生成并加载rdb文件</li>\n</ul>\n</li>\n<li>新版复制：使用psync代替sync，可以<strong>部分同步</strong>和<strong>全部同步</strong><ul>\n<li>全部同步：sync </li>\n<li>部分同步：psync<ul>\n<li>主服务器的复制偏移量和从服务器的复制偏移量<ul>\n<li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N</li>\n<li>从服务器收到N子节数据时就将自己的复制偏移量的值加N</li>\n</ul>\n</li>\n<li>主服务器的复制积压缓冲区<ul>\n<li>主服务器维护的一个固定长度先进先出队列，大小1M</li>\n<li>当主服务器命令传播时，还会将写命令入队到复制缓冲里，并且复制缓冲会为队列中每字节记录复制偏移量</li>\n<li>当从服务器重新连上主服务器，从会通过psync将自己的offset发给主服务器<ul>\n<li>如果offset之后的数据仍在复制积压缓冲里，执行部分重同步</li>\n<li>否则执行完整重同步</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>服务器的运行ID<ul>\n<li>当从服务器对主服务器进行初次复制时，主会将自己的运行ID传给从服务器，从服务器保存起来</li>\n<li>当从服务器断线重连，从服务器向当前连接的主发送之前保存的运行ID<ul>\n<li>如果和当前主服务器的ID相同，则可以尝试执行部分重同步</li>\n<li>否则执行完整重同步<h2 id=\"哨兵模式sentinel？\"><a href=\"#哨兵模式sentinel？\" class=\"headerlink\" title=\"哨兵模式sentinel？\"></a>哨兵模式sentinel？</h2>sentinel是高可用的解决方案，由一个或多个sentinel实例组成的sentinel系统，可以监视任意多个主从服务器，并在被监视的主服务器进入下线时，将从升为主服务器</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>启动哨兵<ul>\n<li>初始化服务器：sentinel并不使用数据库，初始化不会加载RDB或AOF</li>\n<li>使用sentinel专用代码、初始化sentinel状态、初始化sentinel状态的masters属性</li>\n<li>创建连向主服务器的异步网络连接<ul>\n<li>命令连接，向主服务器发送命令并接收命令回复</li>\n<li>订阅连接，专门用于订阅主服务器的<strong>sentinel</strong>:hello 频道</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>获取主服务器信息：默认每十秒一次，通过命令连接向被监视的主服务器发送INFO命令，并通过分析回复来获取状态，可以获取到主服务器信息，以及主服务器下所有从服务器信息</li>\n<li>获取从服务器信息：根据INFO命令回复</li>\n<li>向主从服务器发送信息：每两秒一次向服务器<strong>sentinel</strong>:hello频道发送一条信息</li>\n<li>接收主从服务器的频道信息</li>\n<li>更新sentinels字典</li>\n<li>创建连向其他sentinel的命令连接</li>\n<li>检测主观下线：每秒向所有与它创建了命令连接的实例发送PING，并通过返回的PING命令回复判断是否在线</li>\n<li>检测客观下线：<ul>\n<li>当一个主服务器主观下线后，为了确保主服务器真下线了，会向同样监视这服务器的其他sentinel进行询问</li>\n<li>当认为主服务器进入下线状态的sentinel数量超过配置中设置的quorum参数值，就进入客观下线状态</li>\n</ul>\n</li>\n<li>选举领头sentinel：当一个服务器客观下线时，监视该服务器的sentinel会选举出一个领头sentinel，并由领头进行故障转移<ul>\n<li>选举方式：<ul>\n<li>监视同一主服务器的在线sentinel都有资格</li>\n<li>每次选举无论成功与否，配置纪元的值都会自增一次</li>\n<li>在一个配置纪元里，所有sentinel都有一次将某个sentinel设置为局部头的机会，并且一旦设置不可更改</li>\n<li>每个发现主服务器进入客观下线的sentinel都会要求其他sentinel将自己设为局部头</li>\n<li>设置局部头的规则是先到先得，之后接收到的所有设置要求都会被拒绝</li>\n<li>如果有某个sentinel被半数以上设置成了局部头，那么就成为领头</li>\n<li>在给定时限内，没有一个被选举为领头，那么将在一段时间后再次选举</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>故障转移：<ul>\n<li>选出新的主服务器：从已下线主服务器的所有从服务器列表中筛选<ul>\n<li>删除列表中所有处于下线或者断线状态的从服务器</li>\n<li>删除列表中5s内没有回复过领头sentinel的info命令的从服务器</li>\n<li>删除所有与已下线服务器连接断开超过down-after-milliseconds*10毫秒的从服务器</li>\n<li>根据从服务器优先级排序，相同优先级按照从服务器复制偏移量排序，相同偏移量按运行ID最小排序</li>\n<li>向选出的从服务器发送SLAVEOF no one命令升级为主服务器 </li>\n</ul>\n</li>\n<li>修改从服务器的赋值目标<ul>\n<li>向其他从服务器发送slaveof命令，让他们复制新主服务器</li>\n</ul>\n</li>\n<li>将旧的主服务器变成从服务器<ul>\n<li>当旧的主服务器重新上线时，会向他发出slaveof命令，让他变成从服务器</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"redis集群？\"><a href=\"#redis集群？\" class=\"headerlink\" title=\"redis集群？\"></a>redis集群？</h2><p>Redis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。</p>\n<ul>\n<li><p>节点：一个redis集训由多个节点构成</p>\n<ul>\n<li>启动节点：redis 启动时会根据cluster-enabled配置是否为yes决定是否开启集训模式</li>\n<li>集群数据结构：<ul>\n<li>clusterNode：保存了节点的创建时间、名称、配置纪元、ip、端口号等</li>\n<li>clusterLink：保存了连接<strong>节点</strong>所需的套接字描述符、输入缓冲区、输出缓冲区</li>\n<li>redisClient：保存了连接<strong>客户端</strong>所需的套接字描述符、输入缓冲区、输出缓冲区</li>\n</ul>\n</li>\n<li>节点之间建立连接：通过cluster meet节点之间握手<ul>\n<li>节点A会为节点B创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。</li>\n<li>节点A将根据CLUSTER MEET命令给定的IP地址和端口号，向节点B发送一条MEET消息（message）</li>\n<li>节点B将接收到节点A发送的MEET消息，节点B会为节点A创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。</li>\n<li>节点B将向节点A返回一条PONG消息。</li>\n<li>节点A将接收到节点B返回的PONG消息，通过这条PONG消息节点A可以知道节点B已经成功地接收到了自己发送的MEET消息。</li>\n<li>节点A将向节点B返回一条PING消息。</li>\n<li>节点B将接收到节点A返回的PING消息，通过这条PING消息节点B可以知道节点A已经成功地接收到了自己返回的PONG消息，握手完成。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>槽指派：集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。</p>\n<ul>\n<li>记录节点的槽指派信息：clusterNode结构的slots属性和numslot属性记录了节点负责处理哪些槽<ul>\n<li>slots属性是包含16384位的二进制数组，对应索引i上的值为1那么表示节点负责处理槽i。</li>\n</ul>\n</li>\n<li>传播节点的槽指派信息：将自己的slots数组通过消息发送给集群中的其他节点，以此来告知其他节点自己目前负责处理哪些槽。</li>\n<li>记录集群中所有的槽指派信息：clusterState结构中的slots数组记录了集群中所有16384个槽的指派信息，slots数组包含16384个项，每个数组项都是一个指向clusterNode结构的指针</li>\n</ul>\n</li>\n<li><p>在集训中执行命令：客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己</p>\n<ul>\n<li>如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令。</li>\n<li>如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，指引客户端转向（redirect）至正确的节点，并再次发送之前想要执行的命令</li>\n</ul>\n</li>\n<li><p>重新分片：Redis集群的重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点</p>\n</li>\n<li><p>ASK错误：在进行重新分片期间：属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对则保存在目标节点里面，当客户端向源节点发送一个与数据库键有关的命令，若此时数据不在原节点上，返回ASK并指引客户端转向目标节点。</p>\n</li>\n<li><p>复制与故障转移：</p>\n<ul>\n<li>设置从节点：向一个节点发送命令CLUSTER REPLICATE <node_id>，让接收命令的节点称为node_id的从节点</node_id></li>\n<li>故障检测：<ul>\n<li>集群中的每个节点都会定期地向集群中的其他节点发送PING消息，如果没有在规定时间返回PONG消息，那么该节点会被疑似下线。</li>\n<li>集群中的各个节点会通过互相发送消息的方式来交换集群中各个节点的状态信息，来确认某个节点是疑似下线还是已下线。</li>\n<li>当一个主节点A通过消息得知主节点B认为主节点C进入了疑似下线状态时，会记录主节点C的状态。</li>\n<li>当集群中半数以上的主节点都将某节点疑似下线，那么这个主节点被标记为已下线。</li>\n<li>将主节点x标记为已下线的节点会向集群广播一条关于主节点x的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点x标记为已下线。</li>\n</ul>\n</li>\n<li>故障转移：当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移<ul>\n<li>选举新的主节点<ul>\n<li>集群的配置纪元是一个自增计数器，它的初始值为0。</li>\n<li>当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被增一</li>\n<li>对于每个配置纪元，集群里每个负责处理槽的主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得主节点的投票。</li>\n<li>当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票</li>\n<li>如果一个主节点具有投票权（它正在负责处理槽），并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示这个主节点支持从节点成为新的主节点。</li>\n<li>如果集群里有N个具有投票权的主节点，那么当一个从节点收集到大于等于N/2+1张支持票时，这个从节点就会当选为新的主节点。</li>\n<li>如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。</li>\n</ul>\n</li>\n<li>被选中的从节点会执行SLAVEOF no one命令，成为新的主节点</li>\n<li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</li>\n<li>新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</li>\n<li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"zookeeper\"><a href=\"#zookeeper\" class=\"headerlink\" title=\"zookeeper\"></a>zookeeper</h1><p>它是一个分布式服务框架，主要用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务，集群管理、分布式应用配置项的管理等。<br>简单来说：zk是一个拥有文件系统特点的数据库；zk是一个解决了数据一致性问题的分布式数据库；zk是一个具有发布和订阅功能的分布式数据库。</p>\n<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><h3 id=\"各种排序算法的时间复杂度以及稳定性？\"><a href=\"#各种排序算法的时间复杂度以及稳定性？\" class=\"headerlink\" title=\"各种排序算法的时间复杂度以及稳定性？\"></a>各种排序算法的时间复杂度以及稳定性？</h3><p><img src=\"/JAVA/Interview/sort.png\" alt=\"\"></p>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><ul>\n<li>算法原理：相邻的数据进行两两比较，小(大)数放在前面，大(小)数放在后面，这样一趟下来，最小(大)的数就被排在了第一位，第二趟也是如此，如此类推，直到所有的数据排序完成。</li>\n<li>时间复杂度：最坏：O(n2) 最好: O(n) 平均: O(n2) 空间复杂度：O(1) 稳定性： 稳定</li>\n</ul>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><ul>\n<li>算法原理：先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</li>\n<li>时间复杂度：最坏：O(n2) 最好: O(n) 平均: O(n2) 空间复杂度：O(1) 稳定性： 稳定</li>\n</ul>\n<h3 id=\"直接插入排序\"><a href=\"#直接插入排序\" class=\"headerlink\" title=\"直接插入排序\"></a>直接插入排序</h3><ul>\n<li>算法原理：每次将一个待排序的数据按照其关键字的大小插入到前面已经排序好的数据中的适当位置，直到全部数据排序完成。</li>\n<li>时间复杂度：最坏：O(n2) 最好: O(n) 平均: O(n2) 空间复杂度：O(1) 稳定性： 稳定</li>\n</ul>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><ul>\n<li>算法原理：<ul>\n<li>从数列中挑出一个元素作为基准数。</li>\n<li>分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。</li>\n<li>再对左右区间递归执行第二步，直至各区间只有一个数。</li>\n</ul>\n</li>\n<li>时间复杂度：最坏：O(n2) 最好: O(nlogn) 平均: O(nlogn) 空间复杂度：O(logn) 稳定性： 不稳定 </li>\n</ul>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><ul>\n<li>算法原理：将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</li>\n<li>时间复杂度：最坏：O(nlogn) 最好: O(n) 平均: O(nlogn) 空间复杂度：O(1) 稳定性： 稳定 </li>\n</ul>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><ul>\n<li>算法原理：堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。</li>\n<li>时间复杂度：最坏：O(nlogn) 最好: O(nlogn) 平均: O(nlogn) 空间复杂度：O(1) 稳定性： 不稳定 </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 堆排序（升序排列）-建立最大堆</span></span><br><span class=\"line\"><span class=\"comment\"> * @param array</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">heapSortAsc</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len = a.length;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = len / <span class=\"number\">2</span> - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">\t\tmaxHeapDown(a, i, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = len - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;<span class=\"comment\">//堆顶和末尾交换</span></span><br><span class=\"line\">\t\tswap(a, i, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tmaxHeapDown(a, <span class=\"number\">0</span>, i - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">maxHeapDown</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;<span class=\"comment\">//自顶向下调整成为最大堆</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> son = start * <span class=\"number\">2</span> + <span class=\"number\">1</span>;<span class=\"comment\">//左儿子</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> root = a[start];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (; son &lt;= end; start = son, son = <span class=\"number\">2</span> * son + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (son &lt; end &amp;&amp; a[son] &lt; a[son + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">\t\t\tson++;<span class=\"comment\">//右儿子</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root &gt;= a[son]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tswap(a, start, son);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"负载均衡算法\"><a href=\"#负载均衡算法\" class=\"headerlink\" title=\"负载均衡算法\"></a>负载均衡算法</h2><h3 id=\"完全随机\"><a href=\"#完全随机\" class=\"headerlink\" title=\"完全随机\"></a>完全随机</h3><p>对所有机器随机选择<br>缺点：服务器有好有坏，处理能力是不同的，我们希望性能好的服务器多处理些请求，性能差的服务器少处理一些请求。</p>\n<h3 id=\"加权随机\"><a href=\"#加权随机\" class=\"headerlink\" title=\"加权随机\"></a>加权随机</h3><p>为每台服务器设置了权重，权重大的服务器获得的概率大一些，权重小的服务器获得的概率小一些。</p>\n<h3 id=\"完全轮询\"><a href=\"#完全轮询\" class=\"headerlink\" title=\"完全轮询\"></a>完全轮询</h3><p>按顺序一个一个执行</p>\n<h3 id=\"普通加权轮询\"><a href=\"#普通加权轮询\" class=\"headerlink\" title=\"普通加权轮询\"></a>普通加权轮询</h3><p>有三个节点{a, b, c}，他们的权重分别是{a=5, b=1, c=1}。发送7次请求，a会被分配5次，b会被分配1次，c会被分配1次。<br>轮训所有节点，找到一个最大权重节点；选中的节点权重-1；直到减到0，恢复该节点原始权重，继续轮询；</p>\n<h3 id=\"平滑加权轮询\"><a href=\"#平滑加权轮询\" class=\"headerlink\" title=\"平滑加权轮询\"></a>平滑加权轮询</h3><p><img src=\"/JAVA/Interview/load.png\" alt=\"\"><br>选中的服务器非固定权重：固定权重-各个服务器的权重之和<br>其他服务器非固定权重 = 固定权重。<br>每一轮将当前有效权重<strong>最大</strong>的实例减去所有实例的权重和，且变量 currentPos 指向此位<br>将每个实例的 非固定权重 都加上 固定权重</p>\n<h3 id=\"一致性hash算法\"><a href=\"#一致性hash算法\" class=\"headerlink\" title=\"一致性hash算法\"></a>一致性hash算法</h3><p>普通的hash算法：如果我们采用普通的hash算法进行路由，将数据映射到具体的节点上，如key%N，key是数据的key，N是机器节点数，如果有一个机器加入或退出这个集群，则所有的数据映射都无效了，如果是持久化存储则要做数据迁移，如果是分布式缓存，则其他缓存就失效了。<br><img src=\"/JAVA/Interview/hash.jpg\" alt=\"\"><br>一致性hash算法：<br>    * 环形hash空间：按照常用的hash算法来将对应的key哈希到一个具有2^32次方个节点的空间中，即0 ~ (2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。<br>    * 映射服务器节点：将各个服务器使用Hash进行一个哈希，具体可以选择服务器的ip或唯一主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。<br>    * 映射数据：对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上,然后从数据所在位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。<br>    * 服务器的删除与添加<br>        * 如果此时NodeC宕机了，此时Object A、B、D不会受到影响，只有Object C会重新分配到Node D上面去，而其他数据对象不会发生变化<br>        * 如果在环境中新增一台服务器Node X，通过hash算法将Node X映射到环中，通过按顺时针迁移的规则，那么Object C被迁移到了Node X中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。</p>\n<p>平衡性问题：当服务器节点比较少的时候，会出现一个问题，就是此时必然造成大量数据集中到一个节点上面，极少数数据集中到另外的节点上面。<br>为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以先确定每个物理节点关联的虚拟节点数量，然后在ip或者主机名后面增加编号。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：<br><img src=\"/JAVA/Interview/hash2.jpg\" alt=\"\"></p>\n<h2 id=\"大数据问题\"><a href=\"#大数据问题\" class=\"headerlink\" title=\"大数据问题\"></a>大数据问题</h2><h3 id=\"给一个超过100G大小的log-file-log中存着IP地址-，设计算法找到出现次数最多的IP地址？\"><a href=\"#给一个超过100G大小的log-file-log中存着IP地址-，设计算法找到出现次数最多的IP地址？\" class=\"headerlink\" title=\"给一个超过100G大小的log file,log中存着IP地址 ，设计算法找到出现次数最多的IP地址？\"></a>给一个超过100G大小的log file,log中存着IP地址 ，设计算法找到出现次数最多的IP地址？</h3><p>但凡是大数据的问题，都可通过切分来解决它。<br>如果我们将其分成1000个小文件，每个文件大概就是500M左右的样子，现在计算机肯定轻轻 松松就能装下。<br>那么，问题又来了，怎样才能保证相同的IP被分到同一个文件中呢？<br>这里我想到的是哈希切分，使用相同的散列函数（如 BKDRHash）将所有IP地址转换为一个整数key，再利用 index=key%1000就可将相同IP分到同一个文件。</p>\n<h2 id=\"智商题\"><a href=\"#智商题\" class=\"headerlink\" title=\"智商题\"></a>智商题</h2><h1 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h1><h2 id=\"分布式ID解决方案\"><a href=\"#分布式ID解决方案\" class=\"headerlink\" title=\"分布式ID解决方案\"></a>分布式ID解决方案</h2><ol>\n<li>基于UUID:对于数据库来说用作业务主键ID，它不仅是太长还是字符串，存储性能差查询也很耗时，所以不推荐用作分布式ID。<ul>\n<li>优点：生成足够简单，本地生成无网络消耗，具有唯一性</li>\n<li>缺点：无序的字符串，不具备趋势自增特性;没有具体的业务含义;长度过长16 字节128位，36位长度的字符串，存储以及查询对MySQL的性能消耗较大，MySQL官方明确建议主键要尽量越短越好，作为数据库主键 UUID 的无序性会导致数据位置频繁变动，严重影响性能。</li>\n</ul>\n</li>\n<li>基于单数据库自增ID<ul>\n<li>优点：实现简单，ID单调自增，数值类型查询速度快</li>\n<li>缺点：DB单点存在宕机风险，无法扛住高并发场景</li>\n</ul>\n</li>\n<li>基于数据库集群模式:那这样还会有个问题，两个MySQL实例的自增ID都从1开始，会生成重复的ID怎么办？<ul>\n<li>操作：设置起始值和自增步长</li>\n<li>优点：解决DB单点问题</li>\n<li>缺点：不利于后续扩容，新增第三台MySQL实例需要人工修改一、二两台MySQL实例的起始值和步长。</li>\n</ul>\n</li>\n<li>基于Redis模式:利用redis的 incr命令实现ID的原子性自增<ul>\n<li>缺点：RDB会定时打一个快照进行持久化，假如连续自增但redis没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。</li>\n<li>缺点：AOF会对每条写命令进行持久化，即使Redis挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致Redis重启恢复的数据时间过长。</li>\n</ul>\n</li>\n<li>基于数据库的号段模式：从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存<ul>\n<li>数据库中存储 <strong>当前最大id</strong>, <strong>号段的步长</strong></li>\n<li>多业务端可能同时操作，所以采用版本号version乐观锁方式更新，</li>\n<li>优点：这种分布式ID生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。</li>\n<li>缺点：id为连续号段，可能会被枚举，安全性不足；服务器出现问题重启，部分在内存中的号段会丢失。</li>\n<li>优化方式：双buffer机制，在号段用完前并发获取下一个号段</li>\n</ul>\n</li>\n<li>基于雪花算法（Snowflake）模式<ul>\n<li>组成：Snowflake ID组成结构：正数位（占1比特）+ 时间戳（占41比特）+ 机器ID（占5比特）+ 数据中心（占5比特）+ 自增值（占12比特），总共64比特组成的一个Long类型。<ul>\n<li>第一个bit位（1bit）：Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0。</li>\n<li>时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69年</li>\n<li>工作机器id（10bit）：也被叫做workId，这个可以灵活配置，机房或者机器号组合都可以。</li>\n<li>序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID</li>\n</ul>\n</li>\n<li>操作：当序列号部分超过4096时，等待下一毫秒；当目前时间戳小于最后一次的时间戳时，时钟回拨，报错！！</li>\n<li>优点：解除对db的依赖；需要人工配置工作id；只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。</li>\n<li>缺点：依赖时间戳，存在机器时钟回拨</li>\n</ul>\n</li>\n<li>百度（uid-generator）:自动生成workId<ul>\n<li>组成：正数位（占1比特） + 时间秒（占28位）+ workId（占22比特）+ 自增值（占13位）；</li>\n<li>操作：依赖db，在服务器启动的时候，根据hostName，port，type和 date 插入db中取出对应的自增di作为workId。</li>\n<li>CachedUidGenerator：采用RingBuffer环状数组，初始时按填充时的时间戳填充ring数组，取id时顺序从数组中取，异步填充数组。</li>\n</ul>\n</li>\n<li>美团(Leaf): 基于ZooKeeper的顺序Id生成workId</li>\n</ol>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.cnblogs.com/bailing80/p/11443409.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/bailing80/p/11443409.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h1><div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ 基础 ------------------------</span>\n</div>\n\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"JDK-和-JRE-有什么区别？\"><a href=\"#JDK-和-JRE-有什么区别？\" class=\"headerlink\" title=\"JDK 和 JRE 有什么区别？\"></a>JDK 和 JRE 有什么区别？</h3><ul>\n<li>JDK：Java 开发工具包，提供了 Java 的开发环境和运行环境（包括JRE）。</li>\n<li>JRE：Java 运行环境</li>\n</ul>\n<h3 id=\"和-equals-的区别是什么？\"><a href=\"#和-equals-的区别是什么？\" class=\"headerlink\" title=\"== 和 equals 的区别是什么？\"></a>== 和 equals 的区别是什么？</h3><ul>\n<li><strong>==：</strong> 基本类型：比较的是值是否相同；引用类型：比较的是引用的地址是否相同；</li>\n<li><strong>equals</strong>：equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较</li>\n</ul>\n<p>总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>\n<h3 id=\"为什么重写了equals方法，就要重写hashCode方法？\"><a href=\"#为什么重写了equals方法，就要重写hashCode方法？\" class=\"headerlink\" title=\"为什么重写了equals方法，就要重写hashCode方法？\"></a>为什么重写了equals方法，就要重写hashCode方法？</h3><p>不是必须，只是建议。虽然可以不重写hashCode，但是会对集合造成影响。<br>比如hashMap，如果equals判断相同的key，但是hashCode不同，也就是内存中的地址不同，那么进行如下操作，就不会被覆盖，而是被put两次<br>hashMap.put(“k”,”v1”)，hashMap.put(“k”:”v2”)</p>\n<h3 id=\"final-在-Java-中有什么作用？\"><a href=\"#final-在-Java-中有什么作用？\" class=\"headerlink\" title=\"final 在 Java 中有什么作用？\"></a>final 在 Java 中有什么作用？</h3><ul>\n<li>final 修饰的类叫最终类，该类不能被继承。</li>\n<li>final 修饰的方法不能被重写。</li>\n<li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li>\n</ul>\n<h3 id=\"Java基础的数据类型有哪些？\"><a href=\"#Java基础的数据类型有哪些？\" class=\"headerlink\" title=\"Java基础的数据类型有哪些？\"></a>Java基础的数据类型有哪些？</h3><p>基础类型有 8 种：byte、boolean、char、short、int、float、long、double</p>\n<h3 id=\"Java-中操作字符串都有哪些类？它们之间有什么区别？\"><a href=\"#Java-中操作字符串都有哪些类？它们之间有什么区别？\" class=\"headerlink\" title=\"Java 中操作字符串都有哪些类？它们之间有什么区别？\"></a>Java 中操作字符串都有哪些类？它们之间有什么区别？</h3><p>操作字符串的类有：String、StringBuffer、StringBuilder。<br>String：<br>    * 声明的是不可变的对象，它的底层是一个用final修饰的字符数组，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象<br>    * String 对象赋值之后就会在字符串常量池中缓存，如果下次创建会判定常量池是否已经有缓存对象，如果有的话直接返回该引用给创建者。<br>StringBuffer： 可以在原有对象的基础上进行操作，线程安全的，性能高于StringBuilder<br>StringBuilder： 可以在原有对象的基础上进行操作，非线程安全的</p>\n<h3 id=\"String和StringBuilder-的区别？\"><a href=\"#String和StringBuilder-的区别？\" class=\"headerlink\" title=\"String和StringBuilder 的区别？\"></a>String和StringBuilder 的区别？</h3><p>jdk1.5：string 对象时恒定不变的,stringBuider对象表示的字符串是可变的。所以在字符串频繁修改的情况下stringBuider效率<br>jdk1.8: 编译器利用String的可变配套类(StringBuilder)帮我们做了优化，编译器自动调用StringBuilder.apend()方法添加。因此在拼接字符串小于500左右时，两个对象效率相同。</p>\n<h3 id=\"接口和抽象类有什么区别？\"><a href=\"#接口和抽象类有什么区别？\" class=\"headerlink\" title=\"接口和抽象类有什么区别？\"></a>接口和抽象类有什么区别？</h3><p>设计目的：<br>    * 接口的设计目的，是对类的行为进行约束，也就是提供一种机制，可以强制要求不同的类具有相同的行为。<br>    * 抽象类的设计目的，是代码复用。<br>相同：<br>    * 都不能被实例化<br>    * 都能包含抽象的方法<br>不同：<br>    * 在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。<br>    * 抽象类中的成员变量可以是各种类型的；而接口中的成员变量只能是public static final类型的；<br>    * 抽象类可以有静态代码块和静态方法；接口中不能含有静态代码块以及静态方法<br>    * 一个类只能继承一个抽象类，而一个类却可以实现多个接口。　　</p>\n<h3 id=\"请列举你所知道的Object类的方法并简要说明。\"><a href=\"#请列举你所知道的Object类的方法并简要说明。\" class=\"headerlink\" title=\"请列举你所知道的Object类的方法并简要说明。\"></a>请列举你所知道的Object类的方法并简要说明。</h3><ul>\n<li>getClass():用于返回当前运行时对象的Class对象</li>\n<li>equals():用于比较两个对象的地址是否相同，即两个引用是否指向同一个对象；</li>\n<li>clone():用于创建并返回当前对象的一份拷贝</li>\n<li>toString():返回类的名字@实例的哈希码的16进制字符串；</li>\n<li>notify():唤醒等待队列中的其中一个线程</li>\n<li>notifyAll():唤醒线程等待队列中的所有线程；</li>\n<li>wait(long timeout):让一个线程等待一段时间。</li>\n<li>finalize()：用于释放资源，可以覆盖此方法实现资源清理工作。GC在回收对象之前调用该方法，但是无法确定该方法具体什么时候被调用</li>\n</ul>\n<h3 id=\"类的加载顺序\"><a href=\"#类的加载顺序\" class=\"headerlink\" title=\"类的加载顺序\"></a>类的加载顺序</h3><ul>\n<li>父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)</li>\n<li>子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )</li>\n<li>父类非静态代码块( 包括非静态初始化块，非静态属性 )</li>\n<li>父类构造函数</li>\n<li>子类非静态代码块 ( 包括非静态初始化块，非静态属性 )</li>\n<li>子类构造函数</li>\n</ul>\n<h3 id=\"对象在堆上要分配多大内存？\"><a href=\"#对象在堆上要分配多大内存？\" class=\"headerlink\" title=\"对象在堆上要分配多大内存？\"></a>对象在堆上要分配多大内存？</h3><ol>\n<li>java对象的属性—不固定</li>\n<li>对象头—固定12 byte</li>\n<li>数据对齐（64位虚拟机要求对象大小是8的整数倍，不够就补齐）</li>\n</ol>\n<p>64位jvm中，一个仅包含一个boolean属性的对象，大小是16 byte，12byte对象头，1byte数据，3byte填充数据</p>\n<h3 id=\"对象有几种状态？\"><a href=\"#对象有几种状态？\" class=\"headerlink\" title=\"对象有几种状态？\"></a>对象有几种状态？</h3><ol>\n<li>无状态 刚new出来的时候  biased_lock:0 | lock: 10</li>\n<li>偏向锁 biased_lock:1 | lock: 10</li>\n<li>轻量级锁</li>\n<li>重量级锁</li>\n<li>无引用，被gc标记</li>\n</ol>\n<h3 id=\"什么是对象头？\"><a href=\"#什么是对象头？\" class=\"headerlink\" title=\"什么是对象头？\"></a>什么是对象头？</h3><p>所有对象通用的一部分结构。<br>由两部分组成：</p>\n<ol>\n<li>mark word <ul>\n<li>32 bits jvm 占 32 bits<ul>\n<li>hashcode：25｜ age：4｜ biased_lock(偏向锁)：1 | lock(同步状态) : 2 </li>\n</ul>\n</li>\n<li>64 bits jvm 占 64 bits<ul>\n<li><img src=\"/JAVA/Interview/head.png\" alt=\"\"></li>\n<li>无状态下，在未调用过hashcode函数时，对象头hashcode位置都为0，调用过hashcode函数计算之后才会保存。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>klass pointer 指向类.class的指针<ul>\n<li>64 bits jvm 开启指针压缩占 32 bits 不开启占 64 bits</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"解释一下对象创建过程？\"><a href=\"#解释一下对象创建过程？\" class=\"headerlink\" title=\"解释一下对象创建过程？\"></a>解释一下对象创建过程？</h3><p>假设有一个对象T,有一个属性m=8，那么在new 这个对象时先在堆中申请空间，<br>然后属性半初始化也就是m=0，然后再调用构造方法将m修改为8，然后将引用变量t指向堆中的地址。</p>\n<h3 id=\"DCL与volatile的问题？\"><a href=\"#DCL与volatile的问题？\" class=\"headerlink\" title=\"DCL与volatile的问题？\"></a>DCL与volatile的问题？</h3><p>volatile 的作用是线程的可见性和禁止了指令重排序。<br>在单例模式中，未了保证多线程的安全性，采用了DCL（Double-Check-Locking）方式，<br>那么在线程1创建对象X的时候，对象先半初始化，再调用构造方法，线程2再去判断X对象等不等于空，<br>如果此时发生指令重排序，对象先半初始化，线程2再去判断X对象等不等于空，再调用构造方法，会导致线程2拿到了半初始化的对象。<br>所以需要volatile来禁止指令重排。</p>\n<h3 id=\"对象在内存中的存储布局？\"><a href=\"#对象在内存中的存储布局？\" class=\"headerlink\" title=\"对象在内存中的存储布局？\"></a>对象在内存中的存储布局？</h3><p>对象头、实例数据和对齐填充</p>\n<h3 id=\"对象怎么定位？\"><a href=\"#对象怎么定位？\" class=\"headerlink\" title=\"对象怎么定位？\"></a>对象怎么定位？</h3><p>引用-&gt;堆内存的对象-&gt;方法区常量。</p>\n<h3 id=\"对象怎么分配？\"><a href=\"#对象怎么分配？\" class=\"headerlink\" title=\"对象怎么分配？\"></a>对象怎么分配？</h3><p>开始new一个对象<br>    *尝试在栈上分配？<br>        * 可以在栈上分配，在pop时结束生命周期<br>        * 若一个对象的引用逃出了方法或者线程，在方法调用过程中传递对象的引用到另一个方法，或栈空间不够大。则不能在栈上分配。<br>            * 对象是否够大？<br>                * 足够大，老年代分配，full gc时结束生命周期<br>                * 不够大，尝试 tlab 分配？<br>                    * tlab空间是否足够？<br>                        * 足够，tlab（线程本地空间）分配到eden，<br>                        * 不足，共享空间分配到eden<br>                    * young gc-&gt; 幸存者区-&gt; 老年代-&gt; full gc 结束生命周期</p>\n<p>一般的对象分配内存，都是在新生代进行空间申请的。在多个线程都在申请空间时，每次对象分配都必须进行同步。竞争激烈的场合分配的效率又会进一步下降。TLAB是一个存在于eden区的线程独享内存区域，主要用于降低在新生代分配对象时的内存竞争，提升对象分配的效率。</p>\n<h3 id=\"Object-o-new-Object-在内存中占多少字节？\"><a href=\"#Object-o-new-Object-在内存中占多少字节？\" class=\"headerlink\" title=\"Object o = new Object() 在内存中占多少字节？\"></a>Object o = new Object() 在内存中占多少字节？</h3><p>对象的引用o 4 byte<br>Object 的 mark word 占 8 byte<br>klass pointer 若开启指针压缩占 4 byte，不开启压缩占 8 byte<br>对象的属性大小不确定。</p>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ 集合 ------------------------</span>\n</div>\n\n<h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><h3 id=\"HashSet-的底层实现是什么\"><a href=\"#HashSet-的底层实现是什么\" class=\"headerlink\" title=\"HashSet 的底层实现是什么?\"></a>HashSet 的底层实现是什么?</h3><p>HashSet 的实现是依赖于 HashMap 的，HashSet 的值都是存储 在 HashMap 中的。在 HashSet 的构造法中会初始化一个 HashMap 对象<br>HashSet 不允许值重复，因此，HashSet 的值是作为 HashMap 的 key 存储在 HashMap 中的，当存储的值已经存在时返回 false。</p>\n<h3 id=\"Iterator-和-ListIterator-的区别是什么\"><a href=\"#Iterator-和-ListIterator-的区别是什么\" class=\"headerlink\" title=\"Iterator 和 ListIterator 的区别是什么?\"></a>Iterator 和 ListIterator 的区别是什么?</h3><ul>\n<li>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。</li>\n<li>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。<br>ListIterator 实现了 Iterator 接口，并包含其他的功能，比如:增加元素，替换元 素，获取前一个和后一个元素的索引，等等。</li>\n</ul>\n<h3 id=\"数组-Array-和列表-ArrayList-有什么区别\"><a href=\"#数组-Array-和列表-ArrayList-有什么区别\" class=\"headerlink\" title=\"数组 (Array) 和列表 (ArrayList) 有什么区别?\"></a>数组 (Array) 和列表 (ArrayList) 有什么区别?</h3><ul>\n<li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</li>\n<li>Array 大小是固定的，ArrayList 的大小是动态变化的。</li>\n<li>ArrayList 处理固定大小的基本数据类型的时候，这种方式相对比较慢。</li>\n</ul>\n<h3 id=\"Comparable-和-Comparator-接口是干什么的\"><a href=\"#Comparable-和-Comparator-接口是干什么的\" class=\"headerlink\" title=\"Comparable 和 Comparator 接口是干什么的?\"></a>Comparable 和 Comparator 接口是干什么的?</h3><p><strong>Comparable</strong>：只包含一个 compareTo() 方法，这个方法可以个 给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于 已经存在的对象。<br><strong>Comparator</strong>：包含 compare() 和 equals() 两个方法。<br>    * compare() 方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小 于，等于，大于第二个参数。<br>    * equals() 方法需要一个对象作为参数，它用来决定输入 参数是否和 comparator 相等。</p>\n<h3 id=\"Collection-和-Collections-的区别？\"><a href=\"#Collection-和-Collections-的区别？\" class=\"headerlink\" title=\"Collection 和 Collections 的区别？\"></a>Collection 和 Collections 的区别？</h3><p><strong>Collection</strong>：是集合类的上级接口, 继承与它的接口主要是 set 和 list。<br><strong>Collections</strong>： 类是针对集合类的一个帮助类. 它提供一系列的静态方法对各种集合的搜 索, 排序, 线程安全化等操作。</p>\n<h3 id=\"ArrayList-和-Vector-的区别？\"><a href=\"#ArrayList-和-Vector-的区别？\" class=\"headerlink\" title=\"ArrayList 和 Vector 的区别？\"></a>ArrayList 和 Vector 的区别？</h3><p><strong>相同</strong>：<br>    * 都实现了 List 接口(List 接口继承了 Collection 接口)<br>    * 都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组<br>    * 允许重复</p>\n<p><strong>区别</strong>：<br>    * Vector 是线程安全的，ArrayList 是线程序不安全的。<br><strong>数据增长</strong>:<br>    * 相同：ArrayList 与 Vector 都可以设置初始的空间大小<br>    * 不同：Vector 还可以设置增长的空间大小，而 ArrayList 没有提供设置增长空间的方法。<br>           Vector 默认增加原来的 1 倍，ArrayList 增加原来的 0.5 倍。</p>\n<h3 id=\"快速失败-fail-fast-和安全失败-fail-safe-的区别是什么\"><a href=\"#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么\" class=\"headerlink\" title=\"快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么?\"></a>快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么?</h3><p>Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。</p>\n<p>java.util 包下面的所有的集合类都是快速失败的，迭代器会抛出 ConcurrentModificationException 异常<br>java.util.concurrent 包下面的所有的类都是安全失败的。安全失败的迭代器永远不会抛出这样的异常。</p>\n<h3 id=\"List、Map、Set-三个接口，存取元素时，各有什么特点\"><a href=\"#List、Map、Set-三个接口，存取元素时，各有什么特点\" class=\"headerlink\" title=\"List、Map、Set 三个接口，存取元素时，各有什么特点?\"></a>List、Map、Set 三个接口，存取元素时，各有什么特点?</h3><p>这样的题属于随意发挥题:这样的题比较考水平，两个方面的水平:一是要真正明白 这些内容，二是要有较强的总结和表述能力。如果你明白，但表述不清楚，在别人那 里则等同于不明白。</p>\n<p>首先List与Set<br>相同：<br>    * 都是单列元素的集合，有一个相同的父类 Collection<br>不同：<br>    * List 元素可以重复，Set不可以<br>    * List 可以按index取元素，Set只能逐一遍历<br>    * List 是有序集合。</p>\n<p>Map 是双列集合，要存储一对 key/value，不能存储重复的 key。</p>\n<h3 id=\"HashMap-的工作原理是什么\"><a href=\"#HashMap-的工作原理是什么\" class=\"headerlink\" title=\"HashMap 的工作原理是什么?\"></a>HashMap 的工作原理是什么?</h3><p>HashMap 1.8是 <strong>数组 + 链表 + 红黑树</strong> 实现的。</p>\n<ul>\n<li>负载因子（loadFactor）：0.75f</li>\n<li>容量（capacity）：16</li>\n<li>扩容阈值（threshold）：loadFactor * capacity</li>\n<li>转化成树的链表阈值（TREEIFY_THRESHOLD）：8</li>\n<li>转化成树的最小容量（MIN_TREEIFY_CAPACITY）：64<br>Java 中的 HashMap 是以键值对 (key-value) 的形式存储元素的，我们把一对(key-value)称为Node。<br>HashMap 需要 一个 hash 函数，当调用 put() 方法的时候，HashMap 会计算 key 的 hash 值，然后把键值对存储在集合中合适的索引上。<br>如果索引上已经存在了Node，发生哈希冲突。<ul>\n<li>如果索引上的结构是<strong>链表</strong>，则在链表中遍历，如果有相同的key，value 会被更新成新值，否则遍历到链表尾部，插入新的(key-value) ，size+1<ul>\n<li>如果链表的长度大于<strong>转化成树的链表阈值（TREEIFY_THRESHOLD）</strong> 并且，hashMap的容量大于<strong>转化成树的最小容量（MIN_TREEIFY_CAPACITY）</strong> 则转换成<code>红黑树</code>。</li>\n</ul>\n</li>\n<li>如果索引上的结构是<strong>红黑树</strong>，则在红黑树中遍历，如果有相同的key，value 会被更新成新值，否则插入红黑树，size+1。</li>\n</ul>\n</li>\n</ul>\n<p>如果 size &gt; threshold 则进行扩容。<br>    * 当原来的容量已经达到最大容量的时候，将阈值设置为Integer.MAX_VALUE，这样就不会再发生重构的情况<br>    * 将新的阈值设置为旧的阈值的两倍, 新的容量设置为旧容量的2倍。<br>    * 根据新容量新建一个Node数组，将旧数组中的元素全部取出，重新映射到新数组中</p>\n<h3 id=\"hashMap-容量为什么是-2-的幂次？\"><a href=\"#hashMap-容量为什么是-2-的幂次？\" class=\"headerlink\" title=\"hashMap 容量为什么是 2 的幂次？\"></a>hashMap 容量为什么是 2 的幂次？</h3><p>为了<strong>加快哈希计算</strong>以及<strong>减少哈希冲突</strong>。<br>为什么可以加快计算？<br>我们都知道为了找到 KEY 的位置在哈希表的哪个槽里面，需要计算 <strong>hash(KEY) % 数组长度</strong><br>但是 % 计算比 &amp; 慢很多，所以用 &amp; 代替 %，为了保证 &amp; 的计算结果等于 % 的结果需要把 length 减 1，也就是 <strong>hash(KEY) &amp; (length - 1)</strong><br>证明：当length 为2的幂次时，m % length = m &amp; (length-1)<br>     m 可以分成两部分 x（length的正数倍） 和 y（剩余部分） 因此 y的范围为 0 &lt;= y &lt;length<br>     m % length = (x + y)% length = x % length + y % length = 0 + y % length = y<br>     假设y 是 5 二进制 0101，length 为 8 二进制 1000 ，length -1 二进制 0111<br>     0101&amp;0111 = 0101 刚好将 5取出，因此成立</p>\n<p>为什么可以减少冲突？<br>假设现在数组的长度 length 可能是偶数也可能是奇数。<br>length 为偶数时，length-1 为奇数，奇数的二进制最后一位是 1，这样便保证了 hash &amp;(length-1) 的最后一位可能为 0，也可能为 1（这取决于 h 的值），即 &amp; 运算后的结果可能为偶数，也可能为奇数，<strong>这样便可以保证散列的均匀性。</strong><br>length 为奇数的话，很明显 length-1 为偶数，它的最后一位是 0，这样 hash &amp; (length-1) 的最后一位肯定为 0，即只能为偶数，这样任何 hash 值都只会被散列到数组的偶数下标位置上，这便<strong>浪费了近一半的空间</strong></p>\n<h3 id=\"ConcurrentHashMap-的工作原理是什么什么？\"><a href=\"#ConcurrentHashMap-的工作原理是什么什么？\" class=\"headerlink\" title=\"ConcurrentHashMap 的工作原理是什么什么？\"></a>ConcurrentHashMap 的工作原理是什么什么？</h3><ul>\n<li>JDK1.7:<br>  ConcurrentHashMap采用了<strong>数组+Segment+分段锁</strong>的方式实现。<br>  Segment：类似于HashMap的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表,同时又是一个ReentrantLock（Segment继承了ReentrantLock）。<br>  <img src=\"/JAVA/Interview/concurrentHashMap1.7.jpg\" alt=\"\"><br>  从上面的结构我们可以了解到，ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作。<br>  第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部。</li>\n<li>JDK1.8:<br>  采用了数组+链表+红黑树实现.<strong>彻底放弃了Segment转而采用的是Node，其设计思想也不再是JDK1.7中的分段锁思想。</strong><br>  Java8 ConcurrentHashMap结构基本上和Java8的HashMap一样，原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。</li>\n</ul>\n<h3 id=\"HashTable-、ConcurrentHashMap-和-hashMap-的区别？\"><a href=\"#HashTable-、ConcurrentHashMap-和-hashMap-的区别？\" class=\"headerlink\" title=\"HashTable 、ConcurrentHashMap 和 hashMap 的区别？\"></a>HashTable 、ConcurrentHashMap 和 hashMap 的区别？</h3><p>hashTable 默认初始容量是11，hashMap 和 ConcurrentHashMap 默认初始容量是16，<br>HashTable 在put和get方法上用了 synchronized 。ConcurrentHashMap 对每个node节点使用 synchronized</p>\n<h3 id=\"LinkedHashMap-工作原理？\"><a href=\"#LinkedHashMap-工作原理？\" class=\"headerlink\" title=\"LinkedHashMap 工作原理？\"></a>LinkedHashMap 工作原理？</h3><p>LinkedHashMap基于hashMap的基础上，对每个键值对(Node节点)多维护了一个before和after指针，每次插入时维护双向链表。<br>LinkedHashMap有序，可分为插入顺序和访问顺序两种。<br>如果是访问顺序，那put和get操作已存在的Entry时，都会把Entry移动到双向链表的表尾(其实是先删除再插入)。</p>\n<h3 id=\"TreeMap-工作原理？\"><a href=\"#TreeMap-工作原理？\" class=\"headerlink\" title=\"TreeMap 工作原理？\"></a>TreeMap 工作原理？</h3><p>底层红黑树实现。<br>TreeMap有序是通过Comparator来进行比较的，如果comparator为null，那么就使用自然顺序</p>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ 异常 ------------------------</span>\n</div>\n\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><h3 id=\"Java中的异常有哪几类？\"><a href=\"#Java中的异常有哪几类？\" class=\"headerlink\" title=\"Java中的异常有哪几类？\"></a>Java中的异常有哪几类？</h3><p>异常类有分为编译时异常和运行时异常<br>常见的编译时异常：<br>    * IOException<br>    * SQLException<br>    * parseException</p>\n<p>常见的运行时异常（RuntimeException）：<br>    * NullPointerException: 空指针异常,一般出现于数组,空对象的变量和方法<br>    * ArrayIndexOutOfBoundsException: 数组越界异常<br>    * NoClassDefFoundException: java运行时系统找不到所引用的类<br>    * NumberFormatException: 数据格式异常<br>    * OutOfMemoryException: 内存溢出异常<br>    * ArithmeticException: 算数异常,一般在被除数是0中<br>    * IllegalArgumentException: 非法参数异常</p>\n<h3 id=\"Error-和-Exception-区别是什么？\"><a href=\"#Error-和-Exception-区别是什么？\" class=\"headerlink\" title=\"Error 和 Exception 区别是什么？\"></a>Error 和 Exception 区别是什么？</h3><p>Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；<br>Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。</p>\n<h3 id=\"运行时异常和编译时异常区别是什么？\"><a href=\"#运行时异常和编译时异常区别是什么？\" class=\"headerlink\" title=\"运行时异常和编译时异常区别是什么？\"></a>运行时异常和编译时异常区别是什么？</h3><p>运行时异常：编译器不会对运行时异常进行检测，没有 try-catch，方法签名中也没有 throws 关键字声明，编译依然可以通过。如果出现了 RuntimeException, 那一定是程序员的错误<br>编译时异常：如果没有 try-catch，且方法签名中也没有用 throws 关键字声明可能抛出的异常，则编译无法通过。这类异常通常为应用环境中的错误，即外部错误，非应用程序本身错误，如文件找不到等。</p>\n<h3 id=\"throw-和-throws-的区别是什么？\"><a href=\"#throw-和-throws-的区别是什么？\" class=\"headerlink\" title=\"throw 和 throws 的区别是什么？\"></a>throw 和 throws 的区别是什么？</h3><p><strong>throw</strong> 关键字用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。<br><strong>throws</strong> 关键字用在方法签名处，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</p>\n<h3 id=\"Java内存溢出是什么？\"><a href=\"#Java内存溢出是什么？\" class=\"headerlink\" title=\"Java内存溢出是什么？\"></a>Java内存溢出是什么？</h3><p>内存溢出分三种情况。</p>\n<ul>\n<li>OutOfMemoryError： PermGen space 元空间<br>  这个区域主要用来保存加来的Class的一些信息，在程序运行期间属于永久占用的，Java的GC不会对他进行释放，所以如果启动的程序加载的信息比较大，超出了这个空间的大小，就会发生溢出错误；<br>  解决的办法无非就是增加空间分配了——增加java虚拟机中的XX:PermSize和XX:MaxPermSize参数的大小，其中XX:PermSize是初始永久保存区域大小，XX:MaxPermSize是最大永久保存区域大小。</li>\n<li>OutOfMemoryError：Java heap space<br>  heap 是Java内存中的堆区，主要用来存放对象，当对象太多超出了空间大小，GC又来不及释放的时候，就会发生溢出错误。<br>  一般来说，当已存在对象没有引用(即不可达)的时候，GC就会定时的来回收对象，释放空间。但是因为程序的设计问题，导致对象可达但是又没有用(即前文提到的内存泄露)，当这种情况越来越多的时候，问题就来了。<br>  针对这个问题，我们需要做一下两点： 1、检查程序，减少大量重复创建对象的死循环，减少内存泄露。 2、增加Java虚拟机中Xms（初始堆大小）和Xmx（最大堆大小）参数的大小。</li>\n<li>StackOverFlowError<br>  stack是Java内存中的栈空间，主要用来存放方法中的变量，参数等临时性的数据的，发生溢出一般是因为分配空间太小，或是执行的方法递归层数太多创建了占用了太多栈帧导致溢出。<br>  针对这个问题，除了修改配置参数-Xss参数增加线程栈大小之外，优化程序是尤其重要。</li>\n</ul>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ 反射 ------------------------</span>\n</div>\n\n<h2 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h2><h3 id=\"什么是反射？\"><a href=\"#什么是反射？\" class=\"headerlink\" title=\"什么是反射？\"></a>什么是反射？</h3><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；<br>这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p>\n<h3 id=\"什么是-Java-序列化？什么情况下需要序列化？\"><a href=\"#什么是-Java-序列化？什么情况下需要序列化？\" class=\"headerlink\" title=\"什么是 Java 序列化？什么情况下需要序列化？\"></a>什么是 Java 序列化？什么情况下需要序列化？</h3><p>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。<br>以下情况需要使用 Java 序列化：</p>\n<ul>\n<li>想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li>\n<li>想用套接字在网络上传送对象的时候；</li>\n<li>想通过RMI（远程方法调用）传输对象的时候。</li>\n</ul>\n<h3 id=\"动态代理是什么？有哪些应用？\"><a href=\"#动态代理是什么？有哪些应用？\" class=\"headerlink\" title=\"动态代理是什么？有哪些应用？\"></a>动态代理是什么？有哪些应用？</h3><p>动态代理是运行时动态生成代理类。</p>\n<p>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</p>\n<h3 id=\"怎么实现动态代理？\"><a href=\"#怎么实现动态代理？\" class=\"headerlink\" title=\"怎么实现动态代理？\"></a>怎么实现动态代理？</h3><p>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</p>\n<h3 id=\"JDK-动态代理为什么只能基于接口？\"><a href=\"#JDK-动态代理为什么只能基于接口？\" class=\"headerlink\" title=\"JDK 动态代理为什么只能基于接口？\"></a>JDK 动态代理为什么只能基于接口？</h3><p>java的代理对象自动继承了Proxy，又因为JAVA是单继承的，所以目标对象只能实现接口不能继承。</p>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ JVM ------------------------</span>\n</div>\n\n<h2 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h2><h3 id=\"什么是JVM？什么是hotspot？\"><a href=\"#什么是JVM？什么是hotspot？\" class=\"headerlink\" title=\"什么是JVM？什么是hotspot？\"></a>什么是JVM？什么是hotspot？</h3><p>JVM ——- 规范/标准<br>hotspot — 产品/实现</p>\n<h3 id=\"说一下-JVM-的主要组成部分？及其作用？\"><a href=\"#说一下-JVM-的主要组成部分？及其作用？\" class=\"headerlink\" title=\"说一下 JVM 的主要组成部分？及其作用？\"></a>说一下 JVM 的主要组成部分？及其作用？</h3><p><img src=\"/JAVA/Interview/1.png\" alt=\"\"></p>\n<ul>\n<li>类加载器（ClassLoader）</li>\n<li>运行时数据区（Runtime Data Area）</li>\n<li>执行引擎（Execution Engine）</li>\n<li>本地库接口（Native Interface）</li>\n</ul>\n<p>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，<br>           运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，<br>           因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，<br>           而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p>\n<h3 id=\"说一下类装载的执行过程？\"><a href=\"#说一下类装载的执行过程？\" class=\"headerlink\" title=\"说一下类装载的执行过程？\"></a>说一下类装载的执行过程？</h3><p><img src=\"/JAVA/Interview/2.png\" alt=\"\"><br>类装载分为以下 5 个步骤：</p>\n<ol>\n<li><strong>加载</strong>：将.class文件从磁盘读到内存<ul>\n<li>通过类的全限定名(com.xxx.xxx)+类加载器确定唯一的类，来获取定义此类的二进制字节流</li>\n<li>将这个类字节流代表的静态存储结构转为方法区的运行时数据结构</li>\n<li>在堆中生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口。</li>\n</ul>\n</li>\n<li><strong>检查</strong>：检查加载的 class 文件的正确性；<ul>\n<li>文件格式验证:验证字节流是否符合 Class 文件的规范，如 主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.</li>\n<li>元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。</li>\n<li>字节码验证:是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如:方法中的类型转换是否正确，跳转指令是否正确等。</li>\n<li>符号引用验证:基于方法区的存储结构验证，发生在解析中，是否可以将符号引用成功解析为直接引用。</li>\n</ul>\n</li>\n<li><strong>准备</strong>：给类中的静态变量分配内存空间；<ul>\n<li>public static int value = 123; //此时在准备阶段过后的初始值为0而不是123，在初始化过程才会被赋值为123</li>\n<li>public static final int value = 123;//value的值在准备阶段过后就是123。</li>\n</ul>\n</li>\n<li><strong>解析</strong>：虚拟机将常量池中的符号引用替换成直接引用的过程。<strong>符号引用就理解为一个标示，而在直接引用直接指向内存中的地址</strong>；</li>\n<li><strong>初始化</strong>：对静态变量和静态代码块执行初始化工作。</li>\n</ol>\n<h3 id=\"类加载器的种类？\"><a href=\"#类加载器的种类？\" class=\"headerlink\" title=\"类加载器的种类？\"></a>类加载器的种类？</h3><p><img src=\"/JAVA/Interview/3.png\" alt=\"\"></p>\n<ul>\n<li>启动类加载器(Bootstrap ClassLoader)：负责加载JRE的核心类库，如JRE目标下的rt.jar，charsets.jar等</li>\n<li>扩展类加载器(Extension ClassLoader)：负责加载JRE扩展目录ext中jar类包</li>\n<li>系统类加载器(Application ClassLoader)：负责加载ClassPath路径下的类包</li>\n<li>用户自定义加载器(User ClassLoader)：负责加载用户自定义路径下的类包</li>\n</ul>\n<h3 id=\"什么是双亲委派模型？\"><a href=\"#什么是双亲委派模型？\" class=\"headerlink\" title=\"什么是双亲委派模型？\"></a>什么是双亲委派模型？</h3><p><img src=\"/JAVA/Interview/4.png\" alt=\"\"><br>如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p>\n<h3 id=\"双亲委派模式的优势\"><a href=\"#双亲委派模式的优势\" class=\"headerlink\" title=\"双亲委派模式的优势?\"></a>双亲委派模式的优势?</h3><ul>\n<li>沙箱安全机制:比如自己写的String.class类不会被加载，这样可以防止核心库被随意篡改</li>\n<li>避免类的重复加载:当父ClassLoader已经加载了该类的时候，就不需要子ClassLoader再加载一次   </li>\n</ul>\n<h3 id=\"为什么要打破双亲委派模式\"><a href=\"#为什么要打破双亲委派模式\" class=\"headerlink\" title=\"为什么要打破双亲委派模式?\"></a>为什么要打破双亲委派模式?</h3><p>例如：tomcat<br>Tomcat是个web容器,可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。<br>如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加载器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。</p>\n<h3 id=\"JVM-运行时数据区？\"><a href=\"#JVM-运行时数据区？\" class=\"headerlink\" title=\"JVM 运行时数据区？\"></a>JVM 运行时数据区？</h3><p><img src=\"/JAVA/Interview/5.png\" alt=\"\"></p>\n<ul>\n<li>程序计数器（Program Counter Register）: 前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</li>\n<li>Java 虚拟机栈（Java Virtual Machine Stacks）: 用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</li>\n<li>本地方法栈（Native Method Stack）: 与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</li>\n<li>Java 堆（Java Heap）: Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</li>\n<li>方法区（Methed Area）: 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li>\n</ul>\n<h3 id=\"Java-中都有哪些引用类型？\"><a href=\"#Java-中都有哪些引用类型？\" class=\"headerlink\" title=\"Java 中都有哪些引用类型？\"></a>Java 中都有哪些引用类型？</h3><ul>\n<li>强引用：通常我们使用new操作符创建一个对象时所返回的引用即为强引用</li>\n<li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</li>\n<li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li>\n<li>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</li>\n</ul>\n<h3 id=\"Java-堆的结构是什么样子的\"><a href=\"#Java-堆的结构是什么样子的\" class=\"headerlink\" title=\"Java 堆的结构是什么样子的?\"></a>Java 堆的结构是什么样子的?</h3><p><img src=\"/JAVA/Interview/6.jpeg\" alt=\"\"><br>堆空间一般分为新生代、老年代。</p>\n<h3 id=\"什么是新生代？\"><a href=\"#什么是新生代？\" class=\"headerlink\" title=\"什么是新生代？\"></a>什么是新生代？</h3><p>新生代分为两部分:<code>伊甸区</code>(Eden space)和<code>幸存者区</code>(Survivor space)，所有的类都是在伊甸区被new出来的。<br>幸存区(Survivor space):分为From和To区,TO区永远保持空。<br>当Eden区的空间用完是，程序又需要创建对象，JVM的垃圾回收器将Eden区进行垃圾回收(<code>Minor GC</code>)，将Eden区中的不再被其它对象应用的对象进行销毁。<br>然后将Eden区中剩余的对象移到From Survivor区。若From Survivor区也满了，再对该区进行垃圾回收，然后移动到To Survivor区，From区为空后，将To和From区转换，保证To区为空，并且对象年龄加一。<br>当对象年龄默认加到15（因为<strong>对象头只有4个bits</strong>是存对象年龄，最大为15）时将剩下的对象移到老年代。</p>\n<h3 id=\"什么是老年代？\"><a href=\"#什么是老年代？\" class=\"headerlink\" title=\"什么是老年代？\"></a>什么是老年代？</h3><p>新生代经过多次GC仍然存货的对象移动到老年区。<br>若老年代也满了，这时候将发生Major GC(也可以叫<code>Full GC</code>)， 进行老年区的内存清理。<br>若老年区执行了Full GC之后发现依然无法进行对象的保存，就会抛出 OOM(OutOfMemoryError)异常.</p>\n<h3 id=\"Survivor区-到-老年代有什么条件？\"><a href=\"#Survivor区-到-老年代有什么条件？\" class=\"headerlink\" title=\"Survivor区 到 老年代有什么条件？\"></a>Survivor区 到 老年代有什么条件？</h3><p>对象年龄到15，才会移动到老年代。因为<strong>对象头只有4个bits</strong>是存对象年龄，最大为15</p>\n<h3 id=\"JVM-有哪些垃圾回收算法？\"><a href=\"#JVM-有哪些垃圾回收算法？\" class=\"headerlink\" title=\"JVM 有哪些垃圾回收算法？\"></a>JVM 有哪些垃圾回收算法？</h3><ul>\n<li><strong>标记-清除算法</strong>：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</li>\n<li><strong>标记-整理算法</strong>：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li>\n<li><strong>复制算法</strong>：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li>\n<li><strong>分代算法</strong>：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</li>\n</ul>\n<h3 id=\"JVM-有哪些垃圾回收器？\"><a href=\"#JVM-有哪些垃圾回收器？\" class=\"headerlink\" title=\"JVM 有哪些垃圾回收器？\"></a>JVM 有哪些垃圾回收器？</h3><ul>\n<li>Serial：最早的单线程串行垃圾回收器。<strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></li>\n<li>Serial Old：Serial 垃圾回收器的老年代版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。采用<strong>标记-整理</strong>算法。</li>\n<li>ParNew：是 Serial 的多线程版本。<strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></li>\n<li>Parallel： 是 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。<strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></li>\n<li>Parallel Old： 是 Parallel 老年代版本，，Parallel Old 使用的是<strong>标记-整理</strong>的内存回收算法。</li>\n<li>CMS：一种以获得最短停顿时间为目标的收集器，第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作。是一种<strong>标记-清除</strong>算法实现<ul>\n<li>初始标记(CMS initial mark): 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 </li>\n<li>并发标记(CMS concurrent mark): <strong>同时开启GC和用户线程</strong>，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>\n<li>重新标记(CMS remark): 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶 段时间短</li>\n<li>并发清除(CMS concurrent sweep): 开启用户线程，同时GC线程开始对为标记的区域做清扫。</li>\n</ul>\n</li>\n<li>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。G1从整体来看是基于<strong>标记整理</strong>算法实现的收集器;从局部上来看是基于<strong>标记复制</strong>算法实现的</li>\n</ul>\n<h3 id=\"堆栈的区别？\"><a href=\"#堆栈的区别？\" class=\"headerlink\" title=\"堆栈的区别？\"></a>堆栈的区别？</h3><ul>\n<li>功能方面：堆是用来存放对象的，栈是用来执行程序的。</li>\n<li>共享性：堆是线程共享的，栈是线程私有的。</li>\n<li>空间大小：堆大小远远大于栈。</li>\n</ul>\n<h3 id=\"怎么判断对象是否可以被回收？\"><a href=\"#怎么判断对象是否可以被回收？\" class=\"headerlink\" title=\"怎么判断对象是否可以被回收？\"></a>怎么判断对象是否可以被回收？</h3><p><strong>引用计数器</strong>：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；<br><strong>可达性分析</strong>：这个算法的基本思想就是通过一系列的称为”GC Roots”的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象时不可用的。<br>    * <code>GC Roots根节点</code>:类加载器、Thread、虚拟机栈的局部变量表、static成员、常量引用、本地方法栈的变量等等.</p>\n<h3 id=\"JVM-调优的工具？\"><a href=\"#JVM-调优的工具？\" class=\"headerlink\" title=\"JVM 调优的工具？\"></a>JVM 调优的工具？</h3><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>\n<ul>\n<li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li>\n<li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li>\n</ul>\n<h3 id=\"JVM-调优的参数都有哪些？\"><a href=\"#JVM-调优的参数都有哪些？\" class=\"headerlink\" title=\"JVM 调优的参数都有哪些？\"></a>JVM 调优的参数都有哪些？</h3><p>-Xms2g：初始化推大小为 2g；<br>-Xmx2g：堆最大内存为 2g；<br>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；<br>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；<br>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br>-XX:+PrintGC：开启打印 gc 信息；<br>-XX:+PrintGCDetails：打印 gc 详细信息。</p>\n<h3 id=\"Java-中会存在内存泄漏吗？\"><a href=\"#Java-中会存在内存泄漏吗？\" class=\"headerlink\" title=\"Java 中会存在内存泄漏吗？\"></a>Java 中会存在内存泄漏吗？</h3><p>所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。<br>长生命周期的对象持有短生命周期对 象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需 要，但是因为长生命周期对象持有它的引用而导致不能被回收。</p>\n<h3 id=\"finalize-方法什么时候被调用\"><a href=\"#finalize-方法什么时候被调用\" class=\"headerlink\" title=\"finalize() 方法什么时候被调用?\"></a>finalize() 方法什么时候被调用?</h3><p>垃圾回收器(garbage colector)决定回收某对象时，就会运行该 对象的 finalize() 方法 但是在 Java 中很不幸，如果内存总是充 足的，那么垃圾回收可能永远不会进行，也就是说 filalize() 可能 永远不被执行，显然指望它做收尾工作是靠不住的。 那么 finalize() 究竟是做什么的呢? 它最主要的用途是回收特殊渠道申请的内存。Java 程序有垃圾回收器，所以一般情况下内存问题 不用程序员操心。但有一种 JNI(Java Native Interface)调用 non-Java 程序(C 或 C++)， finalize() 的工作就是回收这部分的内存。</p>\n<h3 id=\"深拷贝和浅拷贝区别是什么？\"><a href=\"#深拷贝和浅拷贝区别是什么？\" class=\"headerlink\" title=\"深拷贝和浅拷贝区别是什么？\"></a>深拷贝和浅拷贝区别是什么？</h3><ul>\n<li>浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制，指向同一个地址。</li>\n<li>深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。</li>\n</ul>\n<h3 id=\"如何实现对象克隆？\"><a href=\"#如何实现对象克隆？\" class=\"headerlink\" title=\"如何实现对象克隆？\"></a>如何实现对象克隆？</h3><ul>\n<li>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。</li>\n<li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</li>\n</ul>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ 多线程 ------------------------</span>\n</div>\n\n<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><h3 id=\"什么是线程安全？\"><a href=\"#什么是线程安全？\" class=\"headerlink\" title=\"什么是线程安全？\"></a>什么是线程安全？</h3><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 </p>\n<h3 id=\"如何保证线程安全？\"><a href=\"#如何保证线程安全？\" class=\"headerlink\" title=\"如何保证线程安全？\"></a>如何保证线程安全？</h3><ul>\n<li>synchronized关键字 </li>\n<li>用Lock锁</li>\n<li>volatile+CAS【单纯的volatile是轻量级的同步机制<strong>保证可见性但是不具备原子性</strong>所以要配合CAS来实现线程安全】</li>\n<li>atomic原子类</li>\n</ul>\n<h3 id=\"哪些集合类是线程安全的？\"><a href=\"#哪些集合类是线程安全的？\" class=\"headerlink\" title=\"哪些集合类是线程安全的？\"></a>哪些集合类是线程安全的？</h3><p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p>\n<h3 id=\"并行和并发有什么区别\"><a href=\"#并行和并发有什么区别\" class=\"headerlink\" title=\"并行和并发有什么区别?\"></a>并行和并发有什么区别?</h3><ul>\n<li>并行：多个处理器或多核处理器同时处理多个任务。( 两个队列和一台咖啡机 )</li>\n<li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。( 两个队列和两台咖啡机 )</li>\n</ul>\n<h3 id=\"线程和进程的区别\"><a href=\"#线程和进程的区别\" class=\"headerlink\" title=\"线程和进程的区别?\"></a>线程和进程的区别?</h3><p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p>\n<h3 id=\"守护线程是什么\"><a href=\"#守护线程是什么\" class=\"headerlink\" title=\"守护线程是什么?\"></a>守护线程是什么?</h3><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p>\n<h3 id=\"创建线程有哪几种方式\"><a href=\"#创建线程有哪几种方式\" class=\"headerlink\" title=\"创建线程有哪几种方式?\"></a>创建线程有哪几种方式?</h3><ul>\n<li>继承 Thread 重写 run 方法；</li>\n<li>实现 Runnable 接口；</li>\n<li>实现 Callable 接口。(可以获取线程执行之后的返回值)</li>\n<li>线程池</li>\n</ul>\n<h3 id=\"Runnable和Callable的区别\"><a href=\"#Runnable和Callable的区别\" class=\"headerlink\" title=\"Runnable和Callable的区别?\"></a>Runnable和Callable的区别?</h3><ul>\n<li>Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。</li>\n<li>Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。</li>\n<li>call方法可以抛出异常，run方法不可以。</li>\n<li>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li>\n</ul>\n<h3 id=\"线程有哪些状态\"><a href=\"#线程有哪些状态\" class=\"headerlink\" title=\"线程有哪些状态?\"></a>线程有哪些状态?</h3><ul>\n<li>NEW 尚未启动</li>\n<li>RUNNABLE 正在执行中</li>\n<li>BLOCKED 阻塞的（被同步锁或者IO锁阻塞）</li>\n<li>WAITING 永久等待状态</li>\n<li>TIMED_WAITING 等待指定的时间重新被唤醒的状态</li>\n<li>TERMINATED 执行完成</li>\n</ul>\n<p><img src=\"/JAVA/Interview/01.jpeg\" alt=\"\"></p>\n<h3 id=\"sleep-和-wait-有什么区别\"><a href=\"#sleep-和-wait-有什么区别\" class=\"headerlink\" title=\"sleep() 和 wait() 有什么区别?\"></a>sleep() 和 wait() 有什么区别?</h3><ul>\n<li>类的不同：sleep() 来自 Thread，wait() 来自 Object。</li>\n<li>释放锁：sleep() 不释放锁；wait() 释放锁。</li>\n<li>用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。</li>\n</ul>\n<h3 id=\"sleep-和-yield-区别？\"><a href=\"#sleep-和-yield-区别？\" class=\"headerlink\" title=\"sleep() 和 yield() 区别？\"></a>sleep() 和 yield() 区别？</h3><ul>\n<li>sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield() 方法只会给相同优先级或更高优先级的线程以运行的机会； </li>\n<li>线程执行 sleep() 方法后转入阻塞（blocked）状态，而执行 yield() 方法后转入就绪（Runnable）状态； </li>\n<li>sleep() 方法声明抛出InterruptedException，而 yield() 方法没有声明任何异常； </li>\n<li>sleep() 方法比 yield() 方法（跟操作系统相关）具有更好的可移植性。</li>\n</ul>\n<h3 id=\"notify-和-notifyAll-有什么区别？\"><a href=\"#notify-和-notifyAll-有什么区别？\" class=\"headerlink\" title=\"notify()和 notifyAll()有什么区别？\"></a>notify()和 notifyAll()有什么区别？</h3><ul>\n<li>notifyAll: 会唤醒所有的线程,会将全部线程由等待池移到锁池,然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争</li>\n<li>notify: 唤醒一个线程,具体唤醒哪一个线程由虚拟机控制。</li>\n</ul>\n<h3 id=\"线程的-run-和-start-有什么区别？\"><a href=\"#线程的-run-和-start-有什么区别？\" class=\"headerlink\" title=\"线程的 run() 和 start() 有什么区别？\"></a>线程的 run() 和 start() 有什么区别？</h3><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p>\n<h3 id=\"park-的作用\"><a href=\"#park-的作用\" class=\"headerlink\" title=\"park() 的作用\"></a>park() 的作用</h3><p>LockSupport类中的 park(Object blocker) 表示<strong>阻塞指定线程</strong>，参数blocker当前线程对象，使线程进入等待状态，释放cpu,并不会抛出中断异常<br>unpark(Thread thread) 唤醒指定线程，参数thread指定线程对象 </p>\n<h3 id=\"创建线程池有哪几种方式？\"><a href=\"#创建线程池有哪几种方式？\" class=\"headerlink\" title=\"创建线程池有哪几种方式？\"></a><code>创建线程池有哪几种方式？</code></h3><ol>\n<li>public static ExecutorService newCachedThreadPool() 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程，但是在之前构造的线程可用时将重用它们。</li>\n<li>public static ExecutorService newFixedThreadPool(int nThreads)  创建一个定长线程池，可控制线程最大并发数，以共享的无界队列方式来运行线程，超出的线程会在队列中等待。</li>\n<li>public static ExecutorService newSingleThreadExecutor() 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，以无界队列方式来运行线程，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li>\n<li>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 创建一个周期线程池，支持定时及周期性任务执行。</li>\n<li>public static ExecutorService newWorkStealingPool() 创建持有足够线程的线程池来支持给定的并行级别，并通过使用多个队列，减少竞争，它需要穿一个并行级别的参数，如果不传，则被设定为默认的CPU数量，这个线程池实际上是ForkJoinPool的扩展，适合使用在很耗时的任务中，能够合理的使用CPU进行并行操作。</li>\n</ol>\n<h3 id=\"线程池流程？\"><a href=\"#线程池流程？\" class=\"headerlink\" title=\"线程池流程？\"></a>线程池流程？</h3><p><img src=\"/JAVA/Interview/threadPoll.png\" alt=\"\"></p>\n<h3 id=\"线程池中-submit-和-execute-方法有什么区别？\"><a href=\"#线程池中-submit-和-execute-方法有什么区别？\" class=\"headerlink\" title=\"线程池中 submit() 和 execute() 方法有什么区别？\"></a>线程池中 submit() 和 execute() 方法有什么区别？</h3><ul>\n<li>execute()：只能执行 Runnable 类型的任务。</li>\n<li>submit()：可以执行 Runnable 和 Callable 类型的任务。</li>\n</ul>\n<h3 id=\"什么是CAS？\"><a href=\"#什么是CAS？\" class=\"headerlink\" title=\"什么是CAS？\"></a>什么是CAS？</h3><p>全称Compare and swap，比较并交换。<br>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存值修改为 B<br>java 的 CAS 利用的的是 unsafe（该类都是基于JVM对操作系统进行的操作，因此是unsafe）这个类提供的 CAS 操作<br>unsafe 的CAS 依赖了的 JVM 针对不同的操作系统实现的 Atomic::cmpxchg<br>Atomic::cmpxchg 的实现使用了汇编的 cas 操作，并使用 cpu 硬件提供的 lock信号保证其原子性</p>\n<h3 id=\"CAS有什么问题？\"><a href=\"#CAS有什么问题？\" class=\"headerlink\" title=\"CAS有什么问题？\"></a>CAS有什么问题？</h3><p>ABA问题。<br>举个例子：<br>假设有一个遵循CAS原理的提款机，小灰有100元存款，要用这个提款机来提款50元。<br>由于提款机硬件出了点小问题，小灰的提款操作被同时提交两次，开启了两个线程，两个线程都是获取当前值100元，要更新成50元。<br>理想情况下，应该一个线程更新成功，另一个线程更新失败，小灰的存款只被扣一次。<br>线程1首先执行成功，把余额从100改成50。线程2因为某种原因阻塞了。这时候，小灰的妈妈刚好给小灰汇款50元。<br>线程2仍然是阻塞状态，线程3执行成功，把余额从50改成100。<br>线程2恢复运行，由于阻塞之前已经获得了“当前值”100，并且经过compare检测，此时存款实际值也是100，所以成功把变量值100更新成了50。<br>小灰凭空少了50元钱。</p>\n<p>解决方案：<br>使用携带版本的号的AtomicStampedReference</p>\n<h3 id=\"什么是AQS？\"><a href=\"#什么是AQS？\" class=\"headerlink\" title=\"什么是AQS？\"></a>什么是AQS？</h3><p>AbstractQueuedSynchronizer，抽象队列同步器<br>AQS就是一个并发包的基础组件，是一个抽象类，用来实现各种锁，各种同步组件的。<br>它包含了state变量、加锁线程、等待队列等并发中的核心组件。常见的实现类有:ReentrantLock等。</p>\n<h3 id=\"AQS原理？\"><a href=\"#AQS原理？\" class=\"headerlink\" title=\"AQS原理？\"></a>AQS原理？</h3><ul>\n<li>AQS对象内部有一个核心的变量叫做<strong>state</strong>，是int类型的，代表了加锁的状态，初始状态下，这个state的值是0。</li>\n<li>AQS内部还有一个关键变量，用来记录<strong>当前加锁的是哪个线程</strong>，初始化状态下，这个变量是null。</li>\n<li>AQS内部还有一个<strong>等待队列</strong>，专门放那些加锁失败的线程</li>\n</ul>\n<p>当 线程1 尝试进行加锁，用CAS操作将state值从0变为1。如果CAS操作成功，将当前加锁线程设置成自己。<br>线程1 <strong>可重入加锁时，每次判断当前加锁线程是否是自己，是的话state+1</strong><br>当 线程2 尝试获取锁，用CAS操作将state值从0变为1，失败！！！然后检查当前加锁线程是否是自己，那当然不是。<br>线程2 会将自己放入AQS中的一个等待队列，等待 线程1 释放锁之后，自己就可以重新尝试加锁了。<br>线程1 释放锁就是将state变量的值递减1，将当前加锁线程设置成null。<br>接下来，会从<strong>等待队列的队头唤醒</strong> 线程2 重新尝试加锁。<br>重复上述过程。</p>\n<h3 id=\"ReentrantLock-原理？\"><a href=\"#ReentrantLock-原理？\" class=\"headerlink\" title=\"ReentrantLock 原理？\"></a>ReentrantLock 原理？</h3><p>ReentrantLock 可是分为公平锁和非公平锁，默认的构造函数是非公平锁<br>公平锁：当判断到锁状态字段state == 0 时，不会立马将当前线程设置为该锁的占用线程，而是去判断是在此线程之前是否有其他线程在等待这个锁，然后再CAS操作获取锁<br>非公平锁：没有判断是否有在此之前的排队线程，而是直接CAS操作进行获锁，此多个线程之间同时争用一把锁的时候，谁先获取到就变得随机了<br>加锁过程：<br>线程A，首先获取state的值判断是否为0，若state == 0。<br>    * 判断是自己是否需要排队<br>        * 若需要排队，也就是 队列的 head != tail 也就是队列已初始化了 并且 （head.next !=null 或 head.next.thread != 当前线程）<br>            * 将head.next 指向A，A.pre 指向head。<br>            * 判断A是否是排队的第一个线程<br>        * 若不需要排队，尝试进行加锁，用CAS操作将state值从0变为1。<br>            * 如果CAS操作成功，将当前加锁线程设置成自己。<br>            * 如果CAS操作失败，会检查当前加锁线程是否是自己。<br>                * 若是当前线程，就是重入锁，将state++。<br>                * 若不是当前线程，将线程放入等待队列。<br>                    * 如果队列为空，初始化一个thread=null的node作为队列的头head，将head.next 指向A，A.pre 指向head。<br>            * 判断A是否是排队的第一个线程<br>                * 如果A.pre == head ,表示A是排队的第一个线程，自旋两次尝试加锁，将A.pre 的ws值改为-1，若还失败则使用park()进行线程阻塞。<br>                * 如果不是，则直接使用park()进行线程阻塞。</p>\n<p>释放锁：<br>将state变量的值递减1，如果state == 0，将当前加锁线程设置成null。<br>如果队列不为空，将队列的head节点的ws值改为0，然后用unpark()唤醒 head.next也就是A线程，<br>然后将队列的head设置为A，A节点的thread设置为null。</p>\n<h3 id=\"什么是锁？\"><a href=\"#什么是锁？\" class=\"headerlink\" title=\"什么是锁？\"></a>什么是锁？</h3><p>锁(lock)或互斥(mutex)是一种同步机制，用于在有许多执行线程的环境中强制对资源的访问限制。锁旨在强制实施互斥排他、并发控制策略。<br>锁的作用就是保证多线程同步执行。</p>\n<h3 id=\"Java中有哪些锁？\"><a href=\"#Java中有哪些锁？\" class=\"headerlink\" title=\"Java中有哪些锁？\"></a>Java中有哪些锁？</h3><p>公平锁、非公平锁、读写锁、共享锁、互斥锁、自旋锁、偏向锁、轻量级锁、重量级锁等等。</p>\n<h3 id=\"什么是死锁？\"><a href=\"#什么是死锁？\" class=\"headerlink\" title=\"什么是死锁？\"></a>什么是死锁？</h3><p>线程A持有独占锁资源a，并尝试去获取独占锁资源b<br>同时，线程B持有独占锁资源b，并尝试去获取独占锁资源a<br>这样线程A和线程B相互持有对方需要的锁，从而发生阻塞，最终变为死锁。</p>\n<h3 id=\"死锁发生的必要条件？\"><a href=\"#死锁发生的必要条件？\" class=\"headerlink\" title=\"死锁发生的必要条件？\"></a>死锁发生的必要条件？</h3><ul>\n<li>互斥条件：一个资源每次只能被一个进程使用。</li>\n<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>\n<li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li>\n<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>\n</ul>\n<h3 id=\"怎么防止死锁？\"><a href=\"#怎么防止死锁？\" class=\"headerlink\" title=\"怎么防止死锁？\"></a>怎么防止死锁？</h3><ul>\n<li>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li>\n<li>尽量使用 Java. util. concurrent 并发类代替自己手写锁。</li>\n<li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li>\n<li>尽量减少同步的代码块。</li>\n</ul>\n<h3 id=\"当一个线程进入一个对象的一个-synchronized-方法后，其它线程是否可进入此对象的其它方法\"><a href=\"#当一个线程进入一个对象的一个-synchronized-方法后，其它线程是否可进入此对象的其它方法\" class=\"headerlink\" title=\"当一个线程进入一个对象的一个 synchronized 方法后，其它线程是否可进入此对象的其它方法?\"></a>当一个线程进入一个对象的一个 synchronized 方法后，其它线程是否可进入此对象的其它方法?</h3><ul>\n<li>其他方法前是否加了 synchronized 关键字，如果没加，则能。</li>\n<li>如果这个方法内部调用了 wait，则可以进入其他 synchronized 方法。</li>\n</ul>\n<h3 id=\"synchronized-l-XX-是锁了代码块还是对象？怎么实现？\"><a href=\"#synchronized-l-XX-是锁了代码块还是对象？怎么实现？\" class=\"headerlink\" title=\"synchronized(l){XX}是锁了代码块还是对象？怎么实现？\"></a>synchronized(l){XX}是锁了代码块还是对象？怎么实现？</h3><p>锁了对象l，那么是对l做了什么来表示l被锁了呢？上锁就是改变了对象头。</p>\n<h3 id=\"线程调度-优先级\"><a href=\"#线程调度-优先级\" class=\"headerlink\" title=\"线程调度(优先级)\"></a>线程调度(优先级)</h3><p>与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线 程获取 CPU 资源的概率较大，优先级低的并非没机会执行。<br>线程的优先级用 1-10 之 间的整数表示，数值越大优先级越高，默认的优先级为 5。 在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。</p>\n<h3 id=\"什么是线程饥饿？\"><a href=\"#什么是线程饥饿？\" class=\"headerlink\" title=\"什么是线程饥饿？\"></a>什么是线程饥饿？</h3><p>线程饥饿是另一种活跃性问题，也可以使程序无法执行下去。<br>如果一个线程因为处理器时间全部被其他线程抢走而得不到处理器运行时间，这种状态被称之为<code>饥饿</code><br>一般是由高优先级线程吞噬所有的低优先级线程的处理器时间引起的。</p>\n<h3 id=\"什么是活锁？\"><a href=\"#什么是活锁？\" class=\"headerlink\" title=\"什么是活锁？\"></a>什么是活锁？</h3><p>这两个线程虽然都没有停止运行，但是却无法向下执行，这种情况就是所谓的活锁。<br>举个例子，两个人在走廊上碰见，大家都互相很有礼貌，互相礼让，A从左到右，B也从从左转向右，发现又挡住了地方，继续转换方向，但又碰到了，反反复复，一直没有机会运行下去。</p>\n<ul>\n<li>当所有线程在序中执行 Object.wait(0)，参数为 0 的 wait 方法。程序将发生 活锁直到在相应的对象上有线程调用 Object.notify() 或者 Object.notifyAll()。</li>\n</ul>\n<h3 id=\"Volatile关键字的作用？\"><a href=\"#Volatile关键字的作用？\" class=\"headerlink\" title=\"Volatile关键字的作用？\"></a>Volatile关键字的作用？</h3><p>让其他线程能够马上感知到某一线程多某个变量的修改</p>\n<ul>\n<li>保证可见性:对共享变量的修改，其他的线程马上能感知到</li>\n<li>保证有序性:禁止重排序（编译阶段、指令优化阶段）volatile之前的代码不能调整到他的后面，volatile之后的代码不能调整到他的前面</li>\n</ul>\n<h3 id=\"volatile-能使得一个非原子操作变成原子操作吗\"><a href=\"#volatile-能使得一个非原子操作变成原子操作吗\" class=\"headerlink\" title=\"volatile 能使得一个非原子操作变成原子操作吗?\"></a>volatile 能使得一个非原子操作变成原子操作吗?</h3><p>在 Java 中除了 long 和 double 之外的所有基本类型的读和赋值，都是原子性操作。<br>而 64 位的 long 和 double 变量由于会被 JVM 当作两个分离的 32 位来进行操 作，所以不具有原子性，会产生字撕裂问题。但是当你定义 long 或 double 变量时， 如果使用 volatile 关键字，就会获到<strong>(只有简单的赋值与返回操作的)</strong>原子性。<br>不能保证其他情况的原子性。</p>\n<h3 id=\"synchronized-和-volatile-的区别是什么？\"><a href=\"#synchronized-和-volatile-的区别是什么？\" class=\"headerlink\" title=\"synchronized 和 volatile 的区别是什么？\"></a>synchronized 和 volatile 的区别是什么？</h3><ul>\n<li>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</li>\n<li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li>\n<li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li>\n</ul>\n<h3 id=\"synchronized-和-Lock-有什么区别？\"><a href=\"#synchronized-和-Lock-有什么区别？\" class=\"headerlink\" title=\"synchronized 和 Lock 有什么区别？\"></a>synchronized 和 Lock 有什么区别？</h3><ul>\n<li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li>\n<li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li>\n<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>\n</ul>\n<h3 id=\"synchronized-和-ReentrantLock-区别是什么？\"><a href=\"#synchronized-和-ReentrantLock-区别是什么？\" class=\"headerlink\" title=\"synchronized 和 ReentrantLock 区别是什么？\"></a>synchronized 和 ReentrantLock 区别是什么？</h3><ul>\n<li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li>\n<li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li>\n<li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</li>\n</ul>\n<p>性能区别：由于线程执行是交替执行。<br>jdk1.6 synchronized 是重量级锁，要频繁调用操作系统函数，交替执行，从用户态转到内核态效率低。<br>jdk1.8 synchronized 增加了偏向锁和轻量级锁，也是在jdk层面解决，所以和 ReentrantLock 性能差不多。<br>ReentrantLock 将线程交替执行放到jdk层面解决，所以比1.6的synchronized效率高<br>如果线程是单线程或者线程是交替执行，那么ReentrantLock队列不会进行初始化，不会发送阻塞，都在jdk层面运行。而1.6 synchronized需要调用os操作更改锁对象状态，然后进入同步块。</p>\n<h3 id=\"synchronized-底层实现原理？\"><a href=\"#synchronized-底层实现原理？\" class=\"headerlink\" title=\"synchronized 底层实现原理？\"></a>synchronized 底层实现原理？</h3><p>synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p>\n<h3 id=\"什么是Monitor？\"><a href=\"#什么是Monitor？\" class=\"headerlink\" title=\"什么是Monitor？\"></a>什么是Monitor？</h3><p>Monitor其实是一种同步工具，也可以说是一种同步机制，它通常被描述为一个对象,也常被翻译为“监视器\\管程”,每个对象都会有一个 monitor</p>\n<ul>\n<li>某一线程占有一个对象的时候，先看该对象的 monitor 的计数器是不是0，如果是0表示这个对象还没有线程占有，这个时候线程占有这个对象，并且对这个对象的monitor+1；如果不为0，表示这个对象已经被其他线程占有，这个线程等待。当线程释放占有权的时候，monitor-1；</li>\n<li>同一线程可以对同一对象进行多次加锁，+1，+1，体现了重入性</li>\n</ul>\n<h3 id=\"多线程中-synchronized-锁升级的原理是什么？\"><a href=\"#多线程中-synchronized-锁升级的原理是什么？\" class=\"headerlink\" title=\"多线程中 synchronized 锁升级的原理是什么？\"></a>多线程中 synchronized 锁升级的原理是什么？</h3><p>在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>\n<h3 id=\"什么是偏向锁？\"><a href=\"#什么是偏向锁？\" class=\"headerlink\" title=\"什么是偏向锁？\"></a>什么是偏向锁？</h3><p>当线程请求到锁对象后，将锁对象的状态标志位改为01，即偏向模式。然后使用CAS操作将线程的threadid记录在锁对象的Mark Word中。以后该线程可以直接进入同步块，连CAS操作都不需要。但是，一旦有第二条线程需要竞争锁，那么偏向模式立即结束，进入轻量级锁的状态。</p>\n<h3 id=\"什么是轻量级锁？\"><a href=\"#什么是轻量级锁？\" class=\"headerlink\" title=\"什么是轻量级锁？\"></a>什么是轻量级锁？</h3><p>从偏向锁的状态发生竞争后，会锁膨胀变成轻量级锁。<br>轻量级锁是在内存有一个锁记录，当某个线程获取到锁后，会将锁记录保存到线程内存中，同时将原本的锁记录指向它的线程内存中的备份锁记录位置。其他线程判断锁记录已经指向了其他线程，因此会进入自旋状态。达到一定的次数或时间后，会膨胀变成重量级锁。</p>\n<h3 id=\"悲观锁和乐观锁的概念？\"><a href=\"#悲观锁和乐观锁的概念？\" class=\"headerlink\" title=\"悲观锁和乐观锁的概念？\"></a>悲观锁和乐观锁的概念？</h3><ul>\n<li>乐观锁：乐观地认为所有的并发操作都是线程安全的，不需要加锁来处理。但为了保证数据没有被修改，会通过CAS操作来进行判定和替换。</li>\n<li>悲观锁：悲观地认为所有的并发操作都是线程不安全的，都需要加锁来保证线程安全</li>\n</ul>\n<h3 id=\"ThreadLocal-是什么？有哪些使用场景？\"><a href=\"#ThreadLocal-是什么？有哪些使用场景？\" class=\"headerlink\" title=\"ThreadLocal 是什么？有哪些使用场景？\"></a>ThreadLocal 是什么？有哪些使用场景？</h3><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>\n<p>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p>\n<h3 id=\"ThreadLocal原理？\"><a href=\"#ThreadLocal原理？\" class=\"headerlink\" title=\"ThreadLocal原理？\"></a>ThreadLocal原理？</h3><ul>\n<li>每个Thread维护着一个ThreadLocalMap的引用</li>\n<li>ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储</li>\n<li>调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值是传递进来的对象</li>\n<li>调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象</li>\n<li>ThreadLocal本身并不存储值，它只是作为一个key来让线程从ThreadLocalMap获取value。</li>\n</ul>\n<h3 id=\"ThreadLocal缺点？\"><a href=\"#ThreadLocal缺点？\" class=\"headerlink\" title=\"ThreadLocal缺点？\"></a>ThreadLocal缺点？</h3><p>由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏。<br>ThreadLocal由于真正存储数据的ThreadLocalMap只单纯地采取了数组的形式来存储数据，因此出现hash冲突时会为hash值就增加一个固定的大小0x61c88647进行线性寻找位置，会导致大量的hash冲突，造成很高的资源消耗。</p>\n<h3 id=\"什么是CyclicBarrier？\"><a href=\"#什么是CyclicBarrier？\" class=\"headerlink\" title=\"什么是CyclicBarrier？\"></a>什么是CyclicBarrier？</h3><p>栅栏(Barrier)类似于闭锁，他能阻塞一组线程直到某个事件发生后再全部同时执行。CyclicBarrier 字面意思是回环栅栏，回环的意思是它能够被重复利用，当然前提是在所有线程释放了以后。</p>\n<h3 id=\"什么是CountDownLatch？\"><a href=\"#什么是CountDownLatch？\" class=\"headerlink\" title=\"什么是CountDownLatch？\"></a>什么是CountDownLatch？</h3><p>CountDownLatch也叫闭锁,使得一(多)个主线程必须等待其他线程完成操作后再执行.<br>CountDownLatch内部维护一个计数器(父类的int state),主线程先执行await方法，如果此时计数器大于0，则阻塞等待。当一个线程完成任务后，计数器值减1。直到计数器为0时，表示所有的线程已经完成任务，等待的主线程被唤醒继续执行。</p>\n<h3 id=\"CyclicBarrier-和-CountDownLatch-的区别？\"><a href=\"#CyclicBarrier-和-CountDownLatch-的区别？\" class=\"headerlink\" title=\"CyclicBarrier 和 CountDownLatch 的区别？\"></a>CyclicBarrier 和 CountDownLatch 的区别？</h3><ul>\n<li>CyclicBarrier 是所有线程必须同时到达栅栏位置，才能继续执行。它用于等待其他线程，并且能够重置使用。</li>\n<li>CountDownLatch 用于等待事件，是一次性对象，一旦进入终止状态，就不能被重置。</li>\n<li>CountDownLatch 通常阻塞的是主线程，开锁以后主线程才继续执行。</li>\n<li>CyclicBarrier 阻塞的是子线程，到达栅栏位置后，每个线程还可以继续做自己后续的事情。</li>\n</ul>\n<h2 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h2><h3 id=\"字节流和字符流？\"><a href=\"#字节流和字符流？\" class=\"headerlink\" title=\"字节流和字符流？\"></a>字节流和字符流？</h3><p><img src=\"/JAVA/Interview/io.png\" alt=\"\"><br>字节流：以字节（8bit）为单位，能处理所有类型的数据<br>字符流：以字符为单位，根据码表映射字符，一次可能读多个字节，只能处理字符类型的数据。<br>InputStreamReader:字节到字符的桥梁<br>OutputStreamWriter:字符到字节的桥梁</p>\n<h3 id=\"NIO是什么？\"><a href=\"#NIO是什么？\" class=\"headerlink\" title=\"NIO是什么？\"></a>NIO是什么？</h3><p>NIO（Non-blocking I/O，在Java领域，也称为New I/O），是一种同步非阻塞的I/O模型。<br>说到NIO就得先从传统BIO（Blocking I/O）说起。<br>BIO：传统的网络通讯模型，就是BIO，同步阻塞IO<br>它其实就是服务端创建一个ServerSocket， 然后就是客户端用一个Socket去连接服务端的那个ServerSocket， ServerSocket接收到了一个的连接请求就创建一个Socket和一个线程去跟那个Socket进行通讯。<br>服务端会在等待连接、等待读取或者等待写入时发生阻塞。<br>这种方式的缺点：每次一个客户端接入，都需要在服务端创建一个线程来服务这个客户端。<br>这样大量客户端来的时候，就会造成服务端的线程数量可能达到了几千甚至几万，这样就可能会造成服务端过载过高，最后崩溃死掉。<br>因此我们要在BIO的基础上进行改进。</p>\n<p>假设一个单线程的Socket服务，那么它会在accept()也就是等待客户端连接时阻塞，当有客户端A连接时，服务端会等待read()服务端发来的的数据。<br>首先，如果可以让read（）不阻塞，那么在客户端A连接之后，如果读到数据，就进行逻辑操作，如果没读到数据，我们就继续等待下一个客户端连接<br>那么此时有客户端B连接，这时A发送数据，就接受不到数据了，所以我们再增加一个list保存socket连接，<br>也就是在A连接之后，我们就用list保存这个socket连接，然后轮询这个list，看看有没有客户端发送数据，有就处理，然后继续等待下一个客户端连接。<br>此时 accept（）操作还是阻塞的，在没有客户端连接时，还是接收不到数据。<br>如果可以让accept（）不阻塞，在没有客户端连接的时候，也进行轮询这个list，看看有没有客户端发送数据。<br>这样就实现了一个简单的nio。<br>java的nio就是将上述操作中的轮询操作交给操作系统来进行了。</p>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ Spring ------------------------</span>\n</div>\n\n<h1 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h1><h2 id=\"基础-1\"><a href=\"#基础-1\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"为什么要使用-spring？\"><a href=\"#为什么要使用-spring？\" class=\"headerlink\" title=\"为什么要使用 spring？\"></a>为什么要使用 spring？</h3><ul>\n<li>spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。</li>\n<li>spring 提供了事务支持，使得事务操作变的更加方便。</li>\n<li>spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。</li>\n<li>更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis 等。</li>\n</ul>\n<h3 id=\"spring-有哪些主要模块？\"><a href=\"#spring-有哪些主要模块？\" class=\"headerlink\" title=\"spring 有哪些主要模块？\"></a>spring 有哪些主要模块？</h3><ul>\n<li>spring core：框架的最基础部分，提供 ioc 和依赖注入特性。</li>\n<li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</li>\n<li>spring dao：Data Access Object 提供了JDBC的抽象层。</li>\n<li>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</li>\n<li>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</li>\n<li>spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。</li>\n</ul>\n<h3 id=\"spring-mvc流程\"><a href=\"#spring-mvc流程\" class=\"headerlink\" title=\"spring mvc流程\"></a>spring mvc流程</h3><p><img src=\"/JAVA/Interview/springmvc.png\" alt=\"\"></p>\n<h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><h3 id=\"什么是-aop？\"><a href=\"#什么是-aop？\" class=\"headerlink\" title=\"什么是 aop？\"></a>什么是 aop？</h3><p>aop 是面向切面编程，可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。<br>aop的应用场景：日志记录、权限验证、效率检查、事务管理、exception</p>\n<h3 id=\"AOP术语？\"><a href=\"#AOP术语？\" class=\"headerlink\" title=\"AOP术语？\"></a>AOP术语？</h3><ul>\n<li>切面(Aspect)：切面是通知和切点的结合，通知和切点共同定义了切面的全部内容</li>\n<li>连接点(Join point)：目标对象中的方法。</li>\n<li>通知(Advice)：定义了切面是做什么以及何时使用。</li>\n<li>切点(Pointcut)：表示连接点的集合。（PointCut是JoinPoint的谓语，这是一个动作，主要是告诉通知连接点在哪里，切点表达式决定 JoinPoint 的数量）</li>\n<li>目标对象(Target object)：目标对象 原始对象</li>\n<li>aop代理(AOP proxy)：代理对象  包含了原始对象的代码和增加后的代码的那个对象</li>\n<li>织入(Weaving)：把代理逻辑加入到目标对象上的过程</li>\n</ul>\n<h3 id=\"AOP实现原理？\"><a href=\"#AOP实现原理？\" class=\"headerlink\" title=\"AOP实现原理？\"></a>AOP实现原理？</h3><p>通过动态代理实现。动态代理又分为jdk动态代理和cglib动态代理。</p>\n<ul>\n<li>jdk动态代理：主要通过Proxy.newProxyInstance()和InvocationHandler这两个类和方法实现<ul>\n<li>实现过程<ul>\n<li>实现InvocationHandler接口，重写invoke()方法</li>\n<li>调用Proxy.newProxyInsatnce(classloader,interfaces,handler)方法生成代理类<ul>\n<li>生成的代理类为$Proxy0 extends Proxy implements Person</li>\n<li>因为已经继承了Proxy,所以java动态代理只能对接口进行代理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>总结： 代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h2><h3 id=\"什么是-ioc？\"><a href=\"#什么是-ioc？\" class=\"headerlink\" title=\"什么是 ioc？\"></a>什么是 ioc？</h3><p>控制反转，将你设计好的对象交给容器控制，可以用来减低计算机代码之间的耦合度。</p>\n<h3 id=\"什么是DI？\"><a href=\"#什么是DI？\" class=\"headerlink\" title=\"什么是DI？\"></a>什么是DI？</h3><p>DI是依赖注入，是实现IOC的一种方式。</p>\n<h3 id=\"spring-常用的注入方式有哪些？\"><a href=\"#spring-常用的注入方式有哪些？\" class=\"headerlink\" title=\"spring 常用的注入方式有哪些？\"></a>spring 常用的注入方式有哪些？</h3><ul>\n<li>setter 属性注入</li>\n<li>构造方法注入</li>\n<li>注解方式注入</li>\n</ul>\n<h3 id=\"spring-中的-bean-是线程安全的吗？\"><a href=\"#spring-中的-bean-是线程安全的吗？\" class=\"headerlink\" title=\"spring 中的 bean 是线程安全的吗？\"></a>spring 中的 bean 是线程安全的吗？</h3><p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。<br>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p>\n<ul>\n<li>有状态就是有数据存储功能。</li>\n<li>无状态就是不会保存数据。</li>\n</ul>\n<h3 id=\"spring-自动装配-bean-有哪些方式？\"><a href=\"#spring-自动装配-bean-有哪些方式？\" class=\"headerlink\" title=\"spring 自动装配 bean 有哪些方式？\"></a>spring 自动装配 bean 有哪些方式？</h3><ul>\n<li>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。</li>\n<li>byName：它根据 bean 的名称注入对象依赖项。</li>\n<li>byType：它根据类型注入对象依赖项。</li>\n<li>constructor：通过构造函数来注入依赖项，需要设置大量的参数。</li>\n</ul>\n<h3 id=\"Spring-beanFactory-和-factoryBean-的区别？\"><a href=\"#Spring-beanFactory-和-factoryBean-的区别？\" class=\"headerlink\" title=\"Spring beanFactory 和 factoryBean 的区别？\"></a>Spring beanFactory 和 factoryBean 的区别？</h3><p><strong>beanFactory</strong> 是Spring容器的顶层接口，用于管理Bean的一个工厂。 在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。<br><strong>FactoryBean</strong> 这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean，它能在需要的时候生产一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。</p>\n<p>通常情况下，bean 无须自己实现工厂模式，Spring 容器担任了工厂的 角色；但少数情况下，容器中的 bean 本身就是工厂，作用是产生其他 bean 实例。由工厂 bean 产生的其他 bean 实例，不再由 Spring 容器产生，因此与普通 bean 的配置不同，不再需要提供 class 元素。</p>\n<h3 id=\"BeanFactory和ApplicationContext是什么关系？\"><a href=\"#BeanFactory和ApplicationContext是什么关系？\" class=\"headerlink\" title=\"BeanFactory和ApplicationContext是什么关系？\"></a>BeanFactory和ApplicationContext是什么关系？</h3><p><img src=\"/JAVA/Interview/applicationContext.jpg\" alt=\"\"><br>最主要的区别是BeanFactory是延迟加载，ApplicationContext是即时加载。</p>\n<h3 id=\"spring-支持几种-bean-的作用域？\"><a href=\"#spring-支持几种-bean-的作用域？\" class=\"headerlink\" title=\"spring 支持几种 bean 的作用域？\"></a>spring 支持几种 bean 的作用域？</h3><ul>\n<li>singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；</li>\n<li>prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；</li>\n<li>Web 环境下的作用域：</li>\n<li>request：每次 http 请求都会创建一个 bean；</li>\n<li>session：同一个 http session 共享一个 bean 实例；</li>\n<li>global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。</li>\n</ul>\n<h3 id=\"spring-bean-容器的生命周期是什么样的？\"><a href=\"#spring-bean-容器的生命周期是什么样的？\" class=\"headerlink\" title=\"spring bean 容器的生命周期是什么样的？\"></a>spring bean 容器的生命周期是什么样的？</h3><ol>\n<li>Spring 容器根据配置中的 bean 定义，通过构造方法反射来实例化 bean。</li>\n<li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li>\n<li>如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。</li>\n<li>如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。</li>\n<li>如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。</li>\n<li>如果为 bean 指定了 init 方法（ <bean> 的 init-method 属性），那么将调用它。</bean></li>\n<li>最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。</li>\n<li>如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。</li>\n<li>如果为 bean 指定了 destroy 方法（ <bean> 的 destroy-method 属性），那么将调用它。</bean></li>\n</ol>\n<p><img src=\"/JAVA/Interview/bean.png\" alt=\"\"><br>1：实例化一个ApplicationContext的对象；<br>2：调用bean工厂后置处理器完成扫描；<br>3：循环解析扫描出来的类信息；<br>4：实例化一个BeanDefinition对象来存储解析出来的信息；<br>5：把实例化好的beanDefinition对象put到beanDefinitionMap当中缓存起来，以便后面实例化bean；<br>6：再次调用bean工厂后置处理器；<br>7：当然spring还会干很多事情，比如国际化，比如注册BeanPostProcessor等等，如果我们只关心如何实例化一个bean的话那么这一步就是spring调用finishBeanFactoryInitialization方法来实例化单例的bean，实例化之前spring要做验证，需要遍历所有扫描出来的类，依次判断这个bean是否Lazy，是否prototype，是否abstract等等；<br>8：如果验证完成spring在实例化一个bean之前需要推断构造方法，因为spring实例化对象是通过构造方法反射，故而需要知道用哪个构造方法；<br>9：推断完构造方法之后spring调用构造方法反射实例化一个对象；注意我这里说的是对象、对象、对象；这个时候对象已经实例化出来了，但是并不是一个完整的bean，最简单的体现是这个时候实例化出来的对象属性是没有注入，所以不是一个完整的bean；<br>10：spring处理合并后的beanDefinition(合并？是spring当中非常重要的一块内容)；<br>11：判断是否支持循环依赖，如果支持则提前把一个工厂存入singletonFactories——map；<br>12：判断是否需要完成属性注入<br>13：如果需要完成属性注入，则开始注入属性<br>14：判断bean的类型回调Aware接口<br>15：调用生命周期回调方法<br>16：如果需要代理则完成代理<br>17：put到单例池——bean完成——存在spring容器当中</p>\n<h3 id=\"Spring中的aware接口什么作用？\"><a href=\"#Spring中的aware接口什么作用？\" class=\"headerlink\" title=\"Spring中的aware接口什么作用？\"></a>Spring中的aware接口什么作用？</h3><p>BeanNameAware接口是为了让自身Bean能够感知到，获取到自身在Spring容器中的id属性，也就是beanName；<br>其他的Aware接口也是为了能够感知到自身的一些属性。<br>比如实现了ApplicationContextAware接口的类，能够获取到ApplicationContext。<br>实现了BeanFactoryAware接口的类，能够获取到BeanFactory对象。</p>\n<h3 id=\"Spring-在什么时候完成的依赖注入？\"><a href=\"#Spring-在什么时候完成的依赖注入？\" class=\"headerlink\" title=\"Spring 在什么时候完成的依赖注入？\"></a>Spring 在什么时候完成的依赖注入？</h3><p>在初始化的时候。也就是在new AnnotationConfigApplicationContext的时候</p>\n<h3 id=\"Spring中的循环依赖是怎么解决的？\"><a href=\"#Spring中的循环依赖是怎么解决的？\" class=\"headerlink\" title=\"Spring中的循环依赖是怎么解决的？\"></a>Spring中的循环依赖是怎么解决的？</h3><p>spring 单例情况下是支持循环依赖的。<br>假设A对象和B对象循环依赖，那么在初始化时会经历如下步骤：<br>创建A -&gt; 实例化A -&gt; 填充A的属性 -&gt; getBean(B) -&gt; 创建B -&gt; 实例化B -&gt; 填充B的属性-&gt; getBean(A)<br>-&gt; 若二级缓存中存在，将从二级缓存工厂中生产出的A放入三级缓存-&gt;从三级缓存中获取A-&gt;。。。</p>\n<h3 id=\"Resource-和-Autowired-的区别？\"><a href=\"#Resource-和-Autowired-的区别？\" class=\"headerlink\" title=\"@Resource 和 @Autowired 的区别？\"></a>@Resource 和 @Autowired 的区别？</h3><ul>\n<li>默认装配类型不一样：<ul>\n<li>@Autowired默认按type装配：默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。</li>\n<li>@Resource 默认按照名称进行装配：当找不到与名称匹配的bean才会按照类型装配</li>\n</ul>\n</li>\n<li>bean 在初始化时 调用的后置处理器不一样，<ul>\n<li>@Autowired 调用的是 AutowiredAnnotationBeanPostProcessor()</li>\n<li>@Resource 调用的是 CommonAnnotationBeanPostProcessor()</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Spring-三级缓存？\"><a href=\"#Spring-三级缓存？\" class=\"headerlink\" title=\"Spring 三级缓存？\"></a>Spring 三级缓存？</h3><p>每一级缓存都是一个map。<br>一级：singletonObjects 单例池，主要存放单例 bean<br>二级：singletonFactories 主要存放ObjectFactory类型工厂对象<br>三级：earlySingletonObjects 从工厂中获取的spring 对象，也就是半成品bean<br>三级缓存存在的意义是防止工厂重复执行对对象的操作，提高性能。</p>\n<h3 id=\"Qualifier-注解有什么用？\"><a href=\"#Qualifier-注解有什么用？\" class=\"headerlink\" title=\"@Qualifier 注解有什么用？\"></a>@Qualifier 注解有什么用？</h3><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p>\n<h3 id=\"什么是事务传播行为？\"><a href=\"#什么是事务传播行为？\" class=\"headerlink\" title=\"什么是事务传播行为？\"></a>什么是事务传播行为？</h3><p>事务传播行为（propagation behavior）指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何运行。<br>例如：methodA方法调用methodB方法时，methodB是继续在调用者methodA的事务中运行呢，还是为自己开启一个新事务运行，这就是由methodB的事务传播行为决定的。</p>\n<ul>\n<li>PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，这是最常见的选择，也是<strong>Spring默认的事务传播行为。</strong><ul>\n<li>methodA 调用 methodB时，设置B为当前传播行为，A未开启事物，B在自己的事物中运行，A开启事物，则B加入A的事物，若A发生异常，则B会进行回滚操作。</li>\n</ul>\n</li>\n<li>PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。<ul>\n<li>A开启事物，B也创建自己的事物，若A发生异常，B不影响。</li>\n</ul>\n</li>\n<li>PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。<ul>\n<li>A未开启事物，则B以非事物方式执行，若A发生异常，B不影响；若A开启事物，则B加入A的事物，若A发生异常，则B会进行回滚操作。</li>\n</ul>\n</li>\n<li>PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。<ul>\n<li>A未开启事物，则直接抛出异常；若A开启事物，则B加入A的事物，若A发生异常，则B会进行回滚操作。</li>\n</ul>\n</li>\n<li>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<ul>\n<li>无论A开不开启事物，B都以非事物方式执行   </li>\n</ul>\n</li>\n<li>PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。<ul>\n<li>A未开启事物，则B以非事物方式执行；A开启事物，则抛出异常；</li>\n</ul>\n</li>\n<li>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。<ul>\n<li>A未开启事物，B在自己的事物中运行；若A开启事物，则在嵌套事物中执行，若A抛出异常，则B会回滚。</li>\n</ul>\n</li>\n</ul>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>---------------- 计算机网络 ----------------</span>\n</div>\n\n<h1 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h1><h2 id=\"基础-2\"><a href=\"#基础-2\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"OSI-的七层模型都有哪些？\"><a href=\"#OSI-的七层模型都有哪些？\" class=\"headerlink\" title=\"OSI 的七层模型都有哪些？\"></a>OSI 的七层模型都有哪些？</h3><p><img src=\"/JAVA/Interview/osi.jpeg\" alt=\"\"></p>\n<ul>\n<li>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</li>\n<li>数据链路层：负责建立和管理节点间的链路。</li>\n<li>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。</li>\n<li>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。</li>\n<li>会话层：向两个实体的表示层提供建立和使用连接的方法。</li>\n<li>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。</li>\n<li>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</li>\n</ul>\n<h2 id=\"http协议\"><a href=\"#http协议\" class=\"headerlink\" title=\"http协议\"></a>http协议</h2><p>Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协</p>\n<h3 id=\"HTTP的特性\"><a href=\"#HTTP的特性\" class=\"headerlink\" title=\"HTTP的特性\"></a>HTTP的特性</h3><ul>\n<li>HTTP构建于TCP/IP协议之上，默认端口号是80</li>\n<li>HTTP是无连接无状态的<ul>\n<li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>\n<li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><div class=\"note info\"><p>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求</p></div>\n\n<p>200 OK //客户端请求成功<br>301 Moved Permanently //永久重定向。<br>302 Found //暂时重定向。<br>400 Bad Request //客户端请求有语法错误，不能被服务器所理解<br>401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<br>403 Forbidden //服务器收到请求，但是拒绝提供服务<br>404 Not Found //请求资源不存在，eg：输入了错误的URL<br>500 Internal Server Error //服务器发生不可预期的错误<br>503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>\n<h3 id=\"HTTP-请求-响应的步骤？\"><a href=\"#HTTP-请求-响应的步骤？\" class=\"headerlink\" title=\"HTTP 请求/响应的步骤？\"></a>HTTP 请求/响应的步骤？</h3><ul>\n<li><strong>1、客户端连接到Web服务器</strong><br>  一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href=\"http://www.oakcms.cn。\" target=\"_blank\" rel=\"noopener\">http://www.oakcms.cn。</a></li>\n<li><strong>2、发送HTTP请求</strong><br>  通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</li>\n<li><strong>3、服务器接受请求并返回HTTP响应</strong><br>  Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</li>\n<li><strong>4、释放连接TCP连接</strong><br>  若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</li>\n<li><strong>5、客户端浏览器解析HTML内容</strong><br>  客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</li>\n</ul>\n<h3 id=\"浏览器请求过程？\"><a href=\"#浏览器请求过程？\" class=\"headerlink\" title=\"浏览器请求过程？\"></a>浏览器请求过程？</h3><ul>\n<li>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</li>\n<li>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</li>\n<li>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP三次握手的第三个报文的数据发送给服务器;</li>\n<li>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</li>\n<li>5、释放 TCP连接;</li>\n<li>6、浏览器将该 html 文本并显示内容;</li>\n</ul>\n<h3 id=\"get-和-post-请求有哪些区别？\"><a href=\"#get-和-post-请求有哪些区别？\" class=\"headerlink\" title=\"get 和 post 请求有哪些区别？\"></a>get 和 post 请求有哪些区别？</h3><p>从原理性看：</p>\n<ul>\n<li>根据HTTP规范，GET用于信息获取，而且应该是安全和幂等的</li>\n<li>根据HTTP规范，POST请求表示可能修改服务器上资源的请求</li>\n</ul>\n<p>从表面上看：</p>\n<ul>\n<li>GET请求的数据会附在URL后面，POST的数据放在HTTP包体，POST安全性比GET安全性高</li>\n<li>GET请求会被浏览器主动缓存，并且传递参数有大小限制，POST没有。</li>\n</ul>\n<h2 id=\"TCP／UDP协议\"><a href=\"#TCP／UDP协议\" class=\"headerlink\" title=\"TCP／UDP协议\"></a>TCP／UDP协议</h2><h3 id=\"tcp-和-udp的区别？\"><a href=\"#tcp-和-udp的区别？\" class=\"headerlink\" title=\"tcp 和 udp的区别？\"></a>tcp 和 udp的区别？</h3><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。<br>区别如下：</p>\n<ul>\n<li>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；</li>\n<li>tcp 提供可靠的服务（数据传输），udp 无法保证；</li>\n<li>tcp 面向字节流，udp 面向报文；</li>\n<li>tcp 数据传输慢，udp 数据传输快；</li>\n</ul>\n<h3 id=\"tcp协议是100-可靠的么？\"><a href=\"#tcp协议是100-可靠的么？\" class=\"headerlink\" title=\"tcp协议是100%可靠的么？\"></a>tcp协议是100%可靠的么？</h3><p>TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。</p>\n<h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。<br><img src=\"/JAVA/Interview/Handshake.png\" alt=\"\"></p>\n<ul>\n<li>第一次握手(SYN=1, seq=x):<br>客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。<br>发送完毕后，客户端进入 <code>SYN_SEND</code> 状态。</li>\n<li>第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):<br>服务器发回确认包(<code>ACK</code>)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。<br>发送完毕后，服务器端进入 <code>SYN_RCVD</code> 状态。</li>\n<li>第三次握手(ACK=1，seq=x+1,ACKnum=y+1)<br>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1<br>发送完毕后，客户端进入 <code>ESTABLISHED</code> 状态，当服务器端接收到这个包时，也进入 <code>ESTABLISHED</code> 状态，TCP 握手结束。</li>\n</ul>\n<h4 id=\"为什么需要三次握手，两次不行吗？\"><a href=\"#为什么需要三次握手，两次不行吗？\" class=\"headerlink\" title=\"为什么需要三次握手，两次不行吗？\"></a>为什么需要三次握手，两次不行吗？</h4><p>如果是用两次握手，则会出现下面这种情况：<br>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。<br>客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端<br>此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接。<br><strong>因此</strong>：不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，<code>浪费资源</code>。</p>\n<h4 id=\"什么是半连接队列？\"><a href=\"#什么是半连接队列？\" class=\"headerlink\" title=\"什么是半连接队列？\"></a>什么是半连接队列？</h4><p>服务器第一次收到客户端的 SYN 之后，就会处于 <code>SYN_RCVD</code> 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<code>半连接队列</code>。</p>\n<p>当然还有一个<code>全连接队列</code>，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>\n<h4 id=\"ISN-Initial-Sequence-Number-是固定的吗？\"><a href=\"#ISN-Initial-Sequence-Number-是固定的吗？\" class=\"headerlink\" title=\"ISN(Initial Sequence Number)是固定的吗？\"></a>ISN(Initial Sequence Number)是固定的吗？</h4><p>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，<code>每4ms加1</code> 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。</p>\n<p>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p>\n<h4 id=\"三次握手过程中可以携带数据吗？\"><a href=\"#三次握手过程中可以携带数据吗？\" class=\"headerlink\" title=\"三次握手过程中可以携带数据吗？\"></a>三次握手过程中可以携带数据吗？</h4><p>其实第三次握手的时候，是可以携带数据的。但是，<strong>第一次、第二次握手不可以携带数据</strong></p>\n<p>第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</p>\n<h4 id=\"SYN攻击是什么？\"><a href=\"#SYN攻击是什么？\" class=\"headerlink\" title=\"SYN攻击是什么？\"></a>SYN攻击是什么？</h4><p>在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.</p>\n<p>SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p>\n<h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。<br><img src=\"/JAVA/Interview/wave.png\" alt=\"\"></p>\n<ul>\n<li>第一次挥手(FIN=1，seq=x)<br>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。<br>发送完毕后，客户端进入 <code>FIN_WAIT_1</code> 状态。</li>\n<li>第二次挥手(ACK=1，ACKnum=x+1)<br>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。<br>发送完毕后，服务器端进入 <code>CLOSE_WAIT</code> 状态，客户端接收到这个确认包之后，进入 <code>FIN_WAIT_2</code> 状态，等待服务器端关闭连接。</li>\n<li>第三次挥手(FIN=1，seq=y)<br>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。<br>发送完毕后，服务器端进入 <code>LAST_ACK</code> 状态，等待来自客户端的最后一个ACK</li>\n<li>第四次挥手(ACK=1，ACKnum=y+1)<br>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <code>TIME_WAIT</code> 状态，等待可能出现的要求重传的 ACK 包。<br>服务器端接收到这个确认包之后，关闭连接，进入 <code>CLOSED</code> 状态。<br>客户端等待了某个固定时间（<code>两个最大段生命周期</code>，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 <code>CLOSED</code> 状态。</li>\n</ul>\n<h4 id=\"挥手为什么需要四次？\"><a href=\"#挥手为什么需要四次？\" class=\"headerlink\" title=\"挥手为什么需要四次？\"></a>挥手为什么需要四次？</h4><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。<br>但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，”你发的FIN报文我收到了”。<br>只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p>\n<h4 id=\"2MSL等待状态\"><a href=\"#2MSL等待状态\" class=\"headerlink\" title=\"2MSL等待状态\"></a>2MSL等待状态</h4><p>TIME_WAIT状态也成为2MSL等待状态。它是任何报文段被丢弃前在网络内的最长时间。</p>\n<ul>\n<li>保证客户端发送的最后一个ACK报文段能够到达服务端。<br>这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态。</li>\n<li>防止“已失效的连接请求报文段”出现在本连接中。<br> 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li>\n</ul>\n<h3 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h3><p>TCP协议里窗口机制有2种：一种是固定的窗口大小；一种是滑动的窗口。<br>这个窗口大小就是我们一次传输几个数据。<br>对所有数据帧按顺序赋予编号，发送方在发送过程中始终保持着一个发送窗口，只有落在发送窗口内的帧才允许被发送；<br>同时接收方也维持着一个接收窗口，只有落在接收窗口内的帧才允许接收。<br>这样通过调整发送方窗口和接收方窗口的大小可以实现<code>流量控制</code>。<br><strong>每个TCP/IP主机支持全双工数据传输，因此TCP有两个滑动窗口：一个用于接收数据，另一个用于发送数据。</strong><br><img src=\"/JAVA/Interview/slidingWindow%20%20.png\" alt=\"\"></p>\n<ul>\n<li>首先是<strong>第一次发送数据这个时候的窗口大小是根据链路带宽的大小来决定的</strong>。我们假设这个时候窗口的大小是3。</li>\n<li>这个时候接受方收到数据以后会对数据进行确认告诉发送方我下次希望手到的是数据是多少。这里我们看到接收方发送的ACK=3(这是发送方发送序列2的回答确认，下一次接收方期望接收到的是3序列信号)。</li>\n<li>这个时候发送方收到这个数据以后就知道我第一次发送的3个数据对方只收到了2个。就知道第3个数据对方没有收到。下次在发送的时候就从第3个数据开始发。这个时候窗口大小就变成了2 。 </li>\n<li>看到接收方发送的ACK是5就表示他下一次希望收到的数据是5，发送方就知道我刚才发送的2个数据对方收了这个时候开始发送第5个数据。</li>\n</ul>\n<p>只有在接收窗口向前滑动时（与此同时也发送了确认），发送窗口才有可能向前滑动。 当发送窗口和接收窗口的大小都等于1时，就是停止等待协议。</p>\n<h3 id=\"如果已经建立了连接，但是客户端突然出现故障了怎么办？\"><a href=\"#如果已经建立了连接，但是客户端突然出现故障了怎么办？\" class=\"headerlink\" title=\"如果已经建立了连接，但是客户端突然出现故障了怎么办？\"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>\n<h3 id=\"拥塞控制和流量控制的区别？\"><a href=\"#拥塞控制和流量控制的区别？\" class=\"headerlink\" title=\"拥塞控制和流量控制的区别？\"></a>拥塞控制和流量控制的区别？</h3><ul>\n<li>拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。</li>\n<li>流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。</li>\n</ul>\n<h3 id=\"TCP确认延迟机制？\"><a href=\"#TCP确认延迟机制？\" class=\"headerlink\" title=\"TCP确认延迟机制？\"></a>TCP确认延迟机制？</h3><p>接收方在收到数据后，并不会立即回复ACK,而是延迟一定时间。一般ACK延迟发送的时间为200ms，但这个200ms并非收到数据后需要延迟的时间。系统有一个固定的定时器每隔200ms会来检查是否需要发送ACK包。</p>\n<ol>\n<li>ACK是可以合并的，也就是指如果连续收到两个TCP包，并不一定需要ACK两次，只要回复最终的ACK就可以了，可以降低网络流量。</li>\n<li>如果接收方有数据要发送，那么就会在发送数据的TCP数据包里，带上ACK信息。这样做，可以避免大量的ACK以一个单独的TCP包发送，减少了网络流量。</li>\n</ol>\n<h3 id=\"TCP拥塞控制机制？\"><a href=\"#TCP拥塞控制机制？\" class=\"headerlink\" title=\"TCP拥塞控制机制？\"></a>TCP拥塞控制机制？</h3><ul>\n<li><p>慢启动：<br>  TCP在连接过程的三次握手完成后，开始传数据，并不是一开始向网络通道中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞<br>  而是根据初始的cwnd大小逐步增加发送的数据量，cwnd初始化为1个最大报文段(MSS)大小（这个值可配置不一定是1个MSS）；每当有一个报文段被确认，cwnd大小指数增长。<br>  开始 —&gt; cwnd = 1<br>  1个RTT(往返延迟)后 —&gt; cwnd = 2<em>1 = 2<br>  2个RTT后 —&gt; cwnd = 2</em>2= 4<br>  3个RTT后 —&gt; cwnd = 4*2 = 8</p>\n</li>\n<li><p>拥塞避免<br>  cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，一旦cwnd&gt;=ssthresh（大多数TCP的实现，通常大小都是65536），慢启动过程结束，拥塞避免阶段开始；<br>  此时窗口大小不再呈指数上升，而是以加法增加，避免增长过快导致网络拥塞。<br>  拥塞发生：当发生丢包进行数据包重传时，表示网络已经拥塞。分两种情况进行处理：</p>\n<pre><code>* 等到RTO（重传超时时间）超时，重传数据包\n* sshthresh = cwnd /2，cwnd 重置为 1</code></pre></li>\n<li><p>快重传<br>  对于接收方来说，如果接收方收到一个失序的报文段，就立即回送一个 ACK 给发送方<br>  当发送方收到了3个重复的ACK时，则发送方快速重传丢失的包（所谓失序的报文是指，用户没有按照顺序收到TCP报文段，比如接收方收到了报文 M1, M2, M4，那么M4就称为失序报文，也就是M3被丢失），而不必等待M3的重传计时器到期</p>\n</li>\n<li><p>快恢复<br>  一旦出现超时重传，或者收到第三个重复的 ack 时（快重传），TCP 会把慢启动门限 ssthresh 的值设置为 cwnd 值的一半，同时 cwnd = ssthresh</p>\n</li>\n</ul>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>---------------- 设计模式 ----------------</span>\n</div>\n\n<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>---------------- MyBatis ----------------</span>\n</div>\n\n<h1 id=\"MyBatis\"><a href=\"#MyBatis\" class=\"headerlink\" title=\"MyBatis\"></a>MyBatis</h1><h2 id=\"什么是-MyBatis\"><a href=\"#什么是-MyBatis\" class=\"headerlink\" title=\"什么是 MyBatis?\"></a>什么是 MyBatis?</h2><p>MyBatis 是一个可以自定义 SQL、存储过程和高级映射的持久层框架。</p>\n<h2 id=\"MyBatis-中-和-的区别是什么？\"><a href=\"#MyBatis-中-和-的区别是什么？\" class=\"headerlink\" title=\"MyBatis 中 #{}和 ${}的区别是什么？\"></a>MyBatis 中 #{}和 ${}的区别是什么？</h2><p>#{}是预编译处理，${}是字符替换。 </p>\n<p>在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。<br>Mybatis 在处理${}时，就是把${}替换成变量的值。</p>\n<h2 id=\"MyBatis-有几种分页方式？\"><a href=\"#MyBatis-有几种分页方式？\" class=\"headerlink\" title=\"MyBatis 有几种分页方式？\"></a>MyBatis 有几种分页方式？</h2><p><strong>逻辑分页</strong>： 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。</p>\n<p><strong>物理分页</strong>： 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。</p>\n<h2 id=\"MyBatis-逻辑分页和物理分页的区别是什么？\"><a href=\"#MyBatis-逻辑分页和物理分页的区别是什么？\" class=\"headerlink\" title=\"MyBatis 逻辑分页和物理分页的区别是什么？\"></a>MyBatis 逻辑分页和物理分页的区别是什么？</h2><ul>\n<li>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。</li>\n<li>物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</li>\n</ul>\n<h2 id=\"RowBounds-是一次性查询全部结果吗？为什么？\"><a href=\"#RowBounds-是一次性查询全部结果吗？为什么？\" class=\"headerlink\" title=\"RowBounds 是一次性查询全部结果吗？为什么？\"></a>RowBounds 是一次性查询全部结果吗？为什么？</h2><p>RowBounds 表面是在“所有”数据中检索数据，其实<strong>并非是一次性查询</strong>出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。</p>\n<h2 id=\"MyBatis-是否支持延迟加载？延迟加载的原理是什么？\"><a href=\"#MyBatis-是否支持延迟加载？延迟加载的原理是什么？\" class=\"headerlink\" title=\"MyBatis 是否支持延迟加载？延迟加载的原理是什么？\"></a>MyBatis 是否支持延迟加载？延迟加载的原理是什么？</h2><p>MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。<br>延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。<br>比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。</p>\n<h2 id=\"说一下-MyBatis-的一级缓存和二级缓存？\"><a href=\"#说一下-MyBatis-的一级缓存和二级缓存？\" class=\"headerlink\" title=\"说一下 MyBatis 的一级缓存和二级缓存？\"></a><code>说一下 MyBatis 的一级缓存和二级缓存？</code></h2><p><img src=\"/JAVA/Interview/mybatisCache.jpg\" alt=\"\"></p>\n<ul>\n<li>一级缓存：是SqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。</li>\n<li>二级缓存：是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。。<br>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。<br>缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</li>\n</ul>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>---------------- Kafka ----------------</span>\n</div>\n\n<h1 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h1><h2 id=\"kafka-流程？\"><a href=\"#kafka-流程？\" class=\"headerlink\" title=\"kafka 流程？\"></a>kafka 流程？</h2><p><img src=\"/JAVA/Interview/kafka.png\" alt=\"\"></p>\n<ul>\n<li>生产者：可以声明主题Topic、分区Partition、键 Key以及值 Value，主题和值是必须要声明的，分区和键可以不用指定。拥有相同key的消息将会被写到同一分区，若没有指定key则由分区器分配。</li>\n<li>topic：Topic中数据是顺序不可变序列，采用log追加方式写入，Topic的数据可存储在多个partition中。</li>\n<li>partition：每个 Partition 中的消息都是有序的，生产的消息被不断追加到 Partition log 上，其中的每一个消息都被赋予了一个唯一的 offset 值。 因此数据不会因消费而丢失，所以只要consumer指定offset，一个消息可被不同的consumer多次消费。kafka中只能保证partition中记录是有序的，而不保证topic中不同partition的顺序。</li>\n<li>Replication：同一个 partition 可能会有多个 replication，需要在这些 replication 之间选出一个 leader，producer 和 consumer 只与这个 leader 交互，其它 replication 作为 follower 从 leader 中复制数据。</li>\n<li>消费者：订阅topic是以一个消费组来订阅的，一个消费组里面可以有多个消费者。<strong>一个partition，只能被消费组里的一个消费者消费</strong>，但是可以同时被多个消费组消费。</li>\n</ul>\n<h2 id=\"kafka-可以脱离-zookeeper-单独使用吗？为什么？\"><a href=\"#kafka-可以脱离-zookeeper-单独使用吗？为什么？\" class=\"headerlink\" title=\"kafka 可以脱离 zookeeper 单独使用吗？为什么？\"></a>kafka 可以脱离 zookeeper 单独使用吗？为什么？</h2><p>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</p>\n<h2 id=\"kafka-有几种数据保留的策略？\"><a href=\"#kafka-有几种数据保留的策略？\" class=\"headerlink\" title=\"kafka 有几种数据保留的策略？\"></a>kafka 有几种数据保留的策略？</h2><p>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</p>\n<h2 id=\"kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？\"><a href=\"#kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？\" class=\"headerlink\" title=\"kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？\"></a>kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</h2><p>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p>\n<h2 id=\"什么情况会导致-kafka-运行变慢？\"><a href=\"#什么情况会导致-kafka-运行变慢？\" class=\"headerlink\" title=\"什么情况会导致 kafka 运行变慢？\"></a>什么情况会导致 kafka 运行变慢？</h2><ul>\n<li>cpu 性能瓶颈</li>\n<li>磁盘读写瓶颈</li>\n<li>网络瓶颈</li>\n</ul>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>---------------- MySQL ----------------</span>\n</div>\n\n<h1 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h1><h2 id=\"基础-3\"><a href=\"#基础-3\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"数据库的三范式是什么？\"><a href=\"#数据库的三范式是什么？\" class=\"headerlink\" title=\"数据库的三范式是什么？\"></a>数据库的三范式是什么？</h3><ul>\n<li>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</li>\n<li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li>\n<li>第三范式：任何非主属性不依赖于其它非主属性。<br><a href=\"https://zhuanlan.zhihu.com/p/92991575\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/92991575</a></li>\n</ul>\n<h3 id=\"char-和-varchar-的区别是什么？\"><a href=\"#char-和-varchar-的区别是什么？\" class=\"headerlink\" title=\"char 和 varchar 的区别是什么？\"></a>char 和 varchar 的区别是什么？</h3><ul>\n<li>char(n) ：<strong>固定长度类型</strong>，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</li>\n<li>varchar(n) ：<strong>可变长度</strong>，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。<br>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。<br>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</li>\n</ul>\n<h3 id=\"float-和-double-的区别是什么？\"><a href=\"#float-和-double-的区别是什么？\" class=\"headerlink\" title=\"float 和 double 的区别是什么？\"></a>float 和 double 的区别是什么？</h3><ul>\n<li>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。</li>\n<li>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</li>\n</ul>\n<h3 id=\"MySQL-常用的引擎？\"><a href=\"#MySQL-常用的引擎？\" class=\"headerlink\" title=\"MySQL 常用的引擎？\"></a>MySQL 常用的引擎？</h3><ul>\n<li>InnoDB 引擎：mysql 5.1 后默认的数据库引擎，提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。<pre><code>MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。\n但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。\n由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</code></pre></li>\n<li>MyIASM 引擎：不提供事务的支持，也不支持行级锁和外键。。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。<pre><code>MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。\n所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</code></pre></li>\n</ul>\n<h3 id=\"如何做-MySQL-的性能优化？\"><a href=\"#如何做-MySQL-的性能优化？\" class=\"headerlink\" title=\"如何做 MySQL 的性能优化？\"></a>如何做 MySQL 的性能优化？</h3><ul>\n<li>为搜索字段创建索引。</li>\n<li>避免使用 select *，列出需要查询的字段。</li>\n<li>垂直分割分表。</li>\n<li>选择正确的存储引擎。</li>\n</ul>\n<h3 id=\"left-join、right-join、inner-join的区别\"><a href=\"#left-join、right-join、inner-join的区别\" class=\"headerlink\" title=\"left join、right join、inner join的区别\"></a>left join、right join、inner join的区别</h3><ul>\n<li>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 </li>\n<li>right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录</li>\n<li>inner join(等值连接) 只返回两个表中联结字段相等的行</li>\n</ul>\n<h2 id=\"innodb\"><a href=\"#innodb\" class=\"headerlink\" title=\"innodb\"></a>innodb</h2><h3 id=\"innodb-体系结构？\"><a href=\"#innodb-体系结构？\" class=\"headerlink\" title=\"innodb 体系结构？\"></a>innodb 体系结构？</h3><p><img src=\"/JAVA/Interview/innodb-Architecture.png\" alt=\"\"></p>\n<h3 id=\"什么是redo-log？\"><a href=\"#什么是redo-log？\" class=\"headerlink\" title=\"什么是redo log？\"></a>什么是redo log？</h3><p>当数据库对数据做修改的时候，需要把数据页从磁盘读到buffer pool中，然后在buffer pool中进行修改，那么这个时候buffer pool中的数据页就与磁盘上的数据页内容不一致，称buffer pool的数据页为dirty page 脏数据。<br>如果发生非正常的DB服务重启，那么这些数据并没有同步到磁盘文件中（注意，同步到磁盘文件是个随机IO），会发生数据丢失。<br>如果这个时候，能够有一个文件，当缓冲池中的data page变更结束后，把相应修改记录记录到这个文件（注意，记录日志是顺序IO），那么当DB服务发生crash的情况，恢复DB的时候，也可以根据这个文件的记录内容，重新应用到磁盘文件，数据保持一致。<br>这个文件就是redo log ，用于记录 数据修改后的记录，顺序记录。<br><img src=\"/JAVA/Interview/redo-buffer.png\" alt=\"\"><br>重做日志支持以下三种情况触发刷新：<br>    * Master Thread每一秒将重做日志缓冲刷新到重做日志文件<br>    * 每次事务提交时将重做日志缓冲刷新到重做日志文件<br>    * 当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件</p>\n<h3 id=\"什么是undo-log？\"><a href=\"#什么是undo-log？\" class=\"headerlink\" title=\"什么是undo log？\"></a>什么是undo log？</h3><p>undo日志用于存放数据修改被修改前的值。<br>假设修改表中 id=1 的行数据，把Name=’B’ 修改为Name = ‘B2’ ，那么undo日志就会用来存放Name=’B’的记录，如果这个修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。</p>\n<h3 id=\"undo-和-redo-事物实现过程？\"><a href=\"#undo-和-redo-事物实现过程？\" class=\"headerlink\" title=\"undo 和 redo 事物实现过程？\"></a>undo 和 redo 事物实现过程？</h3><p>事务B要将字段A的值由原来的1修改为3，要将B的值由原来的2修改为4，redo日志记录的是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">假设有A、B两个数据，值分别为1,2.</span><br><span class=\"line\">1. 事务B开始</span><br><span class=\"line\">2. 记录A=1到undo log</span><br><span class=\"line\">3. 修改A=3</span><br><span class=\"line\">4. 记录A=3到 redo log</span><br><span class=\"line\">5. 记录B=2到 undo log</span><br><span class=\"line\">6. 修改B=4</span><br><span class=\"line\">7. 记录B=4到redo log</span><br><span class=\"line\">8. 将redo log写入磁盘</span><br><span class=\"line\">9. 事务提交，将数据写入磁盘</span><br><span class=\"line\">10.事物B结束</span><br></pre></td></tr></table></figure>\n\n<p>如果上面事务B回滚（当做新的事务C），则redo记录的是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 事务C开始</span><br><span class=\"line\">2. 记录A=1到undo log</span><br><span class=\"line\">3. 修改A=3</span><br><span class=\"line\">4. 记录A=3到 redo log</span><br><span class=\"line\">5. 记录B=2到 undo log</span><br><span class=\"line\">6. 修改B=4</span><br><span class=\"line\">7. 记录B=4到redo log</span><br><span class=\"line\">   &lt;!--回滚--&gt;</span><br><span class=\"line\">8. 修改B=2</span><br><span class=\"line\">9. 记录B=2到redo log</span><br><span class=\"line\">10.修改A=1</span><br><span class=\"line\">11.记录A=1到redo log</span><br><span class=\"line\">12.将redo log写入磁盘</span><br><span class=\"line\">13.事务提交，将数据写入磁盘</span><br><span class=\"line\">14.事物C结束</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Double-write解决了什么问题\"><a href=\"#Double-write解决了什么问题\" class=\"headerlink\" title=\"Double write解决了什么问题?\"></a>Double write解决了什么问题?</h3><ul>\n<li>数据库IO的最小单位是16K（MySQL默认，oracle是8K）</li>\n<li>文件系统IO的最小单位是4K（也有1K的）</li>\n<li>磁盘IO的最小单位是512字节</li>\n</ul>\n<p>一个数据页的大小是16K，假设在把内存中的脏页写到数据库的时候，写了8K突然宕机了，也就是说前8K数据是新的，后8K是旧的，那么磁盘数据库这个数据页就是不完整的，是一个坏掉的数据页，这种情况被称为部分写失效</p>\n<h3 id=\"为什么-redo-log-不需要-doublewrite-的支持？\"><a href=\"#为什么-redo-log-不需要-doublewrite-的支持？\" class=\"headerlink\" title=\"为什么 redo log 不需要 doublewrite 的支持？\"></a>为什么 redo log 不需要 doublewrite 的支持？</h3><p>因为 redo log 写入的单位就是 512 字节，也就是磁盘 IO 的最小单位，所以无所谓数据损坏。</p>\n<h3 id=\"页断裂可不可以通过-redo-log-来进行恢复呢？\"><a href=\"#页断裂可不可以通过-redo-log-来进行恢复呢？\" class=\"headerlink\" title=\"页断裂可不可以通过 redo log 来进行恢复呢？\"></a>页断裂可不可以通过 redo log 来进行恢复呢？</h3><p>redo记录的是对页的修改，只能恢复校验完整（还没写）的页，不能修复坏掉的数据页，所以这个数据就丢失了，可能会造成数据不一致，所以需要double write。</p>\n<h3 id=\"两次写工作流程？\"><a href=\"#两次写工作流程？\" class=\"headerlink\" title=\"两次写工作流程？\"></a>两次写工作流程？</h3><p><img src=\"/JAVA/Interview/doublewrite.png\" alt=\"\"><br>doublewrite由两部分组成，一部分为内存中的doublewrite buffer，其大小为2MB，另一部分是磁盘上共享表空间(ibdata x)中连续的128个页，即2个区(extent)，大小也是2M。</p>\n<ol>\n<li>当一系列机制触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先拷贝至内存中的doublewrite buffer中；</li>\n<li>接着从两次写缓冲区分两次写入磁盘共享表空间中(连续存储，顺序写，性能很高)，每次写1MB；</li>\n<li>待第二步完成后，再将doublewrite buffer中的脏页数据写入实际的各个表空间文件(离散写)；(脏页数据固化后，即进行标记对应doublewrite数据可覆盖) </li>\n</ol>\n<h3 id=\"为什么-double-write-可以解决页断裂？\"><a href=\"#为什么-double-write-可以解决页断裂？\" class=\"headerlink\" title=\"为什么 double write 可以解决页断裂？\"></a>为什么 double write 可以解决页断裂？</h3><ol>\n<li>磁盘还未写，此时可以通过 redo log 恢复；</li>\n<li>磁盘正在进行从内存到共享表空间的写，此时数据文件中的页还没开始被写入，因此也同样可以通过 redo log 恢复；</li>\n<li>磁盘正在写数据文件，此时共享表空间已经写完，可以从共享表空间拷贝页的副本到数据文件实现恢复。</li>\n</ol>\n<h2 id=\"事物\"><a href=\"#事物\" class=\"headerlink\" title=\"事物\"></a>事物</h2><h3 id=\"什么是事务？\"><a href=\"#什么是事务？\" class=\"headerlink\" title=\"什么是事务？\"></a>什么是事务？</h3><p>一个事务是可以被看作一个单元的一系列SQL语句的集合。它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。</p>\n<h3 id=\"事务的特性（ACID）-是什么？\"><a href=\"#事务的特性（ACID）-是什么？\" class=\"headerlink\" title=\"事务的特性（ACID） 是什么？\"></a>事务的特性（ACID） 是什么？</h3><ul>\n<li>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>\n<li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li>\n<li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>\n<li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>\n</ul>\n<h3 id=\"数据库的事务隔离级别？\"><a href=\"#数据库的事务隔离级别？\" class=\"headerlink\" title=\"数据库的事务隔离级别？\"></a>数据库的事务隔离级别？</h3><ul>\n<li>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</li>\n<li>READ-COMMITTED：提交读，读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。（会造成幻读、不可重复读）。</li>\n<li>REPEATABLE-READ：可重复读，默认级别。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。（会造成幻读）。</li>\n<li>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，这个事务执行的时候不允许别的事务并发执行。事务只能一个接着一个地执行。该隔离级别能防止脏读、不可重复读、幻读。</li>\n</ul>\n<blockquote>\n<p><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。<br><strong>不可重复读</strong> ：事务A读取数据后，事务B执行更新操作，使A无法再次读取结果。<br><strong>幻读</strong>：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。<br><strong>丢失修改</strong>：两个事务A，B读入同一数据并修改，B提交的结果被A破坏了，导致B的修改丢失。</p>\n</blockquote>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><h3 id=\"从数据库系统的角度来看分为几种？\"><a href=\"#从数据库系统的角度来看分为几种？\" class=\"headerlink\" title=\"从数据库系统的角度来看分为几种？\"></a>从数据库系统的角度来看分为几种？</h3><ol>\n<li><p>共享锁（S）<br> 共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。</p>\n</li>\n<li><p>更新锁（U）<br> 更新锁可以防止通常形式的死锁。一般更新模式由一个事务组成，此事务读取记录，获取资源（页或行）的共享锁，然后修改行，此操作要求锁转换为排它锁。</p>\n</li>\n<li><p>排他锁（X）<br> 排它锁可以防止并发事务对资源进行访问。其它事务不能读取或修改排它锁锁定的数据。</p>\n</li>\n<li><p>意向锁<br> 意向锁就是说在屋（比如代表一个表）门口设置一个标识，说明屋子里有人（比如代表某些记录）被锁住了。另一个人想知道屋子里是否有人被锁，不用进屋子里一个一个的去查，直接看门口标识就行了。</p>\n<ul>\n<li><p>意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得<strong>该表的IS锁</strong></p>\n</li>\n<li><p>意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得<strong>该表的IX锁。</strong></p>\n</li>\n<li><p>意向共享排他锁（SIX）：对一个数据对象加 SIX锁，表示对它加 S锁，再加IX锁，即 SIX=S+IX。例如对某个表加 SIX锁，则表示该事务要读整个表（所以要对该表加 S锁），同时会更新个别元组（所以要对该表加 IX锁）。</p>\n<p>当一个表中的某一行被加上排他锁后，该表就不能再被加表锁。数据库程序如何知道该表不能被加表锁？一种方式是逐条的判断该表的每一条记录是否已经有排他锁，另一种方式是直接在表这一层级检查表本身是否有意向锁，不需要逐条判断。显然后者效率高。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"什么是悲观锁？\"><a href=\"#什么是悲观锁？\" class=\"headerlink\" title=\"什么是悲观锁？\"></a>什么是悲观锁？</h3><p>悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。</p>\n<ul>\n<li>悲观锁的流程<ul>\n<li>在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。 </li>\n<li>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。</li>\n<li>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</li>\n<li>其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</li>\n</ul>\n</li>\n<li>优点与不足<br>  悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。<br>  但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；<br>  另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载,还有会降低了并行性.<br>  一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数</li>\n</ul>\n<h3 id=\"什么是乐观锁？\"><a href=\"#什么是乐观锁？\" class=\"headerlink\" title=\"什么是乐观锁？\"></a>什么是乐观锁？</h3><p>乐观锁 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。<br>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</p>\n<ul>\n<li>实现方式<ul>\n<li>对记录加版本号：在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</li>\n<li>对记录加时间戳：在数据初始化时使用时间戳（timestamp），在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK。</li>\n<li>对将要更新的数据进行提前读取、事后对比。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"什么是锁的粒度？\"><a href=\"#什么是锁的粒度？\" class=\"headerlink\" title=\"什么是锁的粒度？\"></a>什么是锁的粒度？</h3><p>锁的粒度就是指锁的生效范围，就是说是行锁，还是页锁，还是整表锁. 锁的粒度同样既可以由数据库自动管理，也可以通过手工指定hint来管理。</p>\n<h3 id=\"封锁协议？\"><a href=\"#封锁协议？\" class=\"headerlink\" title=\"封锁协议？\"></a>封锁协议？</h3><p><img src=\"/JAVA/Interview/sqllock.gif\" alt=\"\"></p>\n<ul>\n<li>一级封锁协议：对应READ-UNCOMMITTED 隔离级别，本质是在事务A中修改完数据M后，立刻对这个数据M加上共享锁(S锁)（当事务A继续修改数据M的时候，先释放掉S锁，再修改数据，再加上S锁），根据S锁的特性，事务B可以读到事务A修改后的数据(无论事务A是否提交，因为是共享锁，随时随地都能查到数据A修改后的结果)，事务B不能去修改数据M，直到事务A提交，释放掉S锁。<ul>\n<li>缺点：丢失更新。脏读。不可重复读。幻读。</li>\n</ul>\n</li>\n<li>二级封锁协议：对应READ-COMMITTED隔离级别，本质是事务A在修改数据M后立刻加X锁，事务B不能修改数据M，同时不能查询到最新的数据M(避免脏读)，查询到的数据M是上一个版本(Innodb MVCC快照)的。<ul>\n<li>缺点：丢失更新。不可重复读。幻读。</li>\n</ul>\n</li>\n<li>三级封锁协议：对应REPEATABLE-READ隔离级别,本质是二级封锁协议基础上，对读到的数据M瞬间加上共享锁M，直到事务结束才释放（保证了其他事务没办法修改该数据），这个级别是MySql 5.5 默认的隔离级别。<ul>\n<li>缺点：丢失更新。幻读。</li>\n</ul>\n</li>\n<li>最强封锁协议：对应Serialization隔离级别，本质是从MVCC并发控制退化到基于锁的并发控制，对事务中所有读取操作加S锁，写操作加X锁，这样可以避免脏读，不可重复读，幻读，更新丢失，开销也最大，会造成读写冲突，并发程度也最低。</li>\n</ul>\n<h2 id=\"MySQL-的行锁和表锁？\"><a href=\"#MySQL-的行锁和表锁？\" class=\"headerlink\" title=\"MySQL 的行锁和表锁？\"></a>MySQL 的行锁和表锁？</h2><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p>\n<ul>\n<li>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</li>\n<li>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</li>\n</ul>\n<h2 id=\"说一下乐观锁和悲观锁？\"><a href=\"#说一下乐观锁和悲观锁？\" class=\"headerlink\" title=\"说一下乐观锁和悲观锁？\"></a>说一下乐观锁和悲观锁？</h2><ul>\n<li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</li>\n<li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</li>\n</ul>\n<p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p>\n<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><h3 id=\"B-tree和Btree的区别？\"><a href=\"#B-tree和Btree的区别？\" class=\"headerlink\" title=\"B+tree和Btree的区别？\"></a>B+tree和Btree的区别？</h3><p>btree是每个节点都保存数据，而b+tree只有叶子节点保存数据，并且每个叶子节点都有指向前后叶子节点的指针。</p>\n<h3 id=\"InnoDB索引原理？\"><a href=\"#InnoDB索引原理？\" class=\"headerlink\" title=\"InnoDB索引原理？\"></a>InnoDB索引原理？</h3><p>数据库中的B+树索引可以分为<strong>聚集索引和辅助索引</strong>。<br>聚集索引(主键索引)：按照每张表的主键构造一颗B+树，同时叶子结点存放的即为整张表的行纪录数据也称为数据页。<br>辅助索引(非聚集索引)：按照每张表的索引构造一颗B+树，叶子节点存放该行数据的主键。</p>\n<p>当通过索引数据来查找数据的时候，存储引擎会遍历辅助索引并且通过叶级别的指针获取到指向主键索引的的主键，然后再通过主键索引来找到一个完整的记录；</p>\n<h3 id=\"性别为什么不能作为数据库索引\"><a href=\"#性别为什么不能作为数据库索引\" class=\"headerlink\" title=\"性别为什么不能作为数据库索引?\"></a>性别为什么不能作为数据库索引?</h3><p>对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。<br>在使用普通索引查询时，会先加载普通索引，通过普通索引查询到实际行的主键。再使用主键通过聚集索引查询相应的行。以此循环查询所有的行。<br>若直接全量搜索聚集索引，则不需要在普通索引和聚集索引中来回切换。<br>相比两种操作的总开销可能扫描全表效率更高。</p>\n<div style=\"text-align:center;color:#bfbfbf;font-size:16px;\">\n    <span>------------------------ Redis ------------------------</span>\n</div>\n\n<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><h2 id=\"Redis-是什么？都有哪些使用场景？\"><a href=\"#Redis-是什么？都有哪些使用场景？\" class=\"headerlink\" title=\"Redis 是什么？都有哪些使用场景？\"></a>Redis 是什么？都有哪些使用场景？</h2><p>Redis 是一个使用 C 语言开发的高速缓存数据库。<br>Redis 使用场景：</p>\n<ul>\n<li>记录帖子点赞数、点击数、评论数；</li>\n<li>缓存近期热帖；</li>\n<li>缓存文章详情信息；</li>\n<li>记录用户会话信息。</li>\n</ul>\n<h2 id=\"Redis-有哪些功能？\"><a href=\"#Redis-有哪些功能？\" class=\"headerlink\" title=\"Redis 有哪些功能？\"></a>Redis 有哪些功能？</h2><ul>\n<li>数据缓存功能</li>\n<li>分布式锁的功能</li>\n<li>支持数据持久化</li>\n<li>支持事务</li>\n<li>支持消息队列</li>\n</ul>\n<h2 id=\"Redis-支持的数据类型有哪些？\"><a href=\"#Redis-支持的数据类型有哪些？\" class=\"headerlink\" title=\"Redis 支持的数据类型有哪些？\"></a>Redis 支持的数据类型有哪些？</h2><p><img src=\"/JAVA/Interview/redis-shujujiegou.png\" alt=\"\"><br>Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。</p>\n<h2 id=\"Redis-为什么是单线程的？\"><a href=\"#Redis-为什么是单线程的？\" class=\"headerlink\" title=\"Redis 为什么是单线程的？\"></a>Redis 为什么是单线程的？</h2><p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。<br>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>\n<h2 id=\"Redis-单机数据库的好处？\"><a href=\"#Redis-单机数据库的好处？\" class=\"headerlink\" title=\"Redis 单机数据库的好处？\"></a>Redis 单机数据库的好处？</h2><ul>\n<li>纯内存</li>\n<li>单线程，避免频繁上下文切换</li>\n<li>采用<code>非阻塞IO多路复用？</code></li>\n</ul>\n<h2 id=\"Redis-持久化有几种方式？\"><a href=\"#Redis-持久化有几种方式？\" class=\"headerlink\" title=\"Redis 持久化有几种方式？\"></a>Redis 持久化有几种方式？</h2><ul>\n<li>RDB（Redis Database）：默认持久化方式，按一定的时间周期把内存的数据以快照的形式保存到硬盘的二进制文件<ul>\n<li>优点：<ul>\n<li>只有一个dump.rdb 方便持久化</li>\n<li>容灾性好，一个文件可以保存到安全的磁盘</li>\n<li>性能最大化，fork子进程来完成写操作，让主进程继续处理命令，IO最大化</li>\n<li>数据集大时，比AOF的效率高</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>数据安全性低，RDB隔一段时间就会进行持久化，如果持久化之间发生故障，会发生数据丢失</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中，当redis重启会重新执行文件保存的写命令来重建数据库<ul>\n<li>优点：<ul>\n<li>数据安全，aof可以配置为每进行一次命令就记录到AOF文件中</li>\n<li>通过append模式写文件，即使中途服务器宕机，可以通过redis-check-aof工具进行恢复</li>\n<li>rewrite模式：fork一个子进程进行AOF重写</li>\n</ul>\n</li>\n<li>缺点：AOF文件比RDB文件大，且恢复速度慢，数据集大时比RDB效率低。</li>\n</ul>\n</li>\n</ul>\n<p>两种模式同时开启，数据恢复优先选择AOF。</p>\n<h2 id=\"怎么保证缓存和数据库数据的一致性？\"><a href=\"#怎么保证缓存和数据库数据的一致性？\" class=\"headerlink\" title=\"怎么保证缓存和数据库数据的一致性？\"></a>怎么保证缓存和数据库数据的一致性？</h2><ul>\n<li>合理设置缓存的过期时间。</li>\n<li>新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</li>\n</ul>\n<h2 id=\"Redis-淘汰策略有哪些？\"><a href=\"#Redis-淘汰策略有哪些？\" class=\"headerlink\" title=\"Redis 淘汰策略有哪些？\"></a>Redis 淘汰策略有哪些？</h2><ul>\n<li>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</li>\n<li>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</li>\n<li>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</li>\n<li>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</li>\n<li>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。</li>\n<li>no-enviction（驱逐）：禁止驱逐数据。</li>\n</ul>\n<h2 id=\"Redis-过期策略？\"><a href=\"#Redis-过期策略？\" class=\"headerlink\" title=\"Redis 过期策略？\"></a>Redis 过期策略？</h2><ul>\n<li>redis默认每100ms随机抽取进行检查是否有过期的key</li>\n<li>在获取某个key时会检查，这个key如果设置了过期时间那么是否过期了，如果过期则删除</li>\n</ul>\n<h2 id=\"什么是缓存雪崩？\"><a href=\"#什么是缓存雪崩？\" class=\"headerlink\" title=\"什么是缓存雪崩？\"></a>什么是缓存雪崩？</h2><p>由于原有缓存失效，新缓存未到期间，原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成压力，严重会导致数据库宕机，整个系统崩溃<br><strong>解决方法</strong>：考虑用加锁或队列的方式来保证不会有大量线程对数据库一次性进行读写。或将缓存失效时间分散开</p>\n<h2 id=\"什么是缓存穿透？\"><a href=\"#什么是缓存穿透？\" class=\"headerlink\" title=\"什么是缓存穿透？\"></a>什么是缓存穿透？</h2><p>数据在数据库中没有，自然在缓存中也不会有，这就导致用户查询时缓存中找不到，都要去数据库再查一遍<br>解决方法：<br>    1. 布隆过滤器，将所有可能存在的数据哈希到足够大的bitmap中，一个一定不存在的数据会被bitmap拦截<br>    2. 如果查询数据为空（不管数据不存在还是系统故障）仍把这个空结果进行缓存</p>\n<h2 id=\"什么是缓存预热？\"><a href=\"#什么是缓存预热？\" class=\"headerlink\" title=\"什么是缓存预热？\"></a>什么是缓存预热？</h2><p>系统上线后将相关的缓存数据直接加载到缓存系统<br>解决方法：<br>    * 数据量不大，项目启动时自动进行加载<br>    * 定时刷新缓存</p>\n<h2 id=\"Redis-常见的性能问题有哪些？该如何解决？\"><a href=\"#Redis-常见的性能问题有哪些？该如何解决？\" class=\"headerlink\" title=\"Redis 常见的性能问题有哪些？该如何解决？\"></a>Redis 常见的性能问题有哪些？该如何解决？</h2><ul>\n<li>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。</li>\n<li>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</li>\n</ul>\n<h2 id=\"Redis-主从复制？\"><a href=\"#Redis-主从复制？\" class=\"headerlink\" title=\"Redis 主从复制？\"></a>Redis 主从复制？</h2><p>用户可执行slaveof命令或设置slaveof选项让一个服务器去复制另一个服务器</p>\n<ul>\n<li>旧版复制<ul>\n<li>同步sync：用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态<ul>\n<li>从服务器向主服务器发送sync命令</li>\n<li>收到sync命令的主服务器执行<strong>bgsave</strong>在后台生成RDB文件，并用一个缓冲区记录从现在开始执行的所有写命令</li>\n<li>当主服务器bgsave执行完毕时，主服务器会将RDB文件发送给从服务器，从服务器接收并载入rdb，将自己的数据库状态更新至主服务器执行bgsave时的数据状态</li>\n<li>主服务器将缓冲区中写命令发送给从服务器，从服务器执行写命令，更新状态</li>\n</ul>\n</li>\n<li>命令传播：由于主服务器的数据库状态被修改，导致主从状态不一致时让主从服务器的数据库重新回到一致<ul>\n<li>主服务器会将自己执行的写命令发送给从服务器执行，从而使主从状态一致</li>\n</ul>\n</li>\n<li>缺陷：在断线后重复制的效率非常低，需要执行sync命令全量生成并加载rdb文件</li>\n</ul>\n</li>\n<li>新版复制：使用psync代替sync，可以<strong>部分同步</strong>和<strong>全部同步</strong><ul>\n<li>全部同步：sync </li>\n<li>部分同步：psync<ul>\n<li>主服务器的复制偏移量和从服务器的复制偏移量<ul>\n<li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N</li>\n<li>从服务器收到N子节数据时就将自己的复制偏移量的值加N</li>\n</ul>\n</li>\n<li>主服务器的复制积压缓冲区<ul>\n<li>主服务器维护的一个固定长度先进先出队列，大小1M</li>\n<li>当主服务器命令传播时，还会将写命令入队到复制缓冲里，并且复制缓冲会为队列中每字节记录复制偏移量</li>\n<li>当从服务器重新连上主服务器，从会通过psync将自己的offset发给主服务器<ul>\n<li>如果offset之后的数据仍在复制积压缓冲里，执行部分重同步</li>\n<li>否则执行完整重同步</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>服务器的运行ID<ul>\n<li>当从服务器对主服务器进行初次复制时，主会将自己的运行ID传给从服务器，从服务器保存起来</li>\n<li>当从服务器断线重连，从服务器向当前连接的主发送之前保存的运行ID<ul>\n<li>如果和当前主服务器的ID相同，则可以尝试执行部分重同步</li>\n<li>否则执行完整重同步<h2 id=\"哨兵模式sentinel？\"><a href=\"#哨兵模式sentinel？\" class=\"headerlink\" title=\"哨兵模式sentinel？\"></a>哨兵模式sentinel？</h2>sentinel是高可用的解决方案，由一个或多个sentinel实例组成的sentinel系统，可以监视任意多个主从服务器，并在被监视的主服务器进入下线时，将从升为主服务器</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>启动哨兵<ul>\n<li>初始化服务器：sentinel并不使用数据库，初始化不会加载RDB或AOF</li>\n<li>使用sentinel专用代码、初始化sentinel状态、初始化sentinel状态的masters属性</li>\n<li>创建连向主服务器的异步网络连接<ul>\n<li>命令连接，向主服务器发送命令并接收命令回复</li>\n<li>订阅连接，专门用于订阅主服务器的<strong>sentinel</strong>:hello 频道</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>获取主服务器信息：默认每十秒一次，通过命令连接向被监视的主服务器发送INFO命令，并通过分析回复来获取状态，可以获取到主服务器信息，以及主服务器下所有从服务器信息</li>\n<li>获取从服务器信息：根据INFO命令回复</li>\n<li>向主从服务器发送信息：每两秒一次向服务器<strong>sentinel</strong>:hello频道发送一条信息</li>\n<li>接收主从服务器的频道信息</li>\n<li>更新sentinels字典</li>\n<li>创建连向其他sentinel的命令连接</li>\n<li>检测主观下线：每秒向所有与它创建了命令连接的实例发送PING，并通过返回的PING命令回复判断是否在线</li>\n<li>检测客观下线：<ul>\n<li>当一个主服务器主观下线后，为了确保主服务器真下线了，会向同样监视这服务器的其他sentinel进行询问</li>\n<li>当认为主服务器进入下线状态的sentinel数量超过配置中设置的quorum参数值，就进入客观下线状态</li>\n</ul>\n</li>\n<li>选举领头sentinel：当一个服务器客观下线时，监视该服务器的sentinel会选举出一个领头sentinel，并由领头进行故障转移<ul>\n<li>选举方式：<ul>\n<li>监视同一主服务器的在线sentinel都有资格</li>\n<li>每次选举无论成功与否，配置纪元的值都会自增一次</li>\n<li>在一个配置纪元里，所有sentinel都有一次将某个sentinel设置为局部头的机会，并且一旦设置不可更改</li>\n<li>每个发现主服务器进入客观下线的sentinel都会要求其他sentinel将自己设为局部头</li>\n<li>设置局部头的规则是先到先得，之后接收到的所有设置要求都会被拒绝</li>\n<li>如果有某个sentinel被半数以上设置成了局部头，那么就成为领头</li>\n<li>在给定时限内，没有一个被选举为领头，那么将在一段时间后再次选举</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>故障转移：<ul>\n<li>选出新的主服务器：从已下线主服务器的所有从服务器列表中筛选<ul>\n<li>删除列表中所有处于下线或者断线状态的从服务器</li>\n<li>删除列表中5s内没有回复过领头sentinel的info命令的从服务器</li>\n<li>删除所有与已下线服务器连接断开超过down-after-milliseconds*10毫秒的从服务器</li>\n<li>根据从服务器优先级排序，相同优先级按照从服务器复制偏移量排序，相同偏移量按运行ID最小排序</li>\n<li>向选出的从服务器发送SLAVEOF no one命令升级为主服务器 </li>\n</ul>\n</li>\n<li>修改从服务器的赋值目标<ul>\n<li>向其他从服务器发送slaveof命令，让他们复制新主服务器</li>\n</ul>\n</li>\n<li>将旧的主服务器变成从服务器<ul>\n<li>当旧的主服务器重新上线时，会向他发出slaveof命令，让他变成从服务器</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"redis集群？\"><a href=\"#redis集群？\" class=\"headerlink\" title=\"redis集群？\"></a>redis集群？</h2><p>Redis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。</p>\n<ul>\n<li><p>节点：一个redis集训由多个节点构成</p>\n<ul>\n<li>启动节点：redis 启动时会根据cluster-enabled配置是否为yes决定是否开启集训模式</li>\n<li>集群数据结构：<ul>\n<li>clusterNode：保存了节点的创建时间、名称、配置纪元、ip、端口号等</li>\n<li>clusterLink：保存了连接<strong>节点</strong>所需的套接字描述符、输入缓冲区、输出缓冲区</li>\n<li>redisClient：保存了连接<strong>客户端</strong>所需的套接字描述符、输入缓冲区、输出缓冲区</li>\n</ul>\n</li>\n<li>节点之间建立连接：通过cluster meet节点之间握手<ul>\n<li>节点A会为节点B创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。</li>\n<li>节点A将根据CLUSTER MEET命令给定的IP地址和端口号，向节点B发送一条MEET消息（message）</li>\n<li>节点B将接收到节点A发送的MEET消息，节点B会为节点A创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。</li>\n<li>节点B将向节点A返回一条PONG消息。</li>\n<li>节点A将接收到节点B返回的PONG消息，通过这条PONG消息节点A可以知道节点B已经成功地接收到了自己发送的MEET消息。</li>\n<li>节点A将向节点B返回一条PING消息。</li>\n<li>节点B将接收到节点A返回的PING消息，通过这条PING消息节点B可以知道节点A已经成功地接收到了自己返回的PONG消息，握手完成。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>槽指派：集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。</p>\n<ul>\n<li>记录节点的槽指派信息：clusterNode结构的slots属性和numslot属性记录了节点负责处理哪些槽<ul>\n<li>slots属性是包含16384位的二进制数组，对应索引i上的值为1那么表示节点负责处理槽i。</li>\n</ul>\n</li>\n<li>传播节点的槽指派信息：将自己的slots数组通过消息发送给集群中的其他节点，以此来告知其他节点自己目前负责处理哪些槽。</li>\n<li>记录集群中所有的槽指派信息：clusterState结构中的slots数组记录了集群中所有16384个槽的指派信息，slots数组包含16384个项，每个数组项都是一个指向clusterNode结构的指针</li>\n</ul>\n</li>\n<li><p>在集训中执行命令：客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己</p>\n<ul>\n<li>如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令。</li>\n<li>如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，指引客户端转向（redirect）至正确的节点，并再次发送之前想要执行的命令</li>\n</ul>\n</li>\n<li><p>重新分片：Redis集群的重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点</p>\n</li>\n<li><p>ASK错误：在进行重新分片期间：属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对则保存在目标节点里面，当客户端向源节点发送一个与数据库键有关的命令，若此时数据不在原节点上，返回ASK并指引客户端转向目标节点。</p>\n</li>\n<li><p>复制与故障转移：</p>\n<ul>\n<li>设置从节点：向一个节点发送命令CLUSTER REPLICATE <node_id>，让接收命令的节点称为node_id的从节点</node_id></li>\n<li>故障检测：<ul>\n<li>集群中的每个节点都会定期地向集群中的其他节点发送PING消息，如果没有在规定时间返回PONG消息，那么该节点会被疑似下线。</li>\n<li>集群中的各个节点会通过互相发送消息的方式来交换集群中各个节点的状态信息，来确认某个节点是疑似下线还是已下线。</li>\n<li>当一个主节点A通过消息得知主节点B认为主节点C进入了疑似下线状态时，会记录主节点C的状态。</li>\n<li>当集群中半数以上的主节点都将某节点疑似下线，那么这个主节点被标记为已下线。</li>\n<li>将主节点x标记为已下线的节点会向集群广播一条关于主节点x的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点x标记为已下线。</li>\n</ul>\n</li>\n<li>故障转移：当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移<ul>\n<li>选举新的主节点<ul>\n<li>集群的配置纪元是一个自增计数器，它的初始值为0。</li>\n<li>当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被增一</li>\n<li>对于每个配置纪元，集群里每个负责处理槽的主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得主节点的投票。</li>\n<li>当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票</li>\n<li>如果一个主节点具有投票权（它正在负责处理槽），并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示这个主节点支持从节点成为新的主节点。</li>\n<li>如果集群里有N个具有投票权的主节点，那么当一个从节点收集到大于等于N/2+1张支持票时，这个从节点就会当选为新的主节点。</li>\n<li>如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。</li>\n</ul>\n</li>\n<li>被选中的从节点会执行SLAVEOF no one命令，成为新的主节点</li>\n<li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</li>\n<li>新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</li>\n<li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"zookeeper\"><a href=\"#zookeeper\" class=\"headerlink\" title=\"zookeeper\"></a>zookeeper</h1><p>它是一个分布式服务框架，主要用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务，集群管理、分布式应用配置项的管理等。<br>简单来说：zk是一个拥有文件系统特点的数据库；zk是一个解决了数据一致性问题的分布式数据库；zk是一个具有发布和订阅功能的分布式数据库。</p>\n<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><h3 id=\"各种排序算法的时间复杂度以及稳定性？\"><a href=\"#各种排序算法的时间复杂度以及稳定性？\" class=\"headerlink\" title=\"各种排序算法的时间复杂度以及稳定性？\"></a>各种排序算法的时间复杂度以及稳定性？</h3><p><img src=\"/JAVA/Interview/sort.png\" alt=\"\"></p>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><ul>\n<li>算法原理：相邻的数据进行两两比较，小(大)数放在前面，大(小)数放在后面，这样一趟下来，最小(大)的数就被排在了第一位，第二趟也是如此，如此类推，直到所有的数据排序完成。</li>\n<li>时间复杂度：最坏：O(n2) 最好: O(n) 平均: O(n2) 空间复杂度：O(1) 稳定性： 稳定</li>\n</ul>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><ul>\n<li>算法原理：先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</li>\n<li>时间复杂度：最坏：O(n2) 最好: O(n) 平均: O(n2) 空间复杂度：O(1) 稳定性： 稳定</li>\n</ul>\n<h3 id=\"直接插入排序\"><a href=\"#直接插入排序\" class=\"headerlink\" title=\"直接插入排序\"></a>直接插入排序</h3><ul>\n<li>算法原理：每次将一个待排序的数据按照其关键字的大小插入到前面已经排序好的数据中的适当位置，直到全部数据排序完成。</li>\n<li>时间复杂度：最坏：O(n2) 最好: O(n) 平均: O(n2) 空间复杂度：O(1) 稳定性： 稳定</li>\n</ul>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><ul>\n<li>算法原理：<ul>\n<li>从数列中挑出一个元素作为基准数。</li>\n<li>分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。</li>\n<li>再对左右区间递归执行第二步，直至各区间只有一个数。</li>\n</ul>\n</li>\n<li>时间复杂度：最坏：O(n2) 最好: O(nlogn) 平均: O(nlogn) 空间复杂度：O(logn) 稳定性： 不稳定 </li>\n</ul>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><ul>\n<li>算法原理：将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</li>\n<li>时间复杂度：最坏：O(nlogn) 最好: O(n) 平均: O(nlogn) 空间复杂度：O(1) 稳定性： 稳定 </li>\n</ul>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><ul>\n<li>算法原理：堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。</li>\n<li>时间复杂度：最坏：O(nlogn) 最好: O(nlogn) 平均: O(nlogn) 空间复杂度：O(1) 稳定性： 不稳定 </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 堆排序（升序排列）-建立最大堆</span></span><br><span class=\"line\"><span class=\"comment\"> * @param array</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">heapSortAsc</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len = a.length;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = len / <span class=\"number\">2</span> - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">\t\tmaxHeapDown(a, i, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = len - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;<span class=\"comment\">//堆顶和末尾交换</span></span><br><span class=\"line\">\t\tswap(a, i, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tmaxHeapDown(a, <span class=\"number\">0</span>, i - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">maxHeapDown</span><span class=\"params\">(<span class=\"keyword\">int</span>[] a, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;<span class=\"comment\">//自顶向下调整成为最大堆</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> son = start * <span class=\"number\">2</span> + <span class=\"number\">1</span>;<span class=\"comment\">//左儿子</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> root = a[start];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (; son &lt;= end; start = son, son = <span class=\"number\">2</span> * son + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (son &lt; end &amp;&amp; a[son] &lt; a[son + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">\t\t\tson++;<span class=\"comment\">//右儿子</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (root &gt;= a[son]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tswap(a, start, son);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"负载均衡算法\"><a href=\"#负载均衡算法\" class=\"headerlink\" title=\"负载均衡算法\"></a>负载均衡算法</h2><h3 id=\"完全随机\"><a href=\"#完全随机\" class=\"headerlink\" title=\"完全随机\"></a>完全随机</h3><p>对所有机器随机选择<br>缺点：服务器有好有坏，处理能力是不同的，我们希望性能好的服务器多处理些请求，性能差的服务器少处理一些请求。</p>\n<h3 id=\"加权随机\"><a href=\"#加权随机\" class=\"headerlink\" title=\"加权随机\"></a>加权随机</h3><p>为每台服务器设置了权重，权重大的服务器获得的概率大一些，权重小的服务器获得的概率小一些。</p>\n<h3 id=\"完全轮询\"><a href=\"#完全轮询\" class=\"headerlink\" title=\"完全轮询\"></a>完全轮询</h3><p>按顺序一个一个执行</p>\n<h3 id=\"普通加权轮询\"><a href=\"#普通加权轮询\" class=\"headerlink\" title=\"普通加权轮询\"></a>普通加权轮询</h3><p>有三个节点{a, b, c}，他们的权重分别是{a=5, b=1, c=1}。发送7次请求，a会被分配5次，b会被分配1次，c会被分配1次。<br>轮训所有节点，找到一个最大权重节点；选中的节点权重-1；直到减到0，恢复该节点原始权重，继续轮询；</p>\n<h3 id=\"平滑加权轮询\"><a href=\"#平滑加权轮询\" class=\"headerlink\" title=\"平滑加权轮询\"></a>平滑加权轮询</h3><p><img src=\"/JAVA/Interview/load.png\" alt=\"\"><br>选中的服务器非固定权重：固定权重-各个服务器的权重之和<br>其他服务器非固定权重 = 固定权重。<br>每一轮将当前有效权重<strong>最大</strong>的实例减去所有实例的权重和，且变量 currentPos 指向此位<br>将每个实例的 非固定权重 都加上 固定权重</p>\n<h3 id=\"一致性hash算法\"><a href=\"#一致性hash算法\" class=\"headerlink\" title=\"一致性hash算法\"></a>一致性hash算法</h3><p>普通的hash算法：如果我们采用普通的hash算法进行路由，将数据映射到具体的节点上，如key%N，key是数据的key，N是机器节点数，如果有一个机器加入或退出这个集群，则所有的数据映射都无效了，如果是持久化存储则要做数据迁移，如果是分布式缓存，则其他缓存就失效了。<br><img src=\"/JAVA/Interview/hash.jpg\" alt=\"\"><br>一致性hash算法：<br>    * 环形hash空间：按照常用的hash算法来将对应的key哈希到一个具有2^32次方个节点的空间中，即0 ~ (2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。<br>    * 映射服务器节点：将各个服务器使用Hash进行一个哈希，具体可以选择服务器的ip或唯一主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。<br>    * 映射数据：对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上,然后从数据所在位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。<br>    * 服务器的删除与添加<br>        * 如果此时NodeC宕机了，此时Object A、B、D不会受到影响，只有Object C会重新分配到Node D上面去，而其他数据对象不会发生变化<br>        * 如果在环境中新增一台服务器Node X，通过hash算法将Node X映射到环中，通过按顺时针迁移的规则，那么Object C被迁移到了Node X中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。</p>\n<p>平衡性问题：当服务器节点比较少的时候，会出现一个问题，就是此时必然造成大量数据集中到一个节点上面，极少数数据集中到另外的节点上面。<br>为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以先确定每个物理节点关联的虚拟节点数量，然后在ip或者主机名后面增加编号。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：<br><img src=\"/JAVA/Interview/hash2.jpg\" alt=\"\"></p>\n<h2 id=\"大数据问题\"><a href=\"#大数据问题\" class=\"headerlink\" title=\"大数据问题\"></a>大数据问题</h2><h3 id=\"给一个超过100G大小的log-file-log中存着IP地址-，设计算法找到出现次数最多的IP地址？\"><a href=\"#给一个超过100G大小的log-file-log中存着IP地址-，设计算法找到出现次数最多的IP地址？\" class=\"headerlink\" title=\"给一个超过100G大小的log file,log中存着IP地址 ，设计算法找到出现次数最多的IP地址？\"></a>给一个超过100G大小的log file,log中存着IP地址 ，设计算法找到出现次数最多的IP地址？</h3><p>但凡是大数据的问题，都可通过切分来解决它。<br>如果我们将其分成1000个小文件，每个文件大概就是500M左右的样子，现在计算机肯定轻轻 松松就能装下。<br>那么，问题又来了，怎样才能保证相同的IP被分到同一个文件中呢？<br>这里我想到的是哈希切分，使用相同的散列函数（如 BKDRHash）将所有IP地址转换为一个整数key，再利用 index=key%1000就可将相同IP分到同一个文件。</p>\n<h2 id=\"智商题\"><a href=\"#智商题\" class=\"headerlink\" title=\"智商题\"></a>智商题</h2><h1 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h1><h2 id=\"分布式ID解决方案\"><a href=\"#分布式ID解决方案\" class=\"headerlink\" title=\"分布式ID解决方案\"></a>分布式ID解决方案</h2><ol>\n<li>基于UUID:对于数据库来说用作业务主键ID，它不仅是太长还是字符串，存储性能差查询也很耗时，所以不推荐用作分布式ID。<ul>\n<li>优点：生成足够简单，本地生成无网络消耗，具有唯一性</li>\n<li>缺点：无序的字符串，不具备趋势自增特性;没有具体的业务含义;长度过长16 字节128位，36位长度的字符串，存储以及查询对MySQL的性能消耗较大，MySQL官方明确建议主键要尽量越短越好，作为数据库主键 UUID 的无序性会导致数据位置频繁变动，严重影响性能。</li>\n</ul>\n</li>\n<li>基于单数据库自增ID<ul>\n<li>优点：实现简单，ID单调自增，数值类型查询速度快</li>\n<li>缺点：DB单点存在宕机风险，无法扛住高并发场景</li>\n</ul>\n</li>\n<li>基于数据库集群模式:那这样还会有个问题，两个MySQL实例的自增ID都从1开始，会生成重复的ID怎么办？<ul>\n<li>操作：设置起始值和自增步长</li>\n<li>优点：解决DB单点问题</li>\n<li>缺点：不利于后续扩容，新增第三台MySQL实例需要人工修改一、二两台MySQL实例的起始值和步长。</li>\n</ul>\n</li>\n<li>基于Redis模式:利用redis的 incr命令实现ID的原子性自增<ul>\n<li>缺点：RDB会定时打一个快照进行持久化，假如连续自增但redis没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。</li>\n<li>缺点：AOF会对每条写命令进行持久化，即使Redis挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致Redis重启恢复的数据时间过长。</li>\n</ul>\n</li>\n<li>基于数据库的号段模式：从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存<ul>\n<li>数据库中存储 <strong>当前最大id</strong>, <strong>号段的步长</strong></li>\n<li>多业务端可能同时操作，所以采用版本号version乐观锁方式更新，</li>\n<li>优点：这种分布式ID生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。</li>\n<li>缺点：id为连续号段，可能会被枚举，安全性不足；服务器出现问题重启，部分在内存中的号段会丢失。</li>\n<li>优化方式：双buffer机制，在号段用完前并发获取下一个号段</li>\n</ul>\n</li>\n<li>基于雪花算法（Snowflake）模式<ul>\n<li>组成：Snowflake ID组成结构：正数位（占1比特）+ 时间戳（占41比特）+ 机器ID（占5比特）+ 数据中心（占5比特）+ 自增值（占12比特），总共64比特组成的一个Long类型。<ul>\n<li>第一个bit位（1bit）：Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0。</li>\n<li>时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69年</li>\n<li>工作机器id（10bit）：也被叫做workId，这个可以灵活配置，机房或者机器号组合都可以。</li>\n<li>序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID</li>\n</ul>\n</li>\n<li>操作：当序列号部分超过4096时，等待下一毫秒；当目前时间戳小于最后一次的时间戳时，时钟回拨，报错！！</li>\n<li>优点：解除对db的依赖；需要人工配置工作id；只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。</li>\n<li>缺点：依赖时间戳，存在机器时钟回拨</li>\n</ul>\n</li>\n<li>百度（uid-generator）:自动生成workId<ul>\n<li>组成：正数位（占1比特） + 时间秒（占28位）+ workId（占22比特）+ 自增值（占13位）；</li>\n<li>操作：依赖db，在服务器启动的时候，根据hostName，port，type和 date 插入db中取出对应的自增di作为workId。</li>\n<li>CachedUidGenerator：采用RingBuffer环状数组，初始时按填充时的时间戳填充ring数组，取id时顺序从数组中取，异步填充数组。</li>\n</ul>\n</li>\n<li>美团(Leaf): 基于ZooKeeper的顺序Id生成workId</li>\n</ol>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.cnblogs.com/bailing80/p/11443409.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/bailing80/p/11443409.html</a></p>\n"}],"PostAsset":[{"_id":"source/_posts/Github-Pages-Blog/github-pages.png","slug":"github-pages.png","post":"ck8fb4a92000tk2o5p0gggblb","modified":1,"renderable":0},{"_id":"source/_posts/Github-Pages-Blog/setting.png","slug":"setting.png","post":"ck8fb4a92000tk2o5p0gggblb","modified":1,"renderable":0},{"_id":"source/_posts/Github-Pages-Blog/valine.png","slug":"valine.png","post":"ck8fb4a92000tk2o5p0gggblb","modified":1,"renderable":0},{"_id":"source/_posts/JVM-Fundamentals/10.3.png","slug":"10.3.png","post":"ck8fb4a9o0011k2o5ns7o6spj","modified":1,"renderable":0},{"_id":"source/_posts/JVM-Fundamentals/3.png","slug":"3.png","post":"ck8fb4a9o0011k2o5ns7o6spj","modified":1,"renderable":0},{"_id":"source/_posts/JVM-Fundamentals/4.png","slug":"4.png","post":"ck8fb4a9o0011k2o5ns7o6spj","modified":1,"renderable":0},{"_id":"source/_posts/JVM-Fundamentals/9.1.png","slug":"9.1.png","post":"ck8fb4a9o0011k2o5ns7o6spj","modified":1,"renderable":0},{"_id":"source/_posts/JVM-Fundamentals/9.2.png","slug":"9.2.png","post":"ck8fb4a9o0011k2o5ns7o6spj","modified":1,"renderable":0},{"_id":"source/_posts/Java-Synchronized/1.png","slug":"1.png","post":"ck8fb4abm001sk2o5dtcyl3bf","modified":1,"renderable":0},{"_id":"source/_posts/Java-Synchronized/2.png","slug":"2.png","post":"ck8fb4abm001sk2o5dtcyl3bf","modified":1,"renderable":0},{"_id":"source/_posts/Github-Pages-Blog/create-repository.png","slug":"create-repository.png","post":"ck8fb4a92000tk2o5p0gggblb","modified":1,"renderable":0},{"_id":"source/_posts/JVM-Fundamentals/5.png","slug":"5.png","post":"ck8fb4a9o0011k2o5ns7o6spj","modified":1,"renderable":0},{"_id":"source/_posts/JVM-Fundamentals/7.png","slug":"7.png","post":"ck8fb4a9o0011k2o5ns7o6spj","modified":1,"renderable":0},{"_id":"source/_posts/Java-MemoryModel/6.png","slug":"6.png","post":"ck8fb4ab2001kk2o5t4933ytk","modified":1,"renderable":0},{"_id":"source/_posts/Kafka-Background/2.png","slug":"2.png","post":"ck8fb4acc0024k2o50l4jyrn8","modified":1,"renderable":0},{"_id":"source/_posts/Kafka-Background/4.jpg","slug":"4.jpg","post":"ck8fb4acc0024k2o50l4jyrn8","modified":1,"renderable":0},{"_id":"source/_posts/Design-Pattern-Observer/2.png","slug":"2.png","post":"ck8fb4a8q000ik2o51yuoss7g","modified":1,"renderable":0},{"_id":"source/_posts/Github-Pages-Blog/copy-url.png","slug":"copy-url.png","post":"ck8fb4a92000tk2o5p0gggblb","modified":1,"renderable":0},{"_id":"source/_posts/JVM-Fundamentals/1.png","slug":"1.png","post":"ck8fb4a9o0011k2o5ns7o6spj","modified":1,"renderable":0},{"_id":"source/_posts/Interview/1.png","slug":"1.png","post":"ck8fb4ann0079k2o52rrhwwcc","modified":1,"renderable":0},{"_id":"source/_posts/Interview/bean.png","slug":"bean.png","post":"ck8fb4ann0079k2o52rrhwwcc","modified":1,"renderable":0},{"_id":"source/_posts/Java-Synchronized/7.png","slug":"7.png","post":"ck8fb4abm001sk2o5dtcyl3bf","modified":1,"renderable":0},{"_id":"source/_posts/Mysql-LSN/LOG.png","slug":"LOG.png","post":"ck8fb4acs002ck2o5t90ziyb8","modified":1,"renderable":0},{"_id":"source/_posts/C++-02/1.png","slug":"1.png","post":"ck8fb4a8h0009k2o5i5mhy2f9","modified":1,"renderable":0},{"_id":"source/_posts/Mysql01/01.jpg","post":"ck8fb4ado002ok2o5ky2m2j0v","slug":"01.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Mysql-storage/640.png","post":"ck8fb4adw002rk2o5i698re3l","slug":"640.png","modified":1,"renderable":1},{"_id":"source/_posts/Redis-adlist/list.png","post":"ck8fb4ae30037k2o5u8igi2zj","slug":"list.png","modified":1,"renderable":1},{"_id":"source/_posts/Redis-sds/sdshdr.png","post":"ck8fb4ae5003ck2o5y3l1nfvu","slug":"sdshdr.png","modified":1,"renderable":1},{"_id":"source/_posts/Design-Pattern-Observer/1.png","slug":"1.png","post":"ck8fb4a8q000ik2o51yuoss7g","modified":1,"renderable":0},{"_id":"source/_posts/Kafka-Producer/cert_override.png","post":"ck8fb4ack0028k2o5kbmrh14h","slug":"cert_override.png","modified":1,"renderable":1},{"_id":"source/_posts/Kafka-Producer/producer.png","post":"ck8fb4ack0028k2o5kbmrh14h","slug":"producer.png","modified":1,"renderable":1},{"_id":"source/_posts/Mysql-RedoAndUndo/redo-buffer.png","post":"ck8fb4ad1002gk2o5xp846y8p","slug":"redo-buffer.png","modified":1,"renderable":1},{"_id":"source/_posts/Mysql-RedoAndUndo/undo-Segment.png","post":"ck8fb4ad1002gk2o5xp846y8p","slug":"undo-Segment.png","modified":1,"renderable":1},{"_id":"source/_posts/Kafka-Background/1.png","post":"ck8fb4acc0024k2o50l4jyrn8","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/Kafka-Background/3.jpg","post":"ck8fb4acc0024k2o50l4jyrn8","slug":"3.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Kafka-Background/5.jpeg","post":"ck8fb4acc0024k2o50l4jyrn8","slug":"5.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/Kafka-Background/6.png","slug":"6.png","post":"ck8fb4acc0024k2o50l4jyrn8","modified":1,"renderable":0},{"_id":"source/_posts/Java-MemoryModel/1.png","post":"ck8fb4ab2001kk2o5t4933ytk","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-MemoryModel/2.png","post":"ck8fb4ab2001kk2o5t4933ytk","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-MemoryModel/3.png","post":"ck8fb4ab2001kk2o5t4933ytk","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-MemoryModel/4.jpeg","post":"ck8fb4ab2001kk2o5t4933ytk","slug":"4.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/Java-MemoryModel/5.jpeg","post":"ck8fb4ab2001kk2o5t4933ytk","slug":"5.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/Java-MemoryModel/7.png","post":"ck8fb4ab2001kk2o5t4933ytk","slug":"7.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-MemoryModel/8.png","post":"ck8fb4ab2001kk2o5t4933ytk","slug":"8.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-Synchronized/10.png","post":"ck8fb4abm001sk2o5dtcyl3bf","slug":"10.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-Synchronized/3.png","post":"ck8fb4abm001sk2o5dtcyl3bf","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-Synchronized/4.png","post":"ck8fb4abm001sk2o5dtcyl3bf","slug":"4.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-Synchronized/5.png","post":"ck8fb4abm001sk2o5dtcyl3bf","slug":"5.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-Synchronized/6.png","slug":"6.png","post":"ck8fb4abm001sk2o5dtcyl3bf","modified":1,"renderable":0},{"_id":"source/_posts/Java-Synchronized/8.png","post":"ck8fb4abm001sk2o5dtcyl3bf","slug":"8.png","modified":1,"renderable":1},{"_id":"source/_posts/Java-Synchronized/9.png","post":"ck8fb4abm001sk2o5dtcyl3bf","slug":"9.png","modified":1,"renderable":1},{"_id":"source/_posts/Github-Pages-Blog/blog-icon.png","post":"ck8fb4a92000tk2o5p0gggblb","slug":"blog-icon.png","modified":1,"renderable":1},{"_id":"source/_posts/Github-Pages-Blog/categories.png","post":"ck8fb4a92000tk2o5p0gggblb","slug":"categories.png","modified":1,"renderable":1},{"_id":"source/_posts/Github-Pages-Blog/change-theme.png","post":"ck8fb4a92000tk2o5p0gggblb","slug":"change-theme.png","modified":1,"renderable":1},{"_id":"source/_posts/Github-Pages-Blog/comment-delete.png","post":"ck8fb4a92000tk2o5p0gggblb","slug":"comment-delete.png","modified":1,"renderable":1},{"_id":"source/_posts/Github-Pages-Blog/create-project.png","post":"ck8fb4a92000tk2o5p0gggblb","slug":"create-project.png","modified":1,"renderable":1},{"_id":"source/_posts/Github-Pages-Blog/deploy-position.png","post":"ck8fb4a92000tk2o5p0gggblb","slug":"deploy-position.png","modified":1,"renderable":1},{"_id":"source/_posts/Github-Pages-Blog/select-theme.png","slug":"select-theme.png","post":"ck8fb4a92000tk2o5p0gggblb","modified":1,"renderable":0},{"_id":"source/_posts/Github-Pages-Blog/tags.png","post":"ck8fb4a92000tk2o5p0gggblb","slug":"tags.png","modified":1,"renderable":1},{"_id":"source/_posts/Mysql02/1.png","post":"ck8fb4adz002zk2o5vlxhf5qi","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/Mysql02/2.png","post":"ck8fb4adz002zk2o5vlxhf5qi","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/Mysql02/IO.png","post":"ck8fb4adz002zk2o5vlxhf5qi","slug":"IO.png","modified":1,"renderable":1},{"_id":"source/_posts/Mysql02/Insert-Buffer.svg","post":"ck8fb4adz002zk2o5vlxhf5qi","slug":"Insert-Buffer.svg","modified":1,"renderable":1},{"_id":"source/_posts/Mysql02/doublewrite.png","post":"ck8fb4adz002zk2o5vlxhf5qi","slug":"doublewrite.png","modified":1,"renderable":1},{"_id":"source/_posts/Mysql02/index-update.png","post":"ck8fb4adz002zk2o5vlxhf5qi","slug":"index-update.png","modified":1,"renderable":1},{"_id":"source/_posts/Mysql02/innodb-Architecture.png","post":"ck8fb4adz002zk2o5vlxhf5qi","slug":"innodb-Architecture.png","modified":1,"renderable":1},{"_id":"source/_posts/Mysql02/innodb-buffer-pool-list.jpg","post":"ck8fb4adz002zk2o5vlxhf5qi","slug":"innodb-buffer-pool-list.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Mysql02/insert-buffer.png","post":"ck8fb4adz002zk2o5vlxhf5qi","slug":"insert-buffer.png","modified":1,"renderable":1},{"_id":"source/_posts/Mysql02/read.png","post":"ck8fb4adz002zk2o5vlxhf5qi","slug":"read.png","modified":1,"renderable":1},{"_id":"source/_posts/Mysql02/read.svg","post":"ck8fb4adz002zk2o5vlxhf5qi","slug":"read.svg","modified":1,"renderable":1},{"_id":"source/_posts/Mysql02/redo-buffer.png","post":"ck8fb4adz002zk2o5vlxhf5qi","slug":"redo-buffer.png","modified":1,"renderable":1},{"_id":"source/_posts/Mysql02/three-list.png","post":"ck8fb4adz002zk2o5vlxhf5qi","slug":"three-list.png","modified":1,"renderable":1},{"_id":"source/_posts/Mysql02/three-list2.png","post":"ck8fb4adz002zk2o5vlxhf5qi","slug":"three-list2.png","modified":1,"renderable":1},{"_id":"source/_posts/Mysql02/write.png","post":"ck8fb4adz002zk2o5vlxhf5qi","slug":"write.png","modified":1,"renderable":1},{"_id":"source/_posts/Mysql02/write.svg","post":"ck8fb4adz002zk2o5vlxhf5qi","slug":"write.svg","modified":1,"renderable":1},{"_id":"source/_posts/Project-Module/1.png","post":"ck8fb4ae20034k2o5rlnmohc6","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/Project-Module/10.png","post":"ck8fb4ae20034k2o5rlnmohc6","slug":"10.png","modified":1,"renderable":1},{"_id":"source/_posts/Project-Module/11.png","post":"ck8fb4ae20034k2o5rlnmohc6","slug":"11.png","modified":1,"renderable":1},{"_id":"source/_posts/Project-Module/12.png","post":"ck8fb4ae20034k2o5rlnmohc6","slug":"12.png","modified":1,"renderable":1},{"_id":"source/_posts/Project-Module/17.png","post":"ck8fb4ae20034k2o5rlnmohc6","slug":"17.png","modified":1,"renderable":1},{"_id":"source/_posts/Project-Module/19.png","post":"ck8fb4ae20034k2o5rlnmohc6","slug":"19.png","modified":1,"renderable":1},{"_id":"source/_posts/Project-Module/2.png","post":"ck8fb4ae20034k2o5rlnmohc6","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/Project-Module/24.png","post":"ck8fb4ae20034k2o5rlnmohc6","slug":"24.png","modified":1,"renderable":1},{"_id":"source/_posts/Project-Module/3.png","post":"ck8fb4ae20034k2o5rlnmohc6","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/Project-Module/30.1.png","post":"ck8fb4ae20034k2o5rlnmohc6","slug":"30.1.png","modified":1,"renderable":1},{"_id":"source/_posts/Project-Module/30.2.png","post":"ck8fb4ae20034k2o5rlnmohc6","slug":"30.2.png","modified":1,"renderable":1},{"_id":"source/_posts/Project-Module/32.png","post":"ck8fb4ae20034k2o5rlnmohc6","slug":"32.png","modified":1,"renderable":1},{"_id":"source/_posts/Project-Module/4.png","post":"ck8fb4ae20034k2o5rlnmohc6","slug":"4.png","modified":1,"renderable":1},{"_id":"source/_posts/Project-Module/5.png","post":"ck8fb4ae20034k2o5rlnmohc6","slug":"5.png","modified":1,"renderable":1},{"_id":"source/_posts/Project-Module/6.png","post":"ck8fb4ae20034k2o5rlnmohc6","slug":"6.png","modified":1,"renderable":1},{"_id":"source/_posts/Project-Module/7.png","post":"ck8fb4ae20034k2o5rlnmohc6","slug":"7.png","modified":1,"renderable":1},{"_id":"source/_posts/Project-Module/8.png","post":"ck8fb4ae20034k2o5rlnmohc6","slug":"8.png","modified":1,"renderable":1},{"_id":"source/_posts/Project-Module/9.png","slug":"9.png","post":"ck8fb4ae20034k2o5rlnmohc6","modified":1,"renderable":0},{"_id":"source/_posts/JVM-Fundamentals/10.1.png","post":"ck8fb4a9o0011k2o5ns7o6spj","slug":"10.1.png","modified":1,"renderable":1},{"_id":"source/_posts/JVM-Fundamentals/10.2.png","post":"ck8fb4a9o0011k2o5ns7o6spj","slug":"10.2.png","modified":1,"renderable":1},{"_id":"source/_posts/JVM-Fundamentals/10.4.png","slug":"10.4.png","post":"ck8fb4a9o0011k2o5ns7o6spj","modified":1,"renderable":0},{"_id":"source/_posts/JVM-Fundamentals/10.png","post":"ck8fb4a9o0011k2o5ns7o6spj","slug":"10.png","modified":1,"renderable":1},{"_id":"source/_posts/JVM-Fundamentals/2.png","post":"ck8fb4a9o0011k2o5ns7o6spj","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/JVM-Fundamentals/5.1.png","slug":"5.1.png","post":"ck8fb4a9o0011k2o5ns7o6spj","modified":1,"renderable":0},{"_id":"source/_posts/JVM-Fundamentals/5.2.png","slug":"5.2.png","post":"ck8fb4a9o0011k2o5ns7o6spj","modified":1,"renderable":0},{"_id":"source/_posts/JVM-Fundamentals/5.3.png","slug":"5.3.png","post":"ck8fb4a9o0011k2o5ns7o6spj","modified":1,"renderable":0},{"_id":"source/_posts/JVM-Fundamentals/5.4.png","slug":"5.4.png","post":"ck8fb4a9o0011k2o5ns7o6spj","modified":1,"renderable":0},{"_id":"source/_posts/JVM-Fundamentals/5.5.png","slug":"5.5.png","post":"ck8fb4a9o0011k2o5ns7o6spj","modified":1,"renderable":0},{"_id":"source/_posts/JVM-Fundamentals/5.6.png","slug":"5.6.png","post":"ck8fb4a9o0011k2o5ns7o6spj","modified":1,"renderable":0},{"_id":"source/_posts/JVM-Fundamentals/5.7.png","slug":"5.7.png","post":"ck8fb4a9o0011k2o5ns7o6spj","modified":1,"renderable":0},{"_id":"source/_posts/JVM-Fundamentals/5.8.png","slug":"5.8.png","post":"ck8fb4a9o0011k2o5ns7o6spj","modified":1,"renderable":0},{"_id":"source/_posts/JVM-Fundamentals/5.9.png","slug":"5.9.png","post":"ck8fb4a9o0011k2o5ns7o6spj","modified":1,"renderable":0},{"_id":"source/_posts/JVM-Fundamentals/6.jpeg","post":"ck8fb4a9o0011k2o5ns7o6spj","slug":"6.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/JVM-Fundamentals/8.png","post":"ck8fb4a9o0011k2o5ns7o6spj","slug":"8.png","modified":1,"renderable":1},{"_id":"source/_posts/JVM-Fundamentals/9.3.png","post":"ck8fb4a9o0011k2o5ns7o6spj","slug":"9.3.png","modified":1,"renderable":1},{"_id":"source/_posts/JVM-Fundamentals/9.png","post":"ck8fb4a9o0011k2o5ns7o6spj","slug":"9.png","modified":1,"renderable":1},{"_id":"source/_posts/Interview/head.png","slug":"head.png","post":"ck8fb4ann0079k2o52rrhwwcc","modified":1,"renderable":0},{"_id":"source/_posts/Tree/BBT1.png","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"BBT1.png","modified":1,"renderable":1},{"_id":"source/_posts/Tree/BBT2.png","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"BBT2.png","modified":1,"renderable":1},{"_id":"source/_posts/Tree/BBT3.png","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"BBT3.png","modified":1,"renderable":1},{"_id":"source/_posts/Tree/BBT4.png","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"BBT4.png","modified":1,"renderable":1},{"_id":"source/_posts/Tree/BST_delete1.png","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"BST_delete1.png","modified":1,"renderable":1},{"_id":"source/_posts/Tree/BST_delete2.png","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"BST_delete2.png","modified":1,"renderable":1},{"_id":"source/_posts/Tree/BST_insert.png","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"BST_insert.png","modified":1,"renderable":1},{"_id":"source/_posts/Tree/BST_linked.png","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"BST_linked.png","modified":1,"renderable":1},{"_id":"source/_posts/Tree/Red01.jpg","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"Red01.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Tree/Red02.jpeg","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"Red02.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/Tree/Red03.jpeg","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"Red03.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/Tree/Red04.jpeg","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"Red04.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/Tree/Red05.jpeg","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"Red05.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/Tree/Red06.jpeg","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"Red06.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/Tree/Red07.jpeg","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"Red07.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/Tree/Red08.jpeg","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"Red08.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/Tree/Red09.jpeg","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"Red09.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/Tree/Red10.jpg","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"Red10.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Tree/Red11.jpg","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"Red11.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Tree/Red12.jpg","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"Red12.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Tree/Red13.jpg","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"Red13.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Tree/Red14.jpg","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"Red14.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Tree/Red15.jpg","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"Red15.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Tree/Red16.jpg","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"Red16.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Tree/Red17.jpg","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"Red17.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Tree/Req18.jpg","post":"ck8fb4ajz006xk2o5ntw5xnjq","slug":"Req18.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-13-11-50-782_com.xingin.xhs.png","post":"ck8fb4ajy006wk2o5bkmx50wk","slug":"Screenshot_2019-08-31-13-11-50-782_com.xingin.xhs.png","modified":1,"renderable":1},{"_id":"source/_posts/Thailand-Raiders/1.png","post":"ck8fb4ajy006wk2o5bkmx50wk","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/Thailand-Raiders/10.jpeg","post":"ck8fb4ajy006wk2o5bkmx50wk","slug":"10.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/Thailand-Raiders/11.png","slug":"11.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/2.png","slug":"2.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/3.png","slug":"3.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/4.png","slug":"4.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/455-2.jpeg","slug":"455-2.jpeg","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/455-3.jpeg","slug":"455-3.jpeg","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/455.jpeg","slug":"455.jpeg","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/5.png","post":"ck8fb4ajy006wk2o5bkmx50wk","slug":"5.png","modified":1,"renderable":1},{"_id":"source/_posts/Thailand-Raiders/6.png","slug":"6.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/7.png","slug":"7.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/8.png","slug":"8.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/9.png","slug":"9.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-11-45-53-237_com.xingin.xhs.png","slug":"Screenshot_2019-08-31-11-45-53-237_com.xingin.xhs.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-11-45-57-687_com.xingin.xhs.png","slug":"Screenshot_2019-08-31-11-45-57-687_com.xingin.xhs.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-11-46-00-652_com.xingin.xhs.png","slug":"Screenshot_2019-08-31-11-46-00-652_com.xingin.xhs.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-11-46-03-072_com.xingin.xhs.png","slug":"Screenshot_2019-08-31-11-46-03-072_com.xingin.xhs.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-11-46-08-364_com.xingin.xhs.png","slug":"Screenshot_2019-08-31-11-46-08-364_com.xingin.xhs.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-12-05-14-972_com.xingin.xhs.png","slug":"Screenshot_2019-08-31-12-05-14-972_com.xingin.xhs.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-12-05-18-389_com.xingin.xhs.png","slug":"Screenshot_2019-08-31-12-05-18-389_com.xingin.xhs.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-12-05-20-912_com.xingin.xhs.png","slug":"Screenshot_2019-08-31-12-05-20-912_com.xingin.xhs.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-12-05-23-188_com.xingin.xhs.png","slug":"Screenshot_2019-08-31-12-05-23-188_com.xingin.xhs.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-12-05-25-297_com.xingin.xhs.png","slug":"Screenshot_2019-08-31-12-05-25-297_com.xingin.xhs.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-12-05-30-499_com.xingin.xhs.png","slug":"Screenshot_2019-08-31-12-05-30-499_com.xingin.xhs.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-13-11-56-133_com.xingin.xhs.png","slug":"Screenshot_2019-08-31-13-11-56-133_com.xingin.xhs.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-13-12-27-105_com.xingin.xhs.png","slug":"Screenshot_2019-08-31-13-12-27-105_com.xingin.xhs.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-14-05-58-003_com.xingin.xhs.png","slug":"Screenshot_2019-08-31-14-05-58-003_com.xingin.xhs.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/Screenshot_2019-08-31-14-25-04-833_com.xingin.xhs.png","slug":"Screenshot_2019-08-31-14-25-04-833_com.xingin.xhs.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/Tiffany.png","slug":"Tiffany.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/WechatIMG38.jpeg","slug":"WechatIMG38.jpeg","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Thailand-Raiders/WechatIMG39.png","post":"ck8fb4ajy006wk2o5bkmx50wk","slug":"WechatIMG39.png","modified":1,"renderable":1},{"_id":"source/_posts/Thailand-Raiders/WechatIMG40.png","post":"ck8fb4ajy006wk2o5bkmx50wk","slug":"WechatIMG40.png","modified":1,"renderable":1},{"_id":"source/_posts/Thailand-Raiders/tianjin-airport.png","slug":"tianjin-airport.png","post":"ck8fb4ajy006wk2o5bkmx50wk","modified":1,"renderable":0},{"_id":"source/_posts/Interview/01.jpeg","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"01.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/Interview/01.jpg","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"01.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Interview/2.png","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/Interview/3.png","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/Interview/4.png","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"4.png","modified":1,"renderable":1},{"_id":"source/_posts/Interview/5.png","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"5.png","modified":1,"renderable":1},{"_id":"source/_posts/Interview/6.jpeg","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"6.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/Interview/Handshake.png","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"Handshake.png","modified":1,"renderable":1},{"_id":"source/_posts/Interview/applicationContext.jpg","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"applicationContext.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Interview/concurrentHashMap1.7.jpg","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"concurrentHashMap1.7.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Interview/doublewrite.png","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"doublewrite.png","modified":1,"renderable":1},{"_id":"source/_posts/Interview/hash.jpg","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"hash.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Interview/hash2.jpg","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"hash2.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Interview/innodb-Architecture.png","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"innodb-Architecture.png","modified":1,"renderable":1},{"_id":"source/_posts/Interview/io.png","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"io.png","modified":1,"renderable":1},{"_id":"source/_posts/Interview/kafka.png","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"kafka.png","modified":1,"renderable":1},{"_id":"source/_posts/Interview/load.png","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"load.png","modified":1,"renderable":1},{"_id":"source/_posts/Interview/mybatisCache.jpg","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"mybatisCache.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Interview/osi.jpeg","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"osi.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/Interview/redis-shujujiegou.png","slug":"redis-shujujiegou.png","post":"ck8fb4ann0079k2o52rrhwwcc","modified":1,"renderable":0},{"_id":"source/_posts/Interview/redo-buffer.png","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"redo-buffer.png","modified":1,"renderable":1},{"_id":"source/_posts/Interview/slidingWindow  .png","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"slidingWindow  .png","modified":1,"renderable":1},{"_id":"source/_posts/Interview/sort.png","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"sort.png","modified":1,"renderable":1},{"_id":"source/_posts/Interview/springmvc.png","slug":"springmvc.png","post":"ck8fb4ann0079k2o52rrhwwcc","modified":1,"renderable":0},{"_id":"source/_posts/Interview/sqllock.gif","slug":"sqllock.gif","post":"ck8fb4ann0079k2o52rrhwwcc","modified":1,"renderable":0},{"_id":"source/_posts/Interview/threadPoll.png","slug":"threadPoll.png","post":"ck8fb4ann0079k2o52rrhwwcc","modified":1,"renderable":0},{"_id":"source/_posts/Interview/wave.png","post":"ck8fb4ann0079k2o52rrhwwcc","slug":"wave.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ck8fb4a7y0000k2o5uyka3ixq","category_id":"ck8fb4a890004k2o5isqmeoli","_id":"ck8fb4a8n000ek2o57e3ii2p3"},{"post_id":"ck8fb4a860002k2o5csx56k4q","category_id":"ck8fb4a8i000ak2o5vo9v85as","_id":"ck8fb4a8r000jk2o5wijbykvn"},{"post_id":"ck8fb4a8b0006k2o53jxnri0h","category_id":"ck8fb4a8o000fk2o53d9l6iy3","_id":"ck8fb4a91000qk2o5m1tqfdcr"},{"post_id":"ck8fb4a8f0008k2o5tk37pyei","category_id":"ck8fb4a8r000kk2o56bivgkch","_id":"ck8fb4a9i000xk2o5ak42tk2c"},{"post_id":"ck8fb4a8h0009k2o5i5mhy2f9","category_id":"ck8fb4a8r000kk2o56bivgkch","_id":"ck8fb4a9s0012k2o5s2jblcll"},{"post_id":"ck8fb4a8k000ck2o5l35k7e4n","category_id":"ck8fb4a9i000wk2o5hmlpa2ls","_id":"ck8fb4aa7001ak2o5jkrvklh9"},{"post_id":"ck8fb4a8m000dk2o5i6lsj1vz","category_id":"ck8fb4a9i000wk2o5hmlpa2ls","_id":"ck8fb4aap001fk2o5p4cyad69"},{"post_id":"ck8fb4aaf001ck2o52sdtexij","category_id":"ck8fb4a890004k2o5isqmeoli","_id":"ck8fb4ab3001lk2o55l842588"},{"post_id":"ck8fb4a8o000hk2o5pvv4qvrr","category_id":"ck8fb4a9i000wk2o5hmlpa2ls","_id":"ck8fb4abe001qk2o5gnn82pas"},{"post_id":"ck8fb4aao001dk2o5ncgo8hny","category_id":"ck8fb4a890004k2o5isqmeoli","_id":"ck8fb4abm001tk2o51q7l3n7g"},{"post_id":"ck8fb4aav001ik2o5ugy3spbn","category_id":"ck8fb4a890004k2o5isqmeoli","_id":"ck8fb4abz001yk2o5641c7s8t"},{"post_id":"ck8fb4a8q000ik2o51yuoss7g","category_id":"ck8fb4a9i000wk2o5hmlpa2ls","_id":"ck8fb4ac60021k2o5n8zrui7r"},{"post_id":"ck8fb4ab2001kk2o5t4933ytk","category_id":"ck8fb4a890004k2o5isqmeoli","_id":"ck8fb4acd0025k2o5pw9nhzgi"},{"post_id":"ck8fb4abc001pk2o5vizlbue7","category_id":"ck8fb4a890004k2o5isqmeoli","_id":"ck8fb4acl0029k2o5h7242kpx"},{"post_id":"ck8fb4a8r000mk2o5q3lvjr2d","category_id":"ck8fb4a9i000wk2o5hmlpa2ls","_id":"ck8fb4act002dk2o5nskmtgtj"},{"post_id":"ck8fb4abm001sk2o5dtcyl3bf","category_id":"ck8fb4a890004k2o5isqmeoli","_id":"ck8fb4ad1002hk2o5g4y69wng"},{"post_id":"ck8fb4aby001xk2o5ztg0plf2","category_id":"ck8fb4a890004k2o5isqmeoli","_id":"ck8fb4adb002lk2o5rvul4lhj"},{"post_id":"ck8fb4a8t000ok2o5lm4sj09p","category_id":"ck8fb4abn001uk2o58u8uxel0","_id":"ck8fb4adp002pk2o534v6otf0"},{"post_id":"ck8fb4ac50020k2o5q71z9gm2","category_id":"ck8fb4a890004k2o5isqmeoli","_id":"ck8fb4adw002sk2o5imea1izc"},{"post_id":"ck8fb4a92000tk2o5p0gggblb","category_id":"ck8fb4ac60022k2o5apqquflw","_id":"ck8fb4ady002xk2o5o48k9evv"},{"post_id":"ck8fb4a9a000vk2o55nnw227b","category_id":"ck8fb4acr002ak2o5gm4pxzdg","_id":"ck8fb4ae20030k2o5961t4aur"},{"post_id":"ck8fb4a9j000yk2o5fh38du4l","category_id":"ck8fb4ada002jk2o50pdewtqz","_id":"ck8fb4ae30035k2o5kf61ri3x"},{"post_id":"ck8fb4a9o0011k2o5ns7o6spj","category_id":"ck8fb4ada002jk2o50pdewtqz","_id":"ck8fb4ae40039k2o5m1v737fo"},{"post_id":"ck8fb4a9t0014k2o5dvor3mq2","category_id":"ck8fb4ada002jk2o50pdewtqz","_id":"ck8fb4ae6003ek2o5v60snqom"},{"post_id":"ck8fb4ae30037k2o5u8igi2zj","category_id":"ck8fb4a8i000ak2o5vo9v85as","_id":"ck8fb4ae7003ik2o5ei0ekwvl"},{"post_id":"ck8fb4ae5003ck2o5y3l1nfvu","category_id":"ck8fb4a8i000ak2o5vo9v85as","_id":"ck8fb4ae7003kk2o545orr14s"},{"post_id":"ck8fb4a9z0017k2o53yy94api","category_id":"ck8fb4ae40038k2o5nk6rvvab","_id":"ck8fb4ae9003ok2o5c2cqkrpg"},{"post_id":"ck8fb4aa50018k2o5y60yv72v","category_id":"ck8fb4ada002jk2o50pdewtqz","_id":"ck8fb4aea003qk2o5jycybxny"},{"post_id":"ck8fb4acc0024k2o50l4jyrn8","category_id":"ck8fb4ae7003lk2o5ix733zs0","_id":"ck8fb4aeb003vk2o59itgywr8"},{"post_id":"ck8fb4ack0028k2o5kbmrh14h","category_id":"ck8fb4ae7003lk2o5ix733zs0","_id":"ck8fb4aeb003yk2o59tf0nk4d"},{"post_id":"ck8fb4acs002ck2o5t90ziyb8","category_id":"ck8fb4aeb003uk2o5ns49o7iw","_id":"ck8fb4aec0044k2o5h5sppkvw"},{"post_id":"ck8fb4ad1002gk2o5xp846y8p","category_id":"ck8fb4aeb003uk2o5ns49o7iw","_id":"ck8fb4aec0049k2o57py93i7t"},{"post_id":"ck8fb4ada002kk2o55tlbepnc","category_id":"ck8fb4ae7003lk2o5ix733zs0","_id":"ck8fb4aed004ck2o5iz3uys4l"},{"post_id":"ck8fb4ado002ok2o5ky2m2j0v","category_id":"ck8fb4aeb003uk2o5ns49o7iw","_id":"ck8fb4aee004hk2o5fa4vmwsx"},{"post_id":"ck8fb4adw002rk2o5i698re3l","category_id":"ck8fb4aeb003uk2o5ns49o7iw","_id":"ck8fb4aef004mk2o5gp1kqac0"},{"post_id":"ck8fb4adx002wk2o5e20hnos3","category_id":"ck8fb4aeb003uk2o5ns49o7iw","_id":"ck8fb4aeg004rk2o5ms1uhari"},{"post_id":"ck8fb4adz002zk2o5vlxhf5qi","category_id":"ck8fb4aeb003uk2o5ns49o7iw","_id":"ck8fb4aeg004vk2o56eyqrek3"},{"post_id":"ck8fb4ae20034k2o5rlnmohc6","category_id":"ck8fb4ae40038k2o5nk6rvvab","_id":"ck8fb4aeh004zk2o5pppj1vv5"},{"post_id":"ck8fb4ajy006wk2o5bkmx50wk","category_id":"ck8fb4ak1006yk2o5p43zplnx","_id":"ck8fb4ak40073k2o5exkycg66"},{"post_id":"ck8fb4ajz006xk2o5ntw5xnjq","category_id":"ck8fb4ak40070k2o5mhhb8qxh","_id":"ck8fb4ak50075k2o5h1r8xkkb"},{"post_id":"ck8fb4ann0079k2o52rrhwwcc","category_id":"ck8fb4a890004k2o5isqmeoli","_id":"ck8fb4anq007bk2o5qjqptja0"}],"PostTag":[{"post_id":"ck8fb4a7y0000k2o5uyka3ixq","tag_id":"ck8fb4a8a0005k2o52wuuszfb","_id":"ck8fb4a8t000nk2o5dtjxch1x"},{"post_id":"ck8fb4a7y0000k2o5uyka3ixq","tag_id":"ck8fb4a8j000bk2o5mfw0cg77","_id":"ck8fb4a8v000pk2o51swtie5k"},{"post_id":"ck8fb4a7y0000k2o5uyka3ixq","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4a94000uk2o5fpt0tkav"},{"post_id":"ck8fb4a860002k2o5csx56k4q","tag_id":"ck8fb4a8r000lk2o5h4mo6otf","_id":"ck8fb4a9n0010k2o5zlc9fpt8"},{"post_id":"ck8fb4a860002k2o5csx56k4q","tag_id":"ck8fb4a91000sk2o5av969pju","_id":"ck8fb4a9s0013k2o5icl63vfw"},{"post_id":"ck8fb4aaf001ck2o52sdtexij","tag_id":"ck8fb4a8a0005k2o52wuuszfb","_id":"ck8fb4aav001hk2o5b6fykd5f"},{"post_id":"ck8fb4aaf001ck2o52sdtexij","tag_id":"ck8fb4a8j000bk2o5mfw0cg77","_id":"ck8fb4ab2001jk2o5zvkox812"},{"post_id":"ck8fb4aaf001ck2o52sdtexij","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4abc001nk2o581jncjuq"},{"post_id":"ck8fb4a8b0006k2o53jxnri0h","tag_id":"ck8fb4a9j000zk2o5yxesbs5x","_id":"ck8fb4abm001rk2o5pp0zfwla"},{"post_id":"ck8fb4a8b0006k2o53jxnri0h","tag_id":"ck8fb4a9u0016k2o5u2aunpzz","_id":"ck8fb4abx001vk2o506sayi6k"},{"post_id":"ck8fb4a8b0006k2o53jxnri0h","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4ac5001zk2o5ayh6qntq"},{"post_id":"ck8fb4a8f0008k2o5tk37pyei","tag_id":"ck8fb4aav001gk2o5cvevu7ce","_id":"ck8fb4acc0023k2o5v8kl7s3h"},{"post_id":"ck8fb4ab2001kk2o5t4933ytk","tag_id":"ck8fb4a8a0005k2o52wuuszfb","_id":"ck8fb4ack0027k2o5cjw5hoic"},{"post_id":"ck8fb4ab2001kk2o5t4933ytk","tag_id":"ck8fb4a8j000bk2o5mfw0cg77","_id":"ck8fb4acs002bk2o5lhky1ncq"},{"post_id":"ck8fb4ab2001kk2o5t4933ytk","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4ad0002fk2o5jzflaz9s"},{"post_id":"ck8fb4a8h0009k2o5i5mhy2f9","tag_id":"ck8fb4aav001gk2o5cvevu7ce","_id":"ck8fb4ada002ik2o5x4vwtef8"},{"post_id":"ck8fb4abm001sk2o5dtcyl3bf","tag_id":"ck8fb4a8a0005k2o52wuuszfb","_id":"ck8fb4adn002nk2o5i66kipft"},{"post_id":"ck8fb4abm001sk2o5dtcyl3bf","tag_id":"ck8fb4a8j000bk2o5mfw0cg77","_id":"ck8fb4adv002qk2o5lmqjqocy"},{"post_id":"ck8fb4abm001sk2o5dtcyl3bf","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4adx002vk2o5su40xz1z"},{"post_id":"ck8fb4aby001xk2o5ztg0plf2","tag_id":"ck8fb4a8a0005k2o52wuuszfb","_id":"ck8fb4adz002yk2o5zopwg3ut"},{"post_id":"ck8fb4aby001xk2o5ztg0plf2","tag_id":"ck8fb4a8j000bk2o5mfw0cg77","_id":"ck8fb4ae20033k2o5gjcbg0l4"},{"post_id":"ck8fb4aby001xk2o5ztg0plf2","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4ae30036k2o5354lodvy"},{"post_id":"ck8fb4a8k000ck2o5l35k7e4n","tag_id":"ck8fb4abx001wk2o5x2v9l55l","_id":"ck8fb4ae5003bk2o5zgmhg69h"},{"post_id":"ck8fb4a8m000dk2o5i6lsj1vz","tag_id":"ck8fb4abx001wk2o5x2v9l55l","_id":"ck8fb4ae6003dk2o52t8cw99i"},{"post_id":"ck8fb4a8o000hk2o5pvv4qvrr","tag_id":"ck8fb4abx001wk2o5x2v9l55l","_id":"ck8fb4ae7003hk2o5r6sk13fi"},{"post_id":"ck8fb4a8q000ik2o51yuoss7g","tag_id":"ck8fb4abx001wk2o5x2v9l55l","_id":"ck8fb4ae7003jk2o5x0161spv"},{"post_id":"ck8fb4a8r000mk2o5q3lvjr2d","tag_id":"ck8fb4abx001wk2o5x2v9l55l","_id":"ck8fb4ae7003mk2o5ad0ajfcx"},{"post_id":"ck8fb4a8t000ok2o5lm4sj09p","tag_id":"ck8fb4a8a0005k2o52wuuszfb","_id":"ck8fb4ae9003pk2o5e0kh18f4"},{"post_id":"ck8fb4a8t000ok2o5lm4sj09p","tag_id":"ck8fb4ae20032k2o5o0aetc82","_id":"ck8fb4aeb003sk2o5mku4o8iq"},{"post_id":"ck8fb4a92000tk2o5p0gggblb","tag_id":"ck8fb4ae4003ak2o5dd3i66fv","_id":"ck8fb4aeb003xk2o5jrfzgsam"},{"post_id":"ck8fb4a92000tk2o5p0gggblb","tag_id":"ck8fb4ae7003gk2o5vatbtys4","_id":"ck8fb4aec0040k2o56l174uqh"},{"post_id":"ck8fb4a92000tk2o5p0gggblb","tag_id":"ck8fb4ae8003nk2o5vmvx1mcm","_id":"ck8fb4aec0042k2o5lakoty6j"},{"post_id":"ck8fb4a92000tk2o5p0gggblb","tag_id":"ck8fb4aeb003tk2o5u0sqgxfo","_id":"ck8fb4aec0045k2o5n3w0s86s"},{"post_id":"ck8fb4a9a000vk2o55nnw227b","tag_id":"ck8fb4aeb003wk2o5cgskks8p","_id":"ck8fb4aec0047k2o553ddljax"},{"post_id":"ck8fb4a9j000yk2o5fh38du4l","tag_id":"ck8fb4aec0041k2o50e4vc8h1","_id":"ck8fb4aed004dk2o5schjih1v"},{"post_id":"ck8fb4a9j000yk2o5fh38du4l","tag_id":"ck8fb4a8a0005k2o52wuuszfb","_id":"ck8fb4aed004ek2o59mgcv9zi"},{"post_id":"ck8fb4a9j000yk2o5fh38du4l","tag_id":"ck8fb4aec0046k2o57h8zufq1","_id":"ck8fb4aee004ik2o5qmbnfe0c"},{"post_id":"ck8fb4a9j000yk2o5fh38du4l","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4aee004jk2o5s7wqod83"},{"post_id":"ck8fb4a9o0011k2o5ns7o6spj","tag_id":"ck8fb4aec0041k2o50e4vc8h1","_id":"ck8fb4aef004nk2o5yao8xosu"},{"post_id":"ck8fb4a9o0011k2o5ns7o6spj","tag_id":"ck8fb4a8a0005k2o52wuuszfb","_id":"ck8fb4aef004ok2o5mf1mi8wz"},{"post_id":"ck8fb4a9o0011k2o5ns7o6spj","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4aeg004sk2o5y9ldkqqx"},{"post_id":"ck8fb4a9t0014k2o5dvor3mq2","tag_id":"ck8fb4aec0041k2o50e4vc8h1","_id":"ck8fb4aeg004tk2o54aek2a2v"},{"post_id":"ck8fb4a9t0014k2o5dvor3mq2","tag_id":"ck8fb4a8a0005k2o52wuuszfb","_id":"ck8fb4aeg004wk2o5va7osxp0"},{"post_id":"ck8fb4a9t0014k2o5dvor3mq2","tag_id":"ck8fb4aec0046k2o57h8zufq1","_id":"ck8fb4aeh004xk2o5c82eyac4"},{"post_id":"ck8fb4a9t0014k2o5dvor3mq2","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4aeh0050k2o54nifftrx"},{"post_id":"ck8fb4a9z0017k2o53yy94api","tag_id":"ck8fb4aef004pk2o5ki57jcbp","_id":"ck8fb4aeh0051k2o54aeo1c6u"},{"post_id":"ck8fb4a9z0017k2o53yy94api","tag_id":"ck8fb4ae8003nk2o5vmvx1mcm","_id":"ck8fb4aeh0053k2o58oej3v6e"},{"post_id":"ck8fb4aa50018k2o5y60yv72v","tag_id":"ck8fb4aec0041k2o50e4vc8h1","_id":"ck8fb4aei0055k2o5aknbn29y"},{"post_id":"ck8fb4aa50018k2o5y60yv72v","tag_id":"ck8fb4a8a0005k2o52wuuszfb","_id":"ck8fb4aei0056k2o56vznz4i3"},{"post_id":"ck8fb4aa50018k2o5y60yv72v","tag_id":"ck8fb4aec0046k2o57h8zufq1","_id":"ck8fb4aej0058k2o5jtup6i76"},{"post_id":"ck8fb4aa50018k2o5y60yv72v","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4aej0059k2o57dqgfdpr"},{"post_id":"ck8fb4aao001dk2o5ncgo8hny","tag_id":"ck8fb4a8a0005k2o52wuuszfb","_id":"ck8fb4aej005bk2o57vl07sfm"},{"post_id":"ck8fb4aao001dk2o5ncgo8hny","tag_id":"ck8fb4aeh0054k2o5y872wk3w","_id":"ck8fb4aej005ck2o5y2h8bhd1"},{"post_id":"ck8fb4aao001dk2o5ncgo8hny","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4aek005ek2o50x0706qt"},{"post_id":"ck8fb4aav001ik2o5ugy3spbn","tag_id":"ck8fb4a8a0005k2o52wuuszfb","_id":"ck8fb4aek005fk2o5mx8uc09o"},{"post_id":"ck8fb4aav001ik2o5ugy3spbn","tag_id":"ck8fb4aei0057k2o5vorvlgka","_id":"ck8fb4aek005hk2o5d3iyifnr"},{"post_id":"ck8fb4aav001ik2o5ugy3spbn","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4ael005ik2o55qo6fq4h"},{"post_id":"ck8fb4abc001pk2o5vizlbue7","tag_id":"ck8fb4a8a0005k2o52wuuszfb","_id":"ck8fb4ael005jk2o59tcco1ai"},{"post_id":"ck8fb4abc001pk2o5vizlbue7","tag_id":"ck8fb4aei0057k2o5vorvlgka","_id":"ck8fb4aem005lk2o5r5ezcysm"},{"post_id":"ck8fb4abc001pk2o5vizlbue7","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4aem005mk2o5dsh5jlnd"},{"post_id":"ck8fb4ac50020k2o5q71z9gm2","tag_id":"ck8fb4a8a0005k2o52wuuszfb","_id":"ck8fb4aem005ok2o5d8kr6y5w"},{"post_id":"ck8fb4ac50020k2o5q71z9gm2","tag_id":"ck8fb4aek005dk2o5mei5ncxu","_id":"ck8fb4aem005pk2o53gcyx7wk"},{"post_id":"ck8fb4ac50020k2o5q71z9gm2","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4aen005rk2o58azxg1xq"},{"post_id":"ck8fb4acc0024k2o50l4jyrn8","tag_id":"ck8fb4aek005gk2o5a9kfmt0k","_id":"ck8fb4aen005sk2o5yk406kiq"},{"post_id":"ck8fb4acc0024k2o50l4jyrn8","tag_id":"ck8fb4a8a0005k2o52wuuszfb","_id":"ck8fb4aen005uk2o5f4lcxaiu"},{"post_id":"ck8fb4acc0024k2o50l4jyrn8","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4aen005vk2o558wek3tt"},{"post_id":"ck8fb4ack0028k2o5kbmrh14h","tag_id":"ck8fb4aek005gk2o5a9kfmt0k","_id":"ck8fb4aen005xk2o5l50sgsa7"},{"post_id":"ck8fb4ack0028k2o5kbmrh14h","tag_id":"ck8fb4a8a0005k2o52wuuszfb","_id":"ck8fb4aeo005yk2o561r9i208"},{"post_id":"ck8fb4ack0028k2o5kbmrh14h","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4aeo0060k2o5hfsvy5xw"},{"post_id":"ck8fb4acs002ck2o5t90ziyb8","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4aeo0061k2o5hv0ek0ih"},{"post_id":"ck8fb4acs002ck2o5t90ziyb8","tag_id":"ck8fb4aem005nk2o5x52uims6","_id":"ck8fb4aeo0063k2o5hb2grvog"},{"post_id":"ck8fb4ad1002gk2o5xp846y8p","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4aeo0064k2o5aejwluf6"},{"post_id":"ck8fb4ad1002gk2o5xp846y8p","tag_id":"ck8fb4aem005nk2o5x52uims6","_id":"ck8fb4aeo0066k2o5ygkm81wc"},{"post_id":"ck8fb4ada002kk2o55tlbepnc","tag_id":"ck8fb4aek005gk2o5a9kfmt0k","_id":"ck8fb4aeo0067k2o5zdowr4io"},{"post_id":"ck8fb4ada002kk2o55tlbepnc","tag_id":"ck8fb4a8a0005k2o52wuuszfb","_id":"ck8fb4aep0069k2o57okp6xw0"},{"post_id":"ck8fb4ada002kk2o55tlbepnc","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4aep006ak2o5r7h25r3e"},{"post_id":"ck8fb4ado002ok2o5ky2m2j0v","tag_id":"ck8fb4aem005nk2o5x52uims6","_id":"ck8fb4aep006ck2o5g4quek3e"},{"post_id":"ck8fb4ado002ok2o5ky2m2j0v","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4aep006dk2o50x3eyqdg"},{"post_id":"ck8fb4adw002rk2o5i698re3l","tag_id":"ck8fb4aem005nk2o5x52uims6","_id":"ck8fb4aep006fk2o5a07g9dtm"},{"post_id":"ck8fb4adx002wk2o5e20hnos3","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4aep006gk2o5s2bhgdtm"},{"post_id":"ck8fb4adx002wk2o5e20hnos3","tag_id":"ck8fb4aem005nk2o5x52uims6","_id":"ck8fb4aeq006ik2o58bdq2orj"},{"post_id":"ck8fb4adx002wk2o5e20hnos3","tag_id":"ck8fb4aeo0065k2o5pd6svwuz","_id":"ck8fb4aeq006jk2o55abqkxf4"},{"post_id":"ck8fb4adz002zk2o5vlxhf5qi","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4aeq006lk2o5ndg5qh4y"},{"post_id":"ck8fb4adz002zk2o5vlxhf5qi","tag_id":"ck8fb4aem005nk2o5x52uims6","_id":"ck8fb4aeq006mk2o5y3sq5s5v"},{"post_id":"ck8fb4adz002zk2o5vlxhf5qi","tag_id":"ck8fb4aeo0065k2o5pd6svwuz","_id":"ck8fb4aeq006ok2o54kacsu5u"},{"post_id":"ck8fb4ae20034k2o5rlnmohc6","tag_id":"ck8fb4a9j000zk2o5yxesbs5x","_id":"ck8fb4aeq006pk2o5h1a76xf8"},{"post_id":"ck8fb4ae20034k2o5rlnmohc6","tag_id":"ck8fb4ae8003nk2o5vmvx1mcm","_id":"ck8fb4aeq006qk2o5rrk14lcz"},{"post_id":"ck8fb4ae20034k2o5rlnmohc6","tag_id":"ck8fb4aep006hk2o5tt6kyush","_id":"ck8fb4aer006rk2o524xvb40h"},{"post_id":"ck8fb4ae30037k2o5u8igi2zj","tag_id":"ck8fb4a8r000lk2o5h4mo6otf","_id":"ck8fb4aer006sk2o55rpwwngx"},{"post_id":"ck8fb4ae30037k2o5u8igi2zj","tag_id":"ck8fb4aeh0054k2o5y872wk3w","_id":"ck8fb4aer006tk2o524xqy3lq"},{"post_id":"ck8fb4ae5003ck2o5y3l1nfvu","tag_id":"ck8fb4a8r000lk2o5h4mo6otf","_id":"ck8fb4aer006uk2o57n9kvl39"},{"post_id":"ck8fb4ae5003ck2o5y3l1nfvu","tag_id":"ck8fb4aeh0054k2o5y872wk3w","_id":"ck8fb4aer006vk2o5p7w2wpp7"},{"post_id":"ck8fb4ajy006wk2o5bkmx50wk","tag_id":"ck8fb4ak2006zk2o5a7ifzdgf","_id":"ck8fb4ak40072k2o5pjwcfijo"},{"post_id":"ck8fb4ajz006xk2o5ntw5xnjq","tag_id":"ck8fb4a8o000gk2o58zwytdjk","_id":"ck8fb4ak60076k2o5j6bxi0ss"},{"post_id":"ck8fb4ajz006xk2o5ntw5xnjq","tag_id":"ck8fb4ak40071k2o55oarxv4o","_id":"ck8fb4ak60077k2o514mh377y"},{"post_id":"ck8fb4ajz006xk2o5ntw5xnjq","tag_id":"ck8fb4ak40074k2o5ephya7g0","_id":"ck8fb4ak60078k2o5rvt0a2v8"},{"post_id":"ck8fb4ann0079k2o52rrhwwcc","tag_id":"ck8fb4a8a0005k2o52wuuszfb","_id":"ck8fb4aod007ck2o5btv561q9"},{"post_id":"ck8fb4ann0079k2o52rrhwwcc","tag_id":"ck8fb4anp007ak2o54gi6lwsl","_id":"ck8fb4aom007dk2o5v0t01vtj"}],"Tag":[{"name":"JAVA","_id":"ck8fb4a8a0005k2o52wuuszfb"},{"name":"并发","_id":"ck8fb4a8j000bk2o5mfw0cg77"},{"name":"学习笔记","_id":"ck8fb4a8o000gk2o58zwytdjk"},{"name":"redis","_id":"ck8fb4a8r000lk2o5h4mo6otf"},{"name":"面试总结","_id":"ck8fb4a91000sk2o5av969pju"},{"name":"MyBatis","_id":"ck8fb4a9j000zk2o5yxesbs5x"},{"name":"框架","_id":"ck8fb4a9u0016k2o5u2aunpzz"},{"name":"C++","_id":"ck8fb4aav001gk2o5cvevu7ce"},{"name":"设计模式","_id":"ck8fb4abx001wk2o5x2v9l55l"},{"name":"GUAVA","_id":"ck8fb4ae20032k2o5o0aetc82"},{"name":"github","_id":"ck8fb4ae4003ak2o5dd3i66fv"},{"name":"hexo","_id":"ck8fb4ae7003gk2o5vatbtys4"},{"name":"教程","_id":"ck8fb4ae8003nk2o5vmvx1mcm"},{"name":"blog","_id":"ck8fb4aeb003tk2o5u0sqgxfo"},{"name":"Idea","_id":"ck8fb4aeb003wk2o5cgskks8p"},{"name":"JVM","_id":"ck8fb4aec0041k2o50e4vc8h1"},{"name":"GO","_id":"ck8fb4aec0046k2o57h8zufq1"},{"name":"git","_id":"ck8fb4aef004pk2o5ki57jcbp"},{"name":"源码","_id":"ck8fb4aeh0054k2o5y872wk3w"},{"name":"Spring","_id":"ck8fb4aei0057k2o5vorvlgka"},{"name":"线程池","_id":"ck8fb4aek005dk2o5mei5ncxu"},{"name":"Kafka","_id":"ck8fb4aek005gk2o5a9kfmt0k"},{"name":"MySql","_id":"ck8fb4aem005nk2o5x52uims6"},{"name":"InnoDB","_id":"ck8fb4aeo0065k2o5pd6svwuz"},{"name":"Spring Boot","_id":"ck8fb4aep006hk2o5tt6kyush"},{"name":"旅游攻略","_id":"ck8fb4ak2006zk2o5a7ifzdgf"},{"name":"树","_id":"ck8fb4ak40071k2o55oarxv4o"},{"name":"数据结构","_id":"ck8fb4ak40074k2o5ephya7g0"},{"name":"面试","_id":"ck8fb4anp007ak2o54gi6lwsl"}]}}