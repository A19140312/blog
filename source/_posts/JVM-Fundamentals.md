---
title: Java虚拟机
date: 2019-12-30 17:47:00
tags:
    - JVM
    - JAVA
    - 学习笔记
categories: JVM
author: Guyuqing
copyright: true
comments: false
---
Java虚拟机(java virtual machine，JVM)，一种能够运行java字节码的虚拟机。作为一种编程语言的虚拟机，实际上不只是专用于Java语言，只要生成的编译文件匹配JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。 比如kotlin、scala等。
<!-- more -->
# JVM基本结构
JVM由三个主要的子系统构成
* 类加载子系统
* 运行时数据区(内存结构)
* 执行引擎
![](JVM-Fundamentals/1.png)

## 类加载机制
### 类的生命周期
![](JVM-Fundamentals/2.png)
1. 加载：将.class文件从磁盘读到内存
    * 通过类的全限定名(com.xxx.xxx)+类加载器确定唯一的类，来获取定义此类的二进制字节流
    * 将这个类字节流代表的静态存储结构转为方法区的运行时数据结构
    * 在堆中生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口。
2. 连接
    1. 验证：验证字节码文件的正确性
        * 文件格式验证：基于字节流验证。
        * 元数据验证：基于方法区的存储结构验证。
        * 字节码验证：基于方法区的存储结构验证。
        * 符号引用验证：基于方法区的存储结构验证。
    2. 准备：给类的静态变量分配内存，并赋予`默认值`（不包括实例变量）
        * public static int value = 123; //此时在准备阶段过后的初始值为0而不是123，在初始化过程才会被赋值为123
        * public static final int value = 123;//value的值在准备阶段过后就是123。
    3. 解析：类装载器装入类所引用的其它所有类
3. 初始化：为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序编写者为变量分配的真正的初始值，执行静态代码块
4. 使用
5. 卸载

### 类加载器的种类
总体上分为两种：启动类加载器（C++实现） 和 其他类加载器（JAVA实现）
#### 启动类加载器(Bootstrap ClassLoader)
负责加载JRE的核心类库，如JRE目标下的rt.jar，charsets.jar等
#### 扩展类加载器(Extension ClassLoader)
负责加载JRE扩展目录ext中jar类包
#### 系统类加载器(Application ClassLoader)
负责加载ClassPath路径下的类包
#### 用户自定义加载器(User ClassLoader)
负责加载用户自定义路径下的类包

![](JVM-Fundamentals/3.png)

### 类加载机制
#### 全盘负责委托机制
当一个ClassLoader加载一个类的时候，除非显示的使用另一个ClassLoader，该类所依赖和引用的类也由这个 ClassLoader载入

#### 双亲委派机制
指先委托父类加载器寻找目标类，在找不到的情况下，在自己的路径中查找并载入目标类
![](JVM-Fundamentals/4.png)
1. 当有类需要加载，系统类加载器先判断有没有父类，有交给扩展类加载器加载
2. 扩展类加载器判断有没有父类，有交给启动类加载器
3. 启动类加载器没有父类，去实际加载该类，该类不是JRE包下的类，交给子类扩展类加载器去加载
4. 扩展类加载器去加载该类，发现该类不是ext中的包，交给系统类加载器加载
5. 系统类加载器加载，发现是classPath路径下的包，进行加载。

##### 双亲委派模式的优势
* 沙箱安全机制:比如自己写的String.class类不会被加载，这样可以防止核心库被随意篡改
* 避免类的重复加载:当父ClassLoader已经加载了该类的时候，就不需要子ClassLoader再加载一次

##### 为什么要打破双亲委派模式
例如：tomcat 
Tomcat是个web容器,可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。 
如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加载器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。

##### 如何打破双亲委派模式
1. 继承ClassLoader
2. 重写findClass()方法
3. 重写loadClass()方法

## 运行时数据区(内存结构)
![](JVM-Fundamentals/5.png)

### 虚拟机栈
java虚拟机栈是线程私有的，每个方法执行都会创建一个栈帧，栈帧包含局部变量表、操作数栈、动态连接、方法出口等。

#### 栈与栈帧
每一个方法的执行到执行完成，对应着一个栈帧在虚拟机中从入栈到出栈的过程。java虚拟机栈栈顶的栈帧就是当前执行方法的栈帧。PC寄存器会指向该地址。当这个方法调用其他方法的时候久会创建一个新的栈帧，这个新的栈帧会被方法Java虚拟机栈的栈顶，变为当前的活动栈，在当前只有当前活动栈的本地变量才能被使用，当这个栈帧所有指令都完成的时候，这个栈帧被移除，之前的栈帧变为活动栈，前面移除栈帧的返回值变为这个栈帧的一个操作数。

#### 栈帧
栈帧包含局部变量表、操作数栈、动态连接、方法返回地址

##### 局部变量表
* 局部变量表是变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在java编译成class文件的时候，就在方法的Code属性的max_locals数据项中确定该方法需要分配的最大局部变量表的容量。
* 局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放32位（4 字节）以内的数据类型（ boolean、byte、char、short、int、float、reference和returnAddress八种）
* 对于64位长度的数据类型（long，double），虚拟机会以高位对齐方式为其分配`两个连续的Slot`空间，也就是相当于把一次long和double数据类型读写分割成为两次32位读写。
* reference类型虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。
* Slot是可以重用的，当Slot中的变量超出了作用域，那么下一次分配Slot的时候，将会覆盖原来的数据。Slot对对象的引用会影响GC（要是被引用，将不会被回收）。  
* 系统不会为局部变量赋予初始值（实例变量和类变量都会被赋予初始值）。也就是说不存在类变量那样的准备阶段。

##### 操作数栈
* 操作数栈和局部变量表一样，在编译时期就已经确定了该方法所需要分配的局部变量表的最大容量。
* 操作数栈的每一个元素可用是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型占用的栈容量为2。
* 当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈 / 入栈操作（例如：在做算术运算的时候是通过操作数栈来进行的，又或者在调用其它方法的时候是通过操作数栈来进行参数传递的）。

##### 动态连接
直接引用：有具体引用地址的指针，被引用的类、方法或者变量已经被加载到内存中
符号引用：即用用字符串符号的形式来表示引用，其实被引用的类、方法或者变量还没有被加载到内存中。
举个例子：
```java
/**
* 符号引用
*/
String str = "abc";
System.out.println("str=" + str);
/**
* 直接引用
*/
System.out.println("str=" + "abc");
```

动态链接：在程序运行过程中，由符号引用转化为直接引用。
静态链接：在类加载过程中，由符号引用转化为直接引用。

##### 方法返回地址
当一个方法开始执行时，可能有两种方式退出该方法：
* 正常完成出口
    * 正常完成出口是指方法正常完成并退出，没有抛出任何异常(包括Java虚拟机异常以及执行时通过throw语句显示抛出的异常)。如果当前方法正常完成，则根据当前方法返回的字节码指令，这时有可能会有返回值传递给方法调用者(调用它的方法)，或者无返回值。具体是否有返回值以及返回值的数据类型将根据该方法返回的字节码指令确定。
* 异常完成出口
    * 异常完成出口是指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退出。
    
无论方法采用何种方式退出，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在当前栈帧中保存一些信息，用来帮他恢复它的上层方法执行状态。
方法退出过程实际上就等同于把当前栈帧出栈，因此退出可以执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压如调用者的操作数栈中，调整PC计数器的值以指向方法调用指令后的下一条指令。
一般来说，方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理器表确定的，栈帧中一般不会保存此部分信息。

```java
public class Demo {
    public int math(){
        int a = 1;
        int b = 2;
        int c = (a + b)*10;
        return c;
    }
    public static void main(String[] args) {
        Demo demo = new Demo();
        demo.math();
    }
}
```
当执行👆Demo的math方法时，主线程内存会如何操作
![](JVM-Fundamentals/5.1.png)
第一步，现将1放入`操作数栈`
![](JVM-Fundamentals/5.2.png)
第二步，将1放入`局部变量表`中第一个槽里
![](JVM-Fundamentals/5.3.png)
第三步，第四步同上，最终将2放入`局部变量表`中第二个槽里
![](JVM-Fundamentals/5.4.png)
第五步，将1复制一份放入`操作数栈`的栈顶
第六步，将2复制一份放入`操作数栈`的栈顶
![](JVM-Fundamentals/5.5.png)
第七步，将2，1弹出操作数栈交给cpu去运算得到3，放到`操作数栈`的栈顶
![](JVM-Fundamentals/5.6.png)
第八步，从常量池（-128～127）里拿到10，放入`操作数栈`顶
![](JVM-Fundamentals/5.7.png)
第九步，弹出10，3交给cpu去运算得到30，放到`操作数栈`的栈顶（jvm1.6开始进行了指令优化，第8、9步合并成了一步操作）
![](JVM-Fundamentals/5.8.png)
第十步，将30放到`局部变量表`中第3个槽里。
![](JVM-Fundamentals/5.9.png)
第十一步，将30复制一份放入`操作数栈`第栈顶。
第十二步，将30弹出操作数栈，通过`返回地址`返回。

### 程序计数器
就是一个指针，指向方法区中的方法字节码(用来存储**指向下一跳指令的地址**，也就是当前线程将要执行的指令代码)，
由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计，用来保证线程间切换后正确执行。

### 本地方法栈
和栈作用很相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行native方法服务。
登记native方法，在Execution Engine执行时加载本地方法库。

### 方法区
类的所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在这里定义。
简单来说，所有定义的方法的信息都保存在该区域，静态变量+常量+类信息(构造方法/接口定义)+运行时常量池都存在方法区中，
虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap(非堆)，目的应该是为了和Java的堆区分开(jdk1.8以前hotspot虚拟机叫永久代、持久代，jdk1.8时叫元空间)

### 堆
虚拟机启动时自动分配创建，用于存放`对象`的实例，几乎所有对象都在堆上分配内存，当对象无法在该空间申请到内
存是将抛出OutOfMemoryError异常。同时也是垃圾收集器管理的主要区域。
![](JVM-Fundamentals/6.jpeg)

#### 新生代(Young Generation)
类出生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。
新生代分为两部分:`伊甸区`(Eden space)和`幸存者区`(Survivor space)，所有的类都是在伊甸区被new出来的。
幸存区(Survivor space):分为From和To区,TO区永远保持空。
当Eden区的空间用完是，程序又需要创建对象，JVM的垃圾回收器将Eden区进行垃圾回收(`Minor GC`)，将Eden区中的不再被其它对象应用的对象进行销毁。
然后将Eden区中剩余的对象移到From Survivor区。若From Survivor区也满了，再对该区进行垃圾回收，然后移动到To Survivor区，From区为空后，将To和From区转换，保证To区为空，并且对象年龄加一。
当对象年龄默认加到15（因为**对象头只有4个bits**是存对象年龄，最大为15）时将剩下的对象移到老年代。

### 老年代(Old Generation)
新生代经过多次GC仍然存货的对象移动到老年区。
若老年代也满了，这时候将发生Major GC(也可以叫`Full GC`)， 进行老年区的内存清理。
若老年区执行了Full GC之后发现依然无法进行对象的保存，就会抛出 OOM(OutOfMemoryError)异常.

### 元空间(Meta Space)
在JDK1.8之后，元空间替代了永久代，它是对JVM规范中方法区的实现。
区别在于元数据区不在虚拟机当中，而是用的本地内存，永久代在虚拟机当中，永久代逻辑结构上也属于堆，但是物理上不属于。

#### 为什么移除了永久代?
参考官方解释http://openjdk.java.net/jeps/122
大概意思是移除永久代是为融合HotSpot与 JRockit而做出的努力，因为JRockit没有永久代，不需要配置永久代。
![](JVM-Fundamentals/7.png)


## GC算法和收集器

### 如何判断对象可以被回收
堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡(即不能再被任何途径使用的对象)

#### 引用计数法
给对象添加一个引用计数器，每当有一个地方引用，计数器就加1。当引用失效，计数器就减1。任何时候计数器为0 的对象就是不可能再被使用的。

这个方法实现简单，效率高，但是目前主流的虚拟机中没有选择这个算法来管理内存，最主要的原因是它很难解决**对象之前相互循环引用**的问题。所谓对象之间的相互引用问题，通过下面代码所示:除了对象a和b相互引用着对方之外，这两个对象之间再无任何引用。但是它们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数器法无法通知GC回收器回收它们。

```java
public class CounterGC{
    Object instance = null;
    public static void main(String[] args){
      CounterGC a = new CounterGC();
      CounterGC b = new CounterGC();
      a.instance = b;
      b.instance = a;
      a = null;
      b = null;
    }
}
```


#### 可达性分析算法
这个算法的基本思想就是通过一系列的称为"GC Roots"的对象作为起点，从这些节点开始向下搜索，节点所走过的路
径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象时不可用的。

`GC Roots根节点`:类加载器、Thread、虚拟机栈的局部变量表、static成员、常量引用、本地方法栈的变量等等.
![](JVM-Fundamentals/8.png)

### 如何判断一个常量是废弃常量
运行时常量池主要回收的是废弃的常量。那么，我们怎么判断一个常量时废弃常量呢?
假如在常量池中存在字符串"abc"，如果当前没有任何String对象引用该字符串常量的话，就说明常量”abc“就是废弃 常量，如果这时发生内存回收的话而且有必要的话，”abc“会被系统清理出常量池。

### 如何判断一个类是无用的类
需要满足以下三个条件:
* 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
* 加载该类的 ClassLoader 已经被回收。
* 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
虚拟机可以对满足上述3个条件的无用类进行回收，这里仅仅是"**可以**"，而并不是和对象一样不适用了就必然会被回收。

