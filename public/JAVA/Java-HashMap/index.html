<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="mask-icon" href="/images/favicon.ico?v=5.1.4" color="#222"><meta name="keywords" content="JAVA,学习笔记,源码,"><meta name="description" content="HashMap 的存储结构HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的 123456789101112131415161718192021222324252627282930313233343536373839static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; &amp;#123;	final int has"><meta name="keywords" content="JAVA,学习笔记,源码"><meta property="og:type" content="article"><meta property="og:title" content="JAVA-HashMap源码解析"><meta property="og:url" content="https://a19140312.github.io/JAVA/Java-HashMap/index.html"><meta property="og:site_name" content="qing&#39;s 随笔"><meta property="og:description" content="HashMap 的存储结构HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的 123456789101112131415161718192021222324252627282930313233343536373839static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; &amp;#123;	final int has"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2020-03-12T08:44:32.026Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JAVA-HashMap源码解析"><meta name="twitter:description" content="HashMap 的存储结构HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的 123456789101112131415161718192021222324252627282930313233343536373839static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; &amp;#123;	final int has"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!0,onmobile:!0},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><script></script><link rel="canonical" href="https://a19140312.github.io/JAVA/Java-HashMap/"><script src="https://neveryu.github.io/js/src/pace.min.js"></script><script data-ad-client="ca-pub-3961457011147580" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><title>JAVA-HashMap源码解析 | qing's 随笔</title></head><body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">qing's 随笔</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br> 公益404</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://a19140312.github.io/JAVA/Java-HashMap/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="guyuqing"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="qing's 随笔"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">JAVA-HashMap源码解析</h1><div class="post-meta"> <span itemprop="about" itemscope="" itemtype="https://schema.org/Thing"><a href="/authors/Guyuqing" itemprop="url" rel="index"><span itemprop="name">Guyuqing</span></a></span><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-05T15:07:00+08:00">2020-03-05</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a></span></span> <span class="post-meta-divider">|</span><span class="page-pv"><i class="fa fa-file-o"></i> 阅读数<span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="HashMap-的存储结构"><a href="#HashMap-的存储结构" class="headerlink" title="HashMap 的存储结构"></a>HashMap 的存储结构</h1><p>HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">// key的hash值</span></span><br><span class="line">	<span class="keyword">final</span> K key; <span class="comment">// key</span></span><br><span class="line">	V value; <span class="comment">// value</span></span><br><span class="line">	Node&lt;K,V&gt; next; <span class="comment">//同一个hash值下的链表/红黑树</span></span><br><span class="line"></span><br><span class="line">	Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">		<span class="keyword">this</span>.hash = hash;</span><br><span class="line">		<span class="keyword">this</span>.key = key;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">		<span class="keyword">this</span>.next = next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">		V oldValue = value;</span><br><span class="line">		value = newValue;</span><br><span class="line">		<span class="keyword">return</span> oldValue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">			Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">			<span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">					Objects.equals(value, e.getValue()))</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeNode&lt;K,V&gt; 继承 LinkedHashMap.Entry&lt;K,V&gt;，用来实现红黑树相关的存储结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// 存储当前节点的父节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;　<span class="comment">// 存储当前节点的左孩子</span></span><br><span class="line">    TreeNode&lt;K,V&gt; right;　<span class="comment">// 存储当前节点的右孩子</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// prev则指向前一个节点（原链表中的前一个节点）</span></span><br><span class="line">    <span class="keyword">boolean</span> red;　<span class="comment">// 存储当前节点的颜色（红、黑）</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// Red-black tree methods, all adapted from CLR</span></span><br><span class="line">    <span class="comment">// 红黑树相关操作</span></span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    &#125;       </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">checkInvariants</span><span class="params">(TreeNode&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="各常量、成员变量作用"><a href="#各常量、成员变量作用" class="headerlink" title="各常量、成员变量作用　　"></a>各常量、成员变量作用　　</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大容量， 当传入容量过大时将被这个值替换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认负载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当链表的长度超过8，有可能会转化成树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当链表的长度小于6则会从红黑树转回链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。</span></span><br><span class="line"><span class="comment"> * 这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来存储 key-value 的节点对象。在 HashMap 中它有个专业的叫法 buckets ，中文叫作桶。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同时封装了 keySet 和 values 的视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容器中实际存放 Node 的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap 在结构上被修改的次数，结构修改是指改变HashMap中映射的次数，或者以其他方式修改其内部结构(例如，rehash)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap的扩容阈值(=负载因子*table的容量)</span></span><br><span class="line"><span class="comment"> * 在HashMap中存储的Node键值对超过这个数量时，自动扩容容量为原来的二倍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity 初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      负载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果初始容量为负或者负载因子非正数抛出该异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 当初始容量为负</span></span><br><span class="line">	<span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">				initialCapacity);</span><br><span class="line">	<span class="comment">// 当初始容量大于最大容量 2^30 ，初始容量= 2^30</span></span><br><span class="line">	<span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">		initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">	<span class="comment">// 当负载因子非正数 或 负载因子是NaN(Not a Number，0.0f/0.0f的值就是NaN)</span></span><br><span class="line">	<span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">				loadFactor);</span><br><span class="line">	<span class="comment">// 赋值</span></span><br><span class="line">	<span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">	<span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取比传入参数大的最小的2的N次幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">	n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h1><p>put方法主要是调用putVal方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使 key 和 value 产生关联，但如果有相同的 key 则新的会替换掉旧的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * h &gt;&gt;&gt; 16:无符号右移动16位，意味着取高16位二进制</span></span><br><span class="line"><span class="comment"> * 低16位与高16位进行异或</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">	<span class="comment">// 如果为 null 则返回的就是 0，否则就是 hashCode 异或上 hashCode 无符号右移 16 位</span></span><br><span class="line">	<span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="putVal方法"><a href="#putVal方法" class="headerlink" title="putVal方法"></a>putVal方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 如果true代表不更改现有的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 如果为false表示table为创建状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">			   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断table是否等于空或者table的长度等于0，如果是就进行初始化</span></span><br><span class="line"><span class="comment">	 * 此时通过resize()方法得到初始化的table</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">		n = (tab = resize()).length;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 对hash码进行散列 ，对值的位置进行确认</span></span><br><span class="line"><span class="comment">	 * 如果tab[i] 为null 表示没有hash冲突，就新增一个元素</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">		tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果tab[i] 不为null，表示该位置有值了。</span></span><br><span class="line">		Node&lt;K,V&gt; e; K k;</span><br><span class="line">		<span class="comment">//HashMap中判断key相同的条件是key的hash相同，并且符合equals方法。这里判断了p.key是否和插入的key相等，如果相等，则将p的引用赋给e</span></span><br><span class="line">		<span class="comment">//这里为什么要把p赋值给e，而不是直接覆盖原值呢？答案很简单，现在我们只判断了第一个节点，后面还可能出现key相同，所以需要在最后一并处理</span></span><br><span class="line">		<span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">				((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">			e = p;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 判断是否是红黑树</span></span><br><span class="line"><span class="comment">		 * p是红黑树节点，那么肯定插入后仍然是红黑树节点，所以我们直接强制转型p后调用TreeNode.putTreeVal方法，返回的引用赋给e</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">			e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">		<span class="comment">// 否则就是链表</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果是链表，要遍历到最后一个节点进行插入</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// 插入到链尾</span></span><br><span class="line">					p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">					<span class="comment">// 判断节点的长度是否大于TREEIFY_THRESHOLD红黑树的阈值，是就进行转换</span></span><br><span class="line">					<span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">						treeifyBin(tab, hash);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 对链表中的相同 hash 值且 key 相同的进一步作检查</span></span><br><span class="line">				<span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">						((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				p = e;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 插入</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">			<span class="comment">// 取出旧值，onlyIfAbsent此时为 false，所以不管 oldValue 有与否，都拿新值来替换</span></span><br><span class="line">			V oldValue = e.value;</span><br><span class="line">			<span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">				e.value = value;</span><br><span class="line">			afterNodeAccess(e);</span><br><span class="line">			<span class="keyword">return</span> oldValue;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 记录修改次数</span></span><br><span class="line">	++modCount;</span><br><span class="line">	<span class="comment">// 超过阈值 threshold = capacity * factor，调用 resize() 进行扩容</span></span><br><span class="line">	<span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">		resize();</span><br><span class="line">	afterNodeInsertion(evict);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="resize-扩容兼初始化"><a href="#resize-扩容兼初始化" class="headerlink" title="resize 扩容兼初始化"></a>resize 扩容兼初始化</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment"> * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment"> * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment"> * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment"> * 扩容兼初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">	<span class="comment">//将原来的table指针保存</span></span><br><span class="line">	Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">	<span class="comment">//获取原来数组的长度，oldTab为null说明还没有进行初始化</span></span><br><span class="line">	<span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">	<span class="comment">//保存以前重构table的阈值</span></span><br><span class="line">	<span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">	<span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//oldCap &gt; 0表示已经初始化过了</span></span><br><span class="line">	<span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//当原来的容量已经达到最大容量的时候，将阈值设置为Integer.MAX_VALUE，这样就不会再发生重构的情况</span></span><br><span class="line">		<span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">			threshold = Integer.MAX_VALUE;</span><br><span class="line">			<span class="keyword">return</span> oldTab;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 否则将旧的容量扩大两倍</span></span><br><span class="line">		<span class="comment">// 当它小于最大容量，并且旧的容量大于初始化最小容量的时候，</span></span><br><span class="line">		<span class="comment">// 将新的阈值设置为旧的阈值的两倍, 新的容量设置为旧容量的2倍</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">				oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">			newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//虽然还没有初始化，但是设置过了阈值，将旧的阈值设置为新的容量</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">		newCap = oldThr;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//没有初始化阈值的时候采用默认算法计算阈值</span></span><br><span class="line">		newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">		newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 对应oldCap = 0 &amp;&amp; oldThr &gt; 0的情况</span></span><br><span class="line">	<span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//重新用默认负载因子计算 扩容阈值</span></span><br><span class="line">		<span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">		<span class="comment">// 如果新容量小于最大容量 &amp;&amp; 新扩容阈值(ft) 小于最大容量</span></span><br><span class="line">		<span class="comment">// 新阈值 = ft 否则 新阈值 = int的最大范围</span></span><br><span class="line">		newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">				(<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 把当前阈值设为新阈值</span></span><br><span class="line">	threshold = newThr;</span><br><span class="line">	<span class="comment">// 根据新容量，创建新table</span></span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">	Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">	<span class="comment">// 将当前table 设置为新扩容的table</span></span><br><span class="line">	table = newTab;</span><br><span class="line">	<span class="comment">// 如果已经被初始化过</span></span><br><span class="line">	<span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//将旧数组中的元素全部取出，重新映射到新数组中</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">			Node&lt;K,V&gt; e;</span><br><span class="line">			<span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">				oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">					<span class="comment">// 该节点没有next节点，表示没有链表，没有冲突，那重新计算下位置</span></span><br><span class="line">					newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">					<span class="comment">// 冲突的是一棵树节点，分裂成 2 个树，或者如果树很小就转成链表</span></span><br><span class="line">					((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 对原来的链表部分进行重构</span></span><br><span class="line">					Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">					Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">					Node&lt;K,V&gt; next;</span><br><span class="line">					<span class="keyword">do</span> &#123;</span><br><span class="line">						next = e.next;</span><br><span class="line">						<span class="comment">// 索引不变</span></span><br><span class="line">						<span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">							<span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">								loHead = e;</span><br><span class="line">							<span class="keyword">else</span></span><br><span class="line">								loTail.next = e;</span><br><span class="line">							loTail = e;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="comment">// 原索引+oldCap</span></span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							<span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">								hiHead = e;</span><br><span class="line">							<span class="keyword">else</span></span><br><span class="line">								hiTail.next = e;</span><br><span class="line">							hiTail = e;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">					<span class="comment">// 原索引放到 tables 里</span></span><br><span class="line">					<span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">						loTail.next = <span class="keyword">null</span>;</span><br><span class="line">						newTab[j] = loHead;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 原索引+oldCap放到  tables 里</span></span><br><span class="line">					<span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">						hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">						newTab[j + oldCap] = hiHead;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回扩容后的table</span></span><br><span class="line">	<span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="split-扩容时重新划分树"><a href="#split-扩容时重新划分树" class="headerlink" title="split 扩容时重新划分树"></a>split 扩容时重新划分树</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容时重新划分树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 扩容后的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 数组索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bit 原数组容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//b设置为当前桶的头节点</span></span><br><span class="line">	TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">	<span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">	<span class="comment">//低位树链表头节点，尾结点</span></span><br><span class="line">	TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">//高位树链表头节点，尾结点</span></span><br><span class="line">	TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">//lc低位树链表中节点个数，hc高位树链表中节点个数</span></span><br><span class="line">	<span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//e当前遍历节点</span></span><br><span class="line">	<span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">		<span class="comment">//当前遍历节点的后继节点</span></span><br><span class="line">		next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">		<span class="comment">//将当前遍历节点后继设为null</span></span><br><span class="line">		e.next = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">//==0表示当前遍历节点应该存放在低位</span></span><br><span class="line">			<span class="comment">//如果低位中还没有节点</span></span><br><span class="line">			<span class="comment">//将当前遍历节点设为低位头节点</span></span><br><span class="line">			<span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">				loHead = e;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="comment">//将当前遍历节点加入到链表的尾部</span></span><br><span class="line">				loTail.next = e;</span><br><span class="line">			<span class="comment">//设置尾节点为当前遍历节点</span></span><br><span class="line">			loTail = e;</span><br><span class="line">			<span class="comment">//低位链表中的节点数加1</span></span><br><span class="line">			++lc;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//!=0表示当前遍历节点应该存放在高位</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">				hiHead = e;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				hiTail.next = e;</span><br><span class="line">			hiTail = e;</span><br><span class="line">			++hc;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果低位节点链表不为null</span></span><br><span class="line">	<span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//低位节点链表中节点的个数小于6，此时需要将树结构转为链表结构</span></span><br><span class="line">		<span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">			tab[index] = loHead.untreeify(map);</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//链表中节点的个数满足保持树型结构所需要的节点个数</span></span><br><span class="line">			<span class="comment">//低位桶的头节点设为链表的头节点</span></span><br><span class="line">			tab[index] = loHead;</span><br><span class="line">			<span class="comment">// 高位节点链表不为null，说明有节点从原树结构中分离出去了</span></span><br><span class="line">			<span class="comment">// 原有树结构被破坏</span></span><br><span class="line">			<span class="comment">// 所以低位的节点链表需要重新构建树结构</span></span><br><span class="line">			<span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">				loHead.treeify(tab);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 同理</span></span><br><span class="line">	<span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">			tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			tab[index + bit] = hiHead;</span><br><span class="line">			<span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">				hiHead.treeify(tab);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="putTreeVal-在红黑树中添加节点"><a href="#putTreeVal-在红黑树中添加节点" class="headerlink" title="putTreeVal 在红黑树中添加节点"></a>putTreeVal 在红黑树中添加节点</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 当前节点所在的HashMap对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 当前HashMap对象的元素数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h key的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定key所匹配到的节点对象，针对这个对象去修改V（返回空说明创建了一个新节点）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">							   <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义k的Class对象</span></span><br><span class="line">	Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">// 标识是否已经遍历过一次树，未必是从根节点遍历的，但是遍历路径上一定已经包含了后续需要比对的所有节点。</span></span><br><span class="line">	<span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">//父节点不为空那么查找根节点，为空那么自身就是根节点</span></span><br><span class="line">	TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">	<span class="comment">// 从根节点开始遍历，没有终止条件，只能从内部退出</span></span><br><span class="line">	<span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">		<span class="comment">// 声明方向、当前节点hash值、当前节点的键对象</span></span><br><span class="line">		<span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">		<span class="comment">// 如果当前节点hash 大于 指定key的hash值,要添加的元素应该放置在当前节点的左侧</span></span><br><span class="line">		<span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">			dir = -<span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 如果当前节点hash 小于 指定key的hash值,要添加的元素应该放置在当前节点的右侧</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">			dir = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 如果当前节点的键对象 和 指定key对象相同,那么就返回当前节点对象</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">		<span class="comment">// 走到这一步说明 当前节点的hash值  和 指定key的hash值  是相等的，但是equals不等</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">				(kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">				(dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 走到这里说明：指定key没有实现comparable接口   或者   实现了comparable接口并且和当前节点的键对象比较之后相等（仅限第一次循环）</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * searched 标识是否已经对比过当前节点的左右子节点了</span></span><br><span class="line"><span class="comment">			 * 如果还没有遍历过，那么就递归遍历对比，看是否能够得到那个键对象equals相等的的节点</span></span><br><span class="line"><span class="comment">			 * 如果得到了键的equals相等的的节点就返回</span></span><br><span class="line"><span class="comment">			 * 如果还是没有键的equals相等的节点，那说明应该创建一个新节点了</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (!searched) &#123;<span class="comment">// 如果还没有比对过当前节点的所有子节点</span></span><br><span class="line">				<span class="comment">// 定义要返回的节点、和子节点</span></span><br><span class="line">				TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">				<span class="comment">// 标识已经遍历过一次了</span></span><br><span class="line">				searched = <span class="keyword">true</span>;</span><br><span class="line">				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				 * 红黑树也是二叉树，所以只要沿着左右两侧遍历寻找就可以了</span></span><br><span class="line"><span class="comment">				 * 这是个短路运算，如果先从左侧就已经找到了，右侧就不需要遍历了</span></span><br><span class="line"><span class="comment">				 * find 方法内部还会有递归调用</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">						(q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">						((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">								(q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">					<span class="comment">// 找到了指定key键对应的</span></span><br><span class="line">					<span class="keyword">return</span> q;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 走到这里就说明，遍历了所有子节点也没有找到和当前键equals相等的节点</span></span><br><span class="line">			dir = tieBreakOrder(k, pk);<span class="comment">// 再比较一下当前节点键和指定key键的大小</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 定义xp指向当前节点</span></span><br><span class="line">		TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 如果dir小于等于0，那么看当前节点的左节点是否为空，</span></span><br><span class="line"><span class="comment">		 * 如果为空，就可以把要添加的元素作为当前节点的左节点，如果不为空，还需要下一轮继续比较</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 如果dir大于等于0，那么看当前节点的右节点是否为空，</span></span><br><span class="line"><span class="comment">		 * 如果为空，就可以把要添加的元素作为当前节点的右节点，如果不为空，还需要下一轮继续比较</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 如果以上两条当中有一个子节点不为空，</span></span><br><span class="line"><span class="comment">		 * 这个if中还做了一件事，那就是把p已经指向了对应的不为空的子节点，开始下一轮的比较</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果恰好要添加的方向上的子节点为空，此时节点p已经指向了这个空的子节点</span></span><br><span class="line">			<span class="comment">// 获取当前节点的next节点</span></span><br><span class="line">			Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">			<span class="comment">// 创建一个新的树节点</span></span><br><span class="line">			TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">			<span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">				<span class="comment">// 左孩子指向到这个新的树节点</span></span><br><span class="line">				xp.left = x;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="comment">// 右孩子指向到这个新的树节点</span></span><br><span class="line">				xp.right = x;</span><br><span class="line">			<span class="comment">// 链表中的next节点指向到这个新的树节点</span></span><br><span class="line">			xp.next = x;</span><br><span class="line">			<span class="comment">// 这个新的树节点的父节点、前节点均设置为 当前的树节点</span></span><br><span class="line">			x.parent = x.prev = xp;</span><br><span class="line">			<span class="comment">// 如果原来的next节点不为空</span></span><br><span class="line">			<span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">				<span class="comment">// 那么原来的next节点的前节点指向到新的树节点</span></span><br><span class="line">				((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">			<span class="comment">// 重新平衡，以及新的根节点置顶</span></span><br><span class="line">			moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">			<span class="comment">// 返回空，意味着产生了一个新节点</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="treeifyBin-链表转成红黑树"><a href="#treeifyBin-链表转成红黑树" class="headerlink" title="treeifyBin 链表转成红黑树"></a>treeifyBin 链表转成红黑树</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定hash节点处的链表替换成红黑树</span></span><br><span class="line"><span class="comment"> * 除非table太小了，将用resizes（）改变树的容量</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment"> * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">	<span class="comment">// 如果 table 为null 或者</span></span><br><span class="line">	<span class="comment">// table的长度小于 MIN_TREEIFY_CAPACITY（默认64））不进行树化，调用resize进行扩容</span></span><br><span class="line">	<span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">		resize();</span><br><span class="line">	<span class="comment">// 如果 该hash值对应的 tab[index] 不为null，证明该位置有值</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 遍历链表,将单项链表改为双向链表</span></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="comment">// node 节点转成 TreeNode节点</span></span><br><span class="line">			TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">			<span class="comment">// 如果树为空</span></span><br><span class="line">			<span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">				<span class="comment">// 设置树的根</span></span><br><span class="line">				hd = p;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 设置新节点p的上一个节点</span></span><br><span class="line">				p.prev = tl;</span><br><span class="line">				<span class="comment">// 设置 上一节点的 next 指向当前节点</span></span><br><span class="line">				tl.next = p;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//保存上一节点</span></span><br><span class="line">			tl = p;</span><br><span class="line">		&#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">		<span class="comment">// 如果树的根节点不为null，调用treeify()进行树化</span></span><br><span class="line">		<span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">			hd.treeify(tab);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> root of tree</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 树的根节点</span></span><br><span class="line">		TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//x是当前节点，next是后继</span></span><br><span class="line">		<span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">			<span class="comment">// 后继节点</span></span><br><span class="line">			next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">			<span class="comment">// 左右儿子设为null</span></span><br><span class="line">			x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">			<span class="comment">// 如果根是 null</span></span><br><span class="line">			<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 设置父节点为null</span></span><br><span class="line">				x.parent = <span class="keyword">null</span>;</span><br><span class="line">				<span class="comment">// 设置为黑色</span></span><br><span class="line">				x.red = <span class="keyword">false</span>;</span><br><span class="line">				<span class="comment">// 把当前节点设置为根节点</span></span><br><span class="line">				root = x;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果有根节点</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				K k = x.key;</span><br><span class="line">				<span class="keyword">int</span> h = x.hash;</span><br><span class="line">				Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">				<span class="comment">// 遍历树，进行二叉搜索树的插入</span></span><br><span class="line">				<span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">					<span class="comment">// p指向遍历中的当前节点，</span></span><br><span class="line">					<span class="comment">// x为待插入节点，</span></span><br><span class="line">					<span class="comment">// k是x的key，</span></span><br><span class="line">					<span class="comment">// h是x的hash值，</span></span><br><span class="line">					<span class="comment">// ph是p的hash值，</span></span><br><span class="line">					<span class="comment">// pk是p的key，</span></span><br><span class="line">					<span class="comment">// dir用来指示x节点与p的比较，-1表示比p小，1表示比p大</span></span><br><span class="line">					<span class="comment">// 不存在相等情况，因为HashMap中是不存在两个key完全一致的情况。</span></span><br><span class="line">					<span class="keyword">int</span> dir, ph;</span><br><span class="line">					K pk = p.key;</span><br><span class="line">					<span class="comment">// 待插入x的hash值小于当前点p的hash值</span></span><br><span class="line">					<span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">						dir = -<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">						dir = <span class="number">1</span>;</span><br><span class="line">					<span class="comment">// 如果hash值相等，那么判断k是否实现了comparable接口，</span></span><br><span class="line">					<span class="comment">// 如果实现了comparable接口就使用compareTo进行进行比较，</span></span><br><span class="line">					<span class="comment">// 如果仍旧相等或者没有实现comparable接口，则在tieBreakOrder中比较</span></span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">							(kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">							(dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">						dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 将当前节点赋值给XP</span></span><br><span class="line">					TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">					<span class="comment">// 如果dir &lt;= 0 ,p 等于 p的左儿子，否则p 等于 p的右儿子</span></span><br><span class="line">					<span class="comment">// 如果 p 等于 null，则插入x节点</span></span><br><span class="line">					<span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="comment">// x的父节点指向 xp</span></span><br><span class="line">						x.parent = xp;</span><br><span class="line">						<span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">							xp.left = x;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">							xp.right = x;</span><br><span class="line">						<span class="comment">// 进行平衡处理，保证红黑树的性质</span></span><br><span class="line">						root = balanceInsertion(root, x);</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//root节点移动到桶中的第一个元素，也就是链表的首节点</span></span><br><span class="line">		moveRootToFront(tab, root);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><h1 id="untreeify-树变链表"><a href="#untreeify-树变链表" class="headerlink" title="untreeify 树变链表"></a>untreeify 树变链表</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树变链表</span></span><br><span class="line"><span class="comment"> * //重新创建链表节点，并形成链表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">		Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">			hd = p;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tl.next = p;</span><br><span class="line">		tl = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="balanceInsertion-红黑树插入平衡"><a href="#balanceInsertion-红黑树插入平衡" class="headerlink" title="balanceInsertion 红黑树插入平衡"></a>balanceInsertion 红黑树插入平衡</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树的插入平衡处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 新插入节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">											TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//插入的节点默认为红色</span></span><br><span class="line">	x.red = <span class="keyword">true</span>;</span><br><span class="line">	<span class="comment">// xp：当前节点的父节点</span></span><br><span class="line">	<span class="comment">// xpp：爷爷节点</span></span><br><span class="line">	<span class="comment">// xppl：左叔叔节点</span></span><br><span class="line">	<span class="comment">// xppr：右叔叔节点</span></span><br><span class="line">	<span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">		<span class="comment">// L1：如果父节点为空、说明当前节点就是根节点，那么把当前节点标为黑色，返回当前节点</span></span><br><span class="line">		<span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">			x.red = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">return</span> x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 父节点不为空</span></span><br><span class="line">		<span class="comment">// L2：如果 父节点为黑色 那么插入节点为红色不影响树的平衡</span></span><br><span class="line">		<span class="comment">// L3：或者 爷爷节点为空 即 父节点是根节点</span></span><br><span class="line">		<span class="comment">// 返回根节点</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> root;</span><br><span class="line">		<span class="comment">// L4：父节点和祖父节点都存在，并且其父节点是祖父节点的左节点</span></span><br><span class="line">		<span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">			<span class="comment">// L4.1 插入节点的叔叔节点是红色</span></span><br><span class="line">			<span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">				<span class="comment">// 将叔叔设置为黑色，父亲设为黑色，爷爷设为红色</span></span><br><span class="line">				xppr.red = <span class="keyword">false</span>;</span><br><span class="line">				xp.red = <span class="keyword">false</span>;</span><br><span class="line">				xpp.red = <span class="keyword">true</span>;</span><br><span class="line">				<span class="comment">// 将 爷爷 设为当前插入节点，自底向上，重新变色</span></span><br><span class="line">				x = xpp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//L4.2：插入节点的叔叔节点是黑色或不存在</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// L4.2.1 插入节点是其父节点的右孩子</span></span><br><span class="line">				<span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">					<span class="comment">// x 设置为 父节点</span></span><br><span class="line">					<span class="comment">// 将 父节点 左旋</span></span><br><span class="line">					<span class="comment">// 旋转之后，原父子关系对调，因此，x还是子节点</span></span><br><span class="line">					root = rotateLeft(root, x = xp);</span><br><span class="line">					<span class="comment">// 将xp 设为父节点，xpp设为爷爷节点</span></span><br><span class="line">					xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// L4.2.1 插入节点是其父节点的左孩子</span></span><br><span class="line">				<span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// 父节点设为黑色</span></span><br><span class="line">					xp.red = <span class="keyword">false</span>;</span><br><span class="line">					<span class="comment">// 如果 有爷爷节点</span></span><br><span class="line">					<span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="comment">// 爷爷节点设置为红色</span></span><br><span class="line">						xpp.red = <span class="keyword">true</span>;</span><br><span class="line">						<span class="comment">//  爷爷节点右旋</span></span><br><span class="line">						root = rotateRight(root, xpp);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// L5：插入的节点父节点和祖父节点都存在，并且其 父节点是祖父节点的右节点</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// L5.1：插入节点的叔叔节点是红色</span></span><br><span class="line">			<span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">				<span class="comment">// 将叔叔设置为黑色，父亲设为黑色，爷爷设为红色</span></span><br><span class="line">				xppl.red = <span class="keyword">false</span>;</span><br><span class="line">				xp.red = <span class="keyword">false</span>;</span><br><span class="line">				xpp.red = <span class="keyword">true</span>;</span><br><span class="line">				<span class="comment">// 将 爷爷 设为当前插入节点，自底向上，重新变色</span></span><br><span class="line">				x = xpp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//L5.2：插入节点的叔叔节点是黑色或不存在</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// L5.2.1 插入节点是其父节点的左孩子</span></span><br><span class="line">				<span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">					<span class="comment">// x 设置为 父节点</span></span><br><span class="line">					<span class="comment">// 将 父节点 右旋</span></span><br><span class="line">					<span class="comment">// 旋转之后，原父子关系对调，因此，x还是子节点</span></span><br><span class="line">					root = rotateRight(root, x = xp);</span><br><span class="line">					xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// L5.2.2 插入节点是其父节点的右孩子</span></span><br><span class="line">				<span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// 父节点设为黑色</span></span><br><span class="line">					xp.red = <span class="keyword">false</span>;</span><br><span class="line">					<span class="comment">// 如果 有爷爷 节点</span></span><br><span class="line">					<span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="comment">// 爷爷节点设置为红色</span></span><br><span class="line">						xpp.red = <span class="keyword">true</span>;</span><br><span class="line">						<span class="comment">//  爷爷节点右旋</span></span><br><span class="line">						root = rotateLeft(root, xpp);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt; e;</span><br><span class="line">	<span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="getNode"><a href="#getNode" class="headerlink" title="getNode"></a>getNode</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key 的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">	<span class="comment">// table 不为null &amp;&amp; 不为空，并且 (n - 1) &amp; hash 算出来的index位置有值</span></span><br><span class="line">	<span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">			(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 判断第一个存在的节点的key 和 hash值是否与查询的key的相等，如果是直接返回</span></span><br><span class="line">		<span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">				((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">			<span class="keyword">return</span> first;</span><br><span class="line">		<span class="comment">// 遍历该链表/红黑树直到next为null</span></span><br><span class="line">		<span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果该点是红黑树</span></span><br><span class="line">			<span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">				<span class="comment">// 在树上寻找对应的值</span></span><br><span class="line">				<span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">			<span class="keyword">do</span> &#123;</span><br><span class="line">				<span class="comment">// 遍历链表</span></span><br><span class="line">				<span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">						((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">					<span class="keyword">return</span> e;</span><br><span class="line">			&#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//否则不存在，返回null</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="remove-及其相关方法"><a href="#remove-及其相关方法" class="headerlink" title="remove 及其相关方法"></a>remove 及其相关方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt; e;</span><br><span class="line">	<span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">			<span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="removeNode-删除节点"><a href="#removeNode-删除节点" class="headerlink" title="removeNode 删除节点"></a>removeNode 删除节点</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.remove and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 传入匹配的value值，如果matchValue=false，直接忽略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue 为true时，会去进一步匹配value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable if false do not move other nodes while removing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">						   <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">	<span class="comment">//确定table已经被初始化，并且其中有元素，并且对应的 hash值有元素</span></span><br><span class="line">	<span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">			(p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">		<span class="comment">//判断当前这个找到的元素是不是目标元素，如果是的话赋值给node</span></span><br><span class="line">		<span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">				((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">			node = p;</span><br><span class="line">		<span class="comment">//不是的话，就从相同hash值的所有元素中去查找</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">				<span class="comment">//该列表已经转换成红黑树的情况</span></span><br><span class="line">				node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//在链表中查找的情况</span></span><br><span class="line">				<span class="keyword">do</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">							((k = e.key) == key ||</span><br><span class="line">									(key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">						node = e;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					p = e;</span><br><span class="line">				&#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//找到了目标节点</span></span><br><span class="line">		<span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">				(value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">			<span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">				<span class="comment">//是红黑树节点的情况</span></span><br><span class="line">				((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">				<span class="comment">//是一个链表开头元素的情况</span></span><br><span class="line">				tab[index] = node.next;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="comment">//是一个链表中间元素的情况</span></span><br><span class="line">				p.next = node.next;</span><br><span class="line">			<span class="comment">//结构改变，修改次数需要加一</span></span><br><span class="line">			++modCount;</span><br><span class="line">			<span class="comment">//元素减少size减1</span></span><br><span class="line">			--size;</span><br><span class="line">			afterNodeRemoval(node);</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="removeTreeNode-红黑树中删除节点"><a href="#removeTreeNode-红黑树中删除节点" class="headerlink" title="removeTreeNode 红黑树中删除节点"></a>removeTreeNode 红黑树中删除节点</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">						  <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="comment">// 如果 table为空 或者为0 则无法删除，返回</span></span><br><span class="line">	<span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">	<span class="comment">// first 和 root 目前都为 根结点</span></span><br><span class="line">	TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">	<span class="comment">// succ 是要删除节点的下一个，prev是要删除节点的前一个</span></span><br><span class="line">	TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">	<span class="comment">// 首先先从TreeNode链表里将这个节点删除掉。</span></span><br><span class="line">	<span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">		tab[index] = first = succ;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		pred.next = succ;</span><br><span class="line">	<span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">		succ.prev = pred;</span><br><span class="line">	<span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">		root = root.root();</span><br><span class="line">	<span class="comment">// 根结点为空 或 根节点的右儿子为空 或 根结点的做儿子为空 或 根节点的做儿子的做儿子为空</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">			(rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 树太小了，从红黑树转换为链表</span></span><br><span class="line">		tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从红黑树删除这个节点</span></span><br><span class="line">	<span class="comment">// p是要删除的节点 pl 是 p 的左节点, pr 是 P 的右节点。</span></span><br><span class="line">	TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">	<span class="comment">// 当 p 的左右节点都不为null</span></span><br><span class="line">	<span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// s 是 p的右节点 的 左叶子节点 的左节点。。。循环找到叶子节点</span></span><br><span class="line">		<span class="comment">// 就是查找所有比当前节点大的节点当中最小的一个节点</span></span><br><span class="line">		TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">		<span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">			s = sl;</span><br><span class="line">		<span class="comment">//交换 s 和 p 节点的颜色</span></span><br><span class="line">		<span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">		<span class="comment">// sr ：s的右节点</span></span><br><span class="line">		TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">		<span class="comment">// pp ：p的父节点</span></span><br><span class="line">		TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">		<span class="comment">//2： 如果s 等于pr 证明 p的 右节点 没有 左节点</span></span><br><span class="line">		<span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s's direct parent</span></span><br><span class="line">			<span class="comment">//当前节点的父节点设为找到的节点</span></span><br><span class="line">			p.parent = s;</span><br><span class="line">			<span class="comment">//找到节点的右孩子设为当前节点</span></span><br><span class="line">			s.right = p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3： p 的右节点有左儿子</span></span><br><span class="line">		<span class="comment">// （以下操作就是将s和p对换了个位置和颜色，</span></span><br><span class="line">		<span class="comment">// 如果s有右儿子则设置为平衡点，否则p为平衡点）</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// sp ： s的父亲</span></span><br><span class="line">			TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">			<span class="comment">// 将 p 的父亲设为 sp</span></span><br><span class="line">			<span class="comment">// 如果sp 不为null</span></span><br><span class="line">			<span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 当前节点替代 s 节点的位置，与 s 节点的父节点进行关联</span></span><br><span class="line">				<span class="comment">// s 是 sp 的左儿子，左儿子设置为 p</span></span><br><span class="line">				<span class="keyword">if</span> (s == sp.left)</span><br><span class="line">					sp.left = p;</span><br><span class="line">				<span class="keyword">else</span><span class="comment">// s 是 sp 的右儿子，右儿子设置为 p</span></span><br><span class="line">					sp.right = p;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// s 的右节点设置为 p 的右孩子</span></span><br><span class="line">			<span class="comment">// 如果 p 的右孩子不为null</span></span><br><span class="line">			<span class="comment">// 右孩子的父节点设为 s 节点</span></span><br><span class="line">			<span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">				pr.parent = s;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当前节点的左孩子设为null</span></span><br><span class="line">		p.left = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//将 p 节点的右孩子设置为 s节点的右孩子</span></span><br><span class="line">		<span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">			sr.parent = p; <span class="comment">//右孩子的父节点设为当前节点</span></span><br><span class="line">		<span class="comment">// 将 s 节点的左儿子设置为 p节点的左儿子</span></span><br><span class="line">		<span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">			pl.parent = s;<span class="comment">// 左孩子的父节点设为找到节点</span></span><br><span class="line">		<span class="comment">// 将s的父亲 设置为 p 节点的父亲</span></span><br><span class="line">		<span class="comment">// 如果 p是根结点，那么根节点变为s</span></span><br><span class="line">		<span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">			root = s;</span><br><span class="line">		<span class="comment">// 父节点不为null，当前节点是父节点的左孩子</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">			<span class="comment">// 父亲的左儿子改为s</span></span><br><span class="line">			pp.left = s;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="comment">// 父亲的右儿子改为s</span></span><br><span class="line">			pp.right = s;</span><br><span class="line">		<span class="comment">// s节点的右孩子不为null</span></span><br><span class="line">		<span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">			<span class="comment">// 则s节点的右孩子节点作为平衡删除的初始节点</span></span><br><span class="line">			replacement = sr;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="comment">// 否则平衡删除的初始节点为 p。</span></span><br><span class="line">			replacement = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//当前节点左孩子不为null，右孩子为null</span></span><br><span class="line">	<span class="comment">//当前节点的左孩子作为平衡删除的节点</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">		replacement = pl;</span><br><span class="line">	<span class="comment">//当前节点右孩子不为null，左孩子为null</span></span><br><span class="line">	<span class="comment">// 当前节点的右孩子作为平衡删除的节点</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">		replacement = pr;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//左右孩子都为null，当前节点作为平衡删除的节点</span></span><br><span class="line">		replacement = p;</span><br><span class="line">	<span class="comment">//如果当前节点不是作为平衡删除的节点</span></span><br><span class="line">	<span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">		<span class="comment">//此时p.parent有三种情况，1.其原来的父节点，2.它的右子节点，3.s节点的父节点sp</span></span><br><span class="line">		<span class="comment">//将当前节点的父节点设为平衡删除节点的父节点</span></span><br><span class="line">		TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">		<span class="comment">//如果当前节点的父节点为null，则表明当前节点原来是根节点，此时当前节点的父节点还是其原来的父节点</span></span><br><span class="line">		<span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">			root = replacement;<span class="comment">//设置作为平衡删除的节点为根节点</span></span><br><span class="line">		<span class="comment">// 如果父节点不为null，并且当前节点是父节点的左子节点</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)<span class="comment">//设置父节点的左子节点为作为平衡删除的节点</span></span><br><span class="line">			pp.left = replacement;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//设置父节点的右子节点为作为平衡删除的节点</span></span><br><span class="line">			pp.right = replacement;</span><br><span class="line">		<span class="comment">//将当前节点与树结构断开，因为当前节点不是作为平衡删除的节点</span></span><br><span class="line">		p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取根节点，如果删除节点是红色，则不需要做平衡删除，根节点不会再变</span></span><br><span class="line">	<span class="comment">// 如果删除节点是黑色，则需要做平衡删除，根节点可能会发生改变</span></span><br><span class="line">	TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//做平衡删除的节点是当前要删除的节点</span></span><br><span class="line">	<span class="comment">//平衡删除做完后将该节点从树结构中脱离出来</span></span><br><span class="line">	<span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">		TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">		p.parent = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (p == pp.left)</span><br><span class="line">				pp.left = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">				pp.right = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//是否需要从新设置桶的头节点</span></span><br><span class="line">	<span class="keyword">if</span> (movable)</span><br><span class="line">		<span class="comment">//将桶的头节点设为根节点</span></span><br><span class="line">		moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="balanceDeletion-红黑树删除平衡"><a href="#balanceDeletion-红黑树删除平衡" class="headerlink" title="balanceDeletion 红黑树删除平衡"></a>balanceDeletion 红黑树删除平衡</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树平衡删除，只有在删除的节点是黑色时才会调用此方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 平衡节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">										   TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class="line">		<span class="comment">//平衡节点为null或者平衡节点是根节点，无需做平衡处理，返回根节点</span></span><br><span class="line">		<span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)</span><br><span class="line">			<span class="keyword">return</span> root;</span><br><span class="line">		<span class="comment">//平衡节点不是根，但平衡节点的父节点是null</span></span><br><span class="line">		<span class="comment">//则将平衡节点将成为根节点，将其颜色设置为黑色</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">			x.red = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">return</span> x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//不是根节点，父节点也不为null，</span></span><br><span class="line">		<span class="comment">//若做平衡的节点就是要删除的节点，则设什么颜色都无所谓，直接返回根节点</span></span><br><span class="line">		<span class="comment">//若做平衡的节点不是要删除的节点，而且还是红色</span></span><br><span class="line">		<span class="comment">//则其要替换的节点就是其父节点，替换的父节点就是要删除的节点，</span></span><br><span class="line">		<span class="comment">//而做平衡的节点还是红色，则其父一定是黑色，其替换其父所以要变成黑色</span></span><br><span class="line">		<span class="comment">//因为做平衡的节点是红，它替换掉了其父（在进入此方法之前已经替换掉了）</span></span><br><span class="line">		<span class="comment">//其父是黑，所以只需要确保其是黑，就能确保该树枝上的黑色节点数不变</span></span><br><span class="line">		<span class="comment">//替换完直接返回根节点即可</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">			x.red = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">return</span> root;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//x的节点不是根，父也不为null，其颜色是黑色</span></span><br><span class="line">		<span class="comment">//x的节点是其父的左子节点</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class="line">			<span class="comment">//如果它有红色的兄弟节点xpr，那么它的父亲节点xp一定是黑色节点</span></span><br><span class="line">			<span class="comment">// 将兄弟节点设为黑色，父亲节点设为红色，以父节点进行旋转</span></span><br><span class="line">			<span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">				xpr.red = <span class="keyword">false</span>;</span><br><span class="line">				xp.red = <span class="keyword">true</span>;</span><br><span class="line">				<span class="comment">//对父节点xp做左旋转</span></span><br><span class="line">				root = rotateLeft(root, xp);</span><br><span class="line">				<span class="comment">//重新将xp指向x的父节点，xpr指向xp新的右孩子</span></span><br><span class="line">				xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果xpr为空，则向上继续调整，将x的父节点xp作为新的x继续循环</span></span><br><span class="line">			<span class="keyword">if</span> (xpr == <span class="keyword">null</span>)</span><br><span class="line">				x = xp;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//sl和sr分别为其兄弟节点左儿子和右儿子</span></span><br><span class="line">				TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">				<span class="comment">//若sl和sr都为黑色或者不存在，即xpr没有红色孩子，则将xpr染红</span></span><br><span class="line">				<span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">						(sl == <span class="keyword">null</span> || !sl.red)) &#123;</span><br><span class="line">					xpr.red = <span class="keyword">true</span>;</span><br><span class="line">					x = xp;<span class="comment">//本轮结束，继续向上循环</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//否则的话，就需要进一步调整</span></span><br><span class="line">					<span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">						<span class="comment">//若左孩子为红，右孩子不存在或为黑</span></span><br><span class="line">						<span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">							<span class="comment">//左孩子染黑</span></span><br><span class="line">							sl.red = <span class="keyword">false</span>;</span><br><span class="line">						<span class="comment">//将xpr染红</span></span><br><span class="line">						xpr.red = <span class="keyword">true</span>;</span><br><span class="line">						<span class="comment">//右旋</span></span><br><span class="line">						root = rotateRight(root, xpr);</span><br><span class="line">						<span class="comment">//右旋后，xpr指向xp的新右孩子，即上一步中的sl</span></span><br><span class="line">						xpr = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">								<span class="keyword">null</span> : xp.right;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 如果兄弟节点 不为null</span></span><br><span class="line">					<span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="comment">// 如果父节点为空，兄弟节点染为黑色，否则和父亲节点染色相同</span></span><br><span class="line">						xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">						<span class="comment">// sr 设置为兄弟节点的右孩子，如果sr不为null，将sr设置为黑色，防止出现两个红色相连</span></span><br><span class="line">						<span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">							sr.red = <span class="keyword">false</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 如果父节点不为null</span></span><br><span class="line">					<span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="comment">//将父亲节点设置为黑色</span></span><br><span class="line">						xp.red = <span class="keyword">false</span>;</span><br><span class="line">						<span class="comment">// 左旋父节点</span></span><br><span class="line">						root = rotateLeft(root, xp);</span><br><span class="line">					&#125;</span><br><span class="line">					x = root;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//x为其父节点的右孩子，跟上面操作镜像</span></span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">			<span class="keyword">if</span> (xpl != <span class="keyword">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">				xpl.red = <span class="keyword">false</span>;</span><br><span class="line">				xp.red = <span class="keyword">true</span>;</span><br><span class="line">				root = rotateRight(root, xp);</span><br><span class="line">				xpl = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.left;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (xpl == <span class="keyword">null</span>)</span><br><span class="line">				x = xp;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">				<span class="keyword">if</span> ((sl == <span class="keyword">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">						(sr == <span class="keyword">null</span> || !sr.red)) &#123;</span><br><span class="line">					xpl.red = <span class="keyword">true</span>;</span><br><span class="line">					x = xp;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (sl == <span class="keyword">null</span> || !sl.red) &#123;</span><br><span class="line">						<span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">							sr.red = <span class="keyword">false</span>;</span><br><span class="line">						xpl.red = <span class="keyword">true</span>;</span><br><span class="line">						root = rotateLeft(root, xpl);</span><br><span class="line">						xpl = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">								<span class="keyword">null</span> : xp.left;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (xpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">						xpl.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">						<span class="keyword">if</span> ((sl = xpl.left) != <span class="keyword">null</span>)</span><br><span class="line">							sl.red = <span class="keyword">false</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">						xp.red = <span class="keyword">false</span>;</span><br><span class="line">						root = rotateRight(root, xp);</span><br><span class="line">					&#125;</span><br><span class="line">					x = root;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rotateLeft-红黑树左旋（右旋转同理）"><a href="#rotateLeft-红黑树左旋（右旋转同理）" class="headerlink" title="rotateLeft 红黑树左旋（右旋转同理）"></a>rotateLeft 红黑树左旋（右旋转同理）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树左旋</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> p 要左旋的节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">									  TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// pp : p的父亲</span></span><br><span class="line">	<span class="comment">// r: p的右孩子</span></span><br><span class="line">	<span class="comment">// rl = p 的右孩子的左孩子 -&gt; r的左孩子</span></span><br><span class="line">	TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">	<span class="comment">// 要 p 以及 p的右孩子 不为null</span></span><br><span class="line">	<span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 将p 的右孩子 设置为 rl 并且 rl不为空</span></span><br><span class="line">		<span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">			<span class="comment">// rl的父亲节点设置为p</span></span><br><span class="line">			rl.parent = p;</span><br><span class="line">		<span class="comment">// 将 r 的父亲 设置为 p的父亲（此时r 与p为兄弟）</span></span><br><span class="line">		<span class="comment">// 如果父亲节点为null，则此时 r为跟节点</span></span><br><span class="line">		<span class="comment">// 将root 设置为r ，并设置为黑色</span></span><br><span class="line">		<span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">			(root = r).red = <span class="keyword">false</span>;</span><br><span class="line">		<span class="comment">// 如果父节点的左儿子是 p</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">			<span class="comment">// 将父节点的 左儿子 设为r</span></span><br><span class="line">			pp.left = r;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="comment">// 否则将 右儿子 设为r</span></span><br><span class="line">			pp.right = r;</span><br><span class="line">		<span class="comment">// 将 r 的左节儿子 设置为p</span></span><br><span class="line">		r.left = p;</span><br><span class="line">		<span class="comment">// p 的父亲设置为 r</span></span><br><span class="line">		p.parent = r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回根节点</span></span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div><div><div style="text-align:center;color:#bfbfbf;font-size:16px"> <span>-------- 本文结束</span><i class="fa fa-angellist"></i> <span>感谢阅读 --------</span></div></div></div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.min.js/1.5.10/clipboard.min.js"></script><script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script><script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><p><span>本文标题:</span><a href="/JAVA/Java-HashMap/">JAVA-HashMap源码解析</a></p><p><span>文章作者:</span>Guyuqing</p><p><span>发布时间:</span>2020年03月05日 - 15:07</p><p><span>最后更新:</span>2020年03月12日 - 16:44</p><p><span>原始链接:</span><a href="/JAVA/Java-HashMap/" title="JAVA-HashMap源码解析">https://a19140312.github.io/JAVA/Java-HashMap/</a><span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://a19140312.github.io/JAVA/Java-HashMap/" aria-label="复制成功！"></i></span></p><p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"复制成功",icon:"success",showConfirmButton:!0})})})</script></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>坚持技术分享，您的支持将鼓励我继续创作！</div> <button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'> <span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"> <img id="wechat_qr" src="/images/wechatpay.jpg" alt="guyuqing 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"> <img id="alipay_qr" src="/images/alipay.jpg" alt="guyuqing 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/JAVA/" rel="tag"><i class="fa fa-tag"></i> JAVA</a><a href="/tags/学习笔记/" rel="tag"><i class="fa fa-tag"></i> 学习笔记</a><a href="/tags/源码/" rel="tag"><i class="fa fa-tag"></i> 源码</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/设计模式/Design-Pattern-Singleton/" rel="next" title="设计模式-单例模式"><i class="fa fa-chevron-left"></i> 设计模式-单例模式</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/JAVA/Interview/" rel="prev" title="面试必备">面试必备<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="guyuqing"><p class="site-author-name" itemprop="name">guyuqing</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">41</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">15</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">30</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/a19140312" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="http://weibo.com/" target="_blank" title="微博"><i class="fa fa-fw fa-weibo"></i> 微博</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#HashMap-的存储结构"><span class="nav-number">1.</span> <span class="nav-text">HashMap 的存储结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#各常量、成员变量作用"><span class="nav-number">2.</span> <span class="nav-text">各常量、成员变量作用　　</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构造方法"><span class="nav-number">3.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#put方法"><span class="nav-number">4.</span> <span class="nav-text">put方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#putVal方法"><span class="nav-number">5.</span> <span class="nav-text">putVal方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#resize-扩容兼初始化"><span class="nav-number">6.</span> <span class="nav-text">resize 扩容兼初始化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#split-扩容时重新划分树"><span class="nav-number">7.</span> <span class="nav-text">split 扩容时重新划分树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#putTreeVal-在红黑树中添加节点"><span class="nav-number">8.</span> <span class="nav-text">putTreeVal 在红黑树中添加节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#treeifyBin-链表转成红黑树"><span class="nav-number">9.</span> <span class="nav-text">treeifyBin 链表转成红黑树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#untreeify-树变链表"><span class="nav-number">10.</span> <span class="nav-text">untreeify 树变链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#balanceInsertion-红黑树插入平衡"><span class="nav-number">11.</span> <span class="nav-text">balanceInsertion 红黑树插入平衡</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#get方法"><span class="nav-number">12.</span> <span class="nav-text">get方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#getNode"><span class="nav-number">13.</span> <span class="nav-text">getNode</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#remove-及其相关方法"><span class="nav-number">14.</span> <span class="nav-text">remove 及其相关方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#removeNode-删除节点"><span class="nav-number">15.</span> <span class="nav-text">removeNode 删除节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#removeTreeNode-红黑树中删除节点"><span class="nav-number">16.</span> <span class="nav-text">removeTreeNode 红黑树中删除节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#balanceDeletion-红黑树删除平衡"><span class="nav-number">17.</span> <span class="nav-text">balanceDeletion 红黑树删除平衡</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#rotateLeft-红黑树左旋（右旋转同理）"><span class="nav-number">18.</span> <span class="nav-text">rotateLeft 红黑树左旋（右旋转同理）</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright" style="text-align:center">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">guyuqing</span><div class="theme-info"><div class="powered-by"></div><i class="fa fa-book"></i> <span class="post-count">全站共143.6k字</span></div></div><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script><div class="busuanzi-count" style="text-align:center"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i> 访问人数<span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人</span><span class="site-pv"><i class="fa fa-eye"></i> 总访问量<span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'aO40hbMXUEahTdJdAEqaHaaa-gzGzoHsz',
        appKey: 'T5zgBwJL4cnGAPVsarQphtMa',
        placeholder: '想对作者说点什么～',
        avatar:'monsterid',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script><script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script type="text/javascript" src="/js/src/clipboard.min.js"></script><script type="text/javascript" src="/js/src/clipboard-use.js"></script></body></html>