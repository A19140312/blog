<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式-单例模式</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Design-Pattern-Singleton/</url>
    <content><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>多个线程操作不同实例对象。多个线程要操作同一对象，要保证对象的唯一性</p>
<h2 id="单例模式的特点"><a href="#单例模式的特点" class="headerlink" title="单例模式的特点"></a>单例模式的特点</h2><ol>
<li>有一个实例化的过程（只有一次），产生实例化对象</li>
<li>提供返回实例对象的方法</li>
</ol>
<h2 id="单例模式的分类"><a href="#单例模式的分类" class="headerlink" title="单例模式的分类"></a>单例模式的分类</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">//加载时就产生了实例对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回实例对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i ++)&#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">				HungrySingleton hungerySingleton = HungrySingleton.getInstance();</span><br><span class="line">				System.out.println(hungerySingleton);</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>线程安全性：在加载的时候已经被实例化，所以只有这一次，线程安全的。</li>
<li>懒加载：没有延迟加载</li>
<li>性能：长时间不使用，数据一直放在堆中影响性能</li>
</ul>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i ++)&#123;</span><br><span class="line">		    <span class="keyword">new</span> Thread(()-&gt; System.out.println(LazySingleton.getInstance())).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>线程安全性：不能保证实例对象的唯一性</li>
<li>懒加载：有延迟加载</li>
<li>性能：使用时才进行加载，性能较好</li>
</ul>
<h3 id="懒汉式-同步方法"><a href="#懒汉式-同步方法" class="headerlink" title="懒汉式+同步方法"></a>懒汉式+同步方法</h3><p>将懒汉式的get方法加上synchronized</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">		instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>线程安全性：synchronized保证线程安全</li>
<li>懒加载：有延迟加载</li>
<li>性能：多个线程调用该方法时 synchronized 会使线程阻塞，退化到了串行执行</li>
</ul>
<h3 id="Double-Check-Locking"><a href="#Double-Check-Locking" class="headerlink" title="Double-Check-Locking"></a>Double-Check-Locking</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DCLSingleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> DCLSingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">DCLSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DCLSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (DCLSingleton.class)&#123;</span><br><span class="line">				<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">					instance = <span class="keyword">new</span> DCLSingleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i ++)&#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(()-&gt; System.out.println(DCLSingleton.getInstance())).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>线程安全性：线程安全</li>
<li>懒加载：有延迟加载</li>
<li>性能：性能比较好</li>
<li>缺点：会因为指令重排，引起空指针异常。</li>
</ul>
<h3 id="Volatile-Double-check"><a href="#Volatile-Double-check" class="headerlink" title="Volatile+Double-check"></a>Volatile+Double-check</h3><p>添加volatile 避免空指针异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DCLSingleton instance = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Holder"><a href="#Holder" class="headerlink" title="Holder"></a>Holder</h3><p>声明类的时候，成员变量中不声明实例变量，而放到内部静态类中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HolderSingleton</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">HolderSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过内部类实现懒加载，只有调用时才会进行实例化，静态类只能实例一次，保证线程安全</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> HolderSingleton instance=<span class="keyword">new</span> HolderSingleton();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HolderSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Holder.instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">EnumSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//延迟加载</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">enum</span> EnumHolder&#123;</span><br><span class="line">		INSTANCE;</span><br><span class="line">		<span class="keyword">private</span> EnumSingleton instance=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		EnumHolder() &#123;</span><br><span class="line">			<span class="keyword">this</span>.instance = <span class="keyword">new</span> EnumSingleton();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> EnumHolder.INSTANCE.instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-Volatile</title>
    <url>/JAVA/Java-Volatile/</url>
    <content><![CDATA[<h2 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h2><p>java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p>
<h2 id="机器硬件CPU与JMM"><a href="#机器硬件CPU与JMM" class="headerlink" title="机器硬件CPU与JMM"></a>机器硬件CPU与JMM</h2><a href="/JAVA/Java-MemoryModel/" title="点击这里查看这篇文章">点击这里查看这篇文章</a>

<h2 id="Volatile关键字的作用"><a href="#Volatile关键字的作用" class="headerlink" title="Volatile关键字的作用"></a>Volatile关键字的作用</h2><p>volatile作用：让其他线程能够马上感知到某一线程多某个变量的修改</p>
<ul>
<li><p>保证可见性:对共享变量的修改，其他的线程马上能感知到</p>
</li>
<li><p>保证有序性:重排序（编译阶段、指令优化阶段）volatile之前的代码不能调整到他的后面，volatile之后的代码不能调整到他的前面</p>
</li>
<li><p><strong>不能保证原子性</strong>：<br>  举个例子：   </p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>
</li>
</ul>
<h2 id="Volatile实现原理"><a href="#Volatile实现原理" class="headerlink" title="Volatile实现原理"></a>Volatile实现原理</h2><table>
        <tr>
            <th>Java代码</th>
            <th>instance = new Singleton();//instance是volatile变量</th>
        </tr> 
        <tr>
            <th>汇编代码</th>
            <th>0x01a3de1d: movb $0x0,0x1104800(%esi);<br>0x01a3de24: lock  addl $0x0,(%esp);</th>
        </tr> 
</table> 

<p>有volatile变量修饰的共享变量进行写操作的时候会多第二行汇编代码，通过查IA-32架构软件开发者手册可知，<code>lock</code>前缀的指令在多核处理器下会引发了两件事情。</p>
<ul>
<li>将当前处理器缓存行的数据会写回到系统内存。</li>
<li>这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。</li>
</ul>
<h2 id="Volatile的使用场景"><a href="#Volatile的使用场景" class="headerlink" title="Volatile的使用场景"></a>Volatile的使用场景</h2><ul>
<li><p>状态标志（开关模式）</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutDowsnDemmo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> started=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(started)&#123;</span><br><span class="line">            dowork();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        started=<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双重检查锁定（double-checked-locking）</p>
</li>
<li><p>需要利用顺序性</p>
</li>
</ul>
<h2 id="volatile与synchronized的区别"><a href="#volatile与synchronized的区别" class="headerlink" title="volatile与synchronized的区别"></a>volatile与synchronized的区别</h2><ol>
<li>使用上的区别:<br> Volatile只能修饰变量，synchronized只能修饰方法和语句块</li>
<li>对原子性的保证:<br> Volatile不能保证原子性，synchronized可以保证原子性</li>
<li>对可见性的保证:<br> 都可以保证可见性，但实现原理不同;Volatile对变量加了lock，synchronized使用monitorEnter和monitorexit</li>
<li>对有序性的保证:<br> Volatile能保证有序，synchronized可以保证有序性，但是代价（重量级）并发退化到串行</li>
<li>其他:<br> Volatile不会引起阻塞，synchronized引起阻塞</li>
</ol>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>JAVA</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-Synchronized</title>
    <url>/JAVA/Java-Synchronized/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>利用锁的机制来实现同步的。<br>锁机制有如下两种特性：<br><strong>互斥性</strong>：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的<strong>原子性</strong>。<br><strong>可见性</strong>：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。</p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><h3 id="同步非静态方法"><a href="#同步非静态方法" class="headerlink" title="同步非静态方法"></a>同步非静态方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Public <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodName</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步静态方法"><a href="#同步静态方法" class="headerlink" title="同步静态方法"></a>同步静态方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Public <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodName</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><h3 id="获取对象锁"><a href="#获取对象锁" class="headerlink" title="获取对象锁"></a>获取对象锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>|object) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>用来修饰非静态方法，<br>在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，通常会被称为“内置锁”或“对象锁”。类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰</p>
<h3 id="获取类锁"><a href="#获取类锁" class="headerlink" title="获取类锁"></a>获取类锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(类.class) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>用来修饰静态方法<br>在 Java 中，针对每个类也有一个锁，可以称为“类锁”，类锁实际上是通过对象锁实现的，即类的 Class 对象锁。每个类只有一个 Class 对象，所以每个类只有一个类锁。</p>
<h2 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h2><p>Monitor其实是一种同步工具，也可以说是一种同步机制，它通常被描述为一个对象,也常被翻译为“监视器\管程”,每个对象都会有一个 monitor</p>
<ul>
<li>某一线程占有一个对象的时候，先看该对象的 monitor 的计数器是不是0，如果是0表示这个对象还没有线程占有，这个时候线程占有这个对象，并且对这个对象的monitor+1；如果不为0，表示这个对象已经被其他线程占有，这个线程等待。当线程释放占有权的时候，monitor-1；</li>
<li>同一线程可以对同一对象进行多次加锁，+1，+1，体现了重入性</li>
</ul>
<h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><h2 id="线程堆栈分析-互斥"><a href="#线程堆栈分析-互斥" class="headerlink" title="线程堆栈分析(互斥)"></a>线程堆栈分析(互斥)</h2><h3 id="Jconsole"><a href="#Jconsole" class="headerlink" title="Jconsole"></a>Jconsole</h3><p>JConsole 是一个内置 Java 性能分析器<br>Mac下位置：/Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/bin/jconsol</p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (SynchronizedDemo01.class)&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				TimeUnit.MINUTES.sleep(<span class="number">2</span>);</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">"is running"</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SynchronizedDemo01 demo01 = <span class="keyword">new</span> SynchronizedDemo01();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i ++)&#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(demo01::test).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/JAVA/Java-Synchronized/1.png" alt=""><br><img src="/JAVA/Java-Synchronized/2.png" alt=""><br><img src="/JAVA/Java-Synchronized/3.png" alt=""><br><img src="/JAVA/Java-Synchronized/4.png" alt=""><br><img src="/JAVA/Java-Synchronized/5.png" alt=""></p>
<h2 id="JVM指令分析"><a href="#JVM指令分析" class="headerlink" title="JVM指令分析"></a>JVM指令分析</h2><h3 id="Javap"><a href="#Javap" class="headerlink" title="Javap"></a>Javap</h3><p>Javap -V  反编译</p>
<h4 id="对代码块加锁"><a href="#对代码块加锁" class="headerlink" title="对代码块加锁"></a>对代码块加锁</h4><p><img src="/JAVA/Java-Synchronized/6.png" alt=""><br>以上是代码块的加锁monitorenter和monitorExit配合使用</p>
<h4 id="对方法加锁"><a href="#对方法加锁" class="headerlink" title="对方法加锁"></a>对方法加锁</h4><p><img src="/JAVA/Java-Synchronized/7.png" alt=""><br>通过ACC_SYNCHRONIZED实现</p>
<h1 id="Java虚拟机对synchronized的优化"><a href="#Java虚拟机对synchronized的优化" class="headerlink" title="Java虚拟机对synchronized的优化"></a>Java虚拟机对synchronized的优化</h1><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>一个对象实例包含：对象头、实例变量、填充数据<br><img src="/JAVA/Java-Synchronized/8.png" alt="实力对象"><br>对象头结构：<br><img src="/JAVA/Java-Synchronized/9.png" alt="对象头"><br>Mark Word 结构：<br><img src="/JAVA/Java-Synchronized/10.png" alt="对象头"></p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><ul>
<li>作用：偏向锁是为了消除无竞争情况下的同步原语，进一步提升程序性能。</li>
<li>与轻量级锁的区别：轻量级锁是在无竞争的情况下使用CAS操作来代替互斥量的使用，从而实现同步；而偏向锁是在无竞争的情况下完全取消同步。</li>
<li>与轻量级锁的相同点：它们都是乐观锁，都认为同步期间不会有其他线程竞争锁。</li>
<li>原理：当线程请求到锁对象后，将锁对象的状态标志位改为01，即偏向模式。然后使用CAS操作将线程的ID记录在锁对象的Mark Word中。以后该线程可以直接进入同步块，连CAS操作都不需要。但是，一旦有第二条线程需要竞争锁，那么偏向模式立即结束，进入轻量级锁的状态。</li>
<li>优点：偏向锁可以提高有同步但没有竞争的程序性能。但是如果锁对象时常被多条线程竞争，那偏向锁就是多余的。</li>
<li>偏向锁可以通过虚拟机的参数来控制它是否开启。</li>
</ul>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><ul>
<li>本质：使用CAS取代互斥同步</li>
<li>背景：『轻量级锁』是相对于『重量级锁』而言的，而重量级锁就是传统的锁</li>
<li>轻量级锁与重量级锁的比较：<ul>
<li>重量级锁是一种悲观锁，它认为总是有多条线程要竞争锁，所以它每次处理共享数据时，不管当前系统中是否真的有线程在竞争锁，它都会使用互斥同步来保证线程的安全；</li>
<li>而轻量级锁是一种乐观锁，它认为锁存在竞争的概率比较小，所以它不使用互斥同步，而是使用CAS操作来获得锁，这样能减少互斥同步所使用的『互斥量』带来的性能开销。</li>
</ul>
</li>
<li>前提：轻量级锁比重量级锁性能更高的前提是，在轻量级锁被占用的整个同步周期内，<strong>不存在其他线程的竞争</strong>。若在该过程中一旦有其他线程竞争，那么就会膨胀成重量级锁，从而除了使用互斥量以外，还额外发生了CAS操作，因此更慢！</li>
<li>实现原理：<ul>
<li>Mark Word中有个标志位用来表示当前对象所处的状态。</li>
<li>当线程请求锁时，若该锁对象的Mark Word中标志位为01（未锁定状态），则在该线程的栈帧中创建一块名为『锁记录』的空间，然后将锁对象的Mark Word拷贝至该空间；最后通过CAS操作将锁对象的Mark Word指向该锁记录；</li>
<li>若CAS操作成功，则轻量级锁的上锁过程成功；</li>
<li>若CAS操作失败，再判断当前线程是否已经持有了该轻量级锁；若已经持有，则直接进入同步块；若尚未持有，则表示该锁已经被其他线程占用，此时轻量级锁就要膨胀成重量级锁。</li>
</ul>
</li>
</ul>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><ul>
<li>重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现，所以重量级锁又称互斥锁，也称为阻塞同步、悲观锁</li>
<li>当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从<strong>用户态转换到内核态</strong>，线程开销很大。</li>
</ul>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><ul>
<li>背景：互斥同步对性能最大的影响是阻塞，挂起和恢复线程都需要转入内核态中完成；并且通常情况下，共享数据的锁定状态只持续很短的一段时间，为了这很短的一段时间进行上下文切换并不值得。</li>
<li>原理：当一条线程需要请求一把已经被占用的锁时，并不会进入阻塞状态，而是继续持有CPU执行权等待一段时间，该过程称为『自旋』。</li>
<li>优点：由于自旋等待锁的过程线程并不会引起上下文切换，因此比较高效；</li>
<li>缺点：自旋等待过程线程一直占用CPU执行权但不处理任何任务，因此若该过程过长，那就会造成CPU资源的浪费。</li>
<li>自适应自旋：自适应自旋可以根据以往自旋等待时间的经验，计算出一个较为合理的本次自旋等待时间。</li>
</ul>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>编译器会清除一些使用了同步，但同步块中没有涉及共享数据的锁，从而减少多余的同步。</p>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>若有一系列操作，反复地对同一把锁进行上锁和解锁操作，编译器会扩大这部分代码的同步块的边界，从而只使用一次上锁和解锁操作。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>JAVA</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea-Mac激活</title>
    <url>/Idea/Idea-Activation/</url>
    <content><![CDATA[<ol>
<li>首先下载jar包：<a href="https://pan.baidu.com/s/17k7rp63-XHho8oeHE0ROIA" target="_blank" rel="noopener">百度网盘链接</a>  密码:<strong>b8ye</strong>  将其放到合适的文件夹</li>
<li>进入idea（首次进入可以选择免费30天，激活码失效后进入免费30分钟）如果没有项目随便建个项目，点击菜单栏 <strong>Help -&gt; Edit Custom VM Options</strong> <ul>
<li>注意：切记一定要通过 IDEA 来修改 .vmoptions 文件，不要手动直接去修改，现在 IDEA 针对反破解已经越来越严格</li>
</ul>
</li>
<li>在末尾添加路径：<strong>-javaagent:/Users/XXXX/XXXX/jetbrainsCrack.jar</strong><ul>
<li>注意：补丁全路径中不要包含中文，否则，可能导致破解失败！</li>
</ul>
</li>
<li><code>重启idea！！！一定要重启</code></li>
<li>重启完成后，开始填入激活码，点击菜单栏 <strong>Help -&gt; Register:</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A82DEE284F-eyJsaWNlbnNlSWQiOiJBODJERUUyODRGIiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJVbmxpbWl0ZWQgbGljZW5zZSB0aWxsIGVuZCBvZiB0aGUgY2VudHVyeS4iLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiODkwNzA3MC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-5epo90Xs7KIIBb8ckoxnB/AZQ8Ev7rFrNqwFhBAsQYsQyhvqf1FcYdmlecFWJBHSWZU9b41kvsN4bwAHT5PiznOTmfvGv1MuOzMO0VOXZlc+edepemgpt+t3GUHvfGtzWFYeKeyCk+CLA9BqUzHRTgl2uBoIMNqh5izlDmejIwUHLl39QOyzHiTYNehnVN7GW5+QUeimTr/koVUgK8xofu59Tv8rcdiwIXwTo71LcU2z2P+T3R81fwKkt34evy7kRch4NIQUQUno//Pl3V0rInm3B2oFq9YBygPUdBUbdH/KHROyohZRD8SaZJO6kUT0BNvtDPKF4mCT1saWM38jkw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3AGXEJXFK9-eyJsaWNlbnNlSWQiOiIzQUdYRUpYRks5IiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-WGTHs6XpDhr+uumvbwQPOdlxWnQwgnGaL4eRnlpGKApEEkJyYvNEuPWBSrQkPmVpim/8Sab6HV04Dw3IzkJT0yTc29sPEXBf69+7y6Jv718FaJu4MWfsAk/ZGtNIUOczUQ0iGKKnSSsfQ/3UoMv0q/yJcfvj+me5Zd/gfaisCCMUaGjB/lWIPpEPzblDtVJbRexB1MALrLCEoDv3ujcPAZ7xWb54DiZwjYhQvQ+CvpNNF2jeTku7lbm5v+BoDsdeRq7YBt9ANLUKPr2DahcaZ4gctpHZXhG96IyKx232jYq9jQrFDbQMtVr3E+GsCekMEWSD//dLT+HuZdc1sAIYrw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KNBB2QUUR1-eyJsaWNlbnNlSWQiOiJLTkJCMlFVVVIxIiwibGljZW5zZWVOYW1lIjoiZ2hib2tlIiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IiIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiQUMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRFBOIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBTIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRNIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkNMIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJTMCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSTSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJXUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSU1UiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiMTI3OTY4NzcvMCIsImdyYWNlUGVyaW9kRGF5cyI6NywiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-1iV7BA/baNqv0Q5yUnAphUmh66QhkDRX+qPL09ICuEicBqiPOBxmVLLCVUpkxhrNyfmOtat2LcHwcX/NHkYXdoW+6aS0S388xe1PV2oodiPBhFlEaOac42UQLgP4EidfGQSvKwC9tR1zL5b2CJPQKZ7iiHh/iKBQxP6OBMUP1T7j3Fe1rlxfYPc92HRZf6cO+C0+buJP5ERZkyIn5ZrVM4TEnWrRHbpL8SVNq4yqfc+NwoRzRSNC++81VDS3AXv9c91YeZJz6JXO7AokIk54wltr42FLNuKbozvB/HCxV9PA5vIiM+kZY1K0w5ytgxEYKqA87adA7R5xL/crpaMxHQ==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==</span><br></pre></td></tr></table></figure>

<p>或者随便在网上找个激活码</p>
<ol start="6">
<li>点击激活，可以看到激活日期到2089年</li>
</ol>
]]></content>
      <categories>
        <category>Idea</category>
      </categories>
      <tags>
        <tag>Idea</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-内存模型</title>
    <url>/JAVA/Java-MemoryModel/</url>
    <content><![CDATA[<h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><a href="/JVM/JVM-Fundamentals/" title="点击这里查看这篇文章">点击这里查看这篇文章</a>

<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>Java内存模型(Java Memory Model，简称JMM)，本身是种<code>抽象的概念</code>，并不是像硬件架构一样真实存在的；它描述的是一组规则或规范，通过这组规范定义了程序中各个变量(包括实例字段、静态字段和构成数组对象的元素)的访问方式。<br><img src="/JAVA/Java-MemoryModel/1.png" alt=""></p>
<a id="more"></a>
<ul>
<li>主内存：共享的信息</li>
<li>工作内存：私有信息，基本数据类型，直接分配到工作内存，引用的地址存放在工作内存，引用的对象存放在堆中</li>
<li>工作方式：<ul>
<li>线程修改私有数据，直接在工作空间修改</li>
<li>线程修改共享数据，把数据复制到工作空间中去，在工作空间中修改，修改完成以后，刷新内存中的数据 </li>
</ul>
</li>
</ul>
<h1 id="硬件架构"><a href="#硬件架构" class="headerlink" title="硬件架构"></a>硬件架构</h1><p><img src="/JAVA/Java-MemoryModel/2.png" alt=""></p>
<ul>
<li><strong>多CPU</strong>：一个现代计算机通常由两个或者多个CPU。其中一些CPU还有多核。从这一点可以看出，在一个有两个或者多个CPU的现代计算机上同时运行多个线程是可能的。每个CPU在某一时刻运行一个线程是没有问题的。这意味着，如果你的Java程序是多线程的，在你的Java程序中每个CPU上一个线程可能同时（并发）执行。</li>
<li><strong>CPU寄存器</strong>：每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。</li>
<li><strong>高速缓存cache</strong>：由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还要慢一点。每个CPU可能有一个CPU缓存层，一些CPU还有多层缓存。在某一时刻，一个或者多个缓存行（cache lines）可能被读到缓存，一个或者多个缓存行可能再被刷新回主存。</li>
<li><strong>内存</strong>：一个计算机还包含一个主存。所有的CPU都可以访问主存。主存通常比CPU中的缓存大得多。</li>
</ul>
<p>运作原理：通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。</p>
<ul>
<li>解决方案：<ul>
<li>总线加锁：所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被<strong>阻塞</strong>住,那么该处理器可以独占使用共享内存。</li>
<li>缓存上的一致性协议(MESI)</li>
</ul>
</li>
</ul>
<h2 id="缓存一致性协议-MESI"><a href="#缓存一致性协议-MESI" class="headerlink" title="缓存一致性协议(MESI)"></a>缓存一致性协议(MESI)</h2><p>多核CPU硬件架构厂商，设计之初就预测到多线程操作数据不一致的问题，因此出现了——缓存一致性协议。</p>
<p>不同的CPU硬件生产厂商，具体的实现不一样。Intel的MESI协议最出名。<br>MESI协议文档：<a href="https://en.wikipedia.org/wiki/MESI_protocol" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/MESI_protocol</a></p>
<p>在MESI协议中，每个Cache line有4个状态，可用2个bit表示，它们分别是：</p>
<ul>
<li>M(Modified): 这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</li>
<li>E(Exclusive): 这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中。</li>
<li>S(Shared): 这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中。</li>
<li>I(Invalid): 这行数据无效。</li>
</ul>
<p>E状态示例如下：<br><img src="/JAVA/Java-MemoryModel/3.png" alt=""><br>只有Core 0访问变量x，它的Cache line状态为E(Exclusive)。</p>
<p>S状态示例如下：<br><img src="/JAVA/Java-MemoryModel/4.jpeg" alt=""><br>3个Core都访问变量x，它们对应的Cache line为S(Shared)状态。</p>
<p>M状态和I状态示例如下：<br><img src="/JAVA/Java-MemoryModel/5.jpeg" alt=""><br>Core 0修改了x的值之后，这个Cache line变成了M(Modified)状态，其他Core对应的Cache line变成了I(Invalid)状态</p>
<h2 id="有了MESI，为什么还需要JMM？"><a href="#有了MESI，为什么还需要JMM？" class="headerlink" title="有了MESI，为什么还需要JMM？"></a>有了MESI，为什么还需要JMM？</h2><p>既然有了MESI协议，是不是就不需要volatile的可见性语义了？<br>当然不是，还有以下问题：</p>
<ul>
<li>并不是所有的硬件架构都提供了相同的一致性保证，不同的硬件厂商实现不同，JVM需要volatile统一语义。</li>
<li>可见性问题不仅仅局限于CPU缓存内，JVM自己维护的内存模型(JMM)中也有可见性问题。使用volatile做标记，可以解决JVM层面的可见性问题。</li>
</ul>
<h1 id="Java线程与硬件处理器"><a href="#Java线程与硬件处理器" class="headerlink" title="Java线程与硬件处理器"></a>Java线程与硬件处理器</h1><p>Java线程的实现是基于一对一的线程模型，实际上就是通过语言级别层面程序去间接调用系统内核的线程模型，即我们在使用Java线程时，Java虚拟机内部是转而调用当前操作系统的内核线程来完成当前任务。<br><img src="/JAVA/Java-MemoryModel/6.png" alt=""><br>如图所示，每个线程最终都会映射到CPU中进行处理，如果CPU存在多核，那么一个CPU将可以并行执行多个线程任务。</p>
<h1 id="Java内存模型与硬件内存架构的关系"><a href="#Java内存模型与硬件内存架构的关系" class="headerlink" title="Java内存模型与硬件内存架构的关系"></a>Java内存模型与硬件内存架构的关系</h1><p>多线程的执行最终都会映射到硬件处理器上进行执行，但Java内存模型和硬件内存架构并不完全一致。<br>对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存(线程私有数据区域)和主内存(堆内存)之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响,不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。<br><img src="/JAVA/Java-MemoryModel/7.png" alt=""></p>
<h1 id="Java内存模型的必要性"><a href="#Java内存模型的必要性" class="headerlink" title="Java内存模型的必要性"></a>Java内存模型的必要性</h1><p>如下图，主内存中存在一个共享变量x，现在有A和B两线程分别对该变量x=1进行操作,A线程想要修改x的值为2，而B线程却想要读取x的值,那么B线程读取到到是1还是2呢？<br>答案：都可能，这是不确定的，这也就是所谓的线程安全问题。<br><img src="/JAVA/Java-MemoryModel/8.png" alt=""><br>为了解决类似上述的问题，JVM定义了一组规则，通过这组规则来决定一个线程对共享变量的写入何时对另一个线程可见。</p>
<h1 id="JMM对三个特征的保证"><a href="#JMM对三个特征的保证" class="headerlink" title="JMM对三个特征的保证"></a>JMM对三个特征的保证</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>操作不可分割</p>
<ol>
<li>X=10 如果是私有数据具有原子性，如果是共享数据没原子性（需要先把10读到共享空间再把10写入x）  </li>
<li>Y=x  没有原子性<ol>
<li>把数据X读到工作空间（原子性）</li>
<li>把X的值写到Y（原子性）</li>
</ol>
</li>
<li>I++ 没有原子性<ol>
<li>读i到工作空间</li>
<li>+1</li>
<li>刷新结果到内存</li>
</ol>
</li>
</ol>
<p>多个原子性的操作合并到一起没有原子性,但是可以通过Synchronized和JUC中Lock的lock来保证原子性。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>线程只能操作自己工作空间中的数据，当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。</p>
<ul>
<li>Volatile:在JMM模型上实现MESI协议</li>
<li>Synchronized:加锁</li>
<li>JUC   Lock的lock</li>
</ul>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，对于单线程而言确实如此，但对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺序未必一致。</p>
<ul>
<li>Volatile</li>
<li>Synchronized</li>
<li>Happens-before原则<ul>
<li>程序次序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</li>
<li>锁定原则：后一次加锁必须等前一次解锁</li>
<li>Volatile原则：volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。</li>
<li>传递原则：A先于B ，B先于C 那么A必然先于C</li>
<li>线程启动规则：如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见</li>
<li>线程终止规则：假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。</li>
<li>线程中断规则：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</li>
<li>对象终结规则：对象的构造函数执行，结束先于finalize()方法</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>JAVA</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机</title>
    <url>/JVM/JVM-Fundamentals/</url>
    <content><![CDATA[<p>Java虚拟机(java virtual machine，JVM)，一种能够运行java字节码的虚拟机。作为一种编程语言的虚拟机，实际上不只是专用于Java语言，只要生成的编译文件匹配JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。 比如kotlin、scala等。</p>
<h1 id="JVM基本结构"><a href="#JVM基本结构" class="headerlink" title="JVM基本结构"></a>JVM基本结构</h1><p>JVM由三个主要的子系统构成</p>
<ul>
<li>类加载子系统</li>
<li>运行时数据区(内存结构)</li>
<li>执行引擎<img src="/JVM/JVM-Fundamentals/1.png" width="80%" height="80%">
<a id="more"></a>

</li>
</ul>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p><img src="/JVM/JVM-Fundamentals/2.png" alt=""></p>
<ol>
<li>加载：将.class文件从磁盘读到内存<ul>
<li>通过类的全限定名(com.xxx.xxx)+类加载器确定唯一的类，来获取定义此类的二进制字节流</li>
<li>将这个类字节流代表的静态存储结构转为方法区的运行时数据结构</li>
<li>在堆中生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口。</li>
</ul>
</li>
<li>连接<ol>
<li>验证：验证字节码文件的正确性<ul>
<li>文件格式验证：基于字节流验证。</li>
<li>元数据验证：基于方法区的存储结构验证。</li>
<li>字节码验证：基于方法区的存储结构验证。</li>
<li>符号引用验证：基于方法区的存储结构验证。</li>
</ul>
</li>
<li>准备：给类的静态变量分配内存，并赋予<code>默认值</code>（不包括实例变量）<ul>
<li>public static int value = 123; //此时在准备阶段过后的初始值为0而不是123，在初始化过程才会被赋值为123</li>
<li>public static final int value = 123;//value的值在准备阶段过后就是123。</li>
</ul>
</li>
<li>解析：类装载器装入类所引用的其它所有类</li>
</ol>
</li>
<li>初始化：为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是程序编写者为变量分配的真正的初始值，执行静态代码块</li>
<li>使用</li>
<li>卸载</li>
</ol>
<h3 id="类加载器的种类"><a href="#类加载器的种类" class="headerlink" title="类加载器的种类"></a>类加载器的种类</h3><p>总体上分为两种：启动类加载器（C++实现） 和 其他类加载器（JAVA实现）</p>
<h4 id="启动类加载器-Bootstrap-ClassLoader"><a href="#启动类加载器-Bootstrap-ClassLoader" class="headerlink" title="启动类加载器(Bootstrap ClassLoader)"></a>启动类加载器(Bootstrap ClassLoader)</h4><p>负责加载JRE的核心类库，如JRE目标下的rt.jar，charsets.jar等</p>
<h4 id="扩展类加载器-Extension-ClassLoader"><a href="#扩展类加载器-Extension-ClassLoader" class="headerlink" title="扩展类加载器(Extension ClassLoader)"></a>扩展类加载器(Extension ClassLoader)</h4><p>负责加载JRE扩展目录ext中jar类包</p>
<h4 id="系统类加载器-Application-ClassLoader"><a href="#系统类加载器-Application-ClassLoader" class="headerlink" title="系统类加载器(Application ClassLoader)"></a>系统类加载器(Application ClassLoader)</h4><p>负责加载ClassPath路径下的类包</p>
<h4 id="用户自定义加载器-User-ClassLoader"><a href="#用户自定义加载器-User-ClassLoader" class="headerlink" title="用户自定义加载器(User ClassLoader)"></a>用户自定义加载器(User ClassLoader)</h4><p>负责加载用户自定义路径下的类包<br><img src="/JVM/JVM-Fundamentals/3.png" width="50%" height="50%"></p>
<h3 id="类加载机制-1"><a href="#类加载机制-1" class="headerlink" title="类加载机制"></a>类加载机制</h3><h4 id="全盘负责委托机制"><a href="#全盘负责委托机制" class="headerlink" title="全盘负责委托机制"></a>全盘负责委托机制</h4><p>当一个ClassLoader加载一个类的时候，除非显示的使用另一个ClassLoader，该类所依赖和引用的类也由这个 ClassLoader载入</p>
<h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>指先委托父类加载器寻找目标类，在找不到的情况下，在自己的路径中查找并载入目标类<br><img src="/JVM/JVM-Fundamentals/4.png" width="50%" height="50%"></p>
<ol>
<li>当有类需要加载，系统类加载器先判断有没有父类，有交给扩展类加载器加载</li>
<li>扩展类加载器判断有没有父类，有交给启动类加载器</li>
<li>启动类加载器没有父类，去实际加载该类，该类不是JRE包下的类，交给子类扩展类加载器去加载</li>
<li>扩展类加载器去加载该类，发现该类不是ext中的包，交给系统类加载器加载</li>
<li>系统类加载器加载，发现是classPath路径下的包，进行加载。</li>
</ol>
<h5 id="双亲委派模式的优势"><a href="#双亲委派模式的优势" class="headerlink" title="双亲委派模式的优势"></a>双亲委派模式的优势</h5><ul>
<li>沙箱安全机制:比如自己写的String.class类不会被加载，这样可以防止核心库被随意篡改</li>
<li>避免类的重复加载:当父ClassLoader已经加载了该类的时候，就不需要子ClassLoader再加载一次</li>
</ul>
<h5 id="为什么要打破双亲委派模式"><a href="#为什么要打破双亲委派模式" class="headerlink" title="为什么要打破双亲委派模式"></a>为什么要打破双亲委派模式</h5><p>例如：tomcat<br>Tomcat是个web容器,可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。<br>如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加载器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。</p>
<h5 id="如何打破双亲委派模式"><a href="#如何打破双亲委派模式" class="headerlink" title="如何打破双亲委派模式"></a>如何打破双亲委派模式</h5><ol>
<li>继承ClassLoader</li>
<li>重写findClass()方法</li>
<li>重写loadClass()方法</li>
</ol>
<h2 id="运行时数据区-内存结构"><a href="#运行时数据区-内存结构" class="headerlink" title="运行时数据区(内存结构)"></a>运行时数据区(内存结构)</h2><p><img src="/JVM/JVM-Fundamentals/5.png" alt=""></p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>java虚拟机栈是线程私有的，每个方法执行都会创建一个栈帧，栈帧包含局部变量表、操作数栈、动态连接、方法出口等。</p>
<h4 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h4><p>每一个方法的执行到执行完成，对应着一个栈帧在虚拟机中从入栈到出栈的过程。java虚拟机栈栈顶的栈帧就是当前执行方法的栈帧。PC寄存器会指向该地址。当这个方法调用其他方法的时候久会创建一个新的栈帧，这个新的栈帧会被方法Java虚拟机栈的栈顶，变为当前的活动栈，在当前只有当前活动栈的本地变量才能被使用，当这个栈帧所有指令都完成的时候，这个栈帧被移除，之前的栈帧变为活动栈，前面移除栈帧的返回值变为这个栈帧的一个操作数。</p>
<h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p>栈帧包含局部变量表、操作数栈、动态连接、方法返回地址</p>
<h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><ul>
<li>局部变量表是变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在java编译成class文件的时候，就在方法的Code属性的max_locals数据项中确定该方法需要分配的最大局部变量表的容量。</li>
<li>局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放32位（4 字节）以内的数据类型（ boolean、byte、char、short、int、float、reference和returnAddress八种）</li>
<li>对于64位长度的数据类型（long，double），虚拟机会以高位对齐方式为其分配<code>两个连续的Slot</code>空间，也就是相当于把一次long和double数据类型读写分割成为两次32位读写。</li>
<li>reference类型虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。</li>
<li>Slot是可以重用的，当Slot中的变量超出了作用域，那么下一次分配Slot的时候，将会覆盖原来的数据。Slot对对象的引用会影响GC（要是被引用，将不会被回收）。  </li>
<li>系统不会为局部变量赋予初始值（实例变量和类变量都会被赋予初始值）。也就是说不存在类变量那样的准备阶段。</li>
</ul>
<h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><ul>
<li>操作数栈和局部变量表一样，在编译时期就已经确定了该方法所需要分配的局部变量表的最大容量。</li>
<li>操作数栈的每一个元素可用是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型占用的栈容量为2。</li>
<li>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈 / 入栈操作（例如：在做算术运算的时候是通过操作数栈来进行的，又或者在调用其它方法的时候是通过操作数栈来进行参数传递的）。</li>
</ul>
<h5 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h5><p>直接引用：有具体引用地址的指针，被引用的类、方法或者变量已经被加载到内存中<br>符号引用：即用用字符串符号的形式来表示引用，其实被引用的类、方法或者变量还没有被加载到内存中。<br>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 符号引用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String str = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(<span class="string">"str="</span> + str);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 直接引用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println(<span class="string">"str="</span> + <span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>

<p>动态链接：在程序运行过程中，由符号引用转化为直接引用。<br>静态链接：在类加载过程中，由符号引用转化为直接引用。</p>
<h5 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h5><p>当一个方法开始执行时，可能有两种方式退出该方法：</p>
<ul>
<li>正常完成出口<ul>
<li>正常完成出口是指方法正常完成并退出，没有抛出任何异常(包括Java虚拟机异常以及执行时通过throw语句显示抛出的异常)。如果当前方法正常完成，则根据当前方法返回的字节码指令，这时有可能会有返回值传递给方法调用者(调用它的方法)，或者无返回值。具体是否有返回值以及返回值的数据类型将根据该方法返回的字节码指令确定。</li>
</ul>
</li>
<li>异常完成出口<ul>
<li>异常完成出口是指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退出。</li>
</ul>
</li>
</ul>
<p>无论方法采用何种方式退出，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在当前栈帧中保存一些信息，用来帮他恢复它的上层方法执行状态。<br>方法退出过程实际上就等同于把当前栈帧出栈，因此退出可以执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压如调用者的操作数栈中，调整PC计数器的值以指向方法调用指令后的下一条指令。<br>一般来说，方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理器表确定的，栈帧中一般不会保存此部分信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">math</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> c = (a + b)*<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">        demo.math();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行👆Demo的math方法时，主线程内存会如何操作<br><img src="/JVM/JVM-Fundamentals/5.1.png" width="50%" height="50%"><br>第一步，现将1放入<code>操作数栈</code><br><img src="/JVM/JVM-Fundamentals/5.2.png" width="50%" height="50%"><br>第二步，将1放入<code>局部变量表</code>中第一个槽里<br><img src="/JVM/JVM-Fundamentals/5.3.png" width="50%" height="50%"><br>第三步，第四步同上，最终将2放入<code>局部变量表</code>中第二个槽里<br><img src="/JVM/JVM-Fundamentals/5.4.png" width="50%" height="50%"><br>第五步，将1复制一份放入<code>操作数栈</code>的栈顶<br>第六步，将2复制一份放入<code>操作数栈</code>的栈顶<br><img src="/JVM/JVM-Fundamentals/5.5.png" width="50%" height="50%"><br>第七步，将2，1弹出操作数栈交给cpu去运算得到3，放到<code>操作数栈</code>的栈顶<br><img src="/JVM/JVM-Fundamentals/5.6.png" width="50%" height="50%"><br>第八步，从常量池（-128～127）里拿到10，放入<code>操作数栈</code>顶<br><img src="/JVM/JVM-Fundamentals/5.7.png" width="50%" height="50%"><br>第九步，弹出10，3交给cpu去运算得到30，放到<code>操作数栈</code>的栈顶（jvm1.6开始进行了指令优化，第8、9步合并成了一步操作）<br><img src="/JVM/JVM-Fundamentals/5.8.png" width="50%" height="50%"><br>第十步，将30放到<code>局部变量表</code>中第3个槽里。<br><img src="/JVM/JVM-Fundamentals/5.9.png" width="50%" height="50%"><br>第十一步，将30复制一份放入<code>操作数栈</code>第栈顶。<br>第十二步，将30弹出操作数栈，通过<code>返回地址</code>返回。</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>就是一个指针，指向方法区中的方法字节码(用来存储<strong>指向下一跳指令的地址</strong>，也就是当前线程将要执行的指令代码)，<br>由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计，用来保证线程间切换后正确执行。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和栈作用很相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行native方法服务。<br>登记native方法，在Execution Engine执行时加载本地方法库。</p>
<h3 id="方法区（永久代-持久代，元空间）"><a href="#方法区（永久代-持久代，元空间）" class="headerlink" title="方法区（永久代/持久代，元空间）"></a>方法区（永久代/持久代，元空间）</h3><p>类的所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在这里定义。<br>简单来说，所有定义的方法的信息都保存在该区域，静态变量+常量+类信息(构造方法/接口定义)+运行时常量池都存在方法区中，<br>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap(非堆)，目的应该是为了和Java的堆区分开(jdk1.8以前hotspot虚拟机叫永久代、持久代，jdk1.8时叫元空间)</p>
<p>永久代和元空间区别在于元数据区不在虚拟机当中，而是用的<code>本地内存</code>，永久代在虚拟机当中，永久代逻辑结构上也属于堆，但是物理上不属于。</p>
<h4 id="为什么移除了永久代"><a href="#为什么移除了永久代" class="headerlink" title="为什么移除了永久代?"></a>为什么移除了永久代?</h4><p>参考官方解释<a href="http://openjdk.java.net/jeps/122" target="_blank" rel="noopener">http://openjdk.java.net/jeps/122</a><br>大概意思是移除永久代是为融合HotSpot与 JRockit而做出的努力，因为JRockit没有永久代，不需要配置永久代。<br><img src="/JVM/JVM-Fundamentals/7.png" alt=""></p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>虚拟机启动时自动分配创建，用于存放<code>对象</code>的实例，几乎所有对象都在堆上分配内存，当对象无法在该空间申请到内<br>存是将抛出OutOfMemoryError异常。同时也是垃圾收集器管理的主要区域。<br><img src="/JVM/JVM-Fundamentals/6.jpeg" alt=""></p>
<h4 id="新生代-Young-Generation"><a href="#新生代-Young-Generation" class="headerlink" title="新生代(Young Generation)"></a>新生代(Young Generation)</h4><p>类出生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。<br>新生代分为两部分:<code>伊甸区</code>(Eden space)和<code>幸存者区</code>(Survivor space)，所有的类都是在伊甸区被new出来的。<br>幸存区(Survivor space):分为From和To区,TO区永远保持空。<br>当Eden区的空间用完是，程序又需要创建对象，JVM的垃圾回收器将Eden区进行垃圾回收(<code>Minor GC</code>)，将Eden区中的不再被其它对象应用的对象进行销毁。<br>然后将Eden区中剩余的对象移到From Survivor区。若From Survivor区也满了，再对该区进行垃圾回收，然后移动到To Survivor区，From区为空后，将To和From区转换，保证To区为空，并且对象年龄加一。<br>当对象年龄默认加到15（因为<strong>对象头只有4个bits</strong>是存对象年龄，最大为15）时将剩下的对象移到老年代。</p>
<h3 id="老年代-Old-Generation"><a href="#老年代-Old-Generation" class="headerlink" title="老年代(Old Generation)"></a>老年代(Old Generation)</h3><p>新生代经过多次GC仍然存货的对象移动到老年区。<br>若老年代也满了，这时候将发生Major GC(也可以叫<code>Full GC</code>)， 进行老年区的内存清理。<br>若老年区执行了Full GC之后发现依然无法进行对象的保存，就会抛出 OOM(OutOfMemoryError)异常.</p>
<h2 id="GC算法和收集器"><a href="#GC算法和收集器" class="headerlink" title="GC算法和收集器"></a>GC算法和收集器</h2><p>几种常见GC：<br>MinorGC/YoungGC 新生代<br>OldGC CMS特有<br>FullGC/MajorGC 回收所有<br>MixedGC（FullGC+YoungGC）  G1特有</p>
<h3 id="如何判断对象可以被回收"><a href="#如何判断对象可以被回收" class="headerlink" title="如何判断对象可以被回收"></a>如何判断对象可以被回收</h3><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡(即不能再被任何途径使用的对象)</p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给对象添加一个引用计数器，每当有一个地方引用，计数器就加1。当引用失效，计数器就减1。任何时候计数器为0 的对象就是不可能再被使用的。</p>
<p>这个方法实现简单，效率高，但是目前主流的虚拟机中没有选择这个算法来管理内存，最主要的原因是它很难解决<strong>对象之前相互循环引用</strong>的问题。所谓对象之间的相互引用问题，通过下面代码所示:除了对象a和b相互引用着对方之外，这两个对象之间再无任何引用。但是它们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数器法无法通知GC回收器回收它们。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterGC</span></span>&#123;</span><br><span class="line">    Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      CounterGC a = <span class="keyword">new</span> CounterGC();</span><br><span class="line">      CounterGC b = <span class="keyword">new</span> CounterGC();</span><br><span class="line">      a.instance = b;</span><br><span class="line">      b.instance = a;</span><br><span class="line">      a = <span class="keyword">null</span>;</span><br><span class="line">      b = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>这个算法的基本思想就是通过一系列的称为”GC Roots”的对象作为起点，从这些节点开始向下搜索，节点所走过的路<br>径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象时不可用的。</p>
<p><code>GC Roots根节点</code>:类加载器、Thread、虚拟机栈的局部变量表、static成员、常量引用、本地方法栈的变量等等.<br><img src="/JVM/JVM-Fundamentals/8.png" alt=""></p>
<h3 id="如何判断一个常量是废弃常量"><a href="#如何判断一个常量是废弃常量" class="headerlink" title="如何判断一个常量是废弃常量"></a>如何判断一个常量是废弃常量</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们怎么判断一个常量时废弃常量呢?<br>假如在常量池中存在字符串”abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量”abc”就是废弃常量，如果这时发生内存回收的话而且有必要的话（内存不够用时才会发生回收），”abc”会被系统清理出常量池。</p>
<h3 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h3><p>需要满足以下三个条件:</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。<br>虚拟机可以对满足上述3个条件的无用类进行回收，这里仅仅是”<strong>可以</strong>“，而并不是和对象一样不适用了就必然会被回收。</li>
</ul>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p><img src="/JVM/JVM-Fundamentals/9.png" alt=""></p>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>它是最基础的收集算法，这个算法分为两个阶段，<code>标记</code>和<code>清除</code>。首先标记出所有需要回收的对象，在标记完成后<br>统一回收所有被标记的对象。它有两个不足的地方:</p>
<ol>
<li>效率问题，标记和清除两个过程的效率都不高;</li>
<li>空间问题，标记清除后会产生大量不连续的碎片;<br><img src="/JVM/JVM-Fundamentals/9.1.png" alt=""></li>
</ol>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决效率问题，复制算法出现了。它可以把内存分为大小相同的两块，每次只使用其中的一块。<br>当这一块的内存使用完后，就将还存活的对象复制到另一块区，然后再把使用的空间一次清理掉。<br>这样就使每次的内存回收都是对内存区间的一半进行回收<br><img src="/JVM/JVM-Fundamentals/9.2.png" alt=""></p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>根据老年代的特点提出的一种标记算法，标记过程和“标记-清除”算法一样，但是后续步骤不是直接对可回收对象进行回收，而是让所有存活的对象向一段移动，然后直接清理掉边界以外的内存<br><img src="/JVM/JVM-Fundamentals/9.3.png" alt=""></p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>现在的商用虚拟机的垃圾收集器基本都采用”分代收集”算法，这种算法就是根据对象存活周期的不同将内存分为几块。<br>一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。<br>在新生代中，每次收集都有大量对象死去，所以可以选择复制算法，只要付出少量对象的复制成本就可以完成每次垃圾收集。<br>而老年代的对象存活几率时比较高的，而且没有额外的空间对它进行分配担保，就必须选择“标记-清除”或 者“标记-整理”算法进行垃圾收集。</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="/JVM/JVM-Fundamentals/10.png" alt=""></p>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>Serial(串行)收集器收集器是最基本、历史最悠久的垃圾收集器了。<br>大家看名字就知道这个收集器是一个单线程收集器了。<br>它的<code>单线程</code>的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程( “Stop The World” )，直到它收集结束。<br><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img src="/JVM/JVM-Fundamentals/10.1.png" alt=""><br>虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短(仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续)。<br>但是Serial收集器有没有优于其他垃圾收集器的地方呢?<br>当然有，它简单而高效(与其他收集器的单线程相比)。 Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。</p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>ParNew收集器其实就是Serial收集器的<code>多线程</code>版本，除了使用多线程进行垃圾收集外，其余行为(控制参数、收集算法、回收策略等等)和Serial收集器完全一样。<br><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img src="/JVM/JVM-Fundamentals/10.2.png" alt=""><br>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器(真正意义上的并发收集器，后面会介绍到)配合工作。</p>
<h4 id="Parallel-Scavenge收集器-JDK1-8"><a href="#Parallel-Scavenge收集器-JDK1-8" class="headerlink" title="Parallel Scavenge收集器(JDK1.8)"></a>Parallel Scavenge收集器(JDK1.8)</h4><p>Parallel Scavenge 收集器类似于ParNew收集器。<br>Parallel Scavenge收集器关注点是<code>吞吐量</code>(高效率的利用CPU)。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。<br>CMS等垃圾收集器的关注点更多的是用户线程的<code>停顿时间</code>(提高用户体验)。 Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。<br><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img src="/JVM/JVM-Fundamentals/10.2.png" alt=""></p>
<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial收集器的老年代版本，它同样是一个<code>单线程</code>收集器，采用<strong>标记-整理</strong>算法。<br>它主要有两大用途:一种用途是在JDK1.5以及以前的版本 中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。</p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>Parallel Scavenge收集器的老年代版本。使用<code>多线程</code>和<strong>标记-整理</strong>算法。<br>在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a><strong>CMS收集器</strong></h4><p>并行和并发概念补充:</p>
<ul>
<li>并行(Parallel) :指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 </li>
<li>并发(Concurrent):指用户线程与垃圾收集线程同时执行(但不一定是并行，可能会交替执行)，用户程序 在继续运行，而垃圾收集器运行在另一个CPU上。</li>
</ul>
<p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。<br>CMS(Concurrent Mark Sweep)收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作。</p>
<p>从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种<strong>标记-清除</strong>算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。<br>整个过程分为四个步骤:</p>
<ul>
<li>初始标记(CMS initial mark): 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 </li>
<li>并发标记(CMS concurrent mark): <strong>同时开启GC和用户线程</strong>，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li>重新标记(CMS remark): 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶 段时间短</li>
<li>并发清除(CMS concurrent sweep): 开启用户线程，同时GC线程开始对为标记的区域做清扫。<br><img src="/JVM/JVM-Fundamentals/10.3.png" alt=""><br>CMS主要优点:并发收集、低停顿。<br>但是它有下面三个明显的缺点:</li>
<li>对CPU资源敏感;</li>
<li>无法处理浮动垃圾;</li>
<li>它使用的回收算法-<strong>标记-清除</strong>算法会导致收集结束时会有大量空间碎片产生。</li>
</ul>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC停顿时间要求的同时,还具备高吞吐量性能特征.<br><img src="/JVM/JVM-Fundamentals/10.3.png" alt=""><br>被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点:</p>
<ul>
<li>并行与并发:G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU(CPU或者CPU核心)来缩短Stop- The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行 </li>
<li>分代收集:虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。 空间整 合:与CMS的“标记–清理”算法不同，G1从整体来看是基于<strong>标记整理</strong>算法实现的收集器;从局部上来看是基于<strong>标记复制</strong>算法实现的</li>
<li><strong>可预测的停顿</strong>:这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内</li>
</ul>
<p>G1收集器的运作大致分为以下几个步骤:</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
<p>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名 字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率(把内存化整为零)。</p>
<h4 id="怎么选择垃圾收集器-（尽量由JVM自己选择）"><a href="#怎么选择垃圾收集器-（尽量由JVM自己选择）" class="headerlink" title="怎么选择垃圾收集器?（尽量由JVM自己选择）"></a>怎么选择垃圾收集器?（尽量由JVM自己选择）</h4><ol>
<li>优先调整堆的大小让服务器自己来选择</li>
<li>如果内存小于100m，使用串行收集器</li>
<li>如果是单核，并且没有停顿时间的要求，串行或JVM自己选择 </li>
<li>如果允许停顿时间超过1秒，选择并行或者JVM自己选</li>
<li>如果响应时间最重要，并且不能超过1秒，使用并发收集器<br>官方推荐ZGC(java最新版本垃圾收器器，可预测的停顿最低2ms)，性能高。</li>
</ol>
<h2 id="JDK性能调优监控工具"><a href="#JDK性能调优监控工具" class="headerlink" title="JDK性能调优监控工具"></a>JDK性能调优监控工具</h2><p>虚拟机参数分析网站：<a href="https://www.perfma.com/product/opts" target="_blank" rel="noopener">https://www.perfma.com/product/opts</a></p>
<h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>显示当前系统的java进程情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdeMacBook-Pro:~ g$ jps</span><br><span class="line">94673 AppServiceApplication</span><br><span class="line">54995</span><br><span class="line">55011 RemoteMavenServer36</span><br><span class="line">94696 AppServiceApplication</span><br><span class="line">96956 Jps</span><br></pre></td></tr></table></figure>

<p>(空白的54995是idea)</p>
<h3 id="Jinfo"><a href="#Jinfo" class="headerlink" title="Jinfo"></a>Jinfo</h3><p>查看正在运行的Java程序的扩展参数</p>
<h4 id="查看JVM的参数"><a href="#查看JVM的参数" class="headerlink" title="查看JVM的参数"></a>查看JVM的参数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdeMacBook-Pro:~ g$ jinfo -flags 94673</span><br><span class="line">VM Flags:</span><br><span class="line">-XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote -XX:CICompilerCount=4 -XX:ConcGCThreads=3 -XX:G1ConcRefinementThreads=10 -XX:G1HeapRegionSize=1048576 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=268435456 -XX:+ManagementServer -XX:MarkStackSize=4194304 -XX:MaxHeapSize=4294967296 -XX:MaxNewSize=2576351232 -XX:MinHeapDeltaBytes=1048576 -XX:NonNMethodCodeHeapSize=7549744 -XX:NonProfiledCodeHeapSize=244108496 -XX:ProfiledCodeHeapSize=0 -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:TieredStopAtLevel=1 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC</span><br></pre></td></tr></table></figure>

<h4 id="查看java系统属性"><a href="#查看java系统属性" class="headerlink" title="查看java系统属性"></a>查看java系统属性</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinfo -sysprops 94673</span><br></pre></td></tr></table></figure>

<h3 id="Jstat"><a href="#Jstat" class="headerlink" title="Jstat"></a>Jstat</h3><p>jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令格式:<br>jstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdeMacBook-Pro:~ g$ jstat -gc 94673</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT</span><br><span class="line"> 0.0   2048.0  0.0   2048.0 96256.0  68608.0   163840.0   132934.6  131280.0 127368.5 14720.0 13850.3    185    1.219   0      0.000  112     0.661    1.880</span><br></pre></td></tr></table></figure>

<ul>
<li>S0C：第一个幸存区的大小</li>
<li>S1C：第二个幸存区的大小</li>
<li>S0U：第一个幸存区的使用大小</li>
<li>S1U：第二个幸存区的使用大小</li>
<li>EC：伊甸园区的大小</li>
<li>EU：伊甸园区的使用大小</li>
<li>OC：老年代大小</li>
<li>OU：老年代使用大小</li>
<li>MC：方法区大小</li>
<li>MU：方法区使用大小</li>
<li>CCSC:压缩类空间大小</li>
<li>CCSU:压缩类空间使用大小</li>
<li>YGC：年轻代垃圾回收次数</li>
<li>YGCT：年轻代垃圾回收消耗时间</li>
<li>FGC：老年代垃圾回收次数</li>
<li>FGCT：老年代垃圾回收消耗时间</li>
<li>GCT：垃圾回收消耗总时间</li>
</ul>
<h3 id="Jmap"><a href="#Jmap" class="headerlink" title="Jmap"></a>Jmap</h3><p>可以用来查看内存信息</p>
<h4 id="堆的对象统计"><a href="#堆的对象统计" class="headerlink" title="堆的对象统计"></a>堆的对象统计</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdeMacBook-Pro:~ g$ jmap -histo 94673 &gt; xxx.txt</span><br></pre></td></tr></table></figure>

<p>部分如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> num     #instances         #bytes  class name (module)</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">   1:        380588       39857240  [B (java.base@11.0.4)</span><br><span class="line">   2:         71568        8387344  [Ljava.lang.Object; (java.base@11.0.4)</span><br><span class="line">   3:        301995        7247880  java.lang.String (java.base@11.0.4)</span><br><span class="line">   4:         25762        5316280  [I (java.base@11.0.4)</span><br><span class="line">   5:         47736        4200768  java.lang.reflect.Method (java.base@11.0.4)</span><br><span class="line">   6:        126275        4040800  java.util.concurrent.ConcurrentHashMap$Node (java.base@11.0.4)</span><br><span class="line">   7:         69142        3871952  java.util.LinkedHashMap (java.base@11.0.4)</span><br><span class="line">   8:          2483        3656120  [C (java.base@11.0.4)</span><br><span class="line">   9:         46566        3352752  io.netty.channel.DefaultChannelHandlerContext</span><br><span class="line">  10:        104582        3346624  java.util.HashMap$Node (java.base@11.0.4)</span><br><span class="line">  11:         20887        2551232  java.lang.Class (java.base@11.0.4)</span><br><span class="line">  12:         32461        2077504  java.util.concurrent.ConcurrentHashMap (java.base@11.0.4)</span><br><span class="line">  13:         48062        1922480  java.util.HashMap$KeyIterator (java.base@11.0.4)</span><br><span class="line">  14:         17400        1720040  [Ljava.util.HashMap$Node; (java.base@11.0.4)</span><br><span class="line">  15:          2184        1432704  io.netty.util.internal.shaded.org.jctools.queues.MpscArrayQueue</span><br><span class="line">  16:         35693        1427720  java.util.LinkedHashMap$Entry (java.base@11.0.4)</span><br><span class="line">  17:         88742        1419872  java.lang.Object (java.base@11.0.4)</span><br><span class="line">  18:          1671        1195280  [Ljava.util.concurrent.ConcurrentHashMap$Node; (java.base@11.0.4)</span><br><span class="line">  19:         10270        1150240  sun.nio.ch.SocketChannelImpl (java.base@11.0.4)</span><br><span class="line">  20:         10237        1064648  io.netty.channel.socket.nio.NioSocketChannel</span><br><span class="line">  21:         42359        1016616  java.util.ArrayList (java.base@11.0.4)</span><br><span class="line">  22:         60868         973888  java.lang.Integer (java.base@11.0.4)</span><br><span class="line">  23:         20436         817440  io.netty.util.DefaultAttributeMap$DefaultAttribute</span><br><span class="line">  24:         10533         758376  org.springframework.core.type.classreading.AnnotationMetadataReadingVisitor</span><br><span class="line">  25:         18570         742800  com.meituan.service.mobile.mtthrift.mtrace.MtraceServerTBinaryProtocol$Factory</span><br><span class="line">  26:         10239         737208  io.netty.channel.DefaultChannelPipeline$HeadContext</span><br><span class="line">  27:         10239         737208  io.netty.channel.DefaultChannelPipeline$TailContext</span><br><span class="line">  28:         30914         729768  [Ljava.lang.Class; (java.base@11.0.4)</span><br><span class="line">  29:         21894         700608  java.util.concurrent.locks.ReentrantLock$NonfairSync (java.base@11.0.4)</span><br><span class="line">------省略----</span><br></pre></td></tr></table></figure>

<ul>
<li>Num:序号</li>
<li>Instances:实例数量</li>
<li>Bytes:占用空间大小</li>
<li>Class Name:类名</li>
</ul>
<h4 id="堆信息"><a href="#堆信息" class="headerlink" title="堆信息"></a>堆信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdeMacBook-Pro:~ g$ jmap -heap 94673</span><br><span class="line">Error: -heap option used</span><br><span class="line">Cannot connect to core dump or remote debug server. Use jhsdb jmap instead</span><br></pre></td></tr></table></figure>

<p>jdk9及以上版本使用jmap -heap pid命令查看当前heap使用情况时，发现报错，提示需要使用jhsdb jmap来替代</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdeMacBook-Pro:~ g$ jhsdb jmap --heap --pid 94673</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-装饰器模式</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Design-Pattern-Decorator/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-观察者模式</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Design-Pattern-Observer/</url>
    <content><![CDATA[<h2 id="认识观察者模式"><a href="#认识观察者模式" class="headerlink" title="认识观察者模式"></a>认识观察者模式</h2><p>我们看看报纸和杂志的订阅是怎么回事:</p>
<ol>
<li>报社的业务就是出版报纸。</li>
<li>向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。只要你是他们的订户，你就会一直收到新报纸。<a id="more"></a></li>
<li>当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸来。</li>
<li>只要报社还在运营，就会一直有人(或单位)向他们订阅报 纸或取消订阅报纸。</li>
</ol>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>出版者+订阅者=观察者模式<br>出版者改称为“主题”(Subject)，订阅者改称为“观察者”(Observer)。<br>观察者模式：定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>建立气象站：<br>该气象站必须建立在WeatherData对象上，由WeatherData对象负责追踪目前的天气状况(温度、<br>湿度、气压)。希望能建立一个应用，有三种布告板，分别显示目前的状况、气象统计及简单的预报。<br>当WeatherObject对象获得最新的测量数据时，三种布告板 必须实时更新。<br>而且，这是一个可以扩展的气象站，Weather-O-Rama气象 站希望公布一组API，好让其他开发人员可以写出自己的气象布告板，并插入此应用中。<br><img src="/设计模式/Design-Pattern-Observer/1.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="comment">// 移除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="comment">// 通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DisplayElement</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 显示布告板</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList observers;</span><br><span class="line">    <span class="comment">// 温度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="comment">// 湿度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">    <span class="comment">// 气压</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; observers.size(); i++) &#123;</span><br><span class="line">            Observer observer = (Observer)observers.get(i);</span><br><span class="line">            observer.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当从气象站得到更新观测值时，我们通知观察者。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measurementsChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        measurementsChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>布告板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span>, <span class="title">DisplayElement</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Subject weatherData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CurrentConditionsDisplay</span><span class="params">(Subject weatherData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weatherData = weatherData;</span><br><span class="line">        weatherData.registerObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Current conditions: "</span> + temperature + <span class="string">"F degrees and "</span> + humidity + <span class="string">"% humidity"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temp;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>气象站测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherStation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line">        CurrentConditionsDisplay currentDisplay = <span class="keyword">new</span> CurrentConditionsDisplay(weatherData);</span><br><span class="line"><span class="comment">//        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);</span></span><br><span class="line"><span class="comment">//        ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData);</span></span><br><span class="line">        weatherData.setMeasurements(<span class="number">80</span>, <span class="number">65</span>, <span class="number">30.4f</span>);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">82</span>, <span class="number">70</span>, <span class="number">29.2f</span>);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">78</span>, <span class="number">90</span>, <span class="number">29.2f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Current conditions: 80.0F degrees and 65.0% humidity</span><br><span class="line">Current conditions: 82.0F degrees and 70.0% humidity</span><br><span class="line">Current conditions: 78.0F degrees and 90.0% humidity</span><br></pre></td></tr></table></figure>

<h2 id="JAVA内置的观察者模式"><a href="#JAVA内置的观察者模式" class="headerlink" title="JAVA内置的观察者模式"></a>JAVA内置的观察者模式</h2><p>Java API有内置的观察者模式。java.util包(package)内包含最基本的Observer接口与Observable类。<br><img src="/设计模式/Design-Pattern-Observer/2.png" alt=""></p>
<p>Observer接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Observable类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;<span class="comment">// 数据更新标记</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; obs; <span class="comment">// 观察者列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (!obs.contains(o)) &#123;</span><br><span class="line">            obs.addElement(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除某一个观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        obs.removeElement(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notifyObservers(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果changed = true 意味着数据被修改，通知每个观察者。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        Object[] arrLocal;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!changed)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            ((Observer)arrLocal[i]).update(<span class="keyword">this</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除所有观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs.removeAllElements();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置changed值</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除changed值</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clearChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取changed值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">hasChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回观察者个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">countObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obs.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 温度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="comment">// 湿度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">    <span class="comment">// 气压</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当从气象站得到更新观测值时，我们通知观察者。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measurementsChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        measurementsChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用“拉”的做法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTemperature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> temperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getHumidity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> humidity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPressure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pressure;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span>, <span class="title">DisplayElement</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line"></span><br><span class="line">    Observable observable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CurrentConditionsDisplay</span><span class="params">(Observable observable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observable = observable;</span><br><span class="line">        observable.addObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Current conditions: "</span> + temperature + <span class="string">"F degrees and "</span> + humidity + <span class="string">"% humidity"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> WeatherData) &#123;</span><br><span class="line">            WeatherData weatherData = (WeatherData)o;</span><br><span class="line">            <span class="keyword">this</span>.temperature = weatherData.getTemperature();</span><br><span class="line">            <span class="keyword">this</span>.humidity = weatherData.getHumidity();</span><br><span class="line">            display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码和测试结果同上</p>
<h3 id="java-util-Observable的缺点"><a href="#java-util-Observable的缺点" class="headerlink" title="java.util.Observable的缺点"></a>java.util.Observable的缺点</h3><p>java.util.Observable的实现 有许多问题，限制了它的使用和复用。</p>
<ul>
<li>观察者是一个“类”而不是一个“接 口”<ul>
<li>你必须设计一个类继承它。如果某类想同时 具有Observable类和另一个超类的行为，就会陷入两难，毕竟Java不支持多重继承。</li>
</ul>
</li>
<li>Observable将关键的方法保护起来<ul>
<li>setChanged()方法被保护起来了(被定义成 protected)。这意味着:除非你继承自Observable，否则你无法创建Observable实例并组合到你自己的对象中来。这个设计违反了第二个设计原 则:“多用组合，少用继承”。</li>
</ul>
</li>
</ul>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul>
<li>观察者模式定义了对象之间一对多的关系。</li>
<li>主题(也就是可观察者)用一个共同的接口来更新观察者。</li>
<li>观察者和可观察者之间用松耦合方式结合(loosecoupl- ing)，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。</li>
<li>使用此模式时，你可从被观察者处推(push)或拉(pull)数据(然而，推的方式被认为更“正确”)。</li>
<li>有多个观察者时，不可以依赖特定的通知次序。</li>
<li>Java有多种观察者模式的实现，包括了通用的java.util.Observable。</li>
<li>要注意java.util.Observable实现上所带来的一些问题。</li>
<li>如果有必要的话，可以实现自己的Observable。</li>
<li>Swing大量使用观察者模式，许多GUI框架也是如此。</li>
<li>此模式也被应用在许多地方，例如:JavaBeans、RMI。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-策略模式</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Design-Pattern-Strategy/</url>
    <content><![CDATA[<h2 id="什么是策略模式"><a href="#什么是策略模式" class="headerlink" title="什么是策略模式"></a>什么是策略模式</h2><p>策略这个词应该怎么理解，打个比方说，我们出门的时候会选择不同的出行方式，比如骑自行车、坐公交、坐火车、坐飞机、坐火箭等等，这些出行方式，每一种都是一个策略。</p>
<p>再比如我们去逛商场，商场现在正在搞活动，有打折的、有满减的、有返利的等等，其实不管商场如何进行促销，说到底都是一些算法，这些算法本身只是一种策略，并且这些算法是随时都可能互相替换的，比如针对同一件商品，今天打八折、明天满100减30，这些策略间是可以互换的。</p>
<p><strong>策略模式（Strategy）</strong>，定义了一组算法，将每个算法都封装起来，并且使它们之间可以互换。</p>
<a id="more"></a>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="模拟鸭子项目"><a href="#模拟鸭子项目" class="headerlink" title="模拟鸭子项目"></a>模拟鸭子项目</h3><p><img src="/设计模式/Design-Pattern-Strategy/1.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Quack</span><span class="params">()</span> </span>&#123;	</span><br><span class="line">        System.out.println(<span class="string">"~~gaga~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;	</span><br><span class="line">        System.out.println(<span class="string">"~~im swim~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GreenHeadDuck继承Duck ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenHeadDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;	</span><br><span class="line">    <span class="meta">@Override</span>	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;	</span><br><span class="line">          System.out.println(<span class="string">"**GreenHead**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="新需求"><a href="#新需求" class="headerlink" title="新需求"></a>新需求</h3><p>添加会飞的鸭子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...;</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span><span class="params">()</span> </span>&#123;	</span><br><span class="line">	 	System.out.println(<span class="string">"~~im fly~~"</span>);</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题来了,这个Fly让所有子类都会飞了，这是不科学的。并非Duck所有的子类都会飞。在Duck超类中加上新的行为，会使得某些并不适合该行为的子类也具有该行为。<br>这个导致，后面几十个鸭子不没有这个功能，不会飞，那么他们的都要去实现。工作量大，而且重复劳动。<br>所以：超类挖的一个坑，每个子类都要来填，增加工作量，复杂度O(N^2)。不是好的设计方式</p>
<h3 id="用策略模式来解决新需求"><a href="#用策略模式来解决新需求" class="headerlink" title="用策略模式来解决新需求"></a>用策略模式来解决新需求</h3><p>需要新的设计方式，应对项目的扩展性，降低复杂度：</p>
<p>1）分析项目变化与不变部分，提取变化部分，然后把变化的部分抽象成接口+实现；</p>
<p>2）鸭子哪些功能是会根据新需求变化的？叫声、飞行…</p>
<p><img src="/设计模式/Design-Pattern-Strategy/2.png" alt=""></p>
<h3 id="重新设计模拟鸭子项目"><a href="#重新设计模拟鸭子项目" class="headerlink" title="重新设计模拟鸭子项目"></a>重新设计模拟鸭子项目</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;	</span><br><span class="line">    FlyBehavior mFlyBehavior;</span><br><span class="line">    QuackBehavior mQuackBehavior;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span><span class="params">()</span> </span>&#123;	</span><br><span class="line">        mFlyBehavior.fly();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Quack</span><span class="params">()</span> </span>&#123;	</span><br><span class="line">        mQuackBehavior.quack();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenHeadDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GreenHeadDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mFlyBehavior = <span class="keyword">new</span> GoodFlyBehavior();</span><br><span class="line">        mQuackBehavior = <span class="keyword">new</span> GaGaQuackBehavior();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I’m a real GreenHeadDuck"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>分析项目中变化部分与不变部分（方法论）——&gt;这个方法论不仅是策略模式中才可以用的，用来分析项目中变法的何不变化的，变化的就可以怎么来抽取替换。而且变化的抽离出来的行为族，行为族之间是可以来相互替换的。</p>
</li>
<li><p>多用组合少用继承；用行为类组合，而不是行为的继承。更有弹性</p>
</li>
</ol>
<h2 id="策略模式中的设计原则"><a href="#策略模式中的设计原则" class="headerlink" title="策略模式中的设计原则"></a>策略模式中的设计原则</h2><ol>
<li><p>开闭原则（Open-Closed Principle，缩写为OCP）</p>
<ul>
<li>一个软件实体应当对扩展开放(例如对抽象层的扩展)，对修改关闭(例如对抽象层的修改)。即在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。</li>
<li>开闭原则的关键，在于抽象。策略模式，是开闭原则的一个极好的应用范例。</li>
</ul>
</li>
<li><p>里氏替换原则（Liskov Substitution Principle，缩写为LSP）</p>
<ul>
<li>里氏替换原则里一个软件实体如果使用的是<strong>一个基类的话，那么一定适用于其子类，而且它根本不能察觉到基类对象和子类对象的区别。</strong> 比如，假设有两个类，一个是Base类，一个是Derived类，并且Derived类是Base类的子类。那么一个方法如果可以接受一个基类对象b的话：method1(Base b)，那么它必然可以接受一个子类对象d，也即可以有method1(d)。反之，则不一定成立。</li>
<li>里氏替换原则讲的是基类与子类的关系。只有当这种关系存在时，里氏替换关系才存在，反之则不存在。</li>
<li>策略模式之所以可行的基础便是里氏替换原则：策略模式要求所有的策略对象都是可以互换的，因此它们都必须是一个抽象策略角色的子类。在客户端则仅知道抽象策略角色类型，虽然变量的真实类型可以是任何一个具体策略角色的实例。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava-总结</title>
    <url>/GUAVA/Guava/</url>
    <content><![CDATA[<h3 id="项目相关信息"><a href="#项目相关信息" class="headerlink" title="项目相关信息"></a>项目相关信息</h3><p>官方首页：<a href="http://code.google.com/p/guava-libraries" target="_blank" rel="noopener">http://code.google.com/p/guava-libraries</a><br>英文文档：<a href="http://www.ostools.net/apidocs/apidoc?api=guava" target="_blank" rel="noopener">http://www.ostools.net/apidocs/apidoc?api=guava</a><br>中文文档：<a href="https://www.kancloud.cn/wizardforcel/java-opensource-doc/112616" target="_blank" rel="noopener">https://www.kancloud.cn/wizardforcel/java-opensource-doc/112616</a></p>
<a id="more"></a>
<h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><ul>
<li><a href="http://www.iocoder.cn/Guava/peida/intro/" target="_blank" rel="noopener">Guava 学习笔记：Google Guava 类库简介</a></li>
<li><a href="http://www.iocoder.cn/Guava/peida/Optional/" target="_blank" rel="noopener">Guava 学习笔记：Optional 优雅的使用null</a></li>
<li><a href="http://www.iocoder.cn/Guava/peida/Preconditions/" target="_blank" rel="noopener">Guava学习笔记：Preconditions优雅的检验参数</a></li>
<li><a href="http://www.iocoder.cn/Guava/peida/Object/" target="_blank" rel="noopener">Guava学习笔记：复写的Object常用方法</a></li>
<li><a href="https://www.cnblogs.com/peida/p/Guava_Ordering.html" target="_blank" rel="noopener">Guava学习笔记：Ordering犀利的比较器</a></li>
<li><a href="http://www.iocoder.cn/Guava/peida/Throwables/" target="_blank" rel="noopener">Guava学习笔记：简化异常处理的Throwables类</a></li>
<li><a href="http://www.iocoder.cn/Guava/peida/Immutable_Collections/" target="_blank" rel="noopener">Guava学习笔记：Immutable(不可变)集合</a></li>
<li><a href="http://www.iocoder.cn/Guava/peida/Multiset/" target="_blank" rel="noopener">Guava学习笔记：Guava新增集合类型-Multiset</a></li>
<li><a href="http://www.iocoder.cn/Guava/peida/Multimap/" target="_blank" rel="noopener">Guava 学习笔记：Guava 新增集合类型 —— Multimap</a></li>
<li><a href="http://www.iocoder.cn/Guava/peida/Bimap/" target="_blank" rel="noopener">Guava学习笔记：Guava新增集合类型-Bimap</a></li>
<li><a href="http://www.iocoder.cn/Guava/peida/Table/" target="_blank" rel="noopener">Guava学习笔记：Guava新集合-Table等</a></li>
<li><a href="http://www.iocoder.cn/Guava/peida/Cache/" target="_blank" rel="noopener">Guava学习笔记：Guava cache</a></li>
<li><a href="http://www.iocoder.cn/Guava/peida/EventBus/" target="_blank" rel="noopener">Guava学习笔记：EventBus</a></li>
<li><a href="http://www.iocoder.cn/Guava/peida/Range/" target="_blank" rel="noopener">Guava学习笔记：Range</a></li>
</ul>
]]></content>
      <categories>
        <category>GUAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>GUAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-CAS</title>
    <url>/JAVA/Java-Cas/</url>
    <content><![CDATA[<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>在看线程池源码的时候发现有很多CAS操作，那么什么是CAS？</p>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>CAS是英文单词 Compare And Swap 的缩写，翻译过来就是比较并替换，它是一种原子操作，同时 CAS 是一种乐观机制。<br>java.util.concurrent 包很多功能都是建立在 CAS 之上，如 ReenterLock 内部的 AQS，各种原子类，其底层都用 CAS来实现原子操作。</p>
<h2 id="如何解决并发安全问题"><a href="#如何解决并发安全问题" class="headerlink" title="如何解决并发安全问题"></a>如何解决并发安全问题</h2><p>在我们认识 CAS 之前，我们是通过什么来解决并发带来的安全问题呢？<br>volatile 关键字可以保证变量的可见性，但保证不了原子性；<br>synchronized 关键字利用 JVM 字节码层面来实现同步机制，它是一个悲观锁机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>javap -c Test.class</code> 命令查看看add方法的字节码指令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: dup</span><br><span class="line">       2: getfield      #2                  // Field n:I</span><br><span class="line">       <span class="number">5</span>: iconst_1</span><br><span class="line">       <span class="number">6</span>: iadd</span><br><span class="line">       7: putfield      #2                  // Field n:I</span><br><span class="line">      <span class="number">10</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>i++被拆分成了几个指令：<br>    1. 执行getfield拿到原始i；<br>    2. 执行iadd进行加1操作；<br>    3. 执行putfield写把累加后的值写回i；</p>
<p>当线程 1 执行到加 1 步骤时，由于还没有执行赋值改变变量的值，这时候并不会刷新主内存区中的变量，<br>如果此时线程 2 正好要拷贝该变量的值到自己私有缓存中，问题就出现了，当线程 2 拷贝完以后，线程1正好执行赋值运算，立马更新主内存区的值，那么此时线程 2 的副本就是旧的了，脏读又出现了。</p>
<p>怎么解决这个问题呢？<br>在 add 方法加上 synchronized 修饰解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方案当然可行，但是大大降低了性能。</p>
<h2 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h2><p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。<br>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存值修改为 B 并返回 true，否则什么都不做，并返回 false。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>下面以<code>AtomicInteger</code>的实现为例，分析一下CAS是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Unsafe</strong>：是CAS的核心类，它可以提供硬件级别的原子操作，它可以获取某个属性在内存中的位置，也可以修改对象的字段值，其底层是用 C/C++<br><strong>valueOffset</strong>：表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。<br><strong>value</strong>：用volatile修饰，保证了多线程之间的内存可见性。</p>
<p>看看<code>AtomicInteger</code>如何实现并发下的累加操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AtomicInteger.getAndAdd</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// unsafe.getAndAddInt</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设线程A和线程B同时执行getAndAdd操作（分别跑在不同CPU上）：</p>
<p>AtomicInteger里面的value原始值为 n，根据Java内存模型，线程A和线程B各自持有一份value的副本，值为n。</p>
<ol>
<li>线程A通过<code>getIntVolatile(var1, var2)</code>拿到value值 n，这时线程A被挂起。</li>
<li>线程B也通过<code>getIntVolatile(var1, var2)</code>方法获取到value值 n，运气好，线程B没有被挂起，并执行compareAndSwapInt方法比较内存值也为 n，成功修改内存值为 m。</li>
<li>这时线程A恢复，执行<code>compareAndSwapInt</code>方法比较，发现自己手里的值(n)和内存的值(m)不一致，说明该值已经被其它线程提前修改过了，那只能重新来一遍了。</li>
<li>重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总是能够看到，线程A继续执行<code>compareAndSwapInt</code>进行比较替换，直到成功。</li>
</ol>
<p>继续深入看看Unsafe类中的compareAndSwapInt方法实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Java 并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的。Java 代码需通过 JNI 才能调用，位于 unsafe.cpp，<br>在OpenJDK8里的路径为: openjdk/hotspot/src/share/vm/prims/unsafe.cpp。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<p>逻辑执行流程：</p>
<ol>
<li>obj是AtomicInteger对象，通过 JNIHandles::resolve() 获取obj在内存中OOP实例p</li>
<li>根据成员变量value反射后计算出的内存偏移值offset去内存中取指针addr</li>
<li>获得更新值x、指针addr、期待值e三个参数后，调用Atomic::cmpxchg(x, addr, e)</li>
<li>通过Atomic::cmpxchg(x, addr, e)实现CAS<br>对应OpenJDK8的路径是: openjdk/hotspot/src/share/vm/runtime/atomic.cpp</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">jbyte Atomic::cmpxchg(jbyte exchange_value, <span class="keyword">volatile</span> jbyte* dest, jbyte compare_value) &#123;</span><br><span class="line">  assert(<span class="keyword">sizeof</span>(jbyte) == <span class="number">1</span>, <span class="string">"assumption."</span>);</span><br><span class="line">  <span class="keyword">uintptr_t</span> dest_addr = (<span class="keyword">uintptr_t</span>)dest;</span><br><span class="line">  <span class="keyword">uintptr_t</span> offset = dest_addr % <span class="keyword">sizeof</span>(jint);</span><br><span class="line">  <span class="keyword">volatile</span> jint* dest_int = (<span class="keyword">volatile</span> jint*)(dest_addr - offset);</span><br><span class="line">  jint cur = *dest_int;</span><br><span class="line">  jbyte* cur_as_bytes = (jbyte*)(&amp;cur);</span><br><span class="line">  jint new_val = cur;</span><br><span class="line">  jbyte* new_val_as_bytes = (jbyte*)(&amp;new_val);</span><br><span class="line">  new_val_as_bytes[offset] = exchange_value;</span><br><span class="line">  <span class="keyword">while</span> (cur_as_bytes[offset] == compare_value) &#123;</span><br><span class="line">    jint res = cmpxchg(new_val, dest_int, cur);</span><br><span class="line">    <span class="keyword">if</span> (res == cur) <span class="keyword">break</span>;</span><br><span class="line">    cur = res;</span><br><span class="line">    new_val = cur;</span><br><span class="line">    new_val_as_bytes[offset] = exchange_value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cur_as_bytes[offset];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的cmpxchg为核心内容. 但是这句代码根据操作系统和处理器的不同, 使用不同的底层代码. </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"runtime/atomic.inline.hpp"</span></span></span><br></pre></td></tr></table></figure>

<p>atomic.inline.hpp中定义如下，可见不同不同操作系统, 不同的处理器, 都要走不同的cmpxchg()方法的实现.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"runtime/atomic.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Linux</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_OS_ARCH_linux_x86</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"atomic_linux_x86.inline.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_OS_ARCH_linux_sparc</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"atomic_linux_sparc.inline.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_OS_ARCH_linux_zero</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"atomic_linux_zero.inline.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_OS_ARCH_linux_arm</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"atomic_linux_arm.inline.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_OS_ARCH_linux_ppc</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"atomic_linux_ppc.inline.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Solaris</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_OS_ARCH_solaris_x86</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"atomic_solaris_x86.inline.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_OS_ARCH_solaris_sparc</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"atomic_solaris_sparc.inline.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Windows</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_OS_ARCH_windows_x86</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"atomic_windows_x86.inline.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ..省略</span></span><br></pre></td></tr></table></figure>

<p>以其中的linux操作系统 x86处理器为例, atomic_linux_x86.inline.hpp<br>在OpenJDK中路径如下: openjdk/hotspot/src/os_cpu/linux_x86/vm/atomic_linux_x86.inline.hpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) <span class="meta-string">"cmp $0, "</span> #mp <span class="meta-string">"; je 1f; lock; 1: "</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> jint     Atomic::cmpxchg    (jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value) &#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __<span class="function">asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">"cmpxchgl %1,(%3)"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"=a"</span> (exchange_value)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"r"</span> (exchange_value), <span class="string">"a"</span> (compare_value), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>已经开始内联汇编了，头疼</p>
<p><code>__asm__</code>：表示汇编的开始<br><code>volatile</code>：表示禁止编译器优化<br><code>cmpxchgl</code>：就是汇编中x86的比较并交换指令了。<br><code>LOCK_IF_MP</code>：是个内联函数，根据当前系统是否为多核处理器决定是否为cmpxchg1指令添加lock前缀。</p>
<p>简单说下C内联汇编的语法格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__<span class="function">asm__ <span class="title">volatile</span><span class="params">(<span class="string">"Instruction List"</span></span></span></span><br><span class="line"><span class="function"><span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">: Output</span></span></span><br><span class="line"><span class="function"><span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">: Input</span></span></span><br><span class="line"><span class="function"><span class="params"> </span></span></span><br><span class="line"><span class="function"><span class="params">: Clobber/Modify)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>instruction list</strong>：它是汇编指令列表<br><strong>Clobber/Modify</strong>：寄存器/内存修改标示。有时候,当你想通知GCC当前内联汇编语句可能会对某些寄存器或内存进行修改,希望GCC在编译时能够将这一点考虑进去;那么你就可以在Clobber/Modify部分声明这些寄存器或内存</p>
<p>所以上述汇编指令解释为：<br>嵌入式汇编规定把输出和输入寄存器按统一顺序编号，顺序是从输出寄存器序列从左到右从上到下以%0开始，分别记为%0、%1···%9。也就是说，输出的eax是%0，输入的exchange_value、compare_value、dest、mp分别是%1、%2、%3、%4。<br>然后看asm里的第一行指令，<strong>cmpxchgl %1,(%3)</strong>，比较eax(compare_value在eax中)与dest的值，如果相等，那么将<strong>exchange_value</strong>的值赋值给dest；否则，将dest的值赋值给eax。<br>然后看输出: “=a” (<strong>exchange_value</strong>) 表示把eax中存的值(compare_value)写入<strong>exchange_value</strong>变量中。</p>
<p><code>Atomic::cmpxchg</code>这个函数最终返回值是exchange_value，也就有两种情况：</p>
<ol>
<li><p>如果cmpxchgl执行时compare_value和dest指针指向内存值相等则会使得dest指针指向内存值变成<strong>exchange_value</strong>，最终eax存的compare_value赋值给了<strong>exchange_value</strong>变量，即函数最终返回的值是原先的compare_value。<br>此时Unsafe_CompareAndSwapInt的返回值(jint)(Atomic::cmpxchg(x, addr, e)) == e就是true，表明CAS成功。</p>
</li>
<li><p>如果cmpxchgl执行时compare_value和(dest)不等则会把当前dest指针指向内存的值写入eax，最终输出时赋值给<strong>exchange_value</strong>变量作为返回值，<br>导致(jint)(Atomic::cmpxchg(x, addr, e)) == e得到false，表明CAS失败。</p>
</li>
</ol>
<h3 id="lock前缀"><a href="#lock前缀" class="headerlink" title="lock前缀"></a>lock前缀</h3><p>在单处理器系统中是不需要加lock的，因为能够在单条指令中完成的操作都可以认为是原子操作，中断只能发生在指令与指令之间。<br>在多处理器系统中,由于系统中有多个处理器在独立的运行，即使在能单条指令中完成的操作也可能受到干扰。</p>
<p>在所有的 X86 CPU 上都具有锁定一个特定内存地址的能力，当这个特定内存地址被锁定后，它就可以阻止其他的系统总线读取或修改这个内存地址。这种能力是通过 LOCK 指令前缀再加上前面的汇编指令来实现的。当使用 LOCK 指令前缀时，它会使 CPU 宣告一个 LOCK# 信号，这样就能确保在多处理器系统或多线程竞争的环境下互斥地使用这个内存地址。当指令执行完毕，这个锁定动作也就会消失。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>CPU开销较大：在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</li>
<li>不能保证代码块的原子性：CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证多个变量共同进行原子性的更新，就得使用Synchronized了。</li>
<li>ABA问题：这是CAS机制最大的问题所在。</li>
</ol>
<h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>线程 1 从内存位置 V 取出 A，这时候线程 2 也从内存位置 V 取出 A，此时线程 1 处于挂起状态，线程 2 将位置 V 的值改成 B，最后再改成 A，<br>这时候线程 1 再执行，发现位置 V 的值没有变化，尽管线程 1 也更改成功了，但内存地址V中的变量已经经历了A-&gt;B-&gt;A的改变。</p>
<p>举个例子：<br>假设有一个遵循CAS原理的提款机，小灰有100元存款，要用这个提款机来提款50元。<br>由于提款机硬件出了点小问题，小灰的提款操作被同时提交两次，开启了两个线程，两个线程都是获取当前值100元，要更新成50元。<br>理想情况下，应该一个线程更新成功，另一个线程更新失败，小灰的存款只被扣一次。<br>线程1首先执行成功，把余额从100改成50。线程2因为某种原因阻塞了。这时候，小灰的妈妈刚好给小灰汇款50元。<br>线程2仍然是阻塞状态，线程3执行成功，把余额从50改成100。<br>线程2恢复运行，由于阻塞之前已经获得了“当前值”100，并且经过compare检测，此时存款实际值也是100，所以成功把变量值100更新成了50。<br>小灰凭空少了50元钱。</p>
<p>所以真正要做到严谨的CAS机制，我们在Compare阶段不仅要比较期望值A和地址V中的实际值，还要比较变量的版本号是否一致。<br>在Java当中，<code>AtomicStampedReference</code>类就实现了用版本号做比较的CAS机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T reference;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reference = reference;</span><br><span class="line">        <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AtomicStampedReference 的内部类 Pair, reference 维护对象的引用，stamp 维护修改的版本号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">          newStamp == current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 compareAndSet 方法得知，如果要更改内存中的值，不但要值相同，还要版本号相同。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.jianshu.com/p/0e312402f6ca" target="_blank" rel="noopener">https://www.jianshu.com/p/0e312402f6ca</a></li>
<li><a href="https://blog.csdn.net/dlh0313/article/details/52172833" target="_blank" rel="noopener">https://blog.csdn.net/dlh0313/article/details/52172833</a></li>
<li><a href="https://www.cnblogs.com/noKing/p/9094983.html" target="_blank" rel="noopener">https://www.cnblogs.com/noKing/p/9094983.html</a></li>
<li><a href="https://www.jianshu.com/p/fb6e91b013cc" target="_blank" rel="noopener">https://www.jianshu.com/p/fb6e91b013cc</a></li>
<li><a href="https://objcoding.com/2018/11/29/cas/" target="_blank" rel="noopener">https://objcoding.com/2018/11/29/cas/</a></li>
<li><a href="https://mp.weixin.qq.com/s/nRnQKhiSUrDKu3mz3vItWg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/nRnQKhiSUrDKu3mz3vItWg</a></li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>JAVA</tag>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-线程池</title>
    <url>/JAVA/Java-ThreadPool/</url>
    <content><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>操作系统调度的最小单元是线程，也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程， 这些线程都拥有各自的计数器、 堆栈和局部变量等属性， 并且能够访问共享的内存变量。 处理器在这些线程上高速切换， 让使用者感觉到这些线程在同时执行。</p>
<a id="more"></a>
<h4 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h4><ul>
<li>通过继承Thread类来创建一个线程</li>
<li>实现Runnable接口并重写run()方法，new Thread(runnable).start()，线程启动时就会自动调用该对象的run方法</li>
<li>实现Callable接口并实现call()方法，使用FutureTask类包装Callable对象，使用FutureTask对象作为Thread对象的targer创建并启动线程；也可以使用线程池启动<pre><code>Runnable 和 Callable 的区别
 1. Runnable规定方法是run方法，Callable规定方法是call方法
 2. Runnable任务执行后无返回值，Callable任务执行后可返回值
 3. run方法无法抛出异常，call方法可以抛出异常
 4. 运行Callable任务可以拿到一个Future对象，Future表示异步计算结果，他提供了检查计算是否完成的方法，以等待计算完成并获取结果。计算完成后用get()方法获取结果，如果线程没有执行完，get()方法会阻塞当前线程执行。如果线程出现异常，get()方法会抛出异常。</code></pre></li>
<li>线程池：Executors类提供了方便的工厂方法来创建不同类型的 executor services。无论Runnable还是Callable都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行<pre><code>1. public static ExecutorService newCachedThreadPool() 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程，但是在之前构造的线程可用时将重用它们。
2. public static ExecutorService newFixedThreadPool(int nThreads)  创建一个定长线程池，可控制线程最大并发数，以共享的无界队列方式来运行线程，超出的线程会在队列中等待。
3. public static ExecutorService newSingleThreadExecutor() 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，以无界队列方式来运行线程，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
4. public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 创建一个周期线程池，支持定时及周期性任务执行。
5. public static ExecutorService newWorkStealingPool() 创建持有足够线程的线程池来支持给定的并行级别，并通过使用多个队列，减少竞争，它需要穿一个并行级别的参数，如果不传，则被设定为默认的CPU数量，这个线程池实际上是ForkJoinPool的扩展，适合使用在很耗时的任务中，能够合理的使用CPU进行并行操作。</code></pre></li>
</ul>
<h4 id="线程的管理"><a href="#线程的管理" class="headerlink" title="线程的管理"></a>线程的管理</h4><ul>
<li>ForkJoinPool 的每个工作线程都维护了一个工作队列(WorkQueue)，这是一个双端队列，里面存放的对象是任务(ForkJoinTask)<ul>
<li>每个工作线程在运行中产生新的任务(通常是因为调用了fork())，会放入工作队列的队尾，并且工作线程在处理自己的工作队列时，使用的是LIFO方式，也就是每次从队尾取任务执行。</li>
<li>每个工作线程在处理自己的工作队列时，会尝试窃取一个任务(或是来自刚刚提交到pool的任务，或是来自其他的工作队列)，窃取的任务位于其他线程工作队列的队首，也就是使用FIFO方式。</li>
<li>在遇到join()时如果join的任务尚未完成，则会先处理其他任务，并等待其完成。</li>
</ul>
</li>
<li>ExecutorCompletionService 内部维护了一个阻塞队列(BlockingQueue), 只有完成的任务才被加入到队列中。如果队列中的数据为空时, 调用take()就会阻塞直到有完成的任务加入队列，基于FutureTask实现。</li>
</ul>
<h1 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h1><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>corePoolSize 核心线程数量，当有新任务在exectue()方法提交时，会执行以下判断：<pre><code>1. 如果运行的线程少于 corePoolSize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的；
2. 如果线程池中的线程数量大于等于 corePoolSize 且小于 maximumPoolSize，则只有当workQueue满时才创建新的线程去处理任务；
3. 如果设置的corePoolSize 和 maximumPoolSize相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取任务并处理；
4. 如果运行的线程数量大于等于maximumPoolSize，这时如果workQueue已经满了，则通过handler所指定的策略来处理任务；
5. 所以，任务提交时，判断的顺序为 corePoolSize –&gt; workQueue –&gt; maximumPoolSize</code></pre></li>
<li>maximumPoolSize 最大线程数量；</li>
<li>keepAliveTime 线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime；</li>
<li>workQueue 保存等待执行的任务的阻塞队列，当提交一个新的任务到线程池以后, 线程池会根据当前线程池中正在运行着的线程的数量来决定对该任务的处理方式，主要有以下几种处理方式:<ul>
<li><strong>直接切换</strong>：这种方式常用的队列是SynchronousQueue</li>
<li><strong>使用无界队列</strong>：一般使用基于链表的阻塞队列LinkedBlockingQueue。如果使用这种方式，那么线程池中能够创建的最大线程数就是corePoolSize，而maximumPoolSize就不会起作用了。当线程池中所有的核心线程都是RUNNING状态时，这时一个新的任务提交就会放入等待队列中。</li>
<li><strong>使用有界队列</strong>：一般使用ArrayBlockingQueue。使用该方式可以将线程池的最大线程数量限制为maximumPoolSize，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。</li>
</ul>
</li>
<li>threadFactory 它是ThreadFactory类型的变量，用来创建新线程。默认使用Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称。</li>
<li>handler 它是RejectedExecutionHandler类型的变量，表示线程池的饱和策略。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。线程池提供了4种策略：<ul>
<li>AbortPolicy：直接抛出异常，这是默认策略；</li>
<li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li>
<li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li>DiscardPolicy：直接丢弃任务；</li>
</ul>
</li>
</ul>
<h2 id="核心源码"><a href="#核心源码" class="headerlink" title="核心源码"></a>核心源码</h2><h3 id="线程池执行源码"><a href="#线程池执行源码" class="headerlink" title="线程池执行源码"></a>线程池执行源码</h3><h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// clt记录着runState和workerCount</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// workerCountOf方法取出低29位的值，表示当前活动的线程数；</span></span><br><span class="line">    <span class="comment">// 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中，并把任务添加到该线程中；</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；</span></span><br><span class="line">        <span class="comment">// 如果为true，根据corePoolSize来判断；</span></span><br><span class="line">        <span class="comment">// 如果为false，则根据maximumPoolSize来判断</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果添加失败，则重新获取ctl值</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前线程池是运行状态 并且 任务能够成功添加到工作队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重新获取ctl值</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，</span></span><br><span class="line">        <span class="comment">// 这时需要移除该command</span></span><br><span class="line">        <span class="comment">// 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法</span></span><br><span class="line">        <span class="comment">// 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；</span></span><br><span class="line">        <span class="comment">// 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；</span></span><br><span class="line">        <span class="comment">// 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果执行到这里，有两种情况：</span></span><br><span class="line">    <span class="comment">// 1.线程池已经不是RUNNING状态；</span></span><br><span class="line">    <span class="comment">// 2.线程池是RUNNING状态，但workerCount &gt;= corePoolSize并且workQueue已满;</span></span><br><span class="line">    <span class="comment">// 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；</span></span><br><span class="line">    <span class="comment">// 如果失败则拒绝该任务 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runState和workCount变量怎么存储在一个int中？参考：<a href="https://blog.csdn.net/weixin_34396902/article/details/94527424" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34396902/article/details/94527424</a></p>
<h4 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 循环CAS操作，将线程池中的线程数+1</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// clt记录着runState和workerCount</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取运行状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果rs &gt;= SHUTDOWN，则表示此时不再接收新任务；</span></span><br><span class="line">        <span class="comment">// 接着判断以下3个条件，只要有1个不满足，则返回false：</span></span><br><span class="line">        <span class="comment">// 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务</span></span><br><span class="line">        <span class="comment">// 2. firsTask为空</span></span><br><span class="line">        <span class="comment">// 3. 阻塞队列不为空</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// rs == SHUTDOWN的情况</span></span><br><span class="line">        <span class="comment">// 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；</span></span><br><span class="line">        <span class="comment">// 如果firstTask为空，并且workQueue也为空，因为队列中已经没有任务了，不需要再添加线程了，则返回false，</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取线程数</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果wc超过CAPACITY(最大线程数线程数),也就是ctl的低29位的最大值（二进制是29个1），返回false；</span></span><br><span class="line">            <span class="comment">// core是addWorker方法的第二个参数,如果为true表示根据corePoolSize来比较，如果为false则根据maximumPoolSize来比较;</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// CAS操作尝试增加workerCount，修改clt的值+1，如果成功，则跳出第一个for循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果增加workerCount失败，则重新获取ctl的值</span></span><br><span class="line">            c = ctl.get();  </span><br><span class="line">            <span class="comment">// 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建线程，并加入到线程池workers中。</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据firstTask来创建Worker对象</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每一个Worker对象都会创建一个线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 对workers操作要通过加锁来实现</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取运行状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// rs &lt; SHUTDOWN表示是RUNNING状态；</span></span><br><span class="line">                <span class="comment">// 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。</span></span><br><span class="line">                <span class="comment">// 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 判断添加的任务状态,如果已经开始丢出异常</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) </span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 将新建的线程加入到线程池中，workers是一个hashSet</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// largestPoolSize记录着线程池中出现过的最大线程数量</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    <span class="comment">//标记任务添加</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                <span class="comment">// 标记线程启动</span></span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 线程添加线程池失败或者线程start失败，则需要调用addWorkerFailed函数</span></span><br><span class="line">        <span class="comment">// 如果添加成功则需要移除线程，并恢复复clt的值</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>t.start()这个语句，启动时会调用Worker类中的run方法，Worker本身实现了Runnable接口，所以一个Worker类型的对象也是一个线程。</p>
<h4 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 线程池中正真运行的线程。通过我们指定的线程工厂创建而来 **/</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** 线程包装的任务。thread 在run时主要调用了该任务的run方法 */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** 记录当前线程完成的任务数 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// 在调用runWorker()前，禁止interrupt中断，在interruptIfStarted()方法中会判断 getState()&gt;=0</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 利用我们指定的线程工厂创建一个线程</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lock methods</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">    <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 尝试获取锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//尝试一次将state从0设置为1，即“锁定”状态，</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//设置exclusiveOwnerThread=当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 尝试释放锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 中断（如果运行）</span></span><br><span class="line"><span class="comment">    * shutdownNow时会循环对worker线程执行</span></span><br><span class="line"><span class="comment">    * 且不需要获取worker锁，即使在worker运行时也可以中断</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="comment">// 如果state&gt;=0、t!=null、且t没有被中断</span></span><br><span class="line">        <span class="comment">// new Worker()时state==-1，说明不能中断</span></span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Worker类投机取巧的继承了AbstractQueuedSynchronizer来简化在执行任务时的获取、释放锁,这样防止了中断在运行中的任务，只会唤醒(中断)在等待从workQueue中获取任务的线程.<br>不直接执行execute(command)提交的command，而要在外面包一层Worker主要是为了使用用AQS锁控制中断，当运行时上锁，就不能中断，TreadPoolExecutor的shutdown()方法中断前都要获取worker锁，只有在等待从workQueue中获取任务getTask()时才能中断。</p>
<h4 id="runWorker-方法"><a href="#runWorker-方法" class="headerlink" title="runWorker 方法"></a>runWorker 方法</h4><p>在Worker类中的run方法调用了runWorker方法来执行任务.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取第一个任务</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// 允许中断</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 是否因为异常退出循环</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果task为空，则通过getTask来获取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">// 线程池处于stop状态或者当前线程被中断时，线程池状态是stop状态</span></span><br><span class="line">            <span class="comment">// 但是当前线程没有中断，则发出中断请求</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//开始执行任务前的Hook，类似回调函数</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//任务执行后的Hook，类似回调函数</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//执行完毕后task重置，completedTasks计数器++，解锁</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标记正常退出</span></span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//线程空闲达到我们设定的值时，Worker退出销毁。</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getTask-方法"><a href="#getTask-方法" class="headerlink" title="getTask 方法"></a>getTask 方法</h4><p>runWorker函数中最重要的是getTask()，不断的从阻塞队列中取任务交给线程执行，并且负责线程回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示上次从阻塞队列中取任务时是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果线程池处于shutdown状态，</span></span><br><span class="line">        <span class="comment">// 并且队列为空，或者线程池处于stop或者terminate状态，</span></span><br><span class="line">        <span class="comment">// 在线程池数量-1，返回null，回收线程</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取线程数</span></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// timed变量用于判断是否需要进行超时控制。</span></span><br><span class="line">        <span class="comment">// allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；</span></span><br><span class="line">        <span class="comment">// wc &gt; corePoolSize，表示当前线程池中的线程数量大于核心线程数量；</span></span><br><span class="line">        <span class="comment">// 对于超过核心线程数量的这些线程，需要进行超时控制</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果线程数目大于最大线程数目 或 当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时</span></span><br><span class="line">        <span class="comment">// 并且 线程数目大于1 或 工作队列为空</span></span><br><span class="line">        <span class="comment">// 尝试将workerCount减1；</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//**保证核心线程不被销毁**</span></span><br><span class="line">            <span class="comment">// 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null；</span></span><br><span class="line">            <span class="comment">// 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果 r == null，说明已经超时，timedOut设置为true，进入下一个循环</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">// 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FutureTask源码"><a href="#FutureTask源码" class="headerlink" title="FutureTask源码"></a>FutureTask源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * state字段用来保存FutureTask内部的任务执行状态，一共有7中状态，每种状态及其对应的值如下</span></span><br><span class="line"><span class="comment">     * NEW:表示是个新的任务或者还没被执行完的任务。这是初始状态。</span></span><br><span class="line"><span class="comment">     * COMPLETING:任务已经执行完成或者执行任务的时候发生异常，但是任务执行结果或者异常原因还没有保存到outcome字段(outcome字段用来保存任务执行结果，如果发生异常，则用来保存异常原因)的时候，状态会从NEW变更到COMPLETING。但是这个状态会时间会比较短，属于中间状态。</span></span><br><span class="line"><span class="comment">     * NORMAL:任务已经执行完成并且任务执行结果已经保存到outcome字段，状态会从COMPLETING转换到NORMAL。这是一个最终态。</span></span><br><span class="line"><span class="comment">     * EXCEPTIONAL:任务执行发生异常并且异常原因已经保存到outcome字段中后，状态会从COMPLETING转换到EXCEPTIONAL。这是一个最终态。</span></span><br><span class="line"><span class="comment">     * CANCELLED:任务还没开始执行或者已经开始执行但是还没有执行完成的时候，用户调用了cancel(false)方法取消任务且不中断任务执行线程，这个时候状态会从NEW转化为CANCELLED状态。这是一个最终态。</span></span><br><span class="line"><span class="comment">     * INTERRUPTING: 任务还没开始执行或者已经执行但是还没有执行完成的时候，用户调用了cancel(true)方法取消任务并且要中断任务执行线程但是还没有中断任务执行线程之前，状态会从NEW转化为INTERRUPTING。这是一个中间状态。</span></span><br><span class="line"><span class="comment">     * INTERRUPTED:调用interrupt()中断任务执行线程之后状态会从INTERRUPTING转换到INTERRUPTED。这是一个最终态。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * NEW -&gt; COMPLETING -&gt; NORMAL 正常执行并返回</span></span><br><span class="line"><span class="comment">     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL 执行过程中出现了异常</span></span><br><span class="line"><span class="comment">     * NEW -&gt; CANCELLED 执行前被取消</span></span><br><span class="line"><span class="comment">     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED 取消时被中断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;<span class="comment">//大于这个值就是完成状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The underlying callable; nulled out after running */</span></span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line">    <span class="comment">/** The result to return or exception to throw from get() */</span></span><br><span class="line">    <span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line">    <span class="comment">/** 执行callable的线程 **/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line">    <span class="comment">/** 使用Treiber算法实现的无阻塞的Stack，用于存放等待的线程 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">        <span class="comment">// 拿到返回结果</span></span><br><span class="line">        Object x = outcome;</span><br><span class="line">        <span class="comment">// 判断状态</span></span><br><span class="line">        <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">            <span class="comment">// 状态正常，就返回结果值</span></span><br><span class="line">            <span class="keyword">return</span> (V)x;</span><br><span class="line">        <span class="comment">// 判断异常，就抛出异常。</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个构造方法会把传入的Runnable封装成一个Callable对象保存在callable字段中，同时如果任务执行成功的话就会返回传入的result。</span></span><br><span class="line"><span class="comment">     * 这种情况下如果不需要返回值的话可以传入一个null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断任务是否被取消</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state &gt;= CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断任务是否完成</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state != NEW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 任务是new状态 并且 根据mayInterruptIfRunning把状态从NEW转化到INTERRUPTING或CANCELLED </span></span><br><span class="line">        <span class="comment">// 不符合上述状态，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">              UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW,</span><br><span class="line">                  mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;    </span><br><span class="line">        <span class="comment">// 2. 如果需要中断任务执行线程</span></span><br><span class="line">            <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// runner保存着当前执行任务的线程</span></span><br><span class="line">                    Thread t = runner;</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">//中断任务执行线程</span></span><br><span class="line">                        t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                    <span class="comment">// 修改状态为INTERRUPTED</span></span><br><span class="line">                    UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">// 判断任务当前的state &lt;= COMPLETING是否成立。</span></span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">            <span class="comment">// 如果成立，表明任务还没有结束(这里的结束包括任务正常执行完毕，任务执行异常，任务被取消)</span></span><br><span class="line">            <span class="comment">// 调用awaitDone()进行阻塞等待。</span></span><br><span class="line">            s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="comment">// 任务已经结束，调用report()返回结果。</span></span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">// 如果awaitDone()超时返回之后任务还没结束，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">            (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尝试CAS操作，把当前的状态从NEW变更为COMPLETING(中间状态)状态。</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">            <span class="comment">// 把任务执行结果保存在outcome字段中。</span></span><br><span class="line">            outcome = v;</span><br><span class="line">            <span class="comment">// CAS的把当前任务状态从COMPLETING变更为NORMAL</span></span><br><span class="line">            UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尝试CAS操作，把当前的状态从NEW变更为COMPLETING(中间状态)状态。</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">            <span class="comment">// 把异常原因保存在outcome字段中，outcome字段用来保存任务执行结果或者异常原因。</span></span><br><span class="line">            outcome = t;</span><br><span class="line">            <span class="comment">// CAS的把当前任务状态从COMPLETING变更为EXCEPTIONAL。</span></span><br><span class="line">            UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 状态如果不是NEW，说明任务或者已经执行过，或者已经被取消，直接返回</span></span><br><span class="line">        <span class="comment">// 状态如果是NEW，则尝试把当前执行线程保存在runner字段(runnerOffset)中，如果赋值失败则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="comment">// 只有初始状态才会执行</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="keyword">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行任务  计算逻辑</span></span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                    ran = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 保存异常</span></span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    <span class="comment">// 任务执行成功，保存返回结果</span></span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论是否执行成功，把runner设置为null</span></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="comment">// 如果任务被中断，执行中断处理</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 与run方法类似，区别在于这个方法不会设置任务的执行结果值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successfully run and reset</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAndReset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> ran = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; s == NEW) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 不获取和设置返回值</span></span><br><span class="line">                    c.call(); <span class="comment">// don't set result</span></span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否正确的执行并复位</span></span><br><span class="line">        <span class="keyword">return</span> ran &amp;&amp; s == NEW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePossibleCancellationInterrupt</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">            <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">                Thread.yield(); <span class="comment">// wait out pending interrupt</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保cancel(true)产生的中断发生在run或runAndReset方法执行的过程中。</span></span><br><span class="line">        <span class="comment">//这里会循环的调用Thread.yield()来确保状态在cancel方法中被设置为INTERRUPTED。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Simple linked list nodes to record waiting threads in a Treiber</span></span><br><span class="line"><span class="comment">     * stack.  See other classes such as Phaser and SynchronousQueue</span></span><br><span class="line"><span class="comment">     * for more detailed explanation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">        WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes and signals all waiting threads, invokes done(), and</span></span><br><span class="line"><span class="comment">     * nulls out callable.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">        <span class="comment">// 执行该方法时state必须大于COMPLETING</span></span><br><span class="line">        <span class="comment">// 依次遍历waiters链表</span></span><br><span class="line">        <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">            <span class="comment">// 设置栈顶节点为null</span></span><br><span class="line">            <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    Thread t = q.thread;</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        q.thread = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 唤醒等待线程</span></span><br><span class="line">                        LockSupport.unpark(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                    WaitNode next = q.next;</span><br><span class="line">                    <span class="comment">// 如果next为空，说明栈空了，跳出循环</span></span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 方便gc回收</span></span><br><span class="line">                    q.next = <span class="keyword">null</span>; </span><br><span class="line">                    <span class="comment">// 重新设置栈顶node</span></span><br><span class="line">                    q = next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 空方法，留给子类扩展</span></span><br><span class="line">        done();</span><br><span class="line"></span><br><span class="line">        callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Awaits completion or aborts on interrupt or timeout.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timed true if use timed waits</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nanos time to wait, if timed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> state upon completion</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 计算等待截止时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 1. 判断阻塞线程是否被中断</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="comment">// 被中断则在等待队列中删除该节点</span></span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="comment">// 抛出InterruptedException异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="comment">// 2. 获取当前状态，如果状态大于COMPLETING</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">                <span class="comment">// 说明任务已经结束(要么正常结束，要么异常结束，要么被取消)</span></span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 把thread显示置空</span></span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 返回结果</span></span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. 如果状态处于中间状态COMPLETING</span></span><br><span class="line">            <span class="comment">// 表示任务已经结束但是任务执行线程还没来得及给outcome赋值</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">                Thread.yield();<span class="comment">// 让出执行权让其他线程优先执行</span></span><br><span class="line">            <span class="comment">// 4. 如果等待节点为空，则构造一个等待节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">                q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">            <span class="comment">// 5. 如果还没有入队列，则把当前节点加入waiters首节点并替换原来waiters</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">                queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                     q.next = waiters, q);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                <span class="comment">// 如果需要等待特定时间，则先计算要等待的时间</span></span><br><span class="line">                <span class="comment">// 如果已经超时，则删除对应节点并返回对应的状态</span></span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 6. 阻塞等待特定时间</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6. 阻塞等待直到被其他线程唤醒</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeWaiter</span><span class="params">(WaitNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将thread设置为null是因为下面要根据thread是否为null判断是否要把node移出</span></span><br><span class="line">            node.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 这里自旋保证删除成功</span></span><br><span class="line">            retry:</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;          <span class="comment">// restart on removeWaiter race</span></span><br><span class="line">                <span class="keyword">for</span> (WaitNode pred = <span class="keyword">null</span>, q = waiters, s; q != <span class="keyword">null</span>; q = s) &#123;</span><br><span class="line">                    s = q.next;</span><br><span class="line">                    <span class="comment">// q.thread != null说明该q节点不需要移除</span></span><br><span class="line">                    <span class="keyword">if</span> (q.thread != <span class="keyword">null</span>)</span><br><span class="line">                        pred = q;</span><br><span class="line">                    <span class="comment">// 如果q.thread == null，且pred != null，需要删除q节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 删除q节点</span></span><br><span class="line">                        pred.next = s;</span><br><span class="line">                         <span class="comment">// pred.thread == null时说明在并发情况下被其他线程修改了；</span></span><br><span class="line">                         <span class="comment">// 返回第一个for循环重试</span></span><br><span class="line">                        <span class="keyword">if</span> (pred.thread == <span class="keyword">null</span>) <span class="comment">// check for race</span></span><br><span class="line">                            <span class="keyword">continue</span> retry;</span><br><span class="line">                    &#125;</span><br><span class="line">                     <span class="comment">// 如果q.thread != null且pred == null，说明q是栈顶节点</span></span><br><span class="line">                     <span class="comment">// 设置栈顶元素为s节点，如果失败则返回重试</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (!UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                          q, s))</span><br><span class="line">                        <span class="keyword">continue</span> retry;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> runnerOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waitersOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = FutureTask.class;</span><br><span class="line">            stateOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"state"</span>));</span><br><span class="line">            runnerOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"runner"</span>));</span><br><span class="line">            waitersOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"waiters"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池中的线程初始化"><a href="#线程池中的线程初始化" class="headerlink" title="线程池中的线程初始化"></a>线程池中的线程初始化</h2><p>　　默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：</p>
<ul>
<li>prestartCoreThread()：初始化一个核心线程；</li>
<li>prestartAllCoreThreads()：初始化所有核心线程</li>
</ul>
<h2 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h2><p>ThreadPoolExecutor提供了两个方法，用于线程池的关闭</p>
<ul>
<li>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li>
<li>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</li>
</ul>
<h2 id="线程池大小"><a href="#线程池大小" class="headerlink" title="线程池大小"></a>线程池大小</h2><ol>
<li>粗略<ol>
<li>如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1</li>
<li>如果是IO密集型任务，参考值可以设置为2*NCPU</li>
</ol>
</li>
<li>精确：（(线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目</li>
<li>最佳：压测</li>
</ol>
<h2 id="任务缓存队列"><a href="#任务缓存队列" class="headerlink" title="任务缓存队列"></a>任务缓存队列</h2><p><strong>workQueue</strong>，它用来存放等待执行的任务。BlockingQueue 是个接口，你需要使用它的实现之一来使用BlockingQueue，java.util.concurrent包下具有以下 BlockingQueue 接口的实现类：</p>
<ul>
<li>ArrayBlockingQueue：ArrayBlockingQueue 是一个有界的阻塞队列，其内部实现是将对象放到一个数组里。有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了(译者注：因为它是基于数组实现的，也就具有数组的特性：一旦初始化，大小就无法修改)。</li>
<li>LinkedBlockingQueue：LinkedBlockingQueue 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。</li>
<li>DelayQueue：DelayQueue 对元素进行持有直到一个特定的延迟到期。注入其中的元素必须实现 java.util.concurrent.Delayed 接口。</li>
<li>PriorityBlockingQueue：PriorityBlockingQueue 是一个无界的并发队列。它使用了和类 java.util.PriorityQueue 一样的排序规则。你无法向这个队列中插入 null 值。所有插入到 PriorityBlockingQueue 的元素必须实现 java.lang.Comparable 接口。因此该队列中元素的排序就取决于你自己的 Comparable 实现。</li>
<li>SynchronousQueue：SynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。</li>
</ul>
<h2 id="线程池总结"><a href="#线程池总结" class="headerlink" title="线程池总结"></a>线程池总结</h2><ol>
<li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</li>
<li>当调用 execute() 方法添加一个任务时，线程池会做如下判断：<ol>
<li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li>
<li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li>
<li>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li>
<li>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。</li>
<li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li>
<li>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>JAVA</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>《Mysql技术内幕》学习笔记-索引与算法</title>
    <url>/Mysql/Mysql05/</url>
    <content><![CDATA[<p>InnoDB存储引擎支持以下几种常见的索引：</p>
<p>B+树索引、全文索引、哈希索引</p>
<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>在介绍B+树前，需要先了解一下二叉查找树。B+树是通过二叉查找树，再由平衡二叉树，B树演化而来。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>左孩子比父节点小，右孩子比父节点大，中序遍历可以得到键值的排序输出。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p><img src="/Mysql/Mysql05/BST_insert.png" alt="BST_insert"></p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>单孩子的情况：如果删除的节点有左孩子那就把左孩子顶上去，如果有右孩子就把右孩子顶上去<br><img src="/Mysql/Mysql05/BST_delete1.png" alt="BST_delete"></p>
<p>左右都有孩子的情况：可以这么想象，如果我们要删除一个数组的元素，那么我们在删除后会将其后面的一个元素顶到被删除的位置。<br>二叉树操作同样，我们根据<code>中序遍历</code>找到要删除结点的后一个结点，然后顶上去，原理跟<code>数组</code>一样。<br><img src="/Mysql/Mysql05/BST_delete2.png" alt="BST_delete"></p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找的平均时间复杂度log(N)，在最坏的情况下会出现<code>链表</code>的形式，复杂度退化到O(N)。<br><img src="/Mysql/Mysql05/BST_linked.png" alt="BST_delete"></p>
<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>当二叉查找树以<code>完全二叉树</code>的形式展现，这样我才能做到查找是严格的O(logN)，</p>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>首先符合二叉查找树的定义，其次必须满足任何节点的两个子树的高度最大差为1。</p>
<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>节点再怎么失衡都逃不过4种情况</p>
<h3 id="左子树的左边节点"><a href="#左子树的左边节点" class="headerlink" title="左子树的左边节点"></a>左子树的左边节点</h3><p><img src="/Mysql/Mysql05/BBT1.png" alt="BBT1"></p>
<h3 id="右子树的右边节点"><a href="#右子树的右边节点" class="headerlink" title="右子树的右边节点"></a>右子树的右边节点</h3><p><img src="/Mysql/Mysql05/BBT2.png" alt="BBT2"></p>
<h3 id="左子树的右边节点"><a href="#左子树的右边节点" class="headerlink" title="左子树的右边节点"></a>左子树的右边节点</h3><p><img src="/Mysql/Mysql05/BBT3.png" alt="BBT3"><br>找到<code>失衡点</code>，失衡点的左子树进行<a href="#右子树的右边节点">右子树的右边节点</a>情况旋转，然后进行<a href="#左子树的左边节点">左子树的左边节点</a>旋转</p>
<h3 id="右子树的左边节点"><a href="#右子树的左边节点" class="headerlink" title="右子树的左边节点"></a>右子树的左边节点</h3><p><img src="/Mysql/Mysql05/BBT4.png" alt="BBT4"></p>
<h2 id="插入-amp-删除"><a href="#插入-amp-删除" class="headerlink" title="插入&amp;删除"></a>插入&amp;删除</h2><p>步骤同<a href="#二叉查找树">二叉查找树</a>，只是在插入或删除节点之后多了一步<a href="#旋转">旋转</a>的过程</p>
<h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1>]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>MySql</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-存储程序</title>
    <url>/Mysql/Mysql-storage/</url>
    <content><![CDATA[<p>MySQL中的存储程序本质上封装了一些可执行的语句，然后给用户提供一种简单的调用方式来执行这些语句，根据调用方式的不同，我们可以把<code>存储程序</code>分为<code>存储例程</code>、<code>触发器</code>和<code>事件</code>这几种类型。其中，<code>存储例程</code>又可以被细分为<code>存储函数</code>和<code>存储过程</code>。</p>
<a id="more"></a>
<p><img src="/Mysql/Mysql-storage/640.png" alt="存储程序"></p>
<h1 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h1><p>MySQL中对我们自定义的变量的命名有个要求，那就是变量名称前必须加一个<code>@符号</code>。我们自定义变量的值的类型可以是任意MySQL支持的类型，例如我们自定义一个变量<font color="red">a</font>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET @a = 1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>如果我们想查看这个变量的值的话，使用<font color="Orange">SELECT</font>语句就好了，不过仍然需要在变量名称加一个@符号：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT @a;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| @a   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|    1 |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>同一个变量也可以存储存储不同类型的值，比方说我们再把一个字符串值赋值给变量<font color="red">a</font>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET @a = '啦';</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT @a;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| @a   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| 啦   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>除了把一个常量赋值给一个变量以外，我们还可以把一个变量赋值给另一个变量：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET @b = @a;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT @b;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| @b   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| 啦   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>我们还可以将某个查询的结果赋值给一个变量，前提是这个<font color="red">查询的结果只有一个值</font>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET @a = (SELECT first_column FROM first_table LIMIT 1);</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>还可以用另一种形式的语句来将查询的结果赋值给一个变量：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT first_column FROM first_table LIMIT 1 INTO @b;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>我们查看一下这两个变量的值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT @a, @b;</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| @a   | @b   |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">|    1 |    1 |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>如果我们的查询结果是一条记录，该记录中有多个列的值的话，我们想把这几个值分别赋值到不同的变量中，只能使用<code>INTO</code>语句了：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT first_column, second_column FROM first_table LIMIT 1 INTO @a, @b;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT @a, @b;                                                           </span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| @a   | @b   |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">|    1 | aaa  |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h1 id="复合语句"><a href="#复合语句" class="headerlink" title="复合语句"></a>复合语句</h1><p>在MySQL客户端的交互界面处，当我们完成键盘输入并按下回车键时，MySQL客户端会检测我们输入的内容中是否包含<code>;</code>、<code>\g</code>或者<code>\G</code>这三个符号之一，如果有的话，会把我们输入的内容发送到服务器。这样一来，如果我们想给服务器发送复合语句（也就是由一条或多条语句组成的语句）的话，就需要把这些语句写到一行中，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT first_column FROM first_table ;SELECT second_column FROM first_table;</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| first_column |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">|            1 |</span><br><span class="line">|            2 |</span><br><span class="line">|         NULL |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line">| second_column |</span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line">| aaa           |</span><br><span class="line">| <span class="literal">NULL</span>          |</span><br><span class="line">| ccc           |</span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>我们也可以用<code>delimiter</code>命令来自定义MySQL的检测输入结束的符号，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; delimiter $</span><br><span class="line">mysql&gt; SELECT first_column FROM first_table ;</span><br><span class="line">    -&gt; SELECT second_column FROM first_table;</span><br><span class="line">    -&gt; $</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| first_column |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">|            1 |</span><br><span class="line">|            2 |</span><br><span class="line">|         NULL |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line">| second_column |</span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line">| aaa           |</span><br><span class="line">| <span class="literal">NULL</span>          |</span><br><span class="line">| ccc           |</span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p><code>delimiter $</code>命令意味着修改MySQL客户端检测输入结束的符号为<code>$</code>,也可以使用任何符号来作为MySQL客户端检测输入结束的符号，也包括多个字符，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; delimiter 666</span><br><span class="line">mysql&gt; SELECT first_column FROM first_table;</span><br><span class="line">    -&gt; SELECT second_column FROM first_table;</span><br><span class="line">    -&gt; 666</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| first_column |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">|            1 |</span><br><span class="line">|            2 |</span><br><span class="line">|         NULL |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line">| second_column |</span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line">| aaa           |</span><br><span class="line">| <span class="literal">NULL</span>          |</span><br><span class="line">| ccc           |</span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h1 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h1><h2 id="创建存储函数"><a href="#创建存储函数" class="headerlink" title="创建存储函数"></a>创建存储函数</h2><p><code>存储函数</code>其实就是一种<code>函数</code>，只不过在这个函数里可以执行命令语句而已。<br>MySQL中定义存储函数的语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 存储函数名称([参数列表])</span><br><span class="line"><span class="keyword">RETURNS</span> 返回值类型</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    函数体内容</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>举个🌰：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; delimiter $</span><br><span class="line">mysql&gt; CREATE FUNCTION second_column(a INT)</span><br><span class="line">    -&gt; RETURNS VARCHAR(100)</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; RETURN (SELECT second_column FROM first_table WHERE first_column = a);</span><br><span class="line">    -&gt; END $</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; delimiter ;</span><br></pre></td></tr></table></figure>

<h2 id="存储函数的调用"><a href="#存储函数的调用" class="headerlink" title="存储函数的调用"></a>存储函数的调用</h2><p>我们自定义的函数和系统内置函数的使用方式是一样的，都是在函数名后加小括号<code>()</code>表示函数调用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT second_column(1);</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| second_column(1) |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| aaa              |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h2 id="查看存储函数"><a href="#查看存储函数" class="headerlink" title="查看存储函数"></a>查看存储函数</h2><p>查看定义了多少个存储函数:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">FUNCTION</span> <span class="keyword">STATUS</span> [<span class="keyword">LIKE</span> 需要匹配的函数名]</span><br></pre></td></tr></table></figure>

<p>查看某个函数的具体定义:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 函数名</span><br></pre></td></tr></table></figure>

<h2 id="删除存储函数"><a href="#删除存储函数" class="headerlink" title="删除存储函数"></a>删除存储函数</h2><p>删除某个存储函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> 函数名</span><br></pre></td></tr></table></figure>

<h2 id="在函数体中定义变量"><a href="#在函数体中定义变量" class="headerlink" title="在函数体中定义变量"></a>在函数体中定义变量</h2><p>在函数体中使用变量前必须先声明这个变量，函数体中的变量名<code>不允许加@</code>前缀,声明方式如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 变量名 数据类型 [<span class="keyword">DEFAULT</span> 默认值];   </span><br><span class="line"></span><br><span class="line">mysql&gt; delimiter $</span><br><span class="line">mysql&gt; CREATE FUNCTION var_demo(a INT)</span><br><span class="line">    -&gt; RETURNS INT</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; DECLARE b INT;</span><br><span class="line">    -&gt; SET b = 5;</span><br><span class="line">    -&gt; RETURN b+a;</span><br><span class="line">    -&gt; END $</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; delimiter ;</span><br></pre></td></tr></table></figure>

<p>我们调用一下这个函数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT var_demo(2);</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| var_demo(2) |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">|           7 |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>如果不对声明的变量赋值，它的默认值就是NULL，也可以通过<code>DEFAULT</code>子句来显式的指定变量的默认值.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; delimiter $</span><br><span class="line">mysql&gt; CREATE FUNCTION var_default_demo()</span><br><span class="line">-&gt; RETURNS INT</span><br><span class="line">-&gt; BEGIN</span><br><span class="line">-&gt;     DECLARE c INT DEFAULT 1;</span><br><span class="line">-&gt;     RETURN c;</span><br><span class="line">-&gt; END $</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; delimiter ;</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT var_default_demo();</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| var_default_demo() |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">|                  1 |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h2 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h2><p>比如我们上边编写的这个second_column函数：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE FUNCTION second_column(a INT)</span><br><span class="line">    -&gt; RETURNS VARCHAR(100)</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; RETURN (SELECT second_column FROM first_table WHERE first_column = a);</span><br><span class="line">    -&gt; END $</span><br></pre></td></tr></table></figure>

<p>需要注意的是，参数名不要和函数体语句中其他的变量名、命令语句的标识符冲突。并且函数参数不可以指定默认值，我们在调用函数的时候，必须显式的指定所有的参数，参数类型也一定要匹配</p>
<h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p>语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">IF 布尔表达式 THEN </span><br><span class="line">    处理语句</span><br><span class="line">[ELSEIF 布尔表达式 THEN</span><br><span class="line">    处理语句]</span><br><span class="line">[ELSE </span><br><span class="line">    处理语句]    </span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br></pre></td></tr></table></figure>

<p>举个🌰：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; delimiter $</span><br><span class="line">mysql&gt; CREATE FUNCTION condition_demo(i INT)</span><br><span class="line">    -&gt; RETURNS VARCHAR(10)</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; DECLARE result VARCHAR(10);</span><br><span class="line">    -&gt; IF i = 1 THEN</span><br><span class="line">    -&gt; SET result = '结果是1';</span><br><span class="line">    -&gt; ELSEIF i = 2 THEN</span><br><span class="line">    -&gt;  SET result = '结果是2';</span><br><span class="line">    -&gt; ELSEIF i = 3 THEN</span><br><span class="line">    -&gt; SET result = '结果是3';</span><br><span class="line">    -&gt; ELSE</span><br><span class="line">    -&gt; SET result = '非法参数';</span><br><span class="line">    -&gt; END IF;</span><br><span class="line">    -&gt; RETURN result;</span><br><span class="line">    -&gt; END $</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; delimiter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT condition_demo(2);</span><br><span class="line">+<span class="comment">-------------------+</span></span><br><span class="line">| condition_demo(2) |</span><br><span class="line">+<span class="comment">-------------------+</span></span><br><span class="line">| 结果是2           |</span><br><span class="line">+<span class="comment">-------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p><code>while</code>循环语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">WHILE 布尔表达式 <span class="keyword">DO</span></span><br><span class="line">    循环语句</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br></pre></td></tr></table></figure>

<p>举个🌰：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; delimiter $</span><br><span class="line">mysql&gt; CREATE FUNCTION sum_all(n INT UNSIGNED)</span><br><span class="line">    -&gt; RETURNS INT</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; DECLARE result INT DEFAULT 0;</span><br><span class="line">    -&gt; DECLARE i INT DEFAULT 1;</span><br><span class="line">    -&gt; WHILE i &lt;= n DO</span><br><span class="line">    -&gt; SET result = result + i;</span><br><span class="line">    -&gt; SET i = i + 1;</span><br><span class="line">    -&gt; END WHILE;</span><br><span class="line">    -&gt; RETURN result;</span><br><span class="line">    -&gt; END $</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; delimiter;</span><br><span class="line"></span><br><span class="line">mysql&gt; select sum_all(10);</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| sum_all(10) |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">|          55 |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p><code>REPEAT</code>循环语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REPEAT</span><br><span class="line">    循环语句</span><br><span class="line">UNTIL 布尔表达式 <span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br></pre></td></tr></table></figure>

<p>举个🌰：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE FUNCTION sum_repeat(n INT UNSIGNED)</span><br><span class="line">    -&gt; RETURNS INT</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; DECLARE result INT DEFAULT 0;</span><br><span class="line">    -&gt; DECLARE i INT DEFAULT 1;</span><br><span class="line">    -&gt; REPEAT</span><br><span class="line">    -&gt; -- 循环开始</span><br><span class="line">    -&gt; SET result = result + i;</span><br><span class="line">    -&gt; SET i = i + 1;</span><br><span class="line">    -&gt; UNTIL i &gt; n END REPEAT;</span><br><span class="line">    -&gt; RETURN result;</span><br><span class="line">    -&gt; END $</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select sum_repeat(5);</span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line">| sum_repeat(5) |</span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line">|            15 |</span><br><span class="line">+<span class="comment">---------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p><code>LOOP</code>循环语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">循环标记:LOOP</span><br><span class="line">    循环语句</span><br><span class="line">    LEAVE 循环标记;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span> 循环标记;</span><br></pre></td></tr></table></figure>

<p>举个🌰：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE FUNCTION sum_loop(n INT UNSIGNED)</span><br><span class="line">    -&gt; RETURNS INT</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; DECLARE result INT DEFAULT 0;</span><br><span class="line">    -&gt; DECLARE i INT DEFAULT 1;</span><br><span class="line">    -&gt; LOOP_NAME:LOOP -- 循环开始</span><br><span class="line">    -&gt; IF i &gt; n THEN</span><br><span class="line">    -&gt; LEAVE LOOP_NAME;</span><br><span class="line">    -&gt; END IF;</span><br><span class="line">    -&gt; SET result = result + i;</span><br><span class="line">    -&gt; SET i = i + 1;</span><br><span class="line">    -&gt; END LOOP LOOP_NAME;</span><br><span class="line">    -&gt; RETURN result;</span><br><span class="line">    -&gt; END $</span><br><span class="line">    </span><br><span class="line">mysql&gt; select sum_loop(10);</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| sum_loop(10) |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">|           55 |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>存储函数侧重于执行语句并返回一个值，而存储过程更侧重于单纯的去执行语句。</p>
<h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称([参数列表])</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    需要执行的语句</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>举个🌰：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE PROCEDURE insert_first_table(c1 INT,c2 VARCHAR(100))</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; SELECT * FROM first_table;</span><br><span class="line">    -&gt; INSERT INTO first_table(first_column,second_column) VALUES(c1,c2);</span><br><span class="line">    -&gt; SELECT * FROM first_table;</span><br><span class="line">    -&gt; END $</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure>

<h2 id="存储过程的调用"><a href="#存储过程的调用" class="headerlink" title="存储过程的调用"></a>存储过程的调用</h2><p>存储函数执行语句并返回一个值，所以常用在表达式中。<br>存储过程偏向于调用那些语句，并不能用在表达式中。<br>我们需要显式的使用CALL语句来调用一个存储过程：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> 存储过程([参数列表]);</span><br></pre></td></tr></table></figure>

<p>举个🌰：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CALL insert_first_table(4,'test');</span><br><span class="line"> </span><br><span class="line">+<span class="comment">--------------+---------------+</span></span><br><span class="line">| first_column | second_column |</span><br><span class="line">+<span class="comment">--------------+---------------+</span></span><br><span class="line">|            1 | aaa           |</span><br><span class="line">|            2 | NULL          |</span><br><span class="line">|         NULL | ccc           |</span><br><span class="line">+<span class="comment">--------------+---------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+<span class="comment">--------------+---------------+</span></span><br><span class="line">| first_column | second_column |</span><br><span class="line">+<span class="comment">--------------+---------------+</span></span><br><span class="line">|            <span class="number">1</span> | aaa           |</span><br><span class="line">|            <span class="number">2</span> | <span class="literal">NULL</span>          |</span><br><span class="line">|         <span class="literal">NULL</span> | ccc           |</span><br><span class="line">|            <span class="number">4</span> | <span class="keyword">test</span>          |</span><br><span class="line">+<span class="comment">--------------+---------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h2 id="查看存储过程"><a href="#查看存储过程" class="headerlink" title="查看存储过程"></a>查看存储过程</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查看当前数据库中创建的存储过程都有哪些的语句：</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCEDURE</span> <span class="keyword">STATUS</span> [<span class="keyword">LIKE</span> 需要匹配的函数名]</span><br><span class="line"></span><br><span class="line">查看某个存储过程定义的语句：</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称</span><br></pre></td></tr></table></figure>

<h2 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h2><p>删除某个存储过程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> 存储过程名称</span><br></pre></td></tr></table></figure>

<h2 id="存储过程参数类型"><a href="#存储过程参数类型" class="headerlink" title="存储过程参数类型"></a>存储过程参数类型</h2><table>
<tr>
    <th>参数类型</th>
    <th>实际参数是否必须是变量</th>
    <th colspan="3">作用</th>
</tr>
<tr>
    <td style="text-align:center">IN</td>
    <td style="text-align:center">否</td>
    <td colspan="3">用于调用者向过程传递数据，如果该参数在过程中被修改，调用者不可见</td>
</tr>
<tr>
    <td style="text-align:center">OUT</td>
    <td style="text-align:center">是</td>
    <td colspan="3">用于把过程产生的结果放到此参数中，过程结束后调用者可以通过该参数来获取过程执行的结果</td>
</tr>
<tr>
    <td style="text-align:center">INOUT</td>
    <td style="text-align:center">是</td>
    <td colspan="3">综合IN和OUT特点，即可用于调用者向过程传递数据，也可用于存放过程中产生的结果</td>
</tr>
</table>  

<h3 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE PROCEDURE test_in(IN num INT)</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; SELECT num;</span><br><span class="line">    -&gt; SET num = 666;</span><br><span class="line">    -&gt; END $</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SET @a = 111;</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; CALL test_in(@a);</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| num  |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|  111 |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Query</span> OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>IN参数类型的变量只能用于读取，对类型的变量赋值是不会被调用者看到的。<br>如果我们不写明参数类型的话，该参数的类型默认是IN。</p>
<h3 id="OUT"><a href="#OUT" class="headerlink" title="OUT"></a>OUT</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE PROCEDURE test_out(OUT num INT)</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; SELECT num;</span><br><span class="line">    -&gt; SET num = 666;</span><br><span class="line">    -&gt; END $</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; CALL test_out(@a);</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| num  |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| NULL |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Query</span> OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> @a;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| @a   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|  666 |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>OUT参数类型的变量只能用于赋值，对类型的变量赋值是会被调用者看到的,因此参数就不允许是常量。</p>
<p>存储过程中向调用者返回多个值，举个例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE PROCEDURE data_out(OUT a INT,OUT b INT)</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; SET a = 100;</span><br><span class="line">    -&gt; SET b = 200;</span><br><span class="line">    -&gt; END $</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; CALL data_out(@a,@b);</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @a,@b;</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| @a   | @b   |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">|  100 |  200 |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="INOUT"><a href="#INOUT" class="headerlink" title="INOUT"></a>INOUT</h3><p>这种类型的参数既可以在存储过程中被读取，也可以被赋值后被调用者看到，因此参数就不允许是常量。</p>
<h2 id="存储过程和函数的区别"><a href="#存储过程和函数的区别" class="headerlink" title="存储过程和函数的区别"></a>存储过程和函数的区别</h2><ul>
<li><p>存储函数在定义时需要显式用RETURNS语句标明返回的数据类型，而且在函数体中必须使用RETURN语句来显式指定返回的值，存储过程不需要。</p>
</li>
<li><p>存储函数的参数类型只能是IN，而存储过程支持IN、OUT、INOUT三种参数类型。</p>
</li>
<li><p>存储函数只能返回一个值，而存储过程可以通过设置多个OUT类型的参数来返回多个结果。</p>
</li>
<li><p>存储函数执行过程中产生的结果集并不会被显示到客户端，而存储过程执行过程中产生的结果集会被显示到客户端。</p>
</li>
<li><p>存储函数的调用直接使用在表达式中，而存储过程只能通过CALL语句来显式调用。</p>
</li>
</ul>
<h1 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h1><p>游标（Cursor）是处理数据的一种方法，为了查看或者处理结果集中的数据，游标提供了在结果集中一次一行或者多行前进或向后浏览数据的能力。<br>初始状态下它标记查询结果集中的第一条记录,根据这个游标取出它对应记录的信息，随后再移动游标，让它指向别的记录。</p>
<h2 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 游标名称 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> 查询语句;</span><br></pre></td></tr></table></figure>

<p>举个🌰：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE PROCEDURE cursor_demo()</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; DECLARE first_table_cursor CURSOR FOR select * from first_table;</span><br><span class="line">    -&gt; END $</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>

<h2 id="打开和关闭游标"><a href="#打开和关闭游标" class="headerlink" title="打开和关闭游标"></a>打开和关闭游标</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">OPEN 游标名称;</span><br><span class="line"></span><br><span class="line">CLOSE 游标名称;</span><br></pre></td></tr></table></figure>

<p>打开游标意味着执行查询语句，让创建好的游标与该查询语句得到的结果集关联起来，关闭游标意味着会释放该游标占用的内存，所以一旦我们使用完了游标，就要把它关闭掉。</p>
<h2 id="游标获取记录"><a href="#游标获取记录" class="headerlink" title="游标获取记录"></a>游标获取记录</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">FETCH 游标名 INTO 变量1, 变量2, ... 变量n</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE PROCEDURE cursor_demo()</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; DECLARE c1 INT;</span><br><span class="line">    -&gt; DECLARE c2 VARCHAR(100);</span><br><span class="line">    -&gt; DECLARE record_count INT;</span><br><span class="line">    -&gt; DECLARE i INT DEFAULT 0;</span><br><span class="line">    -&gt;  -- 声明游标</span><br><span class="line">    -&gt; DECLARE first_table_cursor CURSOR FOR select * from first_table;</span><br><span class="line">    -&gt;</span><br><span class="line">    -&gt; -- 统计表行数</span><br><span class="line">    -&gt; SELECT COUNT(*) FROM first_table INTO record_count;</span><br><span class="line">    -&gt;</span><br><span class="line">    -&gt; -- 使用游标遍历</span><br><span class="line">    -&gt; OPEN first_table_cursor;</span><br><span class="line">    -&gt;</span><br><span class="line">    -&gt; WHILE i &lt; record_count DO</span><br><span class="line">    -&gt; FETCH first_table_cursor INTO c1 , c2;</span><br><span class="line">    -&gt; SELECT c1,c2;</span><br><span class="line">    -&gt; SET i = i + 1;</span><br><span class="line">    -&gt; END WHILE;</span><br><span class="line">    -&gt; CLOSE first_table_cursor;</span><br><span class="line">    -&gt; END $</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; CALL cursor_demo();</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| c1   | c2   |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">|    1 | aaa  |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| c1   | c2   |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">|    <span class="number">2</span> | <span class="literal">NULL</span> |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| c1   | c2   |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| <span class="literal">NULL</span> | ccc  |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| c1   | c2   |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">|    <span class="number">4</span> | <span class="keyword">test</span> |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Query</span> OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>i表示当前游标对应的记录位置。每调用一次 FETCH 语句，游标就移动到下一条记录的位置。</p>
<h2 id="遍历结束的执行策略"><a href="#遍历结束的执行策略" class="headerlink" title="遍历结束的执行策略"></a>遍历结束的执行策略</h2><p>其实在FETCH语句获取不到记录的时候会触发一个事件，从而我们可以得知所有的记录都被获取过了，然后我们就可以去主动的停止循环。<br>MySQL中响应这个事件的语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">NOT</span> <span class="keyword">FOUND</span> 语句;</span><br></pre></td></tr></table></figure>

<p>举个🌰，再来改写一下cursor_demo存储过程：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; delimiter $</span><br><span class="line">mysql&gt; CREATE PROCEDURE cursor_demo()</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; -- 声明变量</span><br><span class="line">    -&gt; DECLARE c1 INT;</span><br><span class="line">    -&gt; DECLARE c2 VARCHAR(100);</span><br><span class="line">    -&gt; DECLARE not_done INT DEFAULT 1;</span><br><span class="line">    -&gt;</span><br><span class="line">    -&gt; -- 声明游标</span><br><span class="line">    -&gt; DECLARE first_table_cursor CURSOR FOR select * from first_table;</span><br><span class="line">    -&gt;</span><br><span class="line">    -&gt; -- 在游标遍历完记录的时候将变量 not_done 的值设置为 0，并且继续执行后边的语句</span><br><span class="line">    -&gt; DECLARE CONTINUE HANDLER FOR NOT FOUND SET not_done = 0;</span><br><span class="line">    -&gt;</span><br><span class="line">    -&gt; -- 使用游标遍历</span><br><span class="line">    -&gt; OPEN first_table_cursor;</span><br><span class="line">    -&gt;</span><br><span class="line">    -&gt; WHILE not_done = 1 DO</span><br><span class="line">    -&gt;</span><br><span class="line">    -&gt; FETCH first_table_cursor INTO c1 , c2;</span><br><span class="line">    -&gt; SELECT c1,c2;</span><br><span class="line">    -&gt; END WHILE;</span><br><span class="line">    -&gt; CLOSE first_table_cursor;</span><br><span class="line">    -&gt; END $</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;  CALL cursor_demo();</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| c1   | c2   |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">|    1 | aaa  |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| c1   | c2   |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">|    <span class="number">2</span> | <span class="literal">NULL</span> |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| c1   | c2   |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| <span class="literal">NULL</span> | ccc  |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| c1   | c2   |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">|    <span class="number">4</span> | <span class="keyword">test</span> |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| c1   | c2   |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">|    <span class="number">4</span> | <span class="keyword">test</span> |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Query</span> OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>我们发现结果集中最后一条记录输出两遍怎么办呢，我们可以使用<code>EXIT</code>来替代上边的<code>CONTINUE</code>：<br><code>CONTINUE</code>表示在FETCH语句获取不到记录的时候仍然会执行之后存储过程的语句，也就是会将最后一次关联的记录中的值放入指定的变量<br><code>EXIT</code>表示在FETCH语句获取不到记录的时候仍然不会执行之后存储过程的语句</p>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>存储函数与存储过程都是需要我们<code>手动</code>调用的，如果想在执行某条语句之前或者之后自动去调用另外一些语句，就需要用到触发器。</p>
<h2 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h2><p>触发器的定义：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名</span><br><span class="line">&#123;<span class="keyword">BEFORE</span>|<span class="keyword">AFTER</span>&#125;          </span><br><span class="line">&#123;<span class="keyword">INSERT</span>|<span class="keyword">DELETE</span>|<span class="keyword">UPDATE</span>&#125;</span><br><span class="line"><span class="keyword">ON</span> 表名</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    触发器内容</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>MySQL中目前只支持对INSERT、DELETE、UPDATE这三种类型的语句设置触发器。</p>
<p>因为触发器会对某个语句影响的所有记录依次调用我们自定义的触发器内容，所以我们需要一种访问该记录中的内容的方式，<br>MySQL提供了NEW和OLD两个单词来分别代表新记录和旧记录，它们在不同操作中的含义不同：</p>
<ul>
<li>对于INSERT语句设置的触发器来说，NEW代表准备插入的记录，不能使用OLD。</li>
<li>对于DELETE语句设置的触发器来说，OLD代表删除前的记录，不能使用NEW。</li>
<li>对于UPDATE语句设置的触发器来说，NEW代表修改后的记录，OLD代表修改前的记录。</li>
</ul>
<p>举个🌰：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TRIGGER test_trigger</span><br><span class="line">    -&gt; BEFORE INSERT ON first_table</span><br><span class="line">    -&gt; FOR EACH ROW</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; IF NEW.first_column &lt; 1 THEN</span><br><span class="line">    -&gt;  SET NEW.first_column = 1;</span><br><span class="line">    -&gt; ELSEIF NEW.first_column &gt; 10 THEN</span><br><span class="line">    -&gt;  SET NEW.first_column = 10;</span><br><span class="line">    -&gt; END IF;</span><br><span class="line">    -&gt; END $</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from first_table;</span><br><span class="line">+<span class="comment">--------------+---------------+</span></span><br><span class="line">| first_column | second_column |</span><br><span class="line">+<span class="comment">--------------+---------------+</span></span><br><span class="line">|            1 | aaa           |</span><br><span class="line">|            2 | NULL          |</span><br><span class="line">|         NULL | ccc           |</span><br><span class="line">|            4 | test          |</span><br><span class="line">+<span class="comment">--------------+---------------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> first_table(first_column,second_column) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="string">'5'</span>),(<span class="number">20</span>,<span class="string">'20'</span>);</span><br><span class="line">Query OK, 2 rows affected (0.01 sec)</span><br><span class="line">Records: 2  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; select * from first_table;</span><br><span class="line">+<span class="comment">--------------+---------------+</span></span><br><span class="line">| first_column | second_column |</span><br><span class="line">+<span class="comment">--------------+---------------+</span></span><br><span class="line">|            1 | aaa           |</span><br><span class="line">|            2 | NULL          |</span><br><span class="line">|         NULL | ccc           |</span><br><span class="line">|            4 | test          |</span><br><span class="line">|            5 | 5             |</span><br><span class="line">|           10 | 20            |</span><br><span class="line">+<span class="comment">--------------+---------------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>(20,’20’)的插入结果变成了(10,’20’)说明触发器生效了。</p>
<h2 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查看当前数据库中的所有触发器的语句：</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TRIGGERS</span>;</span><br><span class="line"></span><br><span class="line">查看某个具体的触发器的定义：</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名;</span><br></pre></td></tr></table></figure>

<h2 id="删除触发器："><a href="#删除触发器：" class="headerlink" title="删除触发器："></a>删除触发器：</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> 触发器名;</span><br></pre></td></tr></table></figure>

<h2 id="触发器使用注意事项"><a href="#触发器使用注意事项" class="headerlink" title="触发器使用注意事项"></a>触发器使用注意事项</h2><ol>
<li>触发器内容中不能有输出结果集的语句。</li>
<li>一个表最多只能定义6个触发器分别是：<ul>
<li>BEFORE INSERT触发器</li>
<li>BEFORE DELETE触发器</li>
<li>BEFORE UPDATE触发器</li>
<li>AFTER INSERT触发器</li>
<li>AFTER DELETE触发器</li>
<li>AFTER UPDATE触发器</li>
</ul>
</li>
<li>NEW中的值可以被更改，OLD中的值无法更改。</li>
<li>如果我们的<code>BEFORE</code>触发器内容执行过程中遇到了<code>ERROR</code>，那这个触发器对应的具体语句将无法执行；如果具体的操作语句执行过程中遇到了<code>ERROR</code>，那与它对应的<code>AFTER</code>触发器的内容将无法执行。</li>
</ol>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>如果我们想指定某些语句在某个时间点或者每隔一个时间段执行一次的话,就需要创建一个事件。</p>
<h2 id="创建事件"><a href="#创建事件" class="headerlink" title="创建事件"></a>创建事件</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EVENT</span> 事件名</span><br><span class="line"><span class="keyword">ON</span> SCHEDULE</span><br><span class="line">&#123;<span class="keyword">AT</span> 某个确定的时间点 | EVERY 期望的时间间隔 [STARTS datetime][<span class="keyword">END</span> datetime]&#125;</span><br><span class="line"><span class="keyword">DO</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    具体的语句</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>事件支持两种类型的定时执行：</p>
<ol>
<li><p>某个确定的时间点执行</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE EVENT insert_first_table</span><br><span class="line">    -&gt; ON SCHEDULE</span><br><span class="line">    -&gt; AT '2019-09-10 11:30:30'</span><br><span class="line">    -&gt; DO</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; INSERT INTO first_table(first_column,second_column) VALUES(6,'6');</span><br><span class="line">    -&gt; END $</span><br></pre></td></tr></table></figure>

<p> 除了直接填某个时间常量，也可以填写一些表达式：</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE EVENT insert_first_table</span><br><span class="line">    -&gt; ON SCHEDULE</span><br><span class="line">    -&gt; AT DATE_ADD(NOW(), INTERVAL 2 DAY)</span><br><span class="line">    -&gt; DO</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; INSERT INTO first_table(first_column,second_column) VALUES(6,'6');</span><br><span class="line">    -&gt; END $</span><br></pre></td></tr></table></figure>

<p> DATE_ADD(NOW(), INTERVAL 2 DAY)表示该事件将在当前时间的两天后执行。</p>
</li>
<li><p>每隔一段时间执行一次</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE EVENT insert_first_table</span><br><span class="line">    -&gt; ON SCHEDULE</span><br><span class="line">    -&gt; EVERY 1 HOUR </span><br><span class="line">    -&gt; DO</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; INSERT INTO first_table(first_column,second_column) VALUES(6,'6');</span><br><span class="line">    -&gt; END $</span><br></pre></td></tr></table></figure>

<p> 默认情况下，采用这种每隔一段时间执行一次的方式将从创建事件的事件开始，无限制的执行下去。我们也可以指定该事件开始执行时间和截止时间：</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE EVENT insert_first_table</span><br><span class="line">    -&gt; ON SCHEDULE</span><br><span class="line">    -&gt; EVERY 1 HOUR STARTS '2019-09-10 11:30:30' ENDS '2019-09-12 11:30:30'</span><br><span class="line">    -&gt; DO</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; INSERT INTO first_table(first_column,second_column) VALUES(6,'6');</span><br><span class="line">    -&gt; END $</span><br></pre></td></tr></table></figure>

<p> 在创建好事件之后我们就不用管了，到了指定时间，MySQL服务器会帮我们自动执行的。</p>
</li>
</ol>
<h2 id="查看事件"><a href="#查看事件" class="headerlink" title="查看事件"></a>查看事件</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查看当前数据库中的所有事件的语句：</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">EVENTS</span>;</span><br><span class="line"></span><br><span class="line">查看某个具体的事件的定义:</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">EVENT</span> 事件名;</span><br></pre></td></tr></table></figure>

<h2 id="删除事件"><a href="#删除事件" class="headerlink" title="删除事件"></a>删除事件</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">EVENT</span> 事件名;</span><br></pre></td></tr></table></figure>

<h2 id="事件使用注意事项"><a href="#事件使用注意事项" class="headerlink" title="事件使用注意事项"></a>事件使用注意事项</h2><p>默认情况下，MySQL服务器并不会帮助我们执行事件，除非我们在启动服务器的时候就指定了下边这个选项：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">event_scheduler = ON</span><br></pre></td></tr></table></figure>

<p>如果在服务器已经启动的情况下，我们可以通过设置<code>event_scheduler</code>的系统变量来让MySQL服务器帮助我们执行事件，设置方式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL event_scheduler = ON;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<h1 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h1><p>在MySql中创建自定义函数报错信息如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; set global log_bin_trust_function_creators=1;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>《Mysql技术内幕》学习笔记-Mysql文件</title>
    <url>/Mysql/Mysql03/</url>
    <content><![CDATA[<h1 id="文件种类"><a href="#文件种类" class="headerlink" title="文件种类"></a>文件种类</h1><ul>
<li><p><a href="#参数文件">参数文件</a>：告诉MySQL实例启动时在哪里可以找到数据库文件，并且指定某些初始化参数，这些参数定义了某种内存结构的大小等设置，还会介绍各种参数的类型。</p>
</li>
<li><p><a href="#日志文件">日志文件</a>：用来记录MySQL实例对某种条件做出响应时写入的文件，如错误日志文件、二进制日志文件、慢查询日志文件、查询日志文件等。</p>
</li>
<li><p><a href="#套接字文件">socket文件</a>：当用UNIX域套接字方式进行连接时需要的文件。</p>
</li>
<li><p><a href="#pid文件">pid文件</a>：MySQL实例的进程ID文件。</p>
</li>
<li><p><a href="#表结构定义文件">MySQL表结构文件</a>：用来存放MySQL表结构定义文件。</p>
</li>
<li><p><a href="#innoDB存储引擎文件">存储引擎文件</a>：因为MySQL表存储引擎的关系，每个存储引擎都会有自己的文件来保存各种数据。这些存储引擎真正存储了记录和索引等数据。本章主要介绍与InnoDB有关的存储引擎文件。”</p>
</li>
</ul>
<h1 id="参数文件"><a href="#参数文件" class="headerlink" title="参数文件"></a>参数文件</h1><p>参数分为两类：</p>
<ul>
<li>动态参数：在 Mysql 实例运行中可以进行更改</li>
<li>静态参数：在整个实例生命周期内都不得更改</li>
</ul>
<p>更改动态参数的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span></span><br><span class="line">| [<span class="keyword">global</span> | <span class="keyword">session</span>] system_var_name=expr</span><br><span class="line">| [@@global. | @@session. | @@] system_var_name = expr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变当前会话，不会改变全局</span></span><br><span class="line"><span class="keyword">SET</span> read_buffer_size = <span class="number">524288</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变全局会话参数，不会改变当前</span></span><br><span class="line"><span class="keyword">SET</span> @@global.read_buffer_size = <span class="number">1048576</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询当前会话参数</span></span><br><span class="line"><span class="keyword">SELECT</span> @@session.read_buffer_size;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询全局会话参数</span></span><br><span class="line"><span class="keyword">SELECT</span> @@global.read_buffer_size;</span><br></pre></td></tr></table></figure>

<p><code>​global</code>：全局的，<code>session</code>：当前会话。<br>这种修改，并不最终修改配置文件my.cnf的参数值，所以重新启动后，参数还是按照配置文件中的加载。</p>
<h1 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h1><p>MySQL中常见的日志文件有：</p>
<ul>
<li>错误日志（error log）：对MySQL的启动、运行、关闭过程进行记录错误信息、警告信息。</li>
<li>慢查询日志（slow query log）</li>
<li>二进制日志（bin log）</li>
<li>查询日志（log）</li>
</ul>
<h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>在MySQL启动时设一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询日志文件中。</p>
<table>
     <tr>
         <th colspan="4">参数</th>
         <th colspan="4">作用</th>
     </tr>
     <tr>
         <th colspan="4">set global log_slow_queries = on;</th>
         <td colspan="4">开启慢查询命令，默认启动慢查询</td>
     </tr>
     <tr>
         <th colspan="4">set global long_query_time = 1;</th>
         <td colspan="4">设置慢查询时间超过1s即被认为慢查询，默认10s</td>
     </tr>
     <tr>
         <th colspan="4">set global log_queries_not_using_indeces = on;</th>
         <td colspan="4">如果SQL语句没有使用索引，会记录到慢查询中</td>
     </tr>
     <tr>
         <th colspan="4">set global log_throttle_queries_not_using_indexs = on;</th>
         <td colspan="4">设置每分钟允许记录到slow log的且未使用索引的SQL语句次数，默认为0，表示没有限制。</td>
     </tr>
</table> 

<h1 id="套接字文件"><a href="#套接字文件" class="headerlink" title="套接字文件"></a>套接字文件</h1><h1 id="pid文件"><a href="#pid文件" class="headerlink" title="pid文件"></a>pid文件</h1><h1 id="表结构定义文件"><a href="#表结构定义文件" class="headerlink" title="表结构定义文件"></a>表结构定义文件</h1><h1 id="innoDB存储引擎文件"><a href="#innoDB存储引擎文件" class="headerlink" title="innoDB存储引擎文件"></a>innoDB存储引擎文件</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>MySQL技术内幕：InnoDB存储引擎(第2版)</li>
<li><a href="https://www.jianshu.com/p/c1ffd6956e6a" target="_blank" rel="noopener">https://www.jianshu.com/p/c1ffd6956e6a</a></li>
<li><a href="https://www.cnblogs.com/BlueMountain-HaggenDazs/p/9297883.html" target="_blank" rel="noopener">https://www.cnblogs.com/BlueMountain-HaggenDazs/p/9297883.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>MySql</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>《Mysql技术内幕》学习笔记-LSN</title>
    <url>/Mysql/Mysql-LSN/</url>
    <content><![CDATA[<p>LSN(log sequence number)——日志序列号：递增产生，表示事务写入重做日志的字节总量，占用8个字节。</p>
<h1 id="LSN存在什么地方？有什么含义？"><a href="#LSN存在什么地方？有什么含义？" class="headerlink" title="LSN存在什么地方？有什么含义？"></a>LSN存在什么地方？有什么含义？</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 15151135824   -- redo <span class="built_in">log</span> buffer 的 lsn，存放在redo <span class="built_in">log</span> buffer 中称： redo_mem_lsn</span><br><span class="line">Log flushed up to   15151135824   -- redo <span class="built_in">log</span> file 的 lsn，存放在redo <span class="built_in">log</span> 中称： redo_log_lsn</span><br><span class="line">Pages flushed up to 15151135824   -- 最后一个刷到磁盘上的页的最新的 lsn  </span><br><span class="line">Last checkpoint at  15151135815   -- 共享表空间上的日志记录点，最后一次检查点，及崩溃恢复时指定的起点 , checkpoint 所在的 lsn, 存放在redo <span class="built_in">log</span>第一个文件的头部，称： cp_lsn</span><br></pre></td></tr></table></figure>

<p><img src="/Mysql/Mysql-LSN/LOG.png" alt="log"></p>
<h1 id="LSN-有什么用？"><a href="#LSN-有什么用？" class="headerlink" title="LSN 有什么用？"></a>LSN 有什么用？</h1><p>主要用于MySQL重启恢复  </p>
<h1 id="恢复的算法"><a href="#恢复的算法" class="headerlink" title="恢复的算法"></a>恢复的算法</h1><p>假设： redo_log_lsn = 15000 , cp_lsn=10000 , 这时候MySQL crash了，重启后的恢复流程如下：</p>
<ol>
<li>cp_lsn = 10000 之前的redo 日志，不需要恢复： 因为checkpoint之前的日志已经可以确保刷新完毕  </li>
<li>那么 10000 &lt;=  redo_log_LSN &lt;= 15000 的日志需要结合page_lsn判断，哪些需要重做，哪些不需要重做。  <ul>
<li>redo_log_LSN 日志里面记录的page 操作，如果redo_log_LSN &lt;= page_lsn   , 这些日志不需要重做，因为page已经是最新的  </li>
<li>redo_log_LSN 日志里面记录的page 操作, 如果redo_log_LSN &gt;= page_lsn   , 这些日志是需要应用到page 里面去的，这一系列操作我们称为恢复. </li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>《Mysql技术内幕》学习笔记-Redo与Undo</title>
    <url>/Mysql/Mysql-RedoAndUndo/</url>
    <content><![CDATA[<h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h1><h2 id="redo-概念"><a href="#redo-概念" class="headerlink" title="redo 概念"></a>redo 概念</h2><p>重做日志(redo log)：在InnoDB存储引擎中，大部分情况下 Redo 是<code>物理日志</code>，记录的是数据页的物理变化。</p>
<h2 id="redo-结构"><a href="#redo-结构" class="headerlink" title="redo 结构"></a>redo 结构</h2><p>Redo log可以简单分为以下两个部分：</p>
<a id="more"></a>
<ol>
<li>重做日志缓冲 (redo log buffer),是易失的，在内存中<ul>
<li>日志会先写到redo log buffer ，根据制定条件刷新到redo log file</li>
<li>由log block组成  </li>
<li>每个log block 512字节，所以不需要 <a href="http://123.56.47.170:8080/2019/07/31/Mysql02/#%E4%B8%A4%E6%AC%A1%E5%86%99" target="_blank" rel="noopener">double write</a>，因为每次刷新都是原子的  </li>
</ul>
</li>
<li>重做日志文件 (redo log file)，是持久的，保存在磁盘中    <ul>
<li>redo log的物理文件，一般有2个,大小可配置  </li>
</ul>
</li>
</ol>
<h2 id="redo-写入时机"><a href="#redo-写入时机" class="headerlink" title="redo 写入时机"></a>redo 写入时机</h2><ul>
<li>在数据页修改完成之后，在脏页刷出磁盘之前，写入redo日志。注意的是<strong>先修改数据，后写日志</strong></li>
<li>redo日志比数据页先写回磁盘</li>
<li>聚集索引、非聚集索引、undo页面的修改，均需要记录Redo日志。</li>
</ul>
<h2 id="redo-的整体流程"><a href="#redo-的整体流程" class="headerlink" title="redo 的整体流程"></a>redo 的整体流程</h2><p><img src="/Mysql/Mysql-RedoAndUndo/redo-buffer.png" alt="redo"></p>
<h2 id="redo如何保证事务的持久性？"><a href="#redo如何保证事务的持久性？" class="headerlink" title="redo如何保证事务的持久性？"></a>redo如何保证事务的持久性？</h2><p>InnoDB 通过 <strong>Force Log at Commit</strong> 机制实现事务的持久性，即当事务提交时，先将 redo log buffer 写入到 redo log file 进行持久化，待事务的commit操作完成时才算完成。<br>这种做法也被称为 <strong>Write-Ahead Log</strong>(预先日志持久化)，在持久化一个数据页之前，先将内存中相应的日志页持久化。</p>
<p>为了保证每次日志都写入redo log file，在每次将redo buffer写入redo log file之后，默认情况下，InnoDB存储引擎都需要调用一次 fsync操作,因为重做日志打开并没有 O_DIRECT选项，所以重做日志先写入到文件系统缓存。为了确保重做日志写入到磁盘，必须进行一次 fsync操作。fsync操作 将数据提交到硬盘中，强制硬盘同步，将一直阻塞到写入硬盘完成后返回，大量进行fsync操作就有性能瓶颈，因此磁盘的性能也影响了事务提交的性能，也就是数据库的性能。<br>(O_DIRECT选项是在Linux系统中的选项，使用该选项后，对文件进行直接IO操作，不经过文件系统缓存，直接写入磁盘)</p>
<h1 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h1><h2 id="undo-概念"><a href="#undo-概念" class="headerlink" title="undo 概念"></a>undo 概念</h2><p>undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。</p>
<h2 id="undo-结构"><a href="#undo-结构" class="headerlink" title="undo 结构"></a>undo 结构</h2><p>在InnoDB存储引擎中，undo存储在回滚段(Rollback Segment)中,每个回滚段记录了1024个undo log segment，而在每个undo log segment段中进行undo 页的申请，在5.6以前，Rollback Segment是在共享表空间里的，5.6.3之后，可通过 innodb_undo_tablespace设置undo存储的位置。</p>
<h2 id="undo-写入时机"><a href="#undo-写入时机" class="headerlink" title="undo 写入时机"></a>undo 写入时机</h2><ul>
<li>DML操作修改聚集索引前，记录undo日志</li>
<li>非聚集索引记录的修改，<strong>不</strong>记录undo日志</li>
</ul>
<h2 id="undo-的整体流程"><a href="#undo-的整体流程" class="headerlink" title="undo 的整体流程"></a>undo 的整体流程</h2><p><img src="/Mysql/Mysql-RedoAndUndo/undo-Segment.png" alt="undo"><br>undo log 采用顺序IO写入磁盘共享表空间。</p>
<h2 id="undo-类型"><a href="#undo-类型" class="headerlink" title="undo 类型"></a>undo 类型</h2><ul>
<li>insert undo log：在insert 操作中产生的undo log，因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</li>
<li>update undo log：在delete 和update操作产生的undo log，该undo log可能需要提供MVCC机制，因此不能再事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</li>
</ul>
<div style="display: none">
## DML的相关物理实现算法
* 主键索引
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 对于delete   --需要undo绑定该记录才能进行回滚，所以只能打上标记，delete mark  </span><br><span class="line">2. 对于update  --原记录可以物理删除，因为可以在新插入进来的地方进行undo绑定  </span><br><span class="line">	* 如果不能原地更新： delete(注意：这里是直接delete,而不是delete mark)  + insert </span><br><span class="line">	* 如果可以原地更新，那么直接update就好</span><br></pre></td></tr></table></figure>

<ul>
<li>非聚集索<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 对于delete  --不能直接被物理删除，因为二级索引没有undo，只能通过打标记，然后回滚。否则如果被物理删除，则无法回滚</span><br><span class="line">	delete mark    </span><br><span class="line">2. 对于update  --不能直接被物理删除，因为二级索引没有undo，只能通过打标记，然后回滚。否则如果被物理删除，则无法回滚</span><br><span class="line">	delete mark + insert</span><br></pre></td></tr></table></figure>

</li>
</ul>
</div>

<h1 id="redo-amp-undo"><a href="#redo-amp-undo" class="headerlink" title="redo &amp; undo"></a>redo &amp; undo</h1><h2 id="undo-log-是否是-redo-log-的逆过程？"><a href="#undo-log-是否是-redo-log-的逆过程？" class="headerlink" title="undo log 是否是 redo log 的逆过程？"></a>undo log 是否是 redo log 的逆过程？</h2><p>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。<br>redo log是物理日志，记录的是数据页的物理变化，显然undo log不是redo log的逆过程。</p>
<h2 id="事务实现过程"><a href="#事务实现过程" class="headerlink" title="事务实现过程"></a>事务实现过程</h2><p>事务B要将字段A的值由原来的1修改为3，要将B的值由原来的2修改为4，redo日志记录的是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设有A、B两个数据，值分别为1,2.</span><br><span class="line">1. 事务B开始</span><br><span class="line">2. 记录A=1到undo log</span><br><span class="line">3. 修改A=3</span><br><span class="line">4. 记录A=3到 redo log</span><br><span class="line">5. 记录B=2到 undo log</span><br><span class="line">6. 修改B=4</span><br><span class="line">7. 记录B=4到redo log</span><br><span class="line">8. 将redo log写入磁盘</span><br><span class="line">9. 事务提交，将数据写入磁盘</span><br><span class="line">10.事物B结束</span><br></pre></td></tr></table></figure>

<p>在insert/update/delete操作中，redo和undo分别记录的内容都不一样，量也不一样。在InnoDB内存中，一般的顺序如下：</p>
<ol>
<li>写undo的redo</li>
<li>写undo</li>
<li>修改数据页</li>
<li>写Redo</li>
</ol>
<p>如果上面事务B回滚（当做新的事务C），则redo记录的是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 事务C开始</span><br><span class="line">2. 记录A=1到undo log</span><br><span class="line">3. 修改A=3</span><br><span class="line">4. 记录A=3到 redo log</span><br><span class="line">5. 记录B=2到 undo log</span><br><span class="line">6. 修改B=4</span><br><span class="line">7. 记录B=4到redo log</span><br><span class="line">   &lt;!--回滚--&gt;</span><br><span class="line">8. 修改B=2</span><br><span class="line">9. 记录B=2到redo log</span><br><span class="line">10.修改A=1</span><br><span class="line">11.记录A=1到redo log</span><br><span class="line">12.将redo log写入磁盘</span><br><span class="line">13.事务提交，将数据写入磁盘</span><br><span class="line">14.事物C结束</span><br></pre></td></tr></table></figure>

<p>恢复策略：恢复时，先根据redo重做所有事务（包括未提交和回滚了的），再根据undo回滚未提交的事务。<br>当系统发生宕机时，如果一个事务的 redo log 已经全部刷入磁盘，那么该事务一定可以恢复；如果一个事务的 redo log 没有全部刷入磁盘，那么就通过 undo log 将这个事务恢复到执行之前。</p>
<p>如上，如果事务B异常未提交事务就宕机，恢复时，先根据redo日志将数据恢复为A=3&amp;B=4，然后根据undo记录的A=1&amp;B=2将数据恢复如初。</p>
<div style="display: none">
# 参考：
* https://keithlan.github.io/2017/06/12/innodb_locks_redo/
* https://juejin.im/post/5c3c5c0451882525487c498d
* https://t.hao0.me/mysql/2016/11/05/mysql-innodb-05-tablespaces.html
</div>]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>《Mysql技术内幕》学习笔记-InnoDB存储引擎</title>
    <url>/Mysql/Mysql02/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>InnoDB存储引擎最早由Innobase Oy公司开发，被包括在MySQL数据库所有的二进制发行版本中，</li>
<li>从MySQL 5.5版本开始是默认的表存储引擎<font color="gray">（之前的版本InnoDB存储引擎仅在Windows下为默认的存储引擎）</font></li>
<li>第一个完整支持ACID事务的MySQL存储引擎<font color="gray">（BDB是第一个支持事务的MySQL存储引擎，现在已经停止开发）</font></li>
<li>特点：行锁设计、支持 MVCC、支持外键、提供一致性非锁定读、有效利用内存和 CPU<a id="more"></a>

</li>
</ul>
<h1 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h1><p><img src="/Mysql/Mysql02/innodb-Architecture.png" alt="innoDB体系结构图"><br>InnoDB存储引擎是由内存池、后台线程、磁盘存储三大部分组成。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>InnoDB 使用的是多线程模型, 其后台有多个不同的线程负责处理不同的任务</p>
<h3 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h3><p>Master Thread是最核心的一个后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性。包括脏页刷新、合并插入缓冲、UNDO页的回收等。</p>
<h3 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h3><p>在 InnoDB 存储引擎中大量使用了异步IO(Async IO)来处理写IO请求, IO Thread的工作主要是负责这些 IO 请求的回调。</p>
<table>
<tr>
    <th>InnoDB 版本</th>
    <th colspan="4">线程</th>
</tr>
<tr>
    <td style="text-align:center"> 1.0之前 </td>
    <td colspan="4">4 个 io thread：write，read，insert buffer，log IO Thread.
    <ul>
        <li>在Linux下，IO Thread的数量不能进行调整</li>
        <li>在Windows下可以通过参数 innodb_file_io_threads 来增大IO Thread</li>
    </ul>
    </td>
</tr>
<tr>
    <td style="text-align:center"> 1.0之后 </td>
    <td colspan="4">read 和 write IO thread 分别增大到了 4 个<br>
    <ul>
    <li>分别使用 innodb_read_io_threads 和 innodb_write_io_threads 设置线程数</li>
    </ul>
    </td>
</tr>
</table>  

<h3 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h3><p>事务提交后，其所使用的undo log可能不再需要，因此需要Purge Thread来回收已经分配并使用的UNDO页。</p>
<table>
<tr>
    <th>InnoDB 版本</th>
    <th colspan="4">作用</th>
</tr>
<tr>
    <td style="text-align:center"> 1.1之前 </td>
    <td colspan="4">purge 操作在 master thread 内完成</td>
</tr>
<tr>
    <td style="text-align:center"> 1.1之后 </td>
    <td colspan="4">purge 可以独立到单独的线程,减轻 master thread 工作,提高 cpu 利用率和提高性能<br>
    <ul>
    <li>MySQL数据库的配置文件<code>[mysqld]</code>中添加如下命令来启用独立的Purge Thread：</li>
    <li>innodb_purge_threads=1 </li>
    <li>1.1版本中，即使将 innodb_purge_threads 设为大于1，InnoDB存储引擎启动时也会将其设为1</li>
    </ul>
    </td>
</tr>
<tr>
    <td style="text-align:center"> 1.2之后</td>
    <td colspan="4">支持多个Purge Thread, 这样做可以加快UNDO页的回收，也能更进一步利用磁盘的随机读取性能</td>
</tr>
</table>                                  

<h3 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h3><p>Page Cleaner Thread的作用是取代Master Thread中脏页刷新的操作，<br>减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高性能。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>innoDB内存主要由<a href="#缓冲池">缓冲池(innodb buffer pool)</a>、<a href="#重做日志缓冲">重做日志缓冲(redo log buffer)</a>、<a href="#额外的内存池">额外内存池组成(innodb additional men pool size)</a>组成</p>
<h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>缓冲池是主存储器中的一个区域，用于在访问时缓存表和索引数据。缓冲池允许直接从内存处理常用数据，从而加快处理速度。<br>在专用服务器上，通常会将最多80％的物理内存分配给缓冲池。<br>读取流程：<br>     <img src="/Mysql/Mysql02/read.png" alt="流程图"><br>更新流程：<br>     <img src="/Mysql/Mysql02/write.png" alt="流程图"></p>
<p>因此缓冲池的大小影响数据库的整体性能。</p>
<div class="note info"><p>由于32位操作系统的限制，在该系统下最多将该值设置为3G。<br>用户可以打开操作系统的<code>PAE</code>选项来获得32位操作系统下最大64GB内存的支持。<br>为了让数据库使用更多的内存,建议数据库系统都采用 64 位操作系统。</p></div>

<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">版本</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">innodb_buffer_pool_instances</td>
<td align="center">从InnoDB 1.0.x开始</td>
<td align="center">配置多个缓冲池实例，默认为1</td>
</tr>
</tbody></table>
<h4 id="缓冲池中缓存的数据页类型"><a href="#缓冲池中缓存的数据页类型" class="headerlink" title="缓冲池中缓存的数据页类型"></a>缓冲池中缓存的数据页类型</h4><ul>
<li>索引页(index page)：缓存数据表索引</li>
<li>数据页(data page)：缓存数据页，占缓冲池的绝大部分</li>
<li>undo页(undo Log Page)：undo页是保存事务，为回滚做准备的。</li>
<li><a href="#插入缓冲">插入缓冲</a>（insert buffer）：插入数据时要先插入到缓存池中。</li>
<li>自适应哈希索引（adaptive hash index）： 除了B+ Tree索引外，在缓冲池还会维护一个哈希索引，以便在缓冲池中快速找到数据页。</li>
<li>InnoDB存储的锁信息（lock info）</li>
<li>数据字典信息（data dictionary）<br>  在MySQL中，数据字典信息内容就包括表结构、数据库名或表名、字段的数据类型、视图、索引、表字段信息、存储过程、触发器等内容。<br>  InnoDB有自己的表缓存，可以称为表定义缓存或者数据字典。当InnoDB打开一张表，就增加一个对应的对象到数据字典。</li>
</ul>
<h4 id="缓冲池管理方式"><a href="#缓冲池管理方式" class="headerlink" title="缓冲池管理方式"></a>缓冲池管理方式</h4><p><img src="/Mysql/Mysql02/three-list2.png" alt="三种list"></p>
<ol>
<li><p><strong>Free list</strong><br>当数据库刚启动时，LRU列表是空的，这时页都存放在Free list中。<br>当需要从缓冲池中分页时，从Free list中查找是否有可用的空闲页，若有则将该页从Free列表中删除，放入到LRU列表中,维持页数守恒。</p>
</li>
<li><p><strong>LRU list</strong><br> <strong>LRU算法</strong>：最频繁使用页在LRU列表的前端，最少使用的页在尾端。首先释放LRU列表中的尾端的页。缓冲池中页的大小默认为16KB。<br> <strong>InnoDB优化的LRU算法(midpoint insertion strategy)</strong>：将新读取到的页不放在首部，而是中间部位 <code>midpoint</code> 位置。目标是确保频繁访问”热”页面保留在缓冲池中。<br> <img src="/Mysql/Mysql02/innodb-buffer-pool-list.jpg" alt="lru"></p>
 <table>
 <tr>
     <th>参数</th>
     <th colspan="2">作用</th>
 </tr>
 <tr>
     <td style="text-align:center"> innodb_old_blocks_pct </td>
     <td colspan="2">控制LRU列表中 old list 的百分比。<br>
        默认值为 37，对应于原始固定比率3/8。<br>
        值范围是 5（缓冲池中的新页面很快就会老化）到 95。
     </td>
 </tr>
 <tr>
     <td style="text-align:center"> innodb_old_blocks_time </td>
     <td colspan="2">指定第一次访问页面之后的时间窗口（ms）<br>
        在此期间可以访问该页面而不移动到LRU列表的前端<br>
        默认值为 1000 ms
     </td>
 </tr>
 </table> 

<p> 默认情况下，算法操作如下：</p>
<ul>
<li>在默认配置下， <code>midpoint</code>位置在LRU list 的5/8处。</li>
<li><code>midpoint</code>是new sublist的尾部与old sublist的头部相交的边界。</li>
<li>当 InnoDB 将页面读入缓冲池时，将页插入<code>midpoint</code>位置(old sublist的头部)。</li>
<li>访问old sublist中的页 &amp;&amp; 该页在old sublist中的停留时间超过innodb_old_blocks_time设置的时间，使其变<code>young</code>,将其移动到缓冲池的头部(new sublist的头部)。</li>
<li>当页从LRU列表的old部分加入到new部分时，称此时发生的操作为<code>page made young</code>，而因为innodb_old_blocks_time的设置而导致页没有从old部分移动到new部分的操作称为<code>page not made young</code></li>
<li>在数据库操作中，被访问的页将移到new sublist的表头，这样一来，在new sublist中的未被访问的节点将逐渐往表尾移动，当移动过中点，将变为old list的节点。当表满时，old list末尾的页将会被移除。</li>
</ul>
<div class="note warning"><p>为什么不采用朴素的LRU？<br>因为某些SQL操作会访问很多页，甚至全部页，但仅仅在该次查询操作，并不是活跃的热点数据。可能会使缓冲池中的页被刷新出，从而影响缓冲池的效率。</p></div>  

<ol start="3">
<li><strong>Flush list</strong><br>在LRU类表的页被修改后，称为脏页（Dirty Page），即缓存和硬盘的页数据不一致。<br>数据库会通过<code>CHECKPOINT</code>机制将脏页刷新回磁盘，Flush list中的页即为脏页列表。</li>
</ol>
</li>
</ol>
<h3 id="重做日志缓冲"><a href="#重做日志缓冲" class="headerlink" title="重做日志缓冲"></a>重做日志缓冲</h3>   <div class="note info"><p><strong>什么是redo log？</strong><br>当数据库对数据做修改的时候，需要把数据页从磁盘读到buffer pool中，然后在buffer pool中进行修改，那么这个时候buffer pool中的数据页就与磁盘上的数据页内容不一致，称buffer pool的数据页为dirty page 脏数据。<br>如果发生非正常的DB服务重启，那么这些数据并没有同步到磁盘文件中（注意，同步到磁盘文件是个随机IO），会发生数据丢失。<br>如果这个时候，能够有一个文件，当缓冲池中的data page变更结束后，把相应修改记录记录到这个文件（注意，记录日志是顺序IO），那么当DB服务发生crash的情况，恢复DB的时候，也可以根据这个文件的记录内容，重新应用到磁盘文件，数据保持一致。<br>这个文件就是redo log ，用于记录 数据修改后的记录，顺序记录。<br><br><strong>什么是undo log？</strong><br>undo日志用于存放数据修改被修改前的值。<br>假设修改表中 id=1 的行数据，把Name=’B’ 修改为Name = ‘B2’ ，那么undo日志就会用来存放Name=’B’的记录，如果这个修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。</p></div>  

<p><img src="/Mysql/Mysql02/redo-buffer.png" alt="lru"></p>
<p>  重做日志缓冲不需要设置很大，通常情况下8M能满足大部分的应用场景。重做日志支持以下三种情况触发刷新：</p>
<ul>
<li>Master Thread每一秒将重做日志缓冲刷新到重做日志文件</li>
<li>每次事务提交时将重做日志缓冲刷新到重做日志文件</li>
<li>当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件</li>
</ul>
<h3 id="额外的内存池"><a href="#额外的内存池" class="headerlink" title="额外的内存池"></a>额外的内存池</h3><p>   在InnoDB存储引擎中，对内存的管理是通过一种称为内存堆的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。</p>
<h1 id="Checkpoint技术"><a href="#Checkpoint技术" class="headerlink" title="Checkpoint技术"></a>Checkpoint技术</h1><div class="note info"><p><strong>什么是Checkpoint？</strong><br>是一个数据库事件(event)，这个事件激活以后会触发数据库写进程(DBWR)将脏数据块写到磁盘中。                           </p>
<p><strong>为什么需要Checkpoint技术？</strong><br>innoDB在事务提交时，先写重做日志，再修改内存数据这样，就产生了脏页。既然有重做日志保证数据持久性，查询时也可以从缓冲池页中取数据，那为什么还要刷新脏页到磁盘呢？如果重做日志可以无限增大，同时缓冲池足够大，能够缓存所有数据，那么是不需要将缓冲池中的脏页刷新到磁盘。但是，会有以下几个问题：<br>1) 服务器内存有限，缓冲池不够用，无法缓存全部数据<br>2) 重做日志无限增大成本要求太高<br>3) 宕机时如果重做全部日志恢复时间过长            </p>
<p><strong>Checkpoint 解决了什么问题？</strong><br>1) 缩短短数据库的恢复时间<br>2) 缓冲池不够时，将脏页刷新到磁盘<br>3) 重做日志不可用时，刷新脏页</p></div> 

<p>对于InnoDB存储引擎而言，其是通过LSN（Log Sequence Number）来标记版本的。每个页有LSN，重做日志中也有LSN，Checkpoint也有LSN。</p>
<p>innodb 内部有两种 checkpoint：</p>
<ol>
<li><p><strong>sharp checkpoint</strong>：数据库关闭的时候将<code>所有的脏页</code>刷回到磁盘，默认方式，参数 innodb_fast_shudown=1</p>
</li>
<li><p><strong>fuzzy checkpoint</strong>：只刷新<code>部分脏页</code></p>
<ul>
<li><p>master thread checkpoint：master thread 异步的以每秒或者每 10 秒的速度从缓冲池的脏页列表中刷新一定比列的也回磁盘</p>
<ul>
<li>周期性，异步，读取flush list，找到脏页，写入磁盘</li>
</ul>
</li>
<li><p>flush_lru_list checkpoint：InnoDB要保证LRU列表中需要有差不多100个空闲页可供使用。如果没有这么多，就会将 lru list 尾部的页移除。如果这些页有脏页，就需要进行 checkpoint。</p>
<ul>
<li>innodb 1.1.x版本之前，检查在用户查询线程中,会阻塞用户查询操作。</li>
<li>innodb 1.2.x版本之后，检查放到了单独的 page cleaner 线程中,可通过 <strong>innodb_lru_scan_depth</strong> 控制lru列表中可用页的数量，默认是1024。</li>
</ul>
</li>
<li><p>async/sync flush checkpoint：重做日志文件不可用时，强制将一些页刷新到磁盘。达到重做日志文件的大小阈值。</p>
<ul>
<li>checkpoint age = redo_log_lsn - cp_lsn<br> 低水位=75% * total_redo_log_file_size<br> 高水位=90% * total_redo_log_file_size</li>
<li>checkpoint age &lt; 低水位<br>   不需要刷新</li>
<li>低水位  &lt;=  checkpoint age &lt;= 高水位<br>   会强制进行 checkpoint ，触发async flush， 根据flush_list的顺序，刷新足够多的脏页，直到 checkpoint age &lt; 低水位</li>
<li>checkpoint age &gt; 高水位<br> 会强制进行 checkpoint ，触发sync flush 根据flush_list的顺序，刷新脏页, 直到 checkpoint age &lt; 低水位</li>
</ul>
</li>
<li><p>dirty page too much checkpoint：当缓冲池中脏页的数量占据一定百分比时，强制进行Checkpoint，用来保证缓冲池中有足够的页，通过 <a href="#innodb_max_dirty_pages_pct">innodb_max_dirty_pages_pct</a> 参数控制。</p>
</li>
</ul>
</li>
</ol>
<div style="text-align:center;color:#bfbfbf;font-size:16px;">
    <span>-------- 第二部分 --------</span>
</div>

<h1 id="Master-thread-工作方式"><a href="#Master-thread-工作方式" class="headerlink" title="Master thread 工作方式"></a>Master thread 工作方式</h1><h2 id="InnoDB-1-0-x-版本之前的-Master-thread"><a href="#InnoDB-1-0-x-版本之前的-Master-thread" class="headerlink" title="InnoDB 1.0.x 版本之前的 Master thread"></a>InnoDB 1.0.x 版本之前的 Master thread</h2><p>Master thread 内部有多个循环 loop 组成：</p>
<ul>
<li>主循环 loop</li>
<li>后台循环 backgroup loop</li>
<li>刷新循环 flush loop</li>
<li>暂停循环 suspend loop</li>
</ul>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">master_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goto loop;</span><br><span class="line">	<span class="comment">//主循环</span></span><br><span class="line">	loop ：</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">		thread_sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//1. 日志缓冲刷新到磁盘，即使事务还没有提交</span></span><br><span class="line">		<span class="keyword">do</span> log buffer flush to disk;</span><br><span class="line">		<span class="comment">//2. 根据前一秒IO操作小于5，合并插入缓冲</span></span><br><span class="line">		<span class="keyword">if</span>(last_one_second_ios &lt; <span class="number">5</span>)</span><br><span class="line">			<span class="keyword">do</span> merge at most <span class="number">5</span> insert buffer;</span><br><span class="line">		<span class="comment">//3. 脏页的比例超过了阈值，刷新 100 个脏页到磁盘</span></span><br><span class="line">		<span class="keyword">if</span>(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct)</span><br><span class="line">			<span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;</span><br><span class="line">		<span class="comment">//4. 没有用户活动（数据库空闲时）或者数据库关闭（shutdown），切换到 backgroup loop</span></span><br><span class="line">		<span class="keyword">if</span>(no user activity)</span><br><span class="line">			goto backgroud loop;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1. 前10秒IO操作小于200，刷新 100 个脏页到磁盘</span></span><br><span class="line">	<span class="keyword">if</span>(last_ten_second_ios &lt; <span class="number">200</span>)</span><br><span class="line">		<span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;</span><br><span class="line">	<span class="comment">//2. 合并至多 5 个插入缓冲</span></span><br><span class="line">	<span class="keyword">do</span> merge at most <span class="number">5</span> insert buffer;</span><br><span class="line">	<span class="comment">//3. 将重做日志刷新到磁盘</span></span><br><span class="line">	<span class="keyword">do</span> log buffer flush to disk;</span><br><span class="line">	<span class="comment">//4. 删除无用的 undo 页（每次最多尝试回收 20 个 undo 页）</span></span><br><span class="line">	<span class="keyword">do</span> full purge;</span><br><span class="line">	<span class="comment">//5. 脏页比例超过 70% 刷新100 个脏页到磁盘，否则刷新 10 个脏页</span></span><br><span class="line">	<span class="keyword">if</span> ( buf_get_modified_ratio_pct ＞ <span class="number">70</span> % )</span><br><span class="line">		<span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		buffer pool flush <span class="number">10</span> dirty page</span><br><span class="line">																</span><br><span class="line">	goto loop</span><br><span class="line">	<span class="comment">//后台循环																</span></span><br><span class="line">	background loop :</span><br><span class="line">	<span class="comment">//1. 删除无用的 undo 页</span></span><br><span class="line">	<span class="keyword">do</span> full purge</span><br><span class="line">	<span class="comment">//2. 合并 20 个插入缓冲</span></span><br><span class="line">	<span class="keyword">do</span> merge <span class="number">20</span> insert buffer</span><br><span class="line">	<span class="comment">//3.如果有任务，跳转到主循环，否则跳转到刷新循环</span></span><br><span class="line">	<span class="keyword">if</span> not idle	</span><br><span class="line">		goto loop</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		goto flush loop</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//刷新循环</span></span><br><span class="line">	flush loop :</span><br><span class="line">	<span class="comment">//不断刷新100个脏页，直到脏页比例没有超过阈值</span></span><br><span class="line">	<span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page</span><br><span class="line">	<span class="keyword">if</span> ( buf_get_modified_ratio_pct ＞ innodb_max_dirty_pages_pct )</span><br><span class="line">		goto flush loop</span><br><span class="line">	<span class="comment">//没有任务，跳转到暂停循环</span></span><br><span class="line">	goto suspend loop</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//暂停循环</span></span><br><span class="line">	suspend loop :</span><br><span class="line">	<span class="comment">//将主线程挂起，等待事件发生</span></span><br><span class="line">	suspend_thread()</span><br><span class="line">	waiting event</span><br><span class="line">	goto loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="InnoDB-1-2-x-版本之前的-Master-thread"><a href="#InnoDB-1-2-x-版本之前的-Master-thread" class="headerlink" title="InnoDB 1.2.x 版本之前的 Master thread"></a>InnoDB 1.2.x 版本之前的 Master thread</h2><ol>
<li>提高刷新脏页数量和合并插入数量，改善磁盘 IO 处理能力,刷新数量不再硬编码，而是使用百分比控制。<ul>
<li>在合并插入缓冲的时候，合并插入缓冲的数量为 <a href="#innodb_io_capacity">innodb_io_capacity</a> 的 5%</li>
<li>在从缓冲区刷新脏页的时候，刷新脏页的数量为 <a href="#innodb_io_capacity">innodb_io_capacity</a></li>
</ul>
</li>
<li>增加了自适应刷新脏页功能。<ul>
<li>1.0.x之前版本：脏页在缓冲池占比小于<a href="#innodb_max_dirty_pages_pct">innodb_max_dirty_pages_pct</a>，不刷新脏页，大于则刷新100个脏页</li>
<li>1.0.x版本开始：引入<a href="#innodb_adaptive_flushing">innodb_adaptive_flushing</a>参数，通过函数buf_flush_get_desired_flush_rate判断产生重做日志的速度来决定最适合的刷新脏页数量。</li>
</ul>
</li>
<li>full purge回收的Undo页的数量也不再硬编码，使用参数<a href="#innodb_purge_batch_size">innodb_purge_batch_size</a>控制。</li>
</ol>
<table>
<tr>
    <th colspan="2">参数</th>
    <th>InnoDB 版本</th>
    <th colspan="3">作用</th>
</tr>
<tr>
    <td colspan="2" style="text-align:center"><span id="innodb_io_capacity">innodb_io_capacity</span></td>
    <td style="text-align:center"> 1.0.x开始 </td>
    <td colspan="3">表示磁盘IO的吞吐量,默认值是200</td>
</tr>
<tr>
    <td colspan="2" rowspan="2" style="text-align:center"><span id="innodb_max_dirty_pages_pct">innodb_max_dirty_pages_pct</span></td>
    <td style="text-align:center"> 1.0.x之前 </td>
    <td colspan="3">脏页在缓冲池中所占比率，默认值是90</td>
</tr>
<tr>
    <td style="text-align:center"> 1.0.x开始</td>
    <td colspan="3">默认值是75<br>加快刷新脏页的频率，保证了磁盘IO的负载。</td>                       
</tr>
<tr>
    <td colspan="2" style="text-align:center"><span id="innodb_adaptive_flushing">innodb_adaptive_flushing</span></td>
    <td style="text-align:center"> 1.0.x开始 </td>
    <td colspan="3">是否自适应刷新脏页，默认为 ON</td>
</tr>
<tr>
    <td colspan="2" style="text-align:center"><span id="innodb_purge_batch_size">innodb_purge_batch_size</span></td>
    <td style="text-align:center"> 1.0.x开始 </td>
    <td colspan="3">清除 undo 页时,表示一次删除多少页,默认是 20</td>
</tr>
</table>   

<p>Master Thread的伪代码变为了下面的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">master_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goto loop;</span><br><span class="line">	<span class="comment">//主循环</span></span><br><span class="line">	loop ：</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">		thread_sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//1. 日志缓冲刷新到磁盘，即使事务还没有提交</span></span><br><span class="line">		<span class="keyword">do</span> log buffer flush to disk;</span><br><span class="line">		<span class="comment">//2. 根据前一秒IO操作小于5%innodb_io_capacity，合并插入缓冲</span></span><br><span class="line">		<span class="keyword">if</span>(last_one_second_ios &lt; <span class="number">5</span>%innodb_io_capacity)</span><br><span class="line">			<span class="keyword">do</span> merge <span class="number">5</span>%innodb_io_capacity insert buffer;</span><br><span class="line">		<span class="comment">//3. 脏页的比例超过了阈值，刷新 100%innodb_io_capacity 个脏页到磁盘</span></span><br><span class="line">		<span class="keyword">if</span>(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct)</span><br><span class="line">			<span class="keyword">do</span> buffer pool flush <span class="number">100</span>%innodb_io_capacity dirty page;</span><br><span class="line">		<span class="comment">//4. 没有用户活动（数据库空闲时）或者数据库关闭（shutdown），切换到 backgroup loop</span></span><br><span class="line">		<span class="keyword">if</span>(no user activity)</span><br><span class="line">			goto backgroud loop;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1. 前10秒IO操作小于innodb_io_capacity，刷新 innodb_io_capacity 个脏页到磁盘</span></span><br><span class="line">	<span class="keyword">if</span>(last_ten_second_ios &lt; innodb_io_capacity)</span><br><span class="line">		<span class="keyword">do</span> buffer pool flush <span class="number">100</span>%innodb_io_capacity dirty page;</span><br><span class="line">	<span class="comment">//2. 合并至多 5%innodb_io_capacity 个插入缓冲</span></span><br><span class="line">	<span class="keyword">do</span> merge at most <span class="number">5</span>%innodb_io_capacity insert buffer;</span><br><span class="line">	<span class="comment">//3. 将重做日志刷新到磁盘</span></span><br><span class="line">	<span class="keyword">do</span> log buffer flush to disk;</span><br><span class="line">	<span class="comment">//4. 删除无用的 undo 页（每次最多尝试回收 5%innodb_io_capacity 个 undo 页）</span></span><br><span class="line">	<span class="keyword">do</span> full purge;</span><br><span class="line">	<span class="comment">//5. 脏页比例超过 70% 刷新 100%innodb_io_capacity 个脏页到磁盘，</span></span><br><span class="line">	<span class="comment">// 否则刷新 10%innodb_io_capacity 个脏页</span></span><br><span class="line">	<span class="keyword">if</span> ( buf_get_modified_ratio_pct ＞ <span class="number">70</span> % )</span><br><span class="line">		<span class="keyword">do</span> buffer pool flush <span class="number">100</span>%innodb_io_capacity dirty page</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		buffer pool flush <span class="number">10</span>%innodb_io_capacity dirty page</span><br><span class="line">																</span><br><span class="line">	goto loop</span><br><span class="line">	<span class="comment">//后台循环																</span></span><br><span class="line">	background loop :</span><br><span class="line">	<span class="comment">//1. 删除无用的 undo 页</span></span><br><span class="line">	<span class="keyword">do</span> full purge</span><br><span class="line">	<span class="comment">//2. 合并 100%innodb_io_capacity 个插入缓冲</span></span><br><span class="line">	<span class="keyword">do</span> merge <span class="number">100</span>%innodb_io_capacity insert buffer</span><br><span class="line">	<span class="comment">//3.如果有任务，跳转到主循环，否则跳转到刷新循环</span></span><br><span class="line">	<span class="keyword">if</span> not idle	</span><br><span class="line">		goto loop</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		goto flush loop</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//刷新循环</span></span><br><span class="line">	flush loop :</span><br><span class="line">	<span class="comment">//不断刷新 100%innodb_io_capacity 个脏页，直到脏页比例没有超过阈值</span></span><br><span class="line">	<span class="keyword">do</span> buffer pool flush <span class="number">100</span>%innodb_io_capacity dirty page</span><br><span class="line">	<span class="keyword">if</span> ( buf_get_modified_ratio_pct ＞ innodb_max_dirty_pages_pct )</span><br><span class="line">		goto flush loop</span><br><span class="line">	<span class="comment">//没有任务，跳转到暂停循环</span></span><br><span class="line">	goto suspend loop</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//暂停循环</span></span><br><span class="line">	suspend loop :</span><br><span class="line">	<span class="comment">//将主线程挂起，等待事件发生</span></span><br><span class="line">	suspend_thread()</span><br><span class="line">	waiting event</span><br><span class="line">	goto loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="InnoDB-1-2-x-版本的-Master-thread"><a href="#InnoDB-1-2-x-版本的-Master-thread" class="headerlink" title="InnoDB 1.2.x 版本的 Master thread"></a>InnoDB 1.2.x 版本的 Master thread</h2><p>InnoDB 1.2.x 版本中再次对 Master Thread 进行了优化，伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> InnoDB is idle</span><br><span class="line"><span class="comment">//之前版本中每10秒的操作</span></span><br><span class="line">srv_master_do_idle_tasks();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//之前版本中每秒的操作</span></span><br><span class="line">srv_master_do_active_tasks();</span><br></pre></td></tr></table></figure>

<p>对于刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。</p>
<h1 id="InnoDB-关键特性"><a href="#InnoDB-关键特性" class="headerlink" title="InnoDB 关键特性"></a>InnoDB 关键特性</h1><p>关键特性包括：</p>
<ul>
<li>插入缓冲 insert buffer</li>
<li>两次写 double write</li>
<li>自适应哈希索引 adaptive hash index</li>
<li>异步 io async io</li>
<li>刷新邻接页 flush neighbor page</li>
</ul>
<h2 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h2><h3 id="聚集索引（一级索引）"><a href="#聚集索引（一级索引）" class="headerlink" title="聚集索引（一级索引）"></a>聚集索引（一级索引）</h3><p>表在存储的时候按照主键排序进行存储，不需要磁盘的随机读取，插入效率高。<br>非叶子节点存放的是键值，叶子节点存放的是行数据，称之为数据页。</p>
<h3 id="辅助索引（二级索引）"><a href="#辅助索引（二级索引）" class="headerlink" title="辅助索引（二级索引）"></a>辅助索引（二级索引）</h3><p>除了聚集索引之外的索引都可以称之为辅助索引，叶子节点中存放的是主键的键值。叶子节点的插入不再有序，这时就需要离散访问非聚集索引页，插入性能变低。<br>一张表可以存在多个辅助索引，但是只能有一个聚集索引，通过辅助索引来查找对应的航记录的话，需要进行两步，第一步通过辅助索引来确定对应的主键，第二步通过相应的主键值在聚集索引中查询到对应的行记录，也就是进行两次B+树搜索。</p>
<h3 id="索引数据页的更新（针对二级索引）"><a href="#索引数据页的更新（针对二级索引）" class="headerlink" title="索引数据页的更新（针对二级索引）"></a>索引数据页的更新（针对二级索引）</h3><p><img src="/Mysql/Mysql02/index-update.png" alt="index更新流程"><br>表数据更新的同时也会更新对应的表的索引数据，所以：对表进行insert delete update时，很可能会产生大量的物理读(物理读索引数据页)</p>
<p><img src="/Mysql/Mysql02/insert-buffer.png" alt="引入insertbuffer后index更新流程"></p>
<h3 id="1-insert-buffer"><a href="#1-insert-buffer" class="headerlink" title="1. insert buffer"></a>1. insert buffer</h3><p>Insert Buffer的使用流程：<br><img src="/Mysql/Mysql02/Insert-Buffer.svg" alt="Insert Buffer的使用流程"></p>
<h4 id="插入缓冲的启用需要满足以下两个条件："><a href="#插入缓冲的启用需要满足以下两个条件：" class="headerlink" title="插入缓冲的启用需要满足以下两个条件："></a>插入缓冲的启用需要满足以下两个条件：</h4><p>1）索引是辅助索引（secondary index）<br>2）索引不是唯一的：整个索引数据被切分为2部分，无法保证唯一性。</p>
<h4 id="insert-buffer结构"><a href="#insert-buffer结构" class="headerlink" title="insert buffer结构"></a>insert buffer结构</h4><p>insert buffer的数据结构是B+树，全局只有一颗B+树。<br>B+树的非叶子节点是Search key，构造结构为(space,marker,offset)。</p>
<ul>
<li>space：待插入记录所在表的表空间id。每个表都有唯一的表空间id，通过表空间id可以查出是哪张表。</li>
<li>marker：兼容之前的版本。</li>
<li>offset：在表空间中页的偏移量。</li>
</ul>
<p>当一个辅助索引要插入到(space,offset)中时，如果该页不在缓冲池中，则按上述规则构造一个search key，将该记录插入到insert buffer中。<br>但是如果该页一直在insert buffer中，不断有记录插入到同一个索引页中，那么该索引页的空间就会逐渐缩小，要出现B+树节点的分裂情况，这时就不能进行insert buffer了。<br>所以，我们需要一个机制来管理每个页面的剩余空闲空间，这就是<code>Insert buffer bitmap</code>。<br>每隔page_size个页面，就是一个Insert buffer bitmap page。<br>例如：若page_size = 16384(16k)，那么page_no为0，16384，32768，…的page，就是Insert buffer bitmap page，Bitmap page的功能，就是管理其后连续的page_size – 1个page的空间使用率。<br>每个辅助索引页在Insert buffer bitmap中占用4bit。</p>
<h4 id="merge-insert-buffer-发生条件"><a href="#merge-insert-buffer-发生条件" class="headerlink" title="merge insert buffer 发生条件"></a>merge insert buffer 发生条件</h4><ul>
<li>辅助索引页被读取到buffer pool中：正常的select查询操作，索引页被调入内存，该索引页对应在insert buffer中的索引更改记录就会发生merge操作。</li>
<li>Insert buffer bitmap page追踪到该索引页无可用空间时。</li>
<li>Master Thread。</li>
</ul>
<h4 id="insert-buffer-刷新到磁盘条件"><a href="#insert-buffer-刷新到磁盘条件" class="headerlink" title="insert buffer 刷新到磁盘条件"></a>insert buffer 刷新到磁盘条件</h4><ul>
<li>有一个后台线程，会认为数据库空闲时；</li>
<li>数据库缓冲池不够用时；</li>
<li>数据库正常关闭时；</li>
<li>redo log写满时：<em>几乎不会出现redo log写满，此时整个数据库处于无法写入的不可用状态</em></li>
</ul>
<h4 id="插入缓冲主要带来如下两个坏处"><a href="#插入缓冲主要带来如下两个坏处" class="headerlink" title="插入缓冲主要带来如下两个坏处"></a>插入缓冲主要带来如下两个坏处</h4><p>1）可能导致数据库宕机后实例恢复时间变长。如果应用程序执行大量的插入和更新操作，且涉及非唯一的聚集索引，一旦出现宕机，这时就有大量内存中的插入缓冲区数据没有合并至索引页中，导致实例恢复时间会很长。<br>2）在写密集的情况下，插入缓冲会占用过多的缓冲池内存，默认情况下最大可以占用1/2，这在实际应用中会带来一定的问题。</p>
<h3 id="2-change-buffer"><a href="#2-change-buffer" class="headerlink" title="2. change buffer"></a>2. change buffer</h3><p>InnoDB从1.0.x版本开始引入了Change Buffer，可以将其视为Insert Buffer的升级。<br>从这个版本开始，InnoDB可以对DML操作——Insert、Delete、Update<code>(delete+insert)</code>都进行缓冲，<br>它们分别是：Insert Buffer, Delete Buffer,Purge Buffer。<br>对一个记录进行 update 操作有两个过程</p>
<ul>
<li>将记录标记为删除：delete buffer</li>
<li>将记录真正删除：pruge buffer</li>
</ul>
<table>
<tr>
    <th colspan="2">参数</th>
    <th>InnoDB 版本</th>
    <th colspan="3">作用</th>
</tr>
<tr>
    <td colspan="2" style="text-align:center"><span id="innodb_change_buffering">innodb_change_buffering</span></td>
    <td style="text-align:center"> 1.0.x开始 </td>
    <td colspan="3">用来开启各种Buffer选项，默认值是all<br>
        <ul>
        <li>inserts</li>
        <li>deletes</li>
        <li>purges</li>
        <li>changes：开启 inserts 和 deletes</li>
        <li>all：都开启</li>
        <li>none：都不开启</li>
        </ul>
    </td>
</tr>
<tr>
    <td colspan="2" rowspan="2" style="text-align:center"><span id="innodb_change_buffer_max_size">innodb_change_buffer_max_size</span></td>
    <td style="text-align:center"> 1.2.x开始 </td>
    <td colspan="3">用来控制change buffer最大使用内存数量<br>默认值为25,表示最多使用1/4的缓存池空间<br>该参数最大有效值是50</td>
</tr>
</table>  

<h2 id="两次写"><a href="#两次写" class="headerlink" title="两次写"></a>两次写</h2><p>提高innodb的可靠性，用来解决部分写失败(partial page write页断裂)。</p>
<h3 id="脏页刷新到磁盘风险"><a href="#脏页刷新到磁盘风险" class="headerlink" title="脏页刷新到磁盘风险"></a>脏页刷新到磁盘风险</h3><p>IO的最小单位：</p>
<ul>
<li>数据库IO的最小单位是16K（MySQL默认，oracle是8K）</li>
<li>文件系统IO的最小单位是4K（也有1K的）</li>
<li>磁盘IO的最小单位是512字节</li>
</ul>
<p>因此，存在IO写入导致page损坏的风险：<br><img src="/Mysql/Mysql02/IO.png" alt="IO风险"></p>
<p>提高innodb的可靠性，用来解决部分写失败(partial page write页断裂)。</p>
<h3 id="Double-write解决了什么问题"><a href="#Double-write解决了什么问题" class="headerlink" title="Double write解决了什么问题"></a>Double write解决了什么问题</h3><p>一个数据页的大小是16K，假设在把内存中的脏页写到数据库的时候，写了8K突然宕机了，也就是说前8K数据是新的，后8K是旧的，那么磁盘数据库这个数据页就是不完整的，是一个坏掉的数据页，这种情况被称为部分<code>写失效</code></p>
<p><strong>那么可不可以通过 redo log 来进行恢复呢？</strong><br>redo记录的是对页的修改，只能恢复校验完整（还没写）的页，不能修复坏掉的数据页，所以这个数据就丢失了，可能会造成数据不一致，所以需要double write。</p>
<div class="note info"><p>为什么 redo log 不需要 doublewrite 的支持？<br>因为 redo log 写入的单位就是 512 字节，也就是磁盘 IO 的最小单位，所以无所谓数据损坏。</p></div>   

<h3 id="两次写工作流程"><a href="#两次写工作流程" class="headerlink" title="两次写工作流程"></a>两次写工作流程</h3><p><img src="/Mysql/Mysql02/doublewrite.png" alt="两次写流程"><br>doublewrite由两部分组成，一部分为内存中的doublewrite buffer，其大小为2MB，另一部分是磁盘上共享表空间(ibdata x)中连续的128个页，即2个区(extent)，大小也是2M。</p>
<ol>
<li>当一系列机制触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先拷贝至内存中的doublewrite buffer中；</li>
<li>接着从两次写缓冲区分两次写入磁盘共享表空间中(连续存储，顺序写，性能很高)，每次写1MB；</li>
<li>待第二步完成后，再将doublewrite buffer中的脏页数据写入实际的各个表空间文件(离散写)；(脏页数据固化后，即进行标记对应doublewrite数据可覆盖)</li>
</ol>
<p>现在我们来分析一下为什么 double write 可以生效。当宕机发生时，有那么几种情况：</p>
<ol>
<li>磁盘还未写，此时可以通过 redo log 恢复；</li>
<li>磁盘正在进行从内存到共享表空间的写，此时数据文件中的页还没开始被写入，因此也同样可以通过 redo log 恢复；</li>
<li>磁盘正在写数据文件，此时共享表空间已经写完，可以从共享表空间拷贝页的副本到数据文件实现恢复。</li>
</ol>
<h2 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h2><p>哈希：一次就可以定位数据</p>
<p>B+树：取决于树的高度，生产环境一般是 3-4 层，所以需要查询 3-4 次</p>
<p>自适应哈希索引 AHI（adaptive hash index）建立条件：观察到一个访问模式访问频繁，就会建立哈希索引</p>
<ul>
<li>通过该模式访问了 100 次（模式：where x = ?）</li>
<li>页通过该模式访问了 N 次，其中 N = 页的记录总数⁄16</li>
</ul>
<p>InnoDB 存储引擎官方文档显示，启用 AHI 后,读取和写入速度可以提高 2 倍，辅助索引的连接操作性能可以提高 5 倍。</p>
<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>为了提高磁盘的操作性能，当前的数据库系统都采用异步IO的方式处理磁盘操作。用户可以在发出一个IO请求胡立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作完成，这就是AIO。<br>AIO的另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO, 这样可以提高IOPS(Input/Output Per Second)的性能。</p>
<p>例如：用户访问页的（space, page_no)为(8,6) (8,7) (8,8)，每个页的大小为16KB，同步IO需要3次IO操作。可以优化为从(8,6)开始读取48KB。</p>
<h2 id="刷新临接页"><a href="#刷新临接页" class="headerlink" title="刷新临接页"></a>刷新临接页</h2><p>当刷新一个脏页时，InnoDB会检查该页所在extent的所有页，如果是脏页，一起刷新。</p>
<table>
    <tr>
        <th colspan="2">参数</th>
        <th>版本</th>
        <th colspan="3">作用</th>
    </tr>
    <tr>
        <th colspan="2" style="text-align:center">innodb_flush_neighbors</th>
        <td style="text-align:center">1.2.x开始</td>
        <td colspan="3">控制是否启用该特性</td>
    </tr>
</table> 


<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><a href="http://oohcode.com/2015/10/14/InnoDB-Key-Features/" target="_blank" rel="noopener">http://oohcode.com/2015/10/14/InnoDB-Key-Features/</a></li>
<li><a href="https://chyroc.cn/posts/innodb-storage-engine-reading-1/" target="_blank" rel="noopener">https://chyroc.cn/posts/innodb-storage-engine-reading-1/</a></li>
<li><a href="https://www.cnblogs.com/zhoujinyi/archive/2013/04/11/2988923.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhoujinyi/archive/2013/04/11/2988923.html</a></li>
<li><a href="http://huzb.me/2019/01/14/%E6%8F%92%E5%85%A5%E7%BC%93%E5%86%B2%E3%80%81%E4%B8%A4%E6%AC%A1%E5%86%99%E5%92%8C%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95/" target="_blank" rel="noopener">http://huzb.me/2019/01/14/%E6%8F%92%E5%85%A5%E7%BC%93%E5%86%B2%E3%80%81%E4%B8%A4%E6%AC%A1%E5%86%99%E5%92%8C%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95/</a></li>
<li><a href="https://blog.csdn.net/tanliqing2010/article/details/81509539" target="_blank" rel="noopener">https://blog.csdn.net/tanliqing2010/article/details/81509539</a></li>
<li><a href="https://www.cnblogs.com/geaozhang/p/7341333.html" target="_blank" rel="noopener">https://www.cnblogs.com/geaozhang/p/7341333.html</a></li>
<li><a href="https://draveness.me/mysql-innodb" target="_blank" rel="noopener">https://draveness.me/mysql-innodb</a></li>
<li><a href="http://richfisher.me/blog/2017/12/18/innodb-notes/" target="_blank" rel="noopener">http://richfisher.me/blog/2017/12/18/innodb-notes/</a></li>
<li><a href="https://www.docs4dev.com/docs/zh/mysql/5.7/reference/innodb-architecture.html#innodb%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener">https://www.docs4dev.com/docs/zh/mysql/5.7/reference/innodb-architecture.html#innodb%E6%9E%B6%E6%9E%84</a></li>
<li>MySQL技术内幕：InnoDB存储引擎(第2版)</li>
</ul>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>MySql</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>《Mysql技术内幕》学习笔记-MySql体系结构和存储引擎</title>
    <url>/Mysql/Mysql01/</url>
    <content><![CDATA[<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><blockquote>
<p>数据库是文件的集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合。<br>在MySQL数据库中，数据库文件可以是frm、MYD、MYI、ibd结尾的文件。</p>
</blockquote>
<a id="more"></a>
<h4 id="数据库实例"><a href="#数据库实例" class="headerlink" title="数据库实例"></a>数据库实例</h4><blockquote>
<p>数据库实例是<code>程序</code>，是位于用户与操作系统之间的一层数据管理软件，用户对数据库数据的任何操作，<br>包括数据库定义、数据查询、数据维护、数据库运行控制等都是在数据库实例下进行的，应用程序只有通过数据库实例才能和数据库打交道。</p>
</blockquote>
<h4 id="MySql体系结构"><a href="#MySql体系结构" class="headerlink" title="MySql体系结构"></a>MySql体系结构</h4><p><img src="/Mysql/Mysql01/01.jpg" alt="mysql体系结构图"></p>
<p>从图中可以发现，MySQL由：连接池组件、管理服务和工具组件、SQL接口组件、查询分析器组件、优化器组件、缓冲（Cache）组件、插件式存储引擎和物理文件组成。<br>MySQL数据库区别于其他数据库的最重要的一个特点就是其插件式的<code>表存储引擎</code>。</p>
<h4 id="MySql存储引擎"><a href="#MySql存储引擎" class="headerlink" title="MySql存储引擎"></a>MySql存储引擎</h4><p>MySql数据库常用存储引擎：InnoDB、MyISAM、NDB、Memory(HEAP)、Archive、BDB(BerkeleyDB)、Federated、Maria等。</p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">InnoDB</th>
<th align="center">MyISAM</th>
<th align="center">NDB</th>
<th align="center">Memory</th>
<th align="center">Archive</th>
<th align="center">BDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存储限制</td>
<td align="center">64TB</td>
<td align="center">No</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">No</td>
<td align="center">No</td>
</tr>
<tr>
<td align="center">事务</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">锁粒度</td>
<td align="center">Row</td>
<td align="center">Table</td>
<td align="center">Row</td>
<td align="center">Table</td>
<td align="center">Row</td>
<td align="center">Page</td>
</tr>
<tr>
<td align="center">MVCC</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center">Yes</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">B树索引</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">哈希索引</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">全文索引</td>
<td align="center">5.6支持英文</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">集群索引</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">数据缓存</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">索引缓存</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">数据压缩</td>
<td align="center"></td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">Yes</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">加密传输</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">批量插入</td>
<td align="center">相对低</td>
<td align="center">高</td>
<td align="center">高</td>
<td align="center">高</td>
<td align="center">非常高</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">内存消耗</td>
<td align="center">高</td>
<td align="center">低</td>
<td align="center">高</td>
<td align="center">中</td>
<td align="center">低</td>
<td align="center">低</td>
</tr>
<tr>
<td align="center">存储空间消耗</td>
<td align="center">高</td>
<td align="center">低</td>
<td align="center">低</td>
<td align="center">N/A</td>
<td align="center">非常低</td>
<td align="center">低</td>
</tr>
<tr>
<td align="center">外键支持</td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">复制支持</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">查询缓存</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">备份恢复</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">数据字典更新</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">备份/时间点恢复</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">集群支持</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">Yes</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>泰国旅游攻略</title>
    <url>/%E6%97%85%E6%B8%B8/Thailand-Raiders/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="一、签证"><a href="#一、签证" class="headerlink" title="一、签证"></a>一、签证</h3><ul>
<li><p>所需资料</p>
<ol>
<li>护照原件（无皮损，且有180天以上的有效期）</li>
<li>往返泰国的机票</li>
<li>携带20,000以上泰铢的现金或者等值货币（约3700-4000元人民币，汇率会有所波动，建议携带足够现金）过关时抽查，如没有携带足够的现金，有可能会被拒签或遣返。</li>
<li>1张2寸白底彩色照片（如没有带照片。可现场拍照，额外拍照费用100泰铢）<a id="more"></a></li>
</ol>
</li>
<li><p>费用</p>
<ol>
<li>1000泰铢手续费（目前落地签免费）</li>
<li>如没带照片，需现场拍照，加收100泰铢拍照费</li>
<li>只收泰铢现多，旁有兑换点，但汇率比较低，建议办理落地签，提前在国内换好所需泰铢费用。(中国银行可预约兑换泰铢，汇率约为1：5，实时汇率请咨询银行）</li>
</ol>
</li>
<li><p>落地签办理流程</p>
<ol>
<li>在机场按照指示牌找到“<code>Visa on Arrival</code>” （落地签）柜台</li>
<li>填写落地签申请表（柜台上就发放有表格，以及填写示例，最好<code>提前打印</code>下来填好）</li>
<li>递交资料（包括申请表、照片、护照、往返机票等），工作人员审核后给排队号</li>
<li>等叫号，上交资料和手续费，工作人员在你的护照上盖上落地签的章，病提供泰文收据等</li>
<li>走到“<code>For Visa-on-Arrival Only</code>”的柜台，入境官会再检查你的护照等资料，然后把出入境卡的入境部分撕掉，将出境卡盖章之后订在护照上，你就可以跨过边检柜台，正式进入泰国境内了</li>
<li>落地签的有效期是15天，即你可以在泰国逗留不超过15天的时间</li>
</ol>
</li>
</ul>
<h2 id="9-10北京出发"><a href="#9-10北京出发" class="headerlink" title="9.10北京出发"></a>9.10北京出发</h2><p>北京南站-&gt;天津站： <code>C2077 20：50-21：20 二等座 54.5￥</code><br><img src="/旅游/Thailand-Raiders/1.png" alt=""></p>
<h3 id="天津"><a href="#天津" class="headerlink" title="天津"></a>天津</h3><p>天津站-&gt;天津滨海国际机场T1航站楼  地铁二号线 <code>45min</code> 约<code>3￥</code><br><img src="/旅游/Thailand-Raiders/tianjin-airport.png" alt=""></p>
<p>约10点到达机场</p>
<p>天津滨海国际机场T1航站楼 -&gt;廊曼国际机场T1航站楼<br><code>SL963  23:50-03:35 +1 经济舱</code></p>
<h3 id="9-11泰国曼谷"><a href="#9-11泰国曼谷" class="headerlink" title="9.11泰国曼谷"></a>9.11泰国曼谷</h3><p>曼谷酒店位置：<code>455/4 Maha Chai Road</code>, Bangkok, Krung Thep Maha Nakhon 10200, Thailand<br><img src="/旅游/Thailand-Raiders/2.png" alt=""><br><img src="/旅游/Thailand-Raiders/455.jpeg" alt=""><br><img src="/旅游/Thailand-Raiders/455-2.jpeg" alt=""><br><img src="/旅游/Thailand-Raiders/455-3.jpeg" alt=""></p>
<p>廊曼国际机场T1航站楼 -&gt;曼谷酒店 <code>455/4 Maha Chai Road</code><br>淘宝下单接送机，或者携程下单（建议携程，航班延误可以2小时免费等）。<br>到酒店睡觉啦啦啦啦</p>
<h4 id="9-11-10-00"><a href="#9-11-10-00" class="headerlink" title="9.11 10:00"></a>9.11 10:00</h4><p>浏览景点安排</p>
<p>大皇宫   <code>3h  500泰铢 111.5￥</code> 长袖，长裙不能露膝盖<br>卧佛寺  <code>0.5h  200泰铢 44￥</code><br>坐船 3泰铢<br>郑王庙  <code>0.5h  30泰铢  7￥</code><br>考山路夜市吃吃吃 <code>2h</code> </p>
<h3 id="9-12-泰国曼谷"><a href="#9-12-泰国曼谷" class="headerlink" title="9.12 泰国曼谷"></a>9.12 泰国曼谷</h3><p>退房<strong>（留小费）</strong></p>
<p>酒店-&gt;汽车站<br>begin<br><img src="/旅游/Thailand-Raiders/3.png" alt=""><br>1、步行到船站 船票单次<code>50🐷</code><br><img src="/旅游/Thailand-Raiders/4.png" alt=""><br>2、坐船<br><img src="/旅游/Thailand-Raiders/5.png" alt=""><br>3、下船后步行到BST车站<br><img src="/旅游/Thailand-Raiders/6.png" alt=""><br>4、坐上BST，约8站到达Ekkamai ，2号出站口出站下楼梯再向后方走100m就到了<br>end</p>
<p>汽车站买票：窗口正上方写着<code>Pattaya</code>就可以买票了约<code>108🐷</code>一位上下浮动 厕所<code>3🐷</code>一次<br>曼谷到芭提雅媒体7：00-20：00，每半小时一班车 <code>车程2h</code></p>
<h3 id="9-12-芭提雅"><a href="#9-12-芭提雅" class="headerlink" title="9.12 芭提雅"></a>9.12 芭提雅</h3><p>酒店位置：88/999,Moo.10 Building B Room No.999, Pattayasaisong Rd, Muang Pattaya, Amphoe Bang Lamung, Chang Wat Chon Buri 20150</p>
<h4 id="双条车"><a href="#双条车" class="headerlink" title="双条车"></a>双条车</h4><p>路线图<br><img src="/旅游/Thailand-Raiders/10.jpeg" alt=""><br><img src="/旅游/Thailand-Raiders/11.png" alt=""><br>上车不要说话，说话会被误认为包车，10🐷/人</p>
<h4 id="游玩路线"><a href="#游玩路线" class="headerlink" title="游玩路线"></a>游玩路线</h4><p>芭提雅车站在North Pattaya Road路 Bus Terminal<br>距酒店2.6公里，可以考虑步行<br><img src="/旅游/Thailand-Raiders/7.png" alt=""></p>
<p>东芭乐园 9：00-18：00 <code>800泰铢   178￥</code> 双条车<br><img src="/旅游/Thailand-Raiders/8.png" alt=""></p>
<p>四方水上市场 9：00-20：00<br><img src="/旅游/Thailand-Raiders/9.png" alt=""></p>
<p>蒂芬妮人妖秀  每天18：00、19：30、21：00共三场  <code>普通800🐷，vip1000🐷、金vip1200🐷   178￥</code> 双条车每人10🐷 或步行<br><img src="/旅游/Thailand-Raiders/Tiffany.png" alt=""></p>
<p>芭提雅海滩走一波 吃小吃</p>
<h3 id="9-13芭提雅"><a href="#9-13芭提雅" class="headerlink" title="9.13芭提雅"></a>9.13芭提雅</h3><p>格兰岛一日游：网上跟团即可<br>海上滑翔、海底漫步、摩托艇、香蕉船、浮潜。</p>
<h3 id="9-14芭提雅"><a href="#9-14芭提雅" class="headerlink" title="9.14芭提雅"></a>9.14芭提雅</h3><p>购物中心逛一逛</p>
<p>到Bus Terminal汽车站买票回曼谷：窗口正上方写着<code>Ekkamai</code>，最晚班次晚上11点</p>
<h3 id="9-14曼谷"><a href="#9-14曼谷" class="headerlink" title="9.14曼谷"></a>9.14曼谷</h3><p>曼谷酒店位置：Ratchaprarop Road Ratchaprarop Road indraCondo/177/209 soi saengkran/ratchprarop road, Khet Ratchathewi, Krung Thep Maha Nakhon 10400, Thailand, Khet Ratchathewi, Krung Thep Maha Nakhon 10400, Thailand</p>
<p><img src="/旅游/Thailand-Raiders/WechatIMG38.jpeg" alt=""><br><img src="/旅游/Thailand-Raiders/WechatIMG39.png" alt=""><br><img src="/旅游/Thailand-Raiders/WechatIMG40.png" alt=""></p>
<h4 id="9-15天津"><a href="#9-15天津" class="headerlink" title="9.15天津"></a>9.15天津</h4><p>预约接机（提前两天预定）</p>
<h2 id="泰国必买"><a href="#泰国必买" class="headerlink" title="泰国必买"></a>泰国必买</h2><p>BIG-C零食<br><img src="/旅游/Thailand-Raiders/Screenshot_2019-08-31-11-46-03-072_com.xingin.xhs.png" alt=""><br><img src="/旅游/Thailand-Raiders/Screenshot_2019-08-31-11-46-08-364_com.xingin.xhs.png" alt=""><br><img src="/旅游/Thailand-Raiders/Screenshot_2019-08-31-11-46-00-652_com.xingin.xhs.png" alt=""><br><img src="/旅游/Thailand-Raiders/Screenshot_2019-08-31-11-45-53-237_com.xingin.xhs.png" alt=""><br><img src="/旅游/Thailand-Raiders/Screenshot_2019-08-31-11-45-57-687_com.xingin.xhs.png" alt=""><br>711<br><img src="/旅游/Thailand-Raiders/Screenshot_2019-08-31-12-05-14-972_com.xingin.xhs.png" alt=""><br><img src="/旅游/Thailand-Raiders/Screenshot_2019-08-31-12-05-18-389_com.xingin.xhs.png" alt=""><br><img src="/旅游/Thailand-Raiders/Screenshot_2019-08-31-12-05-20-912_com.xingin.xhs.png" alt=""><br><img src="/旅游/Thailand-Raiders/Screenshot_2019-08-31-12-05-23-188_com.xingin.xhs.png" alt=""><br><img src="/旅游/Thailand-Raiders/Screenshot_2019-08-31-12-05-25-297_com.xingin.xhs.png" alt=""><br><img src="/旅游/Thailand-Raiders/Screenshot_2019-08-31-12-05-30-499_com.xingin.xhs.png" alt=""></p>
<h3 id="必买药品"><a href="#必买药品" class="headerlink" title="必买药品"></a>必买药品</h3><p><img src="/旅游/Thailand-Raiders/Screenshot_2019-08-31-13-11-50-782_com.xingin.xhs.png" alt=""><br><img src="/旅游/Thailand-Raiders/Screenshot_2019-08-31-13-11-56-133_com.xingin.xhs.png" alt=""><br><img src="/旅游/Thailand-Raiders/Screenshot_2019-08-31-13-12-27-105_com.xingin.xhs.png" alt=""></p>
<h3 id="必买化妆品"><a href="#必买化妆品" class="headerlink" title="必买化妆品"></a>必买化妆品</h3><p>欧莱雅唇膏、小黑瓶<br>ONLY 小白瓶<br>N7冰激凌面膜</p>
<h3 id="必逛"><a href="#必逛" class="headerlink" title="必逛"></a>必逛</h3><p>华歌尔内衣Wacoal（曼谷尚泰商圈和暹罗挨着central world 三/四楼）<br>Lee<br>LeVI’S（暹罗广场，国内五折）<br>everyandboy泰国本土美妆店<br>日本松本清（central world 三楼）<br><img src="/旅游/Thailand-Raiders/Screenshot_2019-08-31-14-05-58-003_com.xingin.xhs.png" alt=""></p>
<h2 id="泰国机场退税取货"><a href="#泰国机场退税取货" class="headerlink" title="泰国机场退税取货"></a>泰国机场退税取货</h2><p><img src="/旅游/Thailand-Raiders/Screenshot_2019-08-31-14-25-04-833_com.xingin.xhs.png" alt=""></p>
]]></content>
      <categories>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>旅游攻略</tag>
      </tags>
  </entry>
  <entry>
    <title>设置git忽略.idea文件</title>
    <url>/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/GIt-Ignore/</url>
    <content><![CDATA[<p>1.将.idea目录加入ignore：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'.idea'</span> &gt;&gt; .gitignore</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>2.从git中删除idea：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm -r --cached .idea</span><br></pre></td></tr></table></figure>

<p>3.将.gitignore文件加入git：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add .gitignore</span><br></pre></td></tr></table></figure>

<p>4.提交.gitignore文件，将.idea从代码仓库中忽略：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">'忽略.idea文件夹'</span></span><br></pre></td></tr></table></figure>

<p>5、Push到Git服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>项目搭建</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++强制类型转换</title>
    <url>/C/C++-01/</url>
    <content><![CDATA[<h2 id="C语言类型转换"><a href="#C语言类型转换" class="headerlink" title="C语言类型转换"></a>C语言类型转换</h2><p>c语言类型转换有如下两种(旧式转型)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(T)expression  <span class="comment">//将 expression 转型为T</span></span><br><span class="line">T(expression)  <span class="comment">//将 expression 转型为T</span></span><br></pre></td></tr></table></figure>

<h2 id="C-新式类型转换"><a href="#C-新式类型转换" class="headerlink" title="C++新式类型转换"></a>C++新式类型转换</h2><p>C++类型转换有如下四种</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="keyword">reinterpret_cast</span>&lt;T&gt;(expression)</span><br><span class="line"><span class="keyword">static_cast</span>&lt;T&gt;(expression)</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>一般用于移除对象的const与volatile。如下图所示，b可以修改a的值。但是注意，编译器会进行优化，将数字常量1替代a常量。所以<code>cout &lt;&lt; a &lt;&lt; endl;</code>输出为1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span>* b = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt; (&amp;a);</span><br><span class="line">	*b = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; *(&amp;a) &lt;&lt; <span class="string">" "</span> &lt;&lt; *b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：1 2 2</span></span><br></pre></td></tr></table></figure>

<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>dynamic_cast 主要作用是将指向<strong>派生类对象</strong>的<strong>基类指针或引用</strong>，安全的转换为指向<strong>派生类对象</strong>的<strong>派生类指针或引用</strong>，并使用转换后的指针调用派生类独有的函数(非虚函数)。如果转换指针转换失败，则将返回空指针；如果转换引用失败，则将会抛出一个名为std::bad_cast的异常。<br>在如下3种情况中转换可以成功</p>
<ul>
<li>expression的类型与待转换类型相同。则转换必定成功。</li>
<li>expression的类型为待转换类型的公有派生类。(指针向上转换)</li>
<li>expression的类型为待转换类型的公有基类时，必须满足以下两个要求，才会转换成功，否则转换失败。(指针向下转换)<ul>
<li>当expression为指向派生类的指针或引用派生类对象的基类引用。</li>
<li>基类中必须包含虚函数，也就是必须具备多态性。</li>
</ul>
</li>
</ul>
<p>假设有如下两个类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Base() &#123;&#125;</span><br><span class="line">	Base(<span class="built_in">string</span> s) : str(s) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Derived() &#123;&#125;</span><br><span class="line">	Derived(<span class="built_in">string</span> s, <span class="keyword">int</span> i) : Base(s), ival(i) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Base::Print();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ival &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PrintIval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ival &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> ival;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//基类指针指向派生类对象，基类中包含虚函数，符合向下转换规则。</span></span><br><span class="line">	Base* b = <span class="keyword">new</span> Derived(<span class="string">"test"</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//使用基类指针无法调用派生类独有的函数，编译无法通过</span></span><br><span class="line">	b-&gt;PrintIval();</span><br><span class="line">	<span class="comment">//类型转换至派生类指针就可以调用到派生类独有的函数</span></span><br><span class="line">	Derived* d = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt; (b);</span><br><span class="line">	d-&gt;PrintIval();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>reinterpret_cast 主要的作用为允许任意<strong>长度相同</strong>的对象之间进行转换，而转换的安全性，则全部由程序员所保证，它只关注对象之间长度是否相同，长度不相同则无法通过编译。注意，<strong>reinterpret_cast无法去掉源对象的const、volatile属性</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//将a的指针转化为长整型数</span></span><br><span class="line">	<span class="keyword">long</span> b = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">long</span>&gt;(&amp;a);</span><br><span class="line">	<span class="comment">//将空指针转化为长整型数</span></span><br><span class="line">	<span class="keyword">long</span> d = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">long</span>&gt;(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//编译报错 int 4字节，而指针8字节</span></span><br><span class="line">	<span class="keyword">int</span> e = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>&gt;(&amp;a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需注意在32位机器上，指针为4字节，而在64位机器上，指针为8字节。</p>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>static_cast 类似C语言强制类型转换，它可以完成如下一些转换</p>
<ul>
<li>编译器隐式执行的类型转换，如int与float、double与char、enum与int之间的转换等。(精度大-&gt;精度小使用位截断处理)</li>
<li>将任意类型表达式转换为void类型，或从void*指针中找回其中的值。</li>
<li>基类与派生类指针或引用类型之间的转换，注意，由派生类转换至基类时(向上转换)是安全的，由基类至派生类转换时(向下转换)是非安全的。<br>example(使用上述代码定义的类):<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> a = <span class="string">'a'</span>;</span><br><span class="line">	<span class="comment">//将 char -&gt; int</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(a);</span><br><span class="line">	</span><br><span class="line">	Base* b = <span class="keyword">new</span> Base(<span class="string">"123"</span>);</span><br><span class="line">	<span class="comment">//将 Base 转换为 void*</span></span><br><span class="line">	<span class="keyword">void</span>* v = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(b);</span><br><span class="line">	<span class="comment">//将 *void 转换为 Base</span></span><br><span class="line">	b = <span class="keyword">static_cast</span>&lt;Base*&gt;(v);</span><br><span class="line">	</span><br><span class="line">	Derived* d = <span class="keyword">new</span> Derived(<span class="string">"123"</span>, <span class="number">123</span>);</span><br><span class="line">	<span class="comment">//向上转换 将Derived* 转换为 Base*</span></span><br><span class="line">	Base* bb = <span class="keyword">static_cast</span>&lt;Base*&gt;(d);</span><br><span class="line">	<span class="comment">//向下转换 将Base* 转换为 Derived*</span></span><br><span class="line">	Derived* dd = <span class="keyword">static_cast</span>&lt;Derived*&gt;(b);</span><br><span class="line">	<span class="comment">//未定义的行为!非常危险!父类对象并不包含该函数，编译不会报错!</span></span><br><span class="line">	dd-&gt;PrintIval();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>一下内容取自effective C++</p>
<blockquote>
<p>如果可以，尽量避免转型，特别是在注重效率的代码中避免 dynamic_cast。如果有个设计需要转型的动作，试着发展无需转型的替代设计。<br>如果转型是必要的，试着将它隐藏至某个函数背后，客户随后可以调用该函数，而不需将转型放进他们的代码内。<br>宁可使用C++-style(新式转型)，不要使用旧式转型。前者很容易辨识出来，而且有其不同的职责。</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++右值引用</title>
    <url>/C/C++-02/</url>
    <content><![CDATA[<h2 id="左值与右值的区分"><a href="#左值与右值的区分" class="headerlink" title="左值与右值的区分"></a>左值与右值的区分</h2><p>在C++中，所有的值均被分为左值与右值之一。左值是指表达式结束后依然存在的<strong>持久化对象</strong>，右值是指表达式结束时就不再存在的<strong>临时对象</strong>。所有的具名变量或者对象都是左值，而右值不具名。有一个很简单的方法区别左值与右值，<strong>观察是否可以对表达式进行取地址，如果能，则为左值，否则为右值。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> func;&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = func();</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br><span class="line"><span class="keyword">int</span> d = c;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>如上图所示，第2行的 a显然是左值，而(1 + 2)产生的临时变量值则为右值。同理第3行的b为左值，而func()的返回值同样是一个临时变量，为右值。第4行的c为左值，而(a+b)作为临时变量则为右值，而第5行中，d与c都为左值。套用上述的区别方法，a,b,c,d变量均可以进行取地址操作，而(1+2), func()返回值, (a+b)我们都无法取其地址。<br>如书中记载，在C++11中，右值分为<strong>纯右值</strong>与<strong>将亡值</strong>。纯右值指的就是我们上述所描述的各类临时变量。而将亡值则是c++11新增的和右值引用相关的表达式，这样的表达式通常时将要移动的对象、T&amp;&amp;函数返回值、std::move()函数的返回值等，将亡值与纯右值均为右值，使用没有任何区别。</p>
<h2 id="左值引用与右值引用"><a href="#左值引用与右值引用" class="headerlink" title="左值引用与右值引用"></a>左值引用与右值引用</h2><p>在C++11前引用已经非常常见了，就是给变量取了一个别名，如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;a = b;</span><br><span class="line"><span class="keyword">int</span> &amp;c = <span class="number">2</span>;   <span class="comment">//编译错误!</span></span><br></pre></td></tr></table></figure>

<p>需注意，在定义左值引用的同时，我们不能将右值绑定至左值引用上，如上面第3行代码所示。<br>而C++的右值引用同左值引用相似，则使用 &amp;&amp; 来表示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; b = (<span class="number">1</span> + <span class="number">2</span>) * <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; c = func();</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; d = a;    <span class="comment">//编译错误!</span></span><br></pre></td></tr></table></figure>

<p>同左值引用相同，在定义右值引用的同时，我们不能将左值绑定在右值引用上，如上面第5行所示。<br>也就是说，右值引用只能绑定右值，左值引用只能绑定左值。<br>若希望将一个左值绑定到右值引用，则可以使用<strong>移动语义</strong><code>std::move()</code>将左值转换为右值，例如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;b = <span class="built_in">std</span>::move(a);  <span class="comment">//编译通过</span></span><br></pre></td></tr></table></figure>

<p>但是注意，<strong>使用移动移动语义转移对象a后，a不可再次被使用</strong>!<br>除了普通引用，还有一类我们经常使用到的引用，<strong>常量左值引用</strong>。大家可以显而易见的发现，常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。但是在它的存活时期中，它只能是可读的。我们常在函数参数中使用到它，如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"1234"</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"1234"</span>)</span></span>;</span><br><span class="line">	func(s1);                  <span class="comment">//非常量左值</span></span><br><span class="line">	func(s2);                  <span class="comment">//常量左值</span></span><br><span class="line">	func(<span class="built_in">string</span>(<span class="string">"1234"</span>));      <span class="comment">//右值</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在如上介绍中很容易可以得出一下结论(转载图片)：<br><img src="/C/C++-02/1.png" alt="表格1"></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka-生产者</title>
    <url>/Kafka/Kafka-Producer/</url>
    <content><![CDATA[<h2 id="Kafka生产者"><a href="#Kafka生产者" class="headerlink" title="Kafka生产者"></a>Kafka生产者</h2><p>kafka数据生产流程如图：<br><img src="/Kafka/Kafka-Producer/cert_override.png" alt=""></p>
<a id="more"></a>
<ol>
<li>创建一个 ProducerRecord 对象,包括目标主题和要发送的内容</li>
<li>将对象序列化成字节数组</li>
<li>数据被传给分区：<ul>
<li>是否指定了partition -&gt; 直接到指定分区</li>
<li>是否指定了key -&gt; 分区器使用该 key 进行 hash 操作，然后对 topic 对应的分区数量进行取模操作并返回一个分区。</li>
<li>没有指定key -&gt; 则通过先产生随机数，之后在该数上自增的方式产生一个数，并转为正数之后进行取余操作。</li>
</ul>
</li>
<li>添加到批次，并发送</li>
<li>服务器收到消息后返回响应<ul>
<li>成功 -&gt; 返回 RecordMetaData对象</li>
<li>失败 -&gt; 返回错误信息</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>JAVA</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka-MacOs安装</title>
    <url>/Kafka/Kafka-Install/</url>
    <content><![CDATA[<h3 id="MacOS-Docker-安装"><a href="#MacOS-Docker-安装" class="headerlink" title="MacOS Docker 安装"></a>MacOS Docker 安装</h3><p>安装和镜像加速参考<a href="https://www.runoob.com/docker/macos-docker-install.html" target="_blank" rel="noopener">docker安装教程</a></p>
<h3 id="Docker-下载Zookeeper-和-kafka-镜像"><a href="#Docker-下载Zookeeper-和-kafka-镜像" class="headerlink" title="Docker 下载Zookeeper 和 kafka 镜像"></a>Docker 下载Zookeeper 和 kafka 镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ » docker pull zookeeper:latest</span><br><span class="line">~ » docker pull wurstmeister/kafka:latest</span><br><span class="line">~ » docker pull sheepkiller/kafka-manager</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>1、创建网络：由于要涉及到zookeeper和kafka之间的通信，所以我们运用docker内部容器通信机制先新建一个网络。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ » docker network create app</span><br><span class="line"></span><br><span class="line">d481270a05236007178e6ed0ce4b775c9d2aebb6c13bc050bb852bc46ca0b874</span><br></pre></td></tr></table></figure>

<p>运行 docker network ls查看新建的网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ » docker network ls                  </span><br><span class="line"></span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">d481270a0523        app                 bridge              <span class="built_in">local</span></span><br><span class="line">0ab6b1467267        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">cd08298f526b        host                host                <span class="built_in">local</span></span><br><span class="line">86a734066770        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure>

<p>运行docker network inspect app查看网络详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ » docker network inspect app                        </span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"app"</span>,</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"d481270a05236007178e6ed0ce4b775c9d2aebb6c13bc050bb852bc46ca0b874"</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2019-07-19T06:57:10.768655482Z"</span>,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"bridge"</span>,</span><br><span class="line">        <span class="string">"EnableIPv6"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"IPAM"</span>: &#123;</span><br><span class="line">            <span class="string">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">"Config"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"Subnet"</span>: <span class="string">"172.18.0.0/16"</span>,</span><br><span class="line">                    <span class="string">"Gateway"</span>: <span class="string">"172.18.0.1"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Internal"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Attachable"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Ingress"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"ConfigFrom"</span>: &#123;</span><br><span class="line">            <span class="string">"Network"</span>: <span class="string">""</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"ConfigOnly"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Containers"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>可以看到其连接的containers为空，说明还没有容器连接进来<br>2、创建Zookeeper容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ » docker run --net=app --name zookeeper -p 2181 -t zookeeper</span><br></pre></td></tr></table></figure>

<p>遇到了如下问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker: Error response from daemon: Conflict. The container name <span class="string">"/zookeeper"</span> is already <span class="keyword">in</span> use by container <span class="string">"26ffbd391e8c6e5e90b8f593e354f80768f179741e1de35640efacc6303fdad0"</span>. You have to remove (or rename) that container to be able to reuse that name.</span><br><span class="line">See <span class="string">'docker run --help'</span>.</span><br></pre></td></tr></table></figure>

<p>docker ps -l 查看发现已经创建的zookeeper 可以使用docker rm 删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ » docker ps -l                                       </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">26ffbd391e8c        zookeeper           <span class="string">"/docker-entrypoint.…"</span>   8 minutes ago       Created                                 zookeeper</span><br><span class="line"></span><br><span class="line">~ » docker rm 26ffbd391e8c</span><br></pre></td></tr></table></figure>

<p>重新执行创建命令</p>
<div class="note info"><p>run，创建新容器，并为容器配置一些参数。</p>
<p>-t，在容器内部创建一个tty或者伪终端。</p>
<p>-i，允许主机终端按照容器内部的标准与其交互。</p>
<p>-d，后台运行容器并打印容器名称。</p>
<p>–name，容器名称。</p>
<p>-p，端口映射，参数格式为：主机物理端口:容器内部端口。</p>
<p>最后跟上的就是我们已经下载的镜像</p></div>

<p>3、创建Kafka容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ » docker run --net=app --name kafka -p 9092 \</span><br><span class="line">--env HOST_IP=127.0.0.1 \</span><br><span class="line">--env KAFKA_ADVERTISED_HOST_NAME=localhost  \</span><br><span class="line">--env KAFKA_ADVERTISED_PORT=9092 \</span><br><span class="line">--env KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 \</span><br><span class="line">--link zookeeper \</span><br><span class="line">wurstmeister/kafka:latest</span><br></pre></td></tr></table></figure>

<div class="note info"><p>-e，配置容器环境变量。</p>
<p>–link，链接到另一个容器，参数格式为：目标容器名称:在本容器内的别名。</p>
<p>这里的环境变量设置，其实是就是对即将创建的Kafka配置文件server.properties进行初始化。</p></div>

<p>4、创建kafka-manager</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ » docker run --net=app \</span><br><span class="line">--name kafka-manager \</span><br><span class="line">-p 9000:9000 \</span><br><span class="line">-e ZK_HOSTS=zookeeper:2181 \</span><br><span class="line">sheepkiller/kafka-manager</span><br></pre></td></tr></table></figure>

<p>访问ip:9000即可</p>
<p>5、测试Kafka<br>进入kafka容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ » docker <span class="built_in">exec</span> -it kafka /bin/bash</span><br></pre></td></tr></table></figure>

<p>发送消息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash-4.4<span class="comment"># kafka-console-producer.sh --broker-list localhost:9092 --topic test</span></span><br><span class="line">&gt;hello</span><br><span class="line">&gt;AAAA</span><br><span class="line">&gt;BBBB</span><br><span class="line">&gt;hey</span><br></pre></td></tr></table></figure>

<p>读取消息(需要打开另一个终端)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash-4.4<span class="comment"># kafka-console-consumer.sh \</span></span><br><span class="line">&gt; --bootstrap-server localhost:9092 \</span><br><span class="line">&gt; --topic <span class="built_in">test</span> --from-beginning</span><br><span class="line">hello</span><br><span class="line">AAAA</span><br><span class="line">BBBB</span><br><span class="line">hey</span><br></pre></td></tr></table></figure>

<p>测试成功！(＾－＾)V</p>
<blockquote>
<p>参考<a href="https://cloud.tencent.com/developer/news/371290" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/371290</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>JAVA</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot + MyBatis 多模块项目搭建</title>
    <url>/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/Project-Module/</url>
    <content><![CDATA[<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><h4 id="开发工具及系统环境"><a href="#开发工具及系统环境" class="headerlink" title="开发工具及系统环境"></a>开发工具及系统环境</h4><ul>
<li>IDE：IntelliJ IDEA 2019.1</li>
<li>系统环境：mac OSX</li>
</ul>
<h4 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h4><ul>
<li>biz层：业务逻辑层</li>
<li>dao层：数据持久层，使用MB插件生成相关代码及xml</li>
<li>common层：提供工程层面的基础工具类。</li>
<li>web层：请求处理层<a id="more"></a>
<h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3></li>
</ul>
<h4 id="搭建父工程"><a href="#搭建父工程" class="headerlink" title="搭建父工程"></a>搭建父工程</h4><p>1、 IDEA 工具栏选择菜单 File -&gt; New -&gt; Project…<br><img src="/项目搭建/Project-Module/1.png" alt=""><br>2、选择Spring Initializr，Initializr默认选择Default，点击Next<br><img src="/项目搭建/Project-Module/2.png" alt=""><br>3、填写项目资料,点击Next<br><img src="/项目搭建/Project-Module/3.png" alt=""><br>4、直接点击Next<br><img src="/项目搭建/Project-Module/4.png" alt=""><br>5、填写name，点击Finish<br><img src="/项目搭建/Project-Module/5.png" alt=""><br>6、项目结构如下<br><img src="/项目搭建/Project-Module/6.png" alt=""><br>7、删除多余目录，只留如下结构<br><img src="/项目搭建/Project-Module/7.png" alt=""></p>
<h4 id="创建子模块"><a href="#创建子模块" class="headerlink" title="创建子模块"></a>创建子模块</h4><p>8、选择项目根目录,右键-&gt;New -&gt; Module<br><img src="/项目搭建/Project-Module/8.png" alt=""><br>9、选择Maven，点击Next<br><img src="/项目搭建/Project-Module/9.png" alt=""><br>10、填写ArifactId，点击Next<br><img src="/项目搭建/Project-Module/10.png" alt=""><br>11、点击Finish<br><img src="/项目搭建/Project-Module/11.png" alt=""><br>12、同理添加其他子模块，最终项目目录结构如下图<br><img src="/项目搭建/Project-Module/12.png" alt=""></p>
<h4 id="模块间依赖关系"><a href="#模块间依赖关系" class="headerlink" title="模块间依赖关系"></a>模块间依赖关系</h4><p>各个子模块的依赖关系：</p>
<ul>
<li>biz层：依赖dao层，common层</li>
<li>dao层：不依赖</li>
<li>common层：不依赖</li>
<li>web层：依赖biz层，common层。</li>
</ul>
<p>13、父pom文件中声明所有子模块依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>biz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dao<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>14、biz层pom文件中添加dao层，common层依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dao<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>15、web层pom文件中添加biz层，common层依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>biz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h4><p>16、在web层pom文件中添加spring-boot-starter-web</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-boot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>17、在web层创建com.example.test.demo.web包并添加入口类AppServiceApplication.java，目录结构如下<br><img src="/项目搭建/Project-Module/17.png" alt=""><br>入口类代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example.test.demo.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppServiceApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AppServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>18、在com.example.test.demo.web包下创建controller目录添加test方法测试接口是否可以正常访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test.demo.web.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"demo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>19、运行AppServiceApplication中的main方法启动项目，默认端口为8080，访问<a href="http://localhost:8080/demo/test得到如下效果" target="_blank" rel="noopener">http://localhost:8080/demo/test得到如下效果</a><br><img src="/项目搭建/Project-Module/19.png" alt=""></p>
<p>20、在biz层创建com.example.test.demo.biz包并创建DemoService接口类代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test.demo.biz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>21、在com.example.test.demo.biz包下创建impl目录并添加DemoServiceImpl类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test.demo.biz.impl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.test.demo.biz.DemoService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"biz test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>22、DemoController类通过@Autowired注解注入DemoService，修改DemoController的test方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test.demo.web.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.test.demo.biz.DemoService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"demo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>23、在入口类AppServiceApplication上添加@ComponentScan注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test.demo.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;</span><br><span class="line">        <span class="string">"com.example.test.demo.*"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppServiceApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AppServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>24、更改完之后运行main方法，访问<a href="http://localhost:8080/demo/test得到如下效果" target="_blank" rel="noopener">http://localhost:8080/demo/test得到如下效果</a><br><img src="/项目搭建/Project-Module/24.png" alt=""></p>
<p>25、其他层同理验证。</p>
<h4 id="集成Mybatis"><a href="#集成Mybatis" class="headerlink" title="集成Mybatis"></a>集成Mybatis</h4><p>26、父pom文件中声明mybatis-spring-boot-starter、mysql-connector-java等依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>biz<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>common<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>web<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql-connector.version</span>&gt;</span>8.0.11<span class="tag">&lt;/<span class="name">mysql-connector.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mybatis.generator.version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">mybatis.generator.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.generator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql-connector.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.generator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>biz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dao<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- mysql --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql-connector.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>27、在dao层中的pom文件中添加以下依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>$&#123;basedir&#125;/src/main/resources/mybatis-generator.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>28、在web/src/main/resources下添加application.properties</p>
<ul>
<li><strong>com.mysql.jdbc.Driver</strong> 是 mysql-connector-java 5中的</li>
<li><strong>com.mysql.cj.jdbc.Driver</strong> 是 mysql-connector-java 6中的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.datasource.driverClassName = com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.url = jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF8&amp;connectTimeout=1000&amp;socketTimeout=3000</span><br><span class="line">spring.datasource.username = root</span><br><span class="line">spring.datasource.password = qwertyui</span><br><span class="line"></span><br><span class="line">mybatis.type-aliases-package = com.example.test.demo.dao.po</span><br><span class="line">mybatis.mapper-locations = classpath:mapper/*.xml</span><br></pre></td></tr></table></figure>

<p>29、在web/src/main/resources下添加mybatis-generator.xml配置内容如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE generatorConfiguration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入SpringBoot配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"application.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"Mysql"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3"</span> <span class="attr">defaultModelType</span>=<span class="string">"flat"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 生成的pojo，将implements Serializable--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">type</span>=<span class="string">"org.mybatis.generator.plugins.SerializablePlugin"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--*是否去除自动生成的注释包含时间戳 true：是 ： false:否--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressDate"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressAllComments"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"$&#123;spring.datasource.driverClassName&#125;"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">"$&#123;spring.datasource.url&#125;"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">"$&#123;spring.datasource.username&#125;"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">"$&#123;spring.datasource.password&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       生成model模型，对应的包路径，以及文件存放路径(targetProject)，targetProject可以指定具体的路径,如./src/main/java，</span></span><br><span class="line"><span class="comment">       也可以使用“MAVEN”来自动生成，这样生成的代码会在target/generatord-source目录下</span></span><br><span class="line"><span class="comment">       --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.example.test.demo.dao.po"</span> <span class="attr">targetProject</span>=<span class="string">"../dao/src/main/java"</span> &gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 从数据库返回的值被清理前后的空格 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--对应的mapper.xml文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"mapper"</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">targetProject</span>=<span class="string">"../dao/src/main/resources"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 对应的Mapper接口类文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span> <span class="attr">targetPackage</span>=<span class="string">"com.example.test.demo.dao.mapper"</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">targetProject</span>=<span class="string">"../dao/src/main/java"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 表名及对应po类名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"user_info"</span> <span class="attr">domainObjectName</span>=<span class="string">"UserInfoPO"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableCountByExample</span>=<span class="string">"true"</span> <span class="attr">enableUpdateByExample</span>=<span class="string">"true"</span> <span class="attr">enableDeleteByExample</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableSelectByExample</span>=<span class="string">"true"</span> <span class="attr">selectByExampleQueryId</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useActualColumnNames"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generatedKey</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">identity</span>=<span class="string">"true"</span> <span class="attr">sqlStatement</span>=<span class="string">"MySql"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>30、根据表自动生成对应的Mapper以及po类,步骤如下。<br><img src="/项目搭建/Project-Module/30.1.png" alt=""><br>得到目录如下<br><img src="/项目搭建/Project-Module/30.2.png" alt=""></p>
<p>30、biz层下DemoServiceImpl通过@Autowired注解注入UserMapper，修改DemoService的test方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test.demo.biz.impl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.test.demo.biz.DemoService;</span><br><span class="line"><span class="keyword">import</span> com.example.test.demo.dao.mapper.UserInfoPOMapper;</span><br><span class="line"><span class="keyword">import</span> com.example.test.demo.dao.po.UserInfoPO;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserInfoPOMapper userInfoPOMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserInfoPO po = userInfoPOMapper.selectByPrimaryKey(<span class="number">1L</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"UserInfo name is:"</span> + po.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>31、在入口类AppServiceApplication上中添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.example.test.demo.dao.mapper"</span>)</span><br></pre></td></tr></table></figure>

<p>32、运行main方法启动项目<br><img src="/项目搭建/Project-Module/32.png" alt=""></p>
<h3 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h3><p>mybatis 自动生成时遇到</p>
<blockquote>
<p>Client does not support authentication protocol requested by server; consider upgrading MySQL client</p>
</blockquote>
<p>解决方法登录mysql：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'qwertyui'</span>;</span><br><span class="line">SELECT plugin FROM mysql.user WHERE User = <span class="string">'root'</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>项目搭建</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>教程</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka背景及架构介绍</title>
    <url>/Kafka/Kafka-Background/</url>
    <content><![CDATA[<h2 id="Kafka创建背景"><a href="#Kafka创建背景" class="headerlink" title="Kafka创建背景"></a>Kafka创建背景</h2><p>kafka最初是LinkedIn的一个内部基础设施系统。最初开发的起因是，LinkedIn虽然有了数据库和其他系统可以用来存储数据，但是缺乏一个可以帮助处理持续数据流的组件。它的设计目的是提供一个高性能的消息系统，可以处理多种类型数据，并能够实时提供纯洁且结构化的用户活动数据和系统度量指标。</p>
<a id="more"></a>
<h2 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h2><p>Kafka是由LinkedIn开发，使用Scala编写的一个分布式的消息系统，具有高性能、持久化、多副本备份、横向扩展能力。生产者往队列里写消息，消费者从队列里取消息进行业务逻辑。一般在架构设计中起到解耦、削峰、异步处理的作用。</p>
<p>kafka对外使用topic的概念，生产者往topic里写消息，消费者从读消息。为了做到水平扩展，一个topic实际是由多个partition组成的，遇到瓶颈时，可以通过增加partition的数量来进行横向扩容。单个parition内是保证消息有序。</p>
<p>每新写一条消息，kafka就是在对应的文件append写，所以性能非常高。</p>
<h2 id="Kafka架构"><a href="#Kafka架构" class="headerlink" title="Kafka架构"></a>Kafka架构</h2><h3 id="一、名词解释"><a href="#一、名词解释" class="headerlink" title="一、名词解释"></a>一、名词解释</h3><ul>
<li><strong>Broker</strong>：消息中间件处理节点（服务器），一个节点就是一个broker，一个Kafka集群由一个或多个broker组成</li>
<li><strong>Topic</strong>：Kafka对消息进行归类，发送到集群的每一条消息都要指定一个topic</li>
<li><strong>Partition</strong>：物理上的概念，每个topic包含一个或多个partition，一个partition对应一个文件夹，这个文件夹下存储partition的数据和索引文件，每个partition内部是有序的</li>
<li><strong>Producer</strong>：生产者，负责发布消息到broker</li>
<li><strong>Consumer</strong>：消费者，从broker读取消息</li>
<li><strong>ConsumerGroup</strong>：每个consumer属于一个特定的consumer group，可为每个consumer指定group name，若不指定，则属于默认的group，一条消息可以发送到不同的consumer group，但一个consumer group中只能有一个consumer能消费这条消息</li>
<li><strong>replica</strong>：partition 的副本，保障 partition 的高可用。</li>
<li><strong>leader</strong>：replica 中的一个角色， producer 和 consumer 只跟 leader 交互。</li>
<li><strong>follower</strong>：replica 中的一个角色，从 leader 中复制数据。</li>
<li><strong>controller</strong>：每个集群都有一个broker同时充当了集群控制器角色（自动从集群的活跃成员中选举出来），负责管理工作包括分配分区给broker，监控broker等等</li>
<li><strong>zookeeper</strong>：Kafka 通过 zookeeper 来存储集群的 meta 信息。</li>
</ul>
<h3 id="二、架构图"><a href="#二、架构图" class="headerlink" title="二、架构图"></a>二、架构图</h3><h4 id="总体数据流"><a href="#总体数据流" class="headerlink" title="总体数据流"></a>总体数据流</h4><p><img src="/Kafka/Kafka-Background/1.png" alt=""><br>Producers往Brokers里面的指定Topic中写消息，Consumers从Brokers里面拉去指定Topic的消息，然后进行业务处理。</p>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p><img src="/Kafka/Kafka-Background/2.png" alt=""><br>①首先要构造一个 ProducerRecord 对象，该对象可以声明主题Topic、分区Partition、键 Key以及值 Value，主题和值是必须要声明的，分区和键可以不用指定。</p>
<p>②调用send() 方法进行消息发送。</p>
<p>③因为消息要到网络上进行传输，所以必须进行序列化，序列化器的作用就是把消息的 key 和 value对象序列化成字节数组。</p>
<p>④接下来数据传到分区器，如果之间的 ProducerRecord 对象指定了分区，那么分区器将不再做任何事，直接把指定的分区返回；如果没有，那么分区器会根据 Key 来选择一个分区，选择好分区之后，生产者就知道该往哪个主题和分区发送记录了。</p>
<p>⑤接着这条记录会被添加到一个记录批次里面，这个批次里所有的消息会被发送到相同的主题和分区。会有一个独立的线程来把这些记录批次发送到相应的 Broker 上。</p>
<p>③Broker成功接收到消息，表示发送成功，返回消息的元数据（包括主题和分区信息以及记录在分区里的偏移量）。发送失败，可以选择重试或者直接抛出异常。</p>
<p>key的作用：可以为消息的附加消息，也可以用来决定消息该被写到哪个主题分区，拥有相同key的消息将会被写到同一分区</p>
<h4 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h4><p><img src="/Kafka/Kafka-Background/3.jpg" alt=""><br>从上图可以看出，Topic中数据是顺序不可变序列，采用log追加方式写入，因而kafka中无因随机写入导致性能低下的问题。</p>
<p>Topic的数据可存储在多个partition中，即可存放在不同的服务器上。这可使Topic大小不限于一台server容量。同时，消息存在多个partition上，可以实现Topic上消息的并发访问。</p>
<h4 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h4><p><img src="/Kafka/Kafka-Background/4.jpg" alt=""></p>
<p>每个 Partition 中的消息都是有序的，生产的消息被不断追加到 Partition log 上，其中的每一个消息都被赋予了一个唯一的 offset 值。 因此数据不会因消费而丢失，所以只要consumer指定offset，一个消息可被不同的consumer多次消费。</p>
<p>kafka中只能保证partition中记录是有序的，而不保证topic中不同partition的顺序。</p>
<p>分区的原因：</p>
<ul>
<li>方便在集群中扩展，每个 Partition 可以通过调整以适应它所在的机器，而一个 topic 又可以有多个 Partition 组成，因此整个集群就可以适应任意大小的数据了;</li>
<li>可以提高并发，因为可以以 Partition 为单位读写了。</li>
</ul>
<h4 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h4><p>同一个 partition 可能会有多个 replication(对应 server.properties 配置中的 default.replication.factor=N)。</p>
<p>没有 replication 的情况下，一旦 broker 宕机，其上所有 patition 的数据都不可被消费，同时 producer 也不能再将数据存于其上的 patition。</p>
<p>引入 replication 之 后，同一个 partition 可能会有多个 replication，而这时需要在这些 replication 之间选出一个 leader，producer 和 consumer 只与这个 leader 交互，其它 replication 作为 follower 从 leader 中复制数据。</p>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p><img src="/Kafka/Kafka-Background/5.jpeg" alt=""><br>订阅topic是以一个消费组来订阅的，一个消费组里面可以有多个消费者。</p>
<p>同一个消费组中的两个消费者，不会同时消费一个partition。换句话来说，<code>就是一个partition，只能被消费组里的一个消费者消费</code>，但是可以同时被多个消费组消费。</p>
<p>因此，如果消费组内的消费者如果比partition多的话，那么就会有个别消费者一直空闲。</p>
<h3 id="Kafka-Zookeeper-节点"><a href="#Kafka-Zookeeper-节点" class="headerlink" title="Kafka Zookeeper 节点"></a>Kafka Zookeeper 节点</h3><p><img src="/Kafka/Kafka-Background/6.png" alt=""></p>
<h2 id="Kafka常见的应用场景"><a href="#Kafka常见的应用场景" class="headerlink" title="Kafka常见的应用场景"></a>Kafka常见的应用场景</h2><h4 id="1-消息队列"><a href="#1-消息队列" class="headerlink" title="1.消息队列"></a>1.消息队列</h4><p>比起大多数的消息系统来说，Kafka有更好的吞吐量，内置的分区，冗余及容错性，这让Kafka成为了一个很好的大规模消息处理应用的解决方案。 消息系统一般吞吐量相对较低，但是需要更小的端到端延时，并尝尝依赖于Kafka提供的强大的持久性保障。在这个领域，Kafka足以媲美传统消息系统， 如ActiveMQ或RabbitMQ。</p>
<h4 id="2-行为跟踪"><a href="#2-行为跟踪" class="headerlink" title="2.行为跟踪"></a>2.行为跟踪</h4><p>行为跟踪是kafka基于发布订阅模式的扩展应用，当我们跟踪用户浏览页面、搜索及其他行为时，以发布-订阅的模式实时记录到对应的topic里那么这些结果被订阅者拿到后，就可以做进一步的实时处理，或实时监控，或放到hadoop/离线数据仓库里处理。</p>
<h4 id="3-元信息监控"><a href="#3-元信息监控" class="headerlink" title="3.元信息监控"></a>3.元信息监控</h4><p>与行为跟踪相似，作为操作记录的监控模块来使用，即汇集记录一些操作信息，可以理解为运维性质的数据监控吧。</p>
<h4 id="4-日志收集"><a href="#4-日志收集" class="headerlink" title="4.日志收集"></a>4.日志收集</h4><p>日志收集方面，其实开源产品有很多，包括Scribe、Apache Flume。很多人使用Kafka代替日志聚合（log aggregation）。日志聚合一般来说是从服务器上收集日志文件，然后放到一个集中的位置（文件服务器或分布式文件系统）进行处理。然而Kafka忽略掉文件的细节，将其更清晰地抽象成一个个日志或事件的消息流。这就让Kafka处理过程延迟更低，更容易支持多数据源和分布式数据处理。比其他系统Kafka具有更高的扩展性，高效的性能和因为复制导致的更高的耐用性保证，以及更低的端到端延迟。</p>
<h4 id="5-流处理"><a href="#5-流处理" class="headerlink" title="5.流处理"></a>5.流处理</h4><p>保存收集上游的流数据，以提供到下游的Storm或其他流式计算框架进行处理。很多用户会将那些从原始topic来的数据进行阶段性处理，汇总，扩充或者以其他的方式转换到新的topic下再继续后面的处理。例如一个文章推荐的处理流程，可能是先从数据源中抓取文章的内容，然后将其丢入一个叫做“文章”的topic中；后续操作可能是需要对这个内容进行清理，比如回复正常数据或者删除重复数据，最后再将内容匹配的结果返还给用户。这就在一个独立的topic之外，产生了一系列的实时数据处理的流程。Strom和Samza是非常著名的实现这种类型数据转换的框架。</p>
<h4 id="6-持久性日志（commit-log）"><a href="#6-持久性日志（commit-log）" class="headerlink" title="6.持久性日志（commit log）"></a>6.持久性日志（commit log）</h4><p>Kafka可以为一种外部的持久性日志的分布式系统提供服务。这种日志可以在节点之外进行持久性日志的记录，节点间备份数据，并为故障节点数据回复提供一种重新同步的机制。Kafka中提供了日志压缩功能，日志压缩之后整体的日志状态仍然保留，并且通过日志回溯可以实现持久性日志的功能。在这种用法中，Kafka类似于Apache BookKeeper项目。</p>
<h4 id="7-事件源"><a href="#7-事件源" class="headerlink" title="7.事件源"></a>7.事件源</h4><p>将状态转移作为按时间顺序排列的记录序列，这种序列可以按时间回溯整个事件的状态变更，kafka本身的持久性，代表着他可以存储大量的日志，并且这些可以根据这些日志进行汇总和回溯等等。</p>
<p><code>实际应用中，适用最多最广泛的自然是MQ的功能。</code></p>
<h2 id="Kafka用作MQ时与常用MQ的对比"><a href="#Kafka用作MQ时与常用MQ的对比" class="headerlink" title="Kafka用作MQ时与常用MQ的对比"></a>Kafka用作MQ时与常用MQ的对比</h2><p><strong>RabbitMQ</strong>——Rabbit Message Queue的简写，但不能仅仅理解其为消息队列，消息代理更合适。 RabbitMQ是一个由Erlang 语言开发的AMQP（高级消息队列协议）的开源实现。 RabbitMQ作为一个消息代理，主要和消息打交道，负责接收并转发消息。</p>
<p><strong>ZeroMQ</strong>——是一个基于消息队列的多线程网络库，其对套接字类型、连接处理、帧、甚至路由的底层细节进行抽象，提供跨越多种传输协议的套接字。是网络通信中新的一层，<code>介于应用层和传输层之间</code>（按照TCP/IP划分），其是一个可伸缩层，可并行运行，分散在分布式系统间。</p>
<p><strong>RocketMQ</strong>——阿里开源的一款高性能、高吞吐量的分布式消息中间件。</p>
<p><strong>ActiveMQ</strong>——是一种开源的，实现了JMS1.1规范的，面向消息(MOM)的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信。</p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">Kafka</th>
<th align="center">RabbitMQ</th>
<th align="center">ZeroMQ</th>
<th align="center">RocketMQ</th>
<th align="center">ActiveMQ</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开发语言</td>
<td align="center">Scala</td>
<td align="center">Erlang</td>
<td align="center">C</td>
<td align="center">Java</td>
<td align="center">Java</td>
</tr>
<tr>
<td align="center">支持协议</td>
<td align="center">自行设计的基于TCP层的协议</td>
<td align="center">AMQP</td>
<td align="center">TCP、UDP</td>
<td align="center">自行设计</td>
<td align="center">OpenWire、STOMP、REST、MQTT、XMPP、AMQP、WS</td>
</tr>
<tr>
<td align="center">消息存储</td>
<td align="center">内存、磁盘、数据库。支持大量堆积。</td>
<td align="center">内存、磁盘。支持少量堆积。</td>
<td align="center">消息发送端的内存或者磁盘中。不支持持久化。</td>
<td align="center">磁盘。支持大量堆积。</td>
<td align="center">内存、磁盘、数据库。支持少量堆积。</td>
</tr>
<tr>
<td align="center">消息事务</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">不支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">负载均衡</td>
<td align="center">支持</td>
<td align="center">支持但支持的不好</td>
<td align="center">去中心化，不支持负载均衡。本身只是一个多线程网络库。</td>
<td align="center">支持</td>
<td align="center">支持，可以基于zookeeper实现</td>
</tr>
<tr>
<td align="center">集群方式</td>
<td align="center">天然的‘‘Leader-Slave’无状态集群，每台服务器既是Master也是Slave。</td>
<td align="center">支持简单集群，’复制’模式，对高级集群模式支持不好。</td>
<td align="center">去中心化，不支持集群。</td>
<td align="center">‘Master-Slave’ 模式，开源版本需手动切换Slave变成Master</td>
<td align="center">支持简单集群模式，比如’主-备’，对高级集群模式支持不好。</td>
</tr>
<tr>
<td align="center">可用性</td>
<td align="center">非常高（分布式）</td>
<td align="center">高（主从）</td>
<td align="center">高</td>
<td align="center">非常高（分布式）</td>
<td align="center">高（主从）</td>
</tr>
<tr>
<td align="center">消息重复</td>
<td align="center">支持at least once、at most once</td>
<td align="center">支持at least once、at most once</td>
<td align="center">只有重传机制，但是没有持久化，消息丢了重传也没有用。既不是at least once、也不是at most once、更不是exactly only once</td>
<td align="center">支持at least once</td>
<td align="center">支持at least once</td>
</tr>
<tr>
<td align="center">吞吐量TPS</td>
<td align="center">极大</td>
<td align="center">比较大</td>
<td align="center">极大</td>
<td align="center">大（发送端不是批量发送）</td>
<td align="center">比较大</td>
</tr>
<tr>
<td align="center">时效性</td>
<td align="center">ms以内</td>
<td align="center">us级</td>
<td align="center"></td>
<td align="center">ms级</td>
<td align="center">ms级</td>
</tr>
<tr>
<td align="center">订阅形式和消息分发</td>
<td align="center">基于topic以及按照topic进行正则匹配的发布订阅模式。</td>
<td align="center">提供了4种方式：direct, topic ,Headers和fanout。</td>
<td align="center">点对点(p2p)</td>
<td align="center">基于topic/messageTag以及按照消息类型、属性进行正则匹配的发布订阅模式</td>
<td align="center">点对点(p2p)、广播（发布-订阅）</td>
</tr>
<tr>
<td align="center">顺序消息</td>
<td align="center">支持</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">消息确认</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">消息回溯</td>
<td align="center">支持指定分区offset位置的回溯</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
<td align="center">支持指定时间点的回溯</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">消费失败重试</td>
<td align="center">不支持，但可以通过指定分区offset位置实现。</td>
<td align="center">不支持，但是可以利用消息确认机制实现。</td>
<td align="center">不支持</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">并发度</td>
<td align="center">高</td>
<td align="center">极高</td>
<td align="center">高</td>
<td align="center">高</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">资料文档</td>
<td align="center">中。有kafka作者自己写的书，网上资料也有一些。</td>
<td align="center">多。有一些不错的书，网上资料多。</td>
<td align="center">少。没有专门写zeromq的书，网上的资料多是一些代码的实现和简单介绍。</td>
<td align="center">少。没有专门写rocketmq的书，网上的资料良莠不齐，官方文档很简洁，但是对技术细节没有过多的描述。</td>
<td align="center">多。没有专门写activemq的书，网上资料多。</td>
</tr>
</tbody></table>
<h3 id="常用MQ的优缺点"><a href="#常用MQ的优缺点" class="headerlink" title="常用MQ的优缺点"></a>常用MQ的优缺点</h3><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>性能卓越，单机写入TPS约在百万条/秒，最大的优点，就是吞吐量高。</li>
<li>时效性：ms级</li>
<li>可用性：非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</li>
<li>消费者采用Pull方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;</li>
<li>有优秀的第三方Kafka Web管理界面Kafka-Manager；</li>
<li>在日志领域比较成熟，被多家公司和多个开源项目使用；</li>
<li>功能支持：功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长</li>
<li>使用短轮询方式，实时性取决于轮询间隔时间；</li>
<li>消费失败不支持重试；</li>
<li>支持消息顺序，但是一台代理宕机后，就会产生消息乱序；</li>
<li>社区更新较慢；</li>
</ul>
<h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul>
<li>由于erlang语言的特性，mq 性能较好，高并发；</li>
<li>吞吐量到万级，MQ功能比较完备 </li>
<li>健壮、稳定、易用、跨平台、支持多种语言、文档齐全；</li>
<li>开源提供的管理界面非常棒，用起来很好用</li>
<li>社区活跃度高；</li>
</ul>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>erlang开发，很难去看懂源码，基本职能依赖于开源社区的快速维护和修复bug，不利于做二次开发和维护。</li>
<li>RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。</li>
<li>需要学习比较复杂的接口和协议，学习和维护成本较高。</li>
</ul>
<h4 id="ZeroMQ"><a href="#ZeroMQ" class="headerlink" title="ZeroMQ"></a>ZeroMQ</h4><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul>
<li>吞吐量：百万级</li>
<li>扩展性强，其他MQ都已经是成形的产品，已经是一款应用程序了。而ZeroMQ说白了就是一组库函数。</li>
</ul>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>原生不支持持久化，仅支持相当有限的本地缓存，如需要消息持久化需要自己进行扩展。</li>
<li>在高并发环境下不会出问题，但是有可能会导致本地的缓存区被塞满而导致消息丢失的情况。</li>
</ul>
<h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><ul>
<li>单机吞吐量：十万级</li>
<li>可用性：非常高，分布式架构</li>
<li>消息可靠性：经过参数优化配置，消息可以做到0丢失</li>
<li>功能支持：MQ功能较为完善，还是分布式的，扩展性好</li>
<li>支持10亿级别的消息堆积，不会因为堆积导致性能下降</li>
<li>源码是java，我们可以自己阅读源码，定制自己公司的MQ，可以掌控</li>
</ul>
<h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>支持的客户端语言不多，目前是java及c++，其中c++不成熟；</li>
<li>社区活跃度一般</li>
<li>MQ核心代码未遵循JMS规范，有些系统要迁移需要修改大量代码</li>
</ul>
<h4 id="RocketMQ-1"><a href="#RocketMQ-1" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><h5 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h5><ul>
<li>单机吞吐量：万级</li>
<li>topic数量都吞吐量的影响：</li>
<li>时效性：ms级</li>
<li>可用性：高，基于主从架构实现高可用性</li>
<li>消息可靠性：有较低的概率丢失数据</li>
<li>功能支持：MQ领域的功能极其完备</li>
<li>遵循JMS规范安装部署方便</li>
</ul>
<h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>在并发较多时，消费端只能接收一部分，会出现丢失消息情况，需重启消费端才能接收到那部分剩下的消息。</li>
<li>官方社区现在对ActiveMQ 5.x维护越来越少，较少在大规模吞吐的场景中使用。</li>
</ul>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>JAVA</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-list双向链表【学习笔记】</title>
    <url>/redis/Redis-adlist/</url>
    <content><![CDATA[<h2 id="list定义"><a href="#list定义" class="headerlink" title="list定义"></a>list定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前迭代到的节点</span></span><br><span class="line">    listNode *next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代的方向</span></span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line"></span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p><img src="/redis/Redis-adlist/list.png" alt="list"></p>
<h2 id="list常用函数"><a href="#list常用函数" class="headerlink" title="list常用函数"></a>list常用函数</h2><h3 id="listCreate-创建新链表"><a href="#listCreate-创建新链表" class="headerlink" title="listCreate-创建新链表"></a>listCreate-创建新链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的链表</span></span><br><span class="line"><span class="comment"> * @return  创建成功返回链表，失败返回 NULL</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> = zmalloc(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化属性</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listRelease-释放整个链表"><a href="#listRelease-释放整个链表" class="headerlink" title="listRelease-释放整个链表"></a>listRelease-释放整个链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放整个链表，以及链表中所有节点</span></span><br><span class="line"><span class="comment"> * @param list</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向头指针</span></span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="comment">// 遍历整个链表</span></span><br><span class="line">    len = <span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        next = current-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有设置值释放函数，那么调用它</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放节点结构</span></span><br><span class="line">        zfree(current);</span><br><span class="line"></span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放链表结构</span></span><br><span class="line">    zfree(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listAddNodeHead-添加新节点到链表头"><a href="#listAddNodeHead-添加新节点到链表头" class="headerlink" title="listAddNodeHead-添加新节点到链表头"></a>listAddNodeHead-添加新节点到链表头</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个包含有给定值指针 value 的新节点添加到链表的表头</span></span><br><span class="line"><span class="comment"> * @param list</span></span><br><span class="line"><span class="comment"> * @param value</span></span><br><span class="line"><span class="comment"> * @return 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL，如果执行成功，返回传入的链表指针</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为节点分配内存</span></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存值指针</span></span><br><span class="line">    node-&gt;value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加节点到空链表</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 添加节点到非空链表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;prev = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新链表节点数</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listAddNodeTail-添加新节点到链表尾"><a href="#listAddNodeTail-添加新节点到链表尾" class="headerlink" title="listAddNodeTail-添加新节点到链表尾"></a>listAddNodeTail-添加新节点到链表尾</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个包含有给定值指针 value 的新节点添加到链表的表尾</span></span><br><span class="line"><span class="comment"> * @param list</span></span><br><span class="line"><span class="comment"> * @param value 新节点</span></span><br><span class="line"><span class="comment"> * @return 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL，如果执行成功，返回传入的链表指针</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为新节点分配内存</span></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存值指针</span></span><br><span class="line">    node-&gt;value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标链表为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 目标链表非空</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail-&gt;next = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新链表节点数</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listInsertNode-将新节点添加到老节点之前或之后"><a href="#listInsertNode-将新节点添加到老节点之前或之后" class="headerlink" title="listInsertNode-将新节点添加到老节点之前或之后"></a>listInsertNode-将新节点添加到老节点之前或之后</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个包含值 value 的新节点，并将它插入到 old_node 的之前或之后</span></span><br><span class="line"><span class="comment"> * 如果 after 为 0 ，将新节点插入到 old_node 之前。</span></span><br><span class="line"><span class="comment"> * 如果 after 为 1 ，将新节点插入到 old_node 之后。</span></span><br><span class="line"><span class="comment"> * @param list 链表</span></span><br><span class="line"><span class="comment"> * @param old_node 老节点</span></span><br><span class="line"><span class="comment"> * @param value 值</span></span><br><span class="line"><span class="comment"> * @param after</span></span><br><span class="line"><span class="comment"> * @return 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL，如果执行成功，返回传入的链表指针</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新节点</span></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存值</span></span><br><span class="line">    node-&gt;value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新节点添加到给定节点之后</span></span><br><span class="line">    <span class="keyword">if</span> (after) &#123;</span><br><span class="line">        node-&gt;prev = old_node;</span><br><span class="line">        node-&gt;next = old_node-&gt;next;</span><br><span class="line">        <span class="comment">// 给定节点是原表尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;tail == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 将新节点添加到给定节点之前</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;next = old_node;</span><br><span class="line">        node-&gt;prev = old_node-&gt;prev;</span><br><span class="line">        <span class="comment">// 给定节点是原表头节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新新节点的前置指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新新节点的后置指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;next-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新链表节点数</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listDelNode-删除指定节点"><a href="#listDelNode-删除指定节点" class="headerlink" title="listDelNode-删除指定节点"></a>listDelNode-删除指定节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从链表 list 中删除给定节点 node </span></span><br><span class="line"><span class="comment"> * 对节点私有值(private value of the node)的释放工作由调用者进行。</span></span><br><span class="line"><span class="comment"> * @param list </span></span><br><span class="line"><span class="comment"> * @param node </span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调整前置节点的指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev)</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整后置节点的指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next)</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node-&gt;prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(node-&gt;value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放节点</span></span><br><span class="line">    zfree(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表数减一</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listGetIterator-生成链表的迭代器"><a href="#listGetIterator-生成链表的迭代器" class="headerlink" title="listGetIterator-生成链表的迭代器"></a>listGetIterator-生成链表的迭代器</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为给定链表创建一个迭代器，</span></span><br><span class="line"><span class="comment"> * 之后每次对这个迭代器调用 listNext 都返回被迭代到的链表节点</span></span><br><span class="line"><span class="comment"> * @param list 链表</span></span><br><span class="line"><span class="comment"> * @param direction 迭代方向 </span></span><br><span class="line"><span class="comment"> *        AL_START_HEAD ：从表头向表尾迭代</span></span><br><span class="line"><span class="comment"> *        AL_START_TAIL ：从表尾想表头迭代</span></span><br><span class="line"><span class="comment"> * @return 迭代器</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 为迭代器分配内存</span></span><br><span class="line">    listIter *iter;</span><br><span class="line">    <span class="keyword">if</span> ((iter = zmalloc(<span class="keyword">sizeof</span>(*iter))) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据迭代方向，设置迭代器的起始节点</span></span><br><span class="line">    <span class="keyword">if</span> (direction == AL_START_HEAD)</span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录迭代方向</span></span><br><span class="line">    iter-&gt;direction = direction;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listNext-返回迭代器当前所指向的节点"><a href="#listNext-返回迭代器当前所指向的节点" class="headerlink" title="listNext-返回迭代器当前所指向的节点"></a>listNext-返回迭代器当前所指向的节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回迭代器当前所指向的节点。</span></span><br><span class="line"><span class="comment"> * 删除当前节点是允许的，但不能修改链表里的其他节点。</span></span><br><span class="line"><span class="comment"> * @param iter 迭代器</span></span><br><span class="line"><span class="comment"> * @return 函数要么返回一个节点，要么返回 NULL </span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *current = iter-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据方向选择下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class="line">            <span class="comment">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listDup-复制整个链表"><a href="#listDup-复制整个链表" class="headerlink" title="listDup-复制整个链表"></a>listDup-复制整个链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复制整个链表。</span></span><br><span class="line"><span class="comment"> * 无论复制是成功还是失败，输入节点都不会修改。</span></span><br><span class="line"><span class="comment"> * 如果链表有设置值复制函数 dup ，那么对值的复制将使用复制函数进行，</span></span><br><span class="line"><span class="comment"> * 否则，新节点将和旧节点共享同一个指针。</span></span><br><span class="line"><span class="comment"> * @param orig</span></span><br><span class="line"><span class="comment"> * @return 复制成功返回输入链表的副本，如果因为内存不足而造成复制失败，返回 NULL 。</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *copy;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新链表</span></span><br><span class="line">    <span class="keyword">if</span> ((copy = listCreate()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置节点值处理函数</span></span><br><span class="line">    copy-&gt;dup = orig-&gt;dup;</span><br><span class="line">    copy-&gt;<span class="built_in">free</span> = orig-&gt;<span class="built_in">free</span>;</span><br><span class="line">    copy-&gt;match = orig-&gt;match;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代整个输入链表</span></span><br><span class="line">    iter = listGetIterator(orig, AL_START_HEAD);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制节点值到新节点</span></span><br><span class="line">        <span class="keyword">if</span> (copy-&gt;dup) &#123;</span><br><span class="line">            value = copy-&gt;dup(node-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                listRelease(copy);</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            value = node-&gt;value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将节点添加到链表</span></span><br><span class="line">        <span class="keyword">if</span> (listAddNodeTail(copy, value) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            listRelease(copy);</span><br><span class="line">            listReleaseIterator(iter);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放迭代器</span></span><br><span class="line">    listReleaseIterator(iter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回副本</span></span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listSearchKey-查找值为key的节点"><a href="#listSearchKey-查找值为key的节点" class="headerlink" title="listSearchKey-查找值为key的节点"></a>listSearchKey-查找值为key的节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找链表 list 中值和 key 匹配的节点。</span></span><br><span class="line"><span class="comment"> * 对比操作由链表的 match 函数负责进行，如果没有设置 match 函数，</span></span><br><span class="line"><span class="comment"> * 那么直接通过对比值的指针来决定是否匹配。</span></span><br><span class="line"><span class="comment"> * @param list 链表</span></span><br><span class="line"><span class="comment"> * @param key 值</span></span><br><span class="line"><span class="comment"> * @return 如果匹配成功，那么第一个匹配的节点会被返回。</span></span><br><span class="line"><span class="comment"> *         如果没有匹配任何节点，那么返回 NULL 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代整个链表</span></span><br><span class="line">    iter = listGetIterator(<span class="built_in">list</span>, AL_START_HEAD);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对比</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match(node-&gt;value, key)) &#123;</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="comment">// 找到</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == node-&gt;value) &#123;</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="comment">// 找到</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    listReleaseIterator(iter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listIndex-返回链表在指定索引上的值"><a href="#listIndex-返回链表在指定索引上的值" class="headerlink" title="listIndex-返回链表在指定索引上的值"></a>listIndex-返回链表在指定索引上的值</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回链表在给定索引上的值。</span></span><br><span class="line"><span class="comment"> * @param list </span></span><br><span class="line"><span class="comment"> * @param index 索引以 0 为起始，也可以是负数， -1 表示链表最后一个节点，诸如此类。</span></span><br><span class="line"><span class="comment"> * @return 如果索引超出范围（out of range），返回 NULL 。</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">    listNode *n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果索引为负数，从表尾开始查找</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = (-index)<span class="number">-1</span>;</span><br><span class="line">        n = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;prev;</span><br><span class="line">    <span class="comment">// 如果索引为正数，从表头开始查找</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listRewind-设置正向迭代器"><a href="#listRewind-设置正向迭代器" class="headerlink" title="listRewind-设置正向迭代器"></a>listRewind-设置正向迭代器</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将迭代器的方向设置为 AL_START_HEAD ，并将迭代指针重新指向表头节点。</span></span><br><span class="line"><span class="comment"> * @param list 链表</span></span><br><span class="line"><span class="comment"> * @param li 迭代器</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    li-&gt;direction = AL_START_HEAD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listRewindTail-设置反向迭代器"><a href="#listRewindTail-设置反向迭代器" class="headerlink" title="listRewindTail-设置反向迭代器"></a>listRewindTail-设置反向迭代器</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将迭代器的方向设置为 AL_START_TAIL, 并将迭代指针重新指向表尾节点。</span></span><br><span class="line"><span class="comment"> * @param list 链表</span></span><br><span class="line"><span class="comment"> * @param li 迭代器</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    li-&gt;direction = AL_START_TAIL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listRotate-将链表尾移动到表头"><a href="#listRotate-将链表尾移动到表头" class="headerlink" title="listRotate-将链表尾移动到表头"></a>listRotate-将链表尾移动到表头</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/</span><br><span class="line"> * 取出链表的表尾节点，并将它移动到表头，成为新的表头节点。</span><br><span class="line"> * @param <span class="built_in">list</span> </span><br><span class="line"> * T = O(<span class="number">1</span>)</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">void</span> listRotate(<span class="built_in">list</span> *<span class="built_in">list</span>) &#123;</span><br><span class="line">    listNode *tail = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listLength(<span class="built_in">list</span>) &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出表尾节点</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = tail-&gt;prev;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入到表头</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head-&gt;prev = tail;</span><br><span class="line">    tail-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    tail-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-sds动态字符串【学习笔记】</title>
    <url>/redis/Redis-sds/</url>
    <content><![CDATA[<h2 id="SDS定义"><a href="#SDS定义" class="headerlink" title="SDS定义"></a>SDS定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型别名，用于指向 sdshdr 的 buf 属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存字符串对象的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据空间</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="SDS常用函数"><a href="#SDS常用函数" class="headerlink" title="SDS常用函数"></a>SDS常用函数</h2><h3 id="sdslen-sds长度"><a href="#sdslen-sds长度" class="headerlink" title="sdslen-sds长度"></a>sdslen-sds长度</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回 sds 实际保存的字符串的长度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>s 实际上存的是buf首个char数据的地址，也就是向前移动8个字节，就能到sdshdr的len的首地址<br>char buf[]这个数组没有大小，是所谓的柔性数组，是不占据内存大小的，所以sizeof(struct sdshdr)为8。<br>具体结构如下图<br><img src="/redis/Redis-sds/sdshdr.png" alt="sdshdr"></p>
<h3 id="sdsavail-sds可用free空间长度"><a href="#sdsavail-sds可用free空间长度" class="headerlink" title="sdsavail-sds可用free空间长度"></a>sdsavail-sds可用free空间长度</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回 sds 可用空间的长度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdsavail</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;<span class="built_in">free</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sdsnewlen-根据字符串长度创建sds"><a href="#sdsnewlen-根据字符串长度创建sds" class="headerlink" title="sdsnewlen-根据字符串长度创建sds"></a>sdsnewlen-根据字符串长度创建sds</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据给定的初始化字符串 init 和字符串长度 initlen,创建一个新的 sds</span></span><br><span class="line"><span class="comment"> * @param init 初始化字符串指针</span></span><br><span class="line"><span class="comment"> * @param initlen 初始化字符串的长度</span></span><br><span class="line"><span class="comment"> * @return 创建成功返回 sdshdr 相对应的 sds,创建失败返回 NULL</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据是否有初始化内容，选择适当的内存分配方式</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (init) &#123;</span><br><span class="line">        <span class="comment">// zmalloc 不初始化所分配的内存</span></span><br><span class="line">        sh = zmalloc(<span class="keyword">sizeof</span>(struct sdshdr)+initlen+<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// zcalloc 将分配的内存全部初始化为 0</span></span><br><span class="line">        sh = zcalloc(<span class="keyword">sizeof</span>(struct sdshdr)+initlen+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存分配失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置初始化长度</span></span><br><span class="line">    sh-&gt;len = initlen;</span><br><span class="line">    <span class="comment">// 新 sds 不预留任何空间</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</span><br><span class="line">    <span class="comment">// 以 \0 结尾</span></span><br><span class="line">    sh-&gt;buf[initlen] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 buf 部分，而不是整个 sdshdr</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)sh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sdsnew-创建sds"><a href="#sdsnew-创建sds" class="headerlink" title="sdsnew-创建sds"></a>sdsnew-创建sds</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据给定字符串 init ，创建一个包含同样字符串的 sds</span></span><br><span class="line"><span class="comment"> * @param init 如果输入为 NULL ，那么创建一个空白 sds</span></span><br><span class="line"><span class="comment"> * @return 创建成功返回 sdshdr 相对应的 sds，创建失败返回 NULL</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sdsempty-创建空sds"><a href="#sdsempty-创建空sds" class="headerlink" title="sdsempty-创建空sds"></a>sdsempty-创建空sds</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建并返回一个只保存了空字符串 "" 的 sds</span></span><br><span class="line"><span class="comment"> * @return 创建成功返回 sdshdr 相对应的 sds,创建失败返回 NULL</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(<span class="string">""</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sdsdup-复制sds创建副本"><a href="#sdsdup-复制sds创建副本" class="headerlink" title="sdsdup-复制sds创建副本"></a>sdsdup-复制sds创建副本</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复制给定 sds 创建副本</span></span><br><span class="line"><span class="comment"> * @param s sds</span></span><br><span class="line"><span class="comment"> * @return 创建成功返回输入 sds 的副本</span></span><br><span class="line"><span class="comment"> *  T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(s, sdslen(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sdsfree-释放sds"><a href="#sdsfree-释放sds" class="headerlink" title="sdsfree-释放sds"></a>sdsfree-释放sds</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放给定的 sds</span></span><br><span class="line"><span class="comment"> * @param s </span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    zfree(s-<span class="keyword">sizeof</span>(struct sdshdr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sdsgrowzero-扩充sds未使用空间补0"><a href="#sdsgrowzero-扩充sds未使用空间补0" class="headerlink" title="sdsgrowzero-扩充sds未使用空间补0"></a>sdsgrowzero-扩充sds未使用空间补0</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 sds 扩充至指定长度，未使用的空间以 0 字节填充。</span></span><br><span class="line"><span class="comment"> * @param s</span></span><br><span class="line"><span class="comment"> * @param len 指定长度</span></span><br><span class="line"><span class="comment"> * @return 扩充成功返回新 sds ，失败返回 NULL</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">size_t</span> totlen, curlen = sh-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 len 比字符串的现有长度小，</span></span><br><span class="line">    <span class="comment">// 那么直接返回，不做动作</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= curlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展 sds</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len-curlen);</span><br><span class="line">    <span class="comment">// 如果内存不足，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新分配的空间用 0 填充，防止出现垃圾内容</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    sh = (<span class="keyword">void</span>*)(s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">    <span class="built_in">memset</span>(s+curlen,<span class="number">0</span>,(len-curlen+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新属性</span></span><br><span class="line">    totlen = sh-&gt;len+sh-&gt;<span class="built_in">free</span>;</span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = totlen-sh-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新的 sds</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对 sds 中 buf 的长度进行扩展，确保在函数执行之后，</span></span><br><span class="line"><span class="comment"> * buf 至少会有 addlen + 1 长度的空余空间（额外的 1 字节是为 \0 准备的）</span></span><br><span class="line"><span class="comment"> * @param s </span></span><br><span class="line"><span class="comment"> * @param addlen </span></span><br><span class="line"><span class="comment"> * @return 扩展成功返回扩展后的 sds，扩展失败返回 NULL</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 s 目前的空余空间长度</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 s 目前已占用空间的长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 最少需要的长度</span></span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新长度，为 s 分配新空间所需的大小</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        <span class="comment">// 如果新长度小于 SDS_MAX_PREALLOC </span></span><br><span class="line">        <span class="comment">// 那么为它分配两倍于所需长度的空间</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr)+newlen+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存不足，分配失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 sds 的空余长度</span></span><br><span class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 sds</span></span><br><span class="line">    <span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 最大预分配长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_MAX_PREALLOC (1024*1024)</span></span><br></pre></td></tr></table></figure>

<h3 id="sdscatlen-根据字符串长度将字符串追加到sds末尾"><a href="#sdscatlen-根据字符串长度将字符串追加到sds末尾" class="headerlink" title="sdscatlen-根据字符串长度将字符串追加到sds末尾"></a>sdscatlen-根据字符串长度将字符串追加到sds末尾</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  将长度为 len 的字符串 t 追加到 sds 的字符串末尾</span></span><br><span class="line"><span class="comment"> * @param s</span></span><br><span class="line"><span class="comment"> * @param t 字符串t</span></span><br><span class="line"><span class="comment"> * @param len t的长度</span></span><br><span class="line"><span class="comment"> * @return 追加成功返回新 sds ，失败返回 NULL</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原有字符串长度</span></span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展 sds 空间</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存不足？直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制 t 中的内容到字符串后部</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新属性</span></span><br><span class="line">    sh-&gt;len = curlen+len;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>-len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新结尾符号</span></span><br><span class="line">    s[curlen+len] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新 sds</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sdscat-将字符串追加到sds末尾"><a href="#sdscat-将字符串追加到sds末尾" class="headerlink" title="sdscat-将字符串追加到sds末尾"></a>sdscat-将字符串追加到sds末尾</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将给定字符串 t 追加到 sds 的末尾</span></span><br><span class="line"><span class="comment"> * @return 追加成功返回新 sds ，失败返回 NULL</span></span><br><span class="line"><span class="comment"> *  T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sdscatsds-将sds追加到另一个sds末尾"><a href="#sdscatsds-将sds追加到另一个sds末尾" class="headerlink" title="sdscatsds-将sds追加到另一个sds末尾"></a>sdscatsds-将sds追加到另一个sds末尾</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将另一个 sds 追加到一个 sds 的末尾</span></span><br><span class="line"><span class="comment"> * @return 追加成功返回新 sds ，失败返回 NULL</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatsds</span><span class="params">(sds s, <span class="keyword">const</span> sds t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, sdslen(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sdscpylen-将字符串前len复制到sds"><a href="#sdscpylen-将字符串前len复制到sds" class="headerlink" title="sdscpylen-将字符串前len复制到sds"></a>sdscpylen-将字符串前len复制到sds</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将字符串 t 的前 len 个字符复制到 sds s 当中,覆盖原有的字符</span></span><br><span class="line"><span class="comment"> * 如果 sds 的长度少于 len 个字符，那么扩展 sds</span></span><br><span class="line"><span class="comment"> * @return 复制成功返回新的 sds ，否则返回 NULL</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sds 现有 buf 的长度</span></span><br><span class="line">    <span class="keyword">size_t</span> totlen = sh-&gt;<span class="built_in">free</span>+sh-&gt;len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 s 的 buf 长度不满足 len ，那么扩展它</span></span><br><span class="line">    <span class="keyword">if</span> (totlen &lt; len) &#123;</span><br><span class="line">        <span class="comment">// T = O(N)</span></span><br><span class="line">        s = sdsMakeRoomFor(s,len-sh-&gt;len);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">        totlen = sh-&gt;<span class="built_in">free</span>+sh-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制内容</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(s, t, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加终结符号</span></span><br><span class="line">    s[len] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新属性</span></span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = totlen-len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新的 sds</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sdscpy-将字符串复制到-sds-当中"><a href="#sdscpy-将字符串复制到-sds-当中" class="headerlink" title="sdscpy-将字符串复制到 sds 当中"></a>sdscpy-将字符串复制到 sds 当中</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将字符串复制到 sds 当中,覆盖原有的字符</span></span><br><span class="line"><span class="comment"> * @return 复制成功返回新的 sds ，否则返回 NULL</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscpylen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>《自己动手写JAVA虚拟机》学习笔记三【解析class文件】</title>
    <url>/JVM/JVM3/</url>
    <content><![CDATA[<p>java虚拟机规范中使用一种类似C语言结构体来描述Class文件的基本结构，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">     u4             magic;<span class="comment">//魔数</span></span><br><span class="line">     u2             minor_version;<span class="comment">//主版本号</span></span><br><span class="line">     u2             major_version;<span class="comment">//次版本号</span></span><br><span class="line">     u2             constant_pool_count;<span class="comment">//常量池长度</span></span><br><span class="line">     cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池信息</span></span><br><span class="line">     u2             access_flags;<span class="comment">//该类的访问修饰符</span></span><br><span class="line">     u2             this_class;<span class="comment">//类索引</span></span><br><span class="line">     u2             super_class;<span class="comment">//父类索引</span></span><br><span class="line">     u2             interfaces_count;<span class="comment">//接口个数</span></span><br><span class="line">     u2             interfaces[interfaces_count];<span class="comment">//接口详细信息</span></span><br><span class="line">     u2             fields_count;<span class="comment">//属性个数</span></span><br><span class="line">     field_info     fields[fields_count];<span class="comment">//属性详细信息</span></span><br><span class="line">     u2             methods_count;<span class="comment">//方法个数</span></span><br><span class="line">     method_info    methods[methods_count];<span class="comment">//方法详情</span></span><br><span class="line">     u2             attributes_count;<span class="comment">//类文件属性个数</span></span><br><span class="line">     attribute_info attributes[attributes_count];<span class="comment">//类文件属性详细信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>把ch02的目录结构复制一份改名ch03，在ch03的目录中创建一个classfile子目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|-jvmgo</span><br><span class="line">    |-ch01</span><br><span class="line">    |-ch01</span><br><span class="line">    |-ch03</span><br><span class="line">        |-classfile</span><br><span class="line">        |-classpath</span><br><span class="line">        |-cmd.go</span><br><span class="line">        |-main.go</span><br></pre></td></tr></table></figure>

<p>为了学习编译后的class文件，新建一个classFileTest.java然后编译</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassFileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> FLAG = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> BYTE = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> X = <span class="string">'X'</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">short</span> SHORT = <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT = <span class="number">123456789</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> LONG = <span class="number">12345678901L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> PI = <span class="number">3.14f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> E = <span class="number">2.71828</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用作者提供的<a href="https://github.com/zxh0/classpy" target="_blank" rel="noopener">classpy</a>的图形化工具，可以查看反编译后的class文件。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>JAVA</tag>
        <tag>JVM</tag>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>《自己动手写JAVA虚拟机》学习笔记二【搜索class文件】</title>
    <url>/JVM/JVM2/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的java程序时，我们知道首先要启动java虚拟机，然后加载主类，最后调用主类的main方法。但是在加载HelloWorld类之前，首先要加载它的超类java.lang.Object，在调用main()函数之前，虚拟机要准备好参数数组，所以需要加载java.lang.String和java.lang.String[]类。把字符串打印到控制台还需要加载java.lang.System类，等等。。那么java虚拟机如何寻找这些类的呢？</p>
<h2 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h2><p>类路径可以分为以下三种：</p>
<ul>
<li>启动类路径(bootstrap classpath)：启动类路径默认对应jre/lib目录，Java标准库位于该路径。</li>
<li>扩展类路径(extention classpath)：扩展类路径默认对应jre/lib/ext目录，使用Java扩展机制的类位于该路径。</li>
<li>用户类路径(user classpath)：我们自己实现的类，以及第三方类库则位于用户类路径。用户类路径的默认值是当前路径，也就是”.”，可以给java命令传递-classpath选项来指定。</li>
</ul>
<a id="more"></a>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>把ch01的目录结构复制一份改名ch02，在ch02的目录中创建一个classpath子目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|-jvmgo</span><br><span class="line">    |-ch01</span><br><span class="line">    |-ch01</span><br><span class="line">        |-classpath</span><br><span class="line">        |-cmd.go</span><br><span class="line">        |-main.go</span><br></pre></td></tr></table></figure>

<p>修改cmd结构体，添加XjreOption字段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cmd <span class="keyword">struct</span> &#123;</span><br><span class="line">	helpFlag <span class="keyword">bool</span></span><br><span class="line">	versionFlag <span class="keyword">bool</span></span><br><span class="line">	cpOption <span class="keyword">string</span></span><br><span class="line">	XjreOption <span class="keyword">string</span></span><br><span class="line">	class <span class="keyword">string</span></span><br><span class="line">	args []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>parseCmd()函数也对应添加Xjre</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//命令解析</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseCmd</span><span class="params">()</span> *<span class="title">Cmd</span></span> &#123;</span><br><span class="line">    ...<span class="comment">//其他代码不变</span></span><br><span class="line">	flag.StringVar(&amp;cmd.cpOption,<span class="string">"cp"</span>,<span class="string">""</span>,<span class="string">"classpath"</span>)</span><br><span class="line">	flag.StringVar(&amp;cmd.XjreOption,<span class="string">"Xjre"</span>,<span class="string">""</span>,<span class="string">"path to jre"</span>)</span><br><span class="line">	<span class="comment">//解析命令行参数到定义的flag</span></span><br><span class="line">	flag.Parse()</span><br><span class="line">	...<span class="comment">//其他代码不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现类路径"><a href="#实现类路径" class="headerlink" title="实现类路径"></a>实现类路径</h3><p>采用组合模式来实现类路径，把类路径当成一个大的整体，由启动类路径、扩展类路径和用户类路径三个小路径构成，三个小路径又分别由更小的路径构成。</p>
<p>首先定义一个Entry接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取系统分隔符，windows是;类UNIX系统是:号</span></span><br><span class="line"><span class="keyword">const</span> pathListSeparator = <span class="keyword">string</span>(os.PathListSeparator)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Entry <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">//寻找和加载class文件  参数：class文件相对路径，路径之间用/，文件名有.class后缀</span></span><br><span class="line">	<span class="comment">//例如读取java.lang.Object入参是java/lang/Object.class</span></span><br><span class="line">	readClass(classname <span class="keyword">string</span>) ([]<span class="keyword">byte</span>, Entry, error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//toString</span></span><br><span class="line">	String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Entry接口一共有四种实现，CompositeEntry，WildcardEntry，ZipEntry，DirEntry</p>
<h4 id="DirEntry"><a href="#DirEntry" class="headerlink" title="DirEntry"></a>DirEntry</h4><p>DirEntry相对简单些，表示目录形式的类路径</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> classpath</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"path/filepath"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DirEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//存放目录的绝对路径</span></span><br><span class="line">	absDir <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newDirEntry</span><span class="params">(path <span class="keyword">string</span>)</span> *<span class="title">DirEntry</span></span> &#123;</span><br><span class="line">	<span class="comment">//将参数转换成绝对路径</span></span><br><span class="line">	absDir, err := filepath.Abs(path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;DirEntry&#123;absDir&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取class文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *DirEntry)</span> <span class="title">readClass</span> <span class="params">(className <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, Entry, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">//把目录和class名拼成完成路径</span></span><br><span class="line">	fileName := filepath.Join(self.absDir,className)</span><br><span class="line">	<span class="comment">//读取class文件内容</span></span><br><span class="line">	data, err := ioutil.ReadFile(fileName)</span><br><span class="line">	<span class="keyword">return</span> data,self,err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接返回目录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *DirEntry)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> self.absDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ZipEntry"><a href="#ZipEntry" class="headerlink" title="ZipEntry"></a>ZipEntry</h4><p>ZipEntry表示ZIP或者JAR文件形式的类路径</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> classpath</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"path/filepath"</span></span><br><span class="line">	<span class="string">"archive/zip"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ZipEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//存放目录的绝对路径</span></span><br><span class="line">	absPath <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newZipEntry</span><span class="params">(path <span class="keyword">string</span>)</span> *<span class="title">ZipEntry</span></span> &#123;</span><br><span class="line">	<span class="comment">//将参数转换成绝对路径</span></span><br><span class="line">	absPath, err := filepath.Abs(path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;ZipEntry&#123;absPath&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取class文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *ZipEntry)</span> <span class="title">readClass</span><span class="params">(classname <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, Entry, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">//打开zip文件</span></span><br><span class="line">	r, err := zip.OpenReader(self.absPath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>,<span class="literal">nil</span>,err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> r.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历zip包里的文件</span></span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> r.File &#123;</span><br><span class="line">		<span class="comment">//找到class文件</span></span><br><span class="line">		<span class="keyword">if</span> f.Name == classname &#123;</span><br><span class="line">			<span class="comment">//打开class文件</span></span><br><span class="line">			rc , err := f.Open()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>,<span class="literal">nil</span>,err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">defer</span> rc.Close()</span><br><span class="line">			<span class="comment">//读取class文件内容</span></span><br><span class="line">			data, err := ioutil.ReadAll(rc)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>,<span class="literal">nil</span>,err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> data,self,err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//未找到class文件</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>,<span class="literal">nil</span>,errors.New(<span class="string">"class not found :"</span> +classname)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接返回目录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *ZipEntry)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> self.absPath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CompositeEntry"><a href="#CompositeEntry" class="headerlink" title="CompositeEntry"></a>CompositeEntry</h4><p>CompositeEntry表示有分隔符的类路径，CompositeEntry由更小的Entry组成，可以表示成[]Entry，go语言中则使用便利的slice</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> classpath</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CompositeEntry []Entry</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将每个小路径转换成具体的Entry</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCompositeEntry</span><span class="params">(pathList <span class="keyword">string</span>)</span> <span class="title">CompositeEntry</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> compositeEntry []Entry</span><br><span class="line">	<span class="comment">//将路径按照分隔符进行分割</span></span><br><span class="line">	<span class="keyword">for</span> _, path := <span class="keyword">range</span> strings.Split(pathList,pathListSeparator)&#123;</span><br><span class="line">		entry := newEntry(path)</span><br><span class="line">		compositeEntry = <span class="built_in">append</span>(compositeEntry,entry)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> compositeEntry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self CompositeEntry)</span> <span class="title">readClass</span><span class="params">(classname <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, Entry, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">//遍历entry数据</span></span><br><span class="line">	<span class="keyword">for</span> _, entry := <span class="keyword">range</span> self&#123;</span><br><span class="line">		<span class="comment">//读取class文件，依次调用每一个子路径的readClass方法</span></span><br><span class="line">		data, from, err := entry.readClass(classname)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> data,from,err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>,<span class="literal">nil</span>,errors.New(<span class="string">"class not found :"</span> +classname)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用每个子路径的String方法，用分隔符拼接起来</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self CompositeEntry)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	strs := <span class="built_in">make</span>([]<span class="keyword">string</span>,<span class="built_in">len</span>(self))</span><br><span class="line">	<span class="keyword">for</span> i, entry := <span class="keyword">range</span> self&#123;</span><br><span class="line">		strs[i] = entry.String()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> strings.Join(strs,pathListSeparator)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WildcardEntry"><a href="#WildcardEntry" class="headerlink" title="WildcardEntry"></a>WildcardEntry</h4><p>WildcardEntry表示以*结尾的类路径，实际上也是CompositeEntry，因此就不再新定义类型类</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> classpath</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"path/filepath"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWildcardEntry</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">CompositeEntry</span></span> &#123;</span><br><span class="line">	<span class="comment">//去掉尾部的*</span></span><br><span class="line">	baseDir := path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">var</span> compositeEntry []Entry</span><br><span class="line">	walkFn := <span class="function"><span class="keyword">func</span><span class="params">(path <span class="keyword">string</span>, info os.FileInfo, err error)</span> <span class="title">error</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果不是目录，返回跳过标识</span></span><br><span class="line">		<span class="keyword">if</span> info.IsDir() &amp;&amp; path != baseDir &#123;</span><br><span class="line">			<span class="keyword">return</span> filepath.SkipDir</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//选出jar文件</span></span><br><span class="line">		<span class="keyword">if</span> strings.HasSuffix(path,<span class="string">".jar"</span>) || strings.HasSuffix(path,<span class="string">".JAR"</span>)&#123;</span><br><span class="line">			jarEntry := newZipEntry(path)</span><br><span class="line">			compositeEntry = <span class="built_in">append</span>(compositeEntry,jarEntry)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历baseDir路径，创建zipEntry</span></span><br><span class="line">	filepath.Walk(baseDir,walkFn)</span><br><span class="line">	<span class="comment">//fmt.Printf("compositeEntry : %s\n",compositeEntry)</span></span><br><span class="line">	<span class="keyword">return</span> compositeEntry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h4><p>四种类路径都实现完之后，再来完善下Entry接口，添加Entry实例的构造方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newEntry</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">Entry</span></span> &#123;</span><br><span class="line">	<span class="comment">//如果路径中含有分隔符</span></span><br><span class="line">	<span class="keyword">if</span> strings.Contains(path,pathListSeparator)&#123;</span><br><span class="line">		<span class="keyword">return</span> newCompositeEntry(path)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果路径末尾是*</span></span><br><span class="line">	<span class="keyword">if</span> strings.HasSuffix(path,<span class="string">"*"</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> newWildcardEntry(path)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果路径以jar或者zip结尾</span></span><br><span class="line">	<span class="keyword">if</span> strings.HasSuffix(path,<span class="string">".jar"</span>) || strings.HasSuffix(path,<span class="string">".JAR"</span>)||</span><br><span class="line">		strings.HasSuffix(path,<span class="string">".zip"</span>) || strings.HasSuffix(path,<span class="string">".ZIP"</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> newZipEntry(path)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newDirEntry(path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现Classpath"><a href="#实现Classpath" class="headerlink" title="实现Classpath"></a>实现Classpath</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> classpath</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"path/filepath"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Classpath <span class="keyword">struct</span> &#123;</span><br><span class="line">	bootClasspath Entry</span><br><span class="line">	extClasspath Entry</span><br><span class="line">	userClasspath Entry</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用-Xjre选项解析启动类路径和扩展类路径，使用-classpath/-cp选项解析用户类路径</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(jreOption,cpOption <span class="keyword">string</span>)</span> *<span class="title">Classpath</span></span>  &#123;</span><br><span class="line">	cp := &amp;Classpath&#123;&#125;</span><br><span class="line">	<span class="comment">//解析启动类路径和扩展类路径</span></span><br><span class="line">	cp.parseBootAndExtClasspath(jreOption)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//解析用户类路径</span></span><br><span class="line">	cp.parseUserClasspath(cpOption)</span><br><span class="line">	<span class="keyword">return</span> cp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getJreDir</span><span class="params">(jreOption <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">//优先使用用户输入的-Xjre作为目录</span></span><br><span class="line">	<span class="keyword">if</span> jreOption != <span class="string">""</span> &amp;&amp; exists(jreOption)&#123;</span><br><span class="line">		<span class="keyword">return</span> jreOption</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在当前目录下寻找jre目录</span></span><br><span class="line">	<span class="keyword">if</span> exists(<span class="string">"./jre"</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"./jre"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//尝试使用JAVA_HOME环境变量</span></span><br><span class="line">	<span class="keyword">if</span> jh := os.Getenv(<span class="string">"JAVA_HOME"</span>); jh != <span class="string">""</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> filepath.Join(jh,<span class="string">"jre"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"Can not find jre folder"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断目录是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exists</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _, err := os.Stat(path); err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> os.IsNotExist(err)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *Classpath)</span> <span class="title">parseBootAndExtClasspath</span><span class="params">(jreOption <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取jre目录</span></span><br><span class="line">	jreDir := getJreDir(jreOption)</span><br><span class="line">	<span class="comment">//jre/lib/*</span></span><br><span class="line">	jreLibPath := filepath.Join(jreDir,<span class="string">"lib"</span>,<span class="string">"*"</span>)</span><br><span class="line">	self.bootClasspath = newWildcardEntry(jreLibPath)</span><br><span class="line">	<span class="comment">//jre/lib/ext/*</span></span><br><span class="line">	jreExtPath := filepath.Join(jreDir,<span class="string">"lib"</span>,<span class="string">"ext"</span>,<span class="string">"*"</span>)</span><br><span class="line">	self.extClasspath = newWildcardEntry(jreExtPath)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析用户类路径</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *Classpath)</span> <span class="title">parseUserClasspath</span><span class="params">(cpOption <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果用户没有提供-classpath/-cp选项，则使用当前目录作为用户类路径</span></span><br><span class="line">	<span class="keyword">if</span> cpOption == <span class="string">""</span>&#123;</span><br><span class="line">		cpOption = <span class="string">"."</span></span><br><span class="line">	&#125;</span><br><span class="line">	self.userClasspath = newEntry(cpOption)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找class方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *Classpath)</span> <span class="title">ReadClass</span><span class="params">(classname <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, Entry, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">//访问ReadClass方法只需传递类名，不用包含".class"后缀</span></span><br><span class="line">	classname = classname + <span class="string">".class"</span></span><br><span class="line">	<span class="comment">// 从bootClasspath寻找class文件</span></span><br><span class="line">	<span class="keyword">if</span> data, entry, err := self.bootClasspath.readClass(classname); err == <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data, entry, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从extClasspath寻找class文件</span></span><br><span class="line">	<span class="keyword">if</span> data, entry, err := self.extClasspath.readClass(classname); err == <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data, entry, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从userClasspath寻找class文件</span></span><br><span class="line">	<span class="keyword">return</span> self.userClasspath.readClass(classname)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *Classpath)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> self.userClasspath.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>完善main.go中的startJVM</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟启动jvm</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startJVM</span><span class="params">(cmd *Cmd)</span></span>  &#123;</span><br><span class="line">	<span class="comment">// 获取Classpath</span></span><br><span class="line">	cp := classpath.Parse(cmd.XjreOption,cmd.cpOption)</span><br><span class="line">	fmt.Printf(<span class="string">"classpath:%s class:%s args:%v\n"</span>,cp,cmd.class,cmd.args)</span><br><span class="line">	<span class="comment">// 将.替换成/(java.lang.String -&gt; java/lang/String)</span></span><br><span class="line">	className := strings.Replace(cmd.class,<span class="string">"."</span>,<span class="string">"/"</span>,<span class="number">-1</span>)</span><br><span class="line">	<span class="comment">// 读取class</span></span><br><span class="line">	classData, _, err := cp.ReadClass(className)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Could not find or load main class %s\n"</span>,cmd.class)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"class data : %v\n"</span>,classData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译main.go，并测试-version</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go install jvmgo/ch02 </span><br><span class="line">$ ch02 java.lang.String</span><br><span class="line"><span class="comment"># 没有传递-Xjre，会去读取$JAVA_HOME，成功打印出String.class的内容</span></span><br><span class="line">$ ch02 -Xjre /opt  java.lang.Object </span><br><span class="line"><span class="comment"># 传递错误-Xjre会打印出Could not find or load main class java.lang.Object</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>JAVA</tag>
        <tag>JVM</tag>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>《自己动手写JAVA虚拟机》学习笔记一【命令行工具】</title>
    <url>/JVM/JVM1/</url>
    <content><![CDATA[<p>最近正在看张秀宏著的《自己动手写Java虚拟机》，这本书适合初学者更深入的理解java虚拟机的含义，也可以简单学习go语言的基本使用。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><p>从Oracle官网下载最新的JDK，双击运行即可。我使用的是1.8.0_161</p>
<h3 id="安装GO"><a href="#安装GO" class="headerlink" title="安装GO"></a>安装GO</h3><p>从<a href="https://golang.org/dl/" target="_blank" rel="noopener">GO语言官网</a>下载最新版本的GO安装文件，双击运行即可,我使用的是1.11.2。<br>测试Go环境是否安装成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">～$ go version</span><br><span class="line">go version go1.11.2 darwin/amd64</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>设置环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加Go的运行环境路径</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</span><br><span class="line"><span class="comment">#添加Go工程的工作空间,可自行修改</span></span><br><span class="line"><span class="built_in">export</span> GOPATH=/home/XXX/XXX/jvmgo/go</span><br></pre></td></tr></table></figure>

<p>执行以下命令，如果GOPATH与你设置的相同环境变量设置成功,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">～$ go env</span><br></pre></td></tr></table></figure>

<h2 id="实现JAVA命令"><a href="#实现JAVA命令" class="headerlink" title="实现JAVA命令"></a>实现JAVA命令</h2><p>java命令常用选项及其用途</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-version</td>
<td align="left">输出版本信息，然后退出</td>
</tr>
<tr>
<td align="left">-?/-help</td>
<td align="left">输出帮助信息，然后退出</td>
</tr>
<tr>
<td align="left">-cp/-classpath</td>
<td align="left">指定用户类路径</td>
</tr>
<tr>
<td align="left">-Dproperty=value</td>
<td align="left">设置Java系统属性</td>
</tr>
<tr>
<td align="left">-Xms</td>
<td align="left">设置初始堆空间大小</td>
</tr>
<tr>
<td align="left">-Xmx</td>
<td align="left">设置最大堆空间大小</td>
</tr>
<tr>
<td align="left">-Xss</td>
<td align="left">设置线程栈空间大小</td>
</tr>
</tbody></table>
<h3 id="编写命令行工具"><a href="#编写命令行工具" class="headerlink" title="编写命令行工具"></a>编写命令行工具</h3><p>首先创建项目结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|-jvmgo</span><br><span class="line">    |-ch01</span><br></pre></td></tr></table></figure>

<p>在ch01目录下创建cmd.go文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"flag"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//用法: java [-options] class [args...] (执行类)</span></span><br><span class="line"><span class="comment">//或  java [-options] -jar jarfile [args...] (执行 jar 文件)</span></span><br><span class="line"><span class="keyword">type</span> Cmd <span class="keyword">struct</span> &#123;</span><br><span class="line">	helpFlag <span class="keyword">bool</span></span><br><span class="line">	versionFlag <span class="keyword">bool</span></span><br><span class="line">	cpOption <span class="keyword">string</span></span><br><span class="line">	class <span class="keyword">string</span></span><br><span class="line">	args []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//把命令的用法打印到控制台</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printUsage</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"Usage：%s [-options] class [args...]\n"</span>,os.Args[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命令解析</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseCmd</span><span class="params">()</span> *<span class="title">Cmd</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//声明cmd为指向空的Cmd对象的指针</span></span><br><span class="line">	cmd := &amp;Cmd&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义flag参数</span></span><br><span class="line">	<span class="comment">//Usage是一个函数，默认输出所有定义了的命令行参数和帮助信息</span></span><br><span class="line">	flag.Usage = printUsage</span><br><span class="line">	flag.BoolVar(&amp;cmd.helpFlag,<span class="string">"help"</span>,<span class="literal">false</span>,<span class="string">"print help message"</span>)</span><br><span class="line">	flag.BoolVar(&amp;cmd.helpFlag,<span class="string">"?"</span>,<span class="literal">false</span>,<span class="string">"print help message"</span>)</span><br><span class="line">	flag.BoolVar(&amp;cmd.versionFlag,<span class="string">"version"</span>,<span class="literal">false</span>,<span class="string">"print version and exit"</span>)</span><br><span class="line">	flag.StringVar(&amp;cmd.cpOption,<span class="string">"classpath"</span>,<span class="string">""</span>,<span class="string">"classpath"</span>)</span><br><span class="line">	flag.StringVar(&amp;cmd.cpOption,<span class="string">"cp"</span>,<span class="string">""</span>,<span class="string">"classpath"</span>)</span><br><span class="line">	<span class="comment">//在所有的flag定义完成之后，可以通过调用flag.Parse()进行解析。</span></span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="comment">//flag.Args()可以捕获未被解析的参数</span></span><br><span class="line">	args := flag.Args()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">0</span>&#123;</span><br><span class="line">		cmd.class = args[<span class="number">0</span>]</span><br><span class="line">		cmd.args = args[<span class="number">1</span>:]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>在ch01目录下创建main.go文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := parseCmd()</span><br><span class="line">	<span class="keyword">if</span> cmd.versionFlag &#123;</span><br><span class="line">		fmt.Println(<span class="string">"version 0.0.1"</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> cmd.helpFlag || cmd.class == <span class="string">""</span>&#123;</span><br><span class="line">		printUsage()</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		startJVM(cmd)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模拟启动jvm</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startJVM</span><span class="params">(cmd *Cmd)</span></span>  &#123;</span><br><span class="line">	<span class="comment">//还未开始写，暂时打印</span></span><br><span class="line">	fmt.Printf(<span class="string">"classpath:%s class:%s args:%v\n"</span>,cmd.cpOption,cmd.class,cmd.args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译main.go，并测试-version</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go install jvmgo/ch01 </span><br><span class="line">$ ch01 -version</span><br><span class="line">version 0.0.1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>JAVA</tag>
        <tag>JVM</tag>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下利用Github Pages快速搭建免费博客</title>
    <url>/blog/Github-Pages-Blog/</url>
    <content><![CDATA[<p>本博客利用Hexo + Next + GitHubPages 搭建博客。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install node</span><br></pre></td></tr></table></figure>

<h3 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install git</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="安装yarn"><a href="#安装yarn" class="headerlink" title="安装yarn"></a>安装yarn</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install yarn</span><br></pre></td></tr></table></figure>

<p>如果安装失败用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install yarn</span><br></pre></td></tr></table></figure>

<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>进入你的项目目录，举个例子我的目录是blog</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br></pre></td></tr></table></figure>

<p>然后用 yarn 安装 hexo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yarn add hexo -S</span><br></pre></td></tr></table></figure>

<p>如果安装失败用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br><span class="line">$ npm install hexo-server --save</span><br></pre></td></tr></table></figure>

<p>详细可见<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="搭建本地博客"><a href="#搭建本地博客" class="headerlink" title="搭建本地博客"></a>搭建本地博客</h2><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><p>进入你的项目目录,初始化hexo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>

<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yarn install</span><br></pre></td></tr></table></figure>

<h3 id="启动本地服务"><a href="#启动本地服务" class="headerlink" title="启动本地服务"></a>启动本地服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>在浏览器输入 <code>localhost:4000</code> 即可</p>
<h2 id="关联-GitHub"><a href="#关联-GitHub" class="headerlink" title="关联 GitHub"></a>关联 GitHub</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p><img src="/blog/Github-Pages-Blog/create-project.png" alt="创建项目"></p>
<p>项目名称一定一定是 <code>[用户名].github.io</code><br><img src="/blog/Github-Pages-Blog/create-repository.png" alt="创建项目"></p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p><img src="/blog/Github-Pages-Blog/setting.png" alt="设置"></p>
<p>在设置中找到GitHub Pages ，分支选择master，点击choose a theme</p>
<p><img src="/blog/Github-Pages-Blog/github-pages.png" alt="设置github-pages"></p>
<p>选择喜欢的主题，点击select theme即可<br><img src="/blog/Github-Pages-Blog/select-theme.png" alt="选择主题"></p>
<p>到这里就可以访问你的主页啦  <code>https://[用户名].github.io/</code>,接下来复制你的项目链接</p>
<p><img src="/blog/Github-Pages-Blog/copy-url.png" alt="复制项目链接"></p>
<p>到你的本地项目根目录找到 <code>_config.yml</code> 文件，粘贴到以下位置</p>
<p><img src="/blog/Github-Pages-Blog/deploy-position.png" alt="hexo设置git"></p>
<h3 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h3><p>站点配置包括修改博客名称，描述，作者等等，建议直接查看<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">官方教程</a></p>
<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>安装 hexo-deployer-git 插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yarn add hexo-deployer-git -S</span><br></pre></td></tr></table></figure>

<p>如果失败的话尝试下面的方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

<p>在你的项目文件夹下运行 hexo d -g （生成本地文件并将本地文件推送到 GitHub ，和 git push 功能相同）,如果失败的话前面加sudo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  hexo d -g</span><br></pre></td></tr></table></figure>

<p>这时访问你的github主页<code>https://[用户名].github.io/</code>就可以啦</p>
<h2 id="NexT主题配置"><a href="#NexT主题配置" class="headerlink" title="NexT主题配置"></a>NexT主题配置</h2><p>NexT 是一个高质量并且优雅的Hexo 主题。<br>详细可见<a href="https://github.com/iissnan/hexo-theme-next/blob/master/README.cn.md" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="安装NexT主题"><a href="#安装NexT主题" class="headerlink" title="安装NexT主题"></a>安装NexT主题</h3><p>在你的项目文件夹下，执行以下命令，安装NexT主题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>

<p>更改项目根目录下<code>_config.yml</code> 文件，如下<br><img src="/blog/Github-Pages-Blog/change-theme.png" alt="更改主题"></p>
<p>重新生成本地文件并推送到github</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  hexo d -g</span><br></pre></td></tr></table></figure>

<p>访问你的github主页<code>https://[用户名].github.io/</code>就可以看到啦</p>
<h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p><code>themes/next</code>文件夹下的<code>_config.yml</code>是主题的配置文件<br>next内置了4种主题方案，选择你喜欢的方案解开注释即可</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Scheme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>

<p>Menu Settings是控制图中菜单的位置，根据需要解开注释即可</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Menu Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line"><span class="comment">#  about: /about/ || user</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line"><span class="comment">#  archives: /archives/ || archive</span></span><br><span class="line"><span class="comment">#  schedule: /schedule/ || calendar</span></span><br><span class="line"><span class="comment">#  sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"><span class="comment">#  commonweal: /404.html || heartbeat</span></span><br></pre></td></tr></table></figure>

<p><img src="/blog/Github-Pages-Blog/blog-icon.png" alt="更改菜单"><br>还有很多很多的配置请参考<a href="http://theme-next.iissnan.com/getting-started.html#install-next-theme" target="_blank" rel="noopener">官方教程</a>,<a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">主题个性配置教程</a>,<a href="http://yearito.cn/posts/hexo-theme-beautify.html" target="_blank" rel="noopener">主题美化</a></p>
<p>修改之后，运行以下命令就可以再你的主页看到啦</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  hexo clean</span><br><span class="line">$  hexo d -g</span><br></pre></td></tr></table></figure>

<p>也可以在本地启动服务器，在浏览器输入 <code>localhost:4000</code> 观看效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<h2 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h2><h3 id="添加【标签】页面"><a href="#添加【标签】页面" class="headerlink" title="添加【标签】页面"></a>添加【标签】页面</h3><p>新建标签页面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>

<p>修改项目根目录下 source/tags 的 index.md 文件如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line">type: "tags"</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>修改<code>themes/next</code>文件夹下的<code>_config.yml</code>主题配置文件，取消  <code>tags: /tags/ || tags</code> 这行注释<br>新建测试文章</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">'test'</span></span><br></pre></td></tr></table></figure>

<p>在测试文章的头部添加tags信息，如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: 测试文章</span><br><span class="line">tags:</span><br><span class="line">  - Testing</span><br><span class="line">  - Another Tag</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>启动本地服务，就可以看到标签菜单，点击可进入标签页，看到 如图所示 证明标签页面添加成功。<br><img src="/blog/Github-Pages-Blog/tags.png" alt="标签"></p>
<h3 id="添加【分类】页面"><a href="#添加【分类】页面" class="headerlink" title="添加【分类】页面"></a>添加【分类】页面</h3><p>新建标签页面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>

<p>修改项目根目录下 source/tags 的 index.md 文件如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: categories</span><br><span class="line">type: "categories"</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>修改<code>themes/next</code>文件夹下的<code>_config.yml</code>主题配置文件，取消  <code>categories: /categories/ || th</code> 这行注释<br>在测试文章的头部添加categories信息，如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: 测试文章</span><br><span class="line">tags:</span><br><span class="line">  - Testing</span><br><span class="line">  - Another Tag</span><br><span class="line">---</span><br><span class="line">categories: Testing</span><br></pre></td></tr></table></figure>

<p>启动本地服务，就可以看到标签菜单，点击可进入标签页，看到 如图所示 证明分类页面添加成功。<br><img src="/blog/Github-Pages-Blog/categories.png" alt="分类"></p>
<h3 id="给博客添加图片"><a href="#给博客添加图片" class="headerlink" title="给博客添加图片"></a>给博客添加图片</h3><p>在项目目录下执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>在用下面命令生成md文章时，会在_post目录下看到一个与文章同名的文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">'文章名'</span></span><br></pre></td></tr></table></figure>

<p>将想要上传的图片先放到文件夹下，然后在博客中使用markdown的格式引入图片：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">文字</span>](<span class="link">xxxx/图片名.jpg</span>)</span><br></pre></td></tr></table></figure>

<p>文章名和文件夹名字相同，所以不需要绝对路径，只要xxxx是文件夹的名字就可以了。</p>
<h3 id="添加Valine评论系统"><a href="#添加Valine评论系统" class="headerlink" title="添加Valine评论系统"></a>添加Valine评论系统</h3><p>首先需要去注册一个<a href="https://leancloud.cn/" target="_blank" rel="noopener">Leancloud</a>账号,验证邮箱<br>然后随便创建一个应用，按如图所示找到<code>appid</code>，<code>appkey</code><br><img src="/blog/Github-Pages-Blog/valine.png" alt="评论"></p>
<p>按下图修改<code>themes/next</code>文件夹下的<code>_config.yml</code>主题配置文件，重新启动服务器就可以啦</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine.</span></span><br><span class="line"><span class="comment"># You can get your appid and appkey from https://leancloud.cn</span></span><br><span class="line"><span class="comment"># more info please open https://valine.js.org</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  appid:</span> <span class="string">your</span> <span class="string">appid</span>  <span class="comment"># your leancloud application appid</span></span><br><span class="line"><span class="attr">  appkey:</span> <span class="string">your</span> <span class="string">appkey</span> <span class="comment"># your leancloud application appkey</span></span><br><span class="line"><span class="attr">  notify:</span> <span class="literal">false</span> <span class="comment"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class="line"><span class="attr">  verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line"><span class="attr">  placeholder:</span> <span class="string">描述</span>  <span class="comment"># comment box placeholder</span></span><br><span class="line"><span class="attr">  avatar:</span> <span class="string">monsterid</span> <span class="comment"># gravatar style</span></span><br><span class="line"><span class="attr">  guest_info:</span> <span class="string">nick,mail</span> <span class="comment"># custom comment header</span></span><br><span class="line"><span class="attr">  pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br></pre></td></tr></table></figure>

<p>如果要删除评论请到<a href="https://leancloud.cn/" target="_blank" rel="noopener">Leancloud</a>里删除哦<br><img src="/blog/Github-Pages-Blog/comment-delete.png" alt="删除评论"></p>
<h3 id="hexo添加多作者"><a href="#hexo添加多作者" class="headerlink" title="hexo添加多作者"></a>hexo添加多作者</h3><p>在项目目录下执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-author --save</span><br></pre></td></tr></table></figure>

<p>在文章的头部添加author信息，如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: 测试文章</span><br><span class="line">tags:</span><br><span class="line">  - Testing</span><br><span class="line">  - Another Tag</span><br><span class="line">---</span><br><span class="line">author: Alice</span><br></pre></td></tr></table></figure>

<p>修改/layout/_macro/下的post.swig文件 +为新添加的行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         &lt;div class=&quot;post-meta&quot;&gt;</span><br><span class="line">+          &lt;span itemprop=&quot;about&quot; itemscope itemtype=&quot;https://schema.org/Thing&quot;&gt;</span><br><span class="line">+            &lt;a href=&quot;/authors/&#123;&#123; post.author &#125;&#125;&quot; itemprop=&quot;url&quot; rel=&quot;index&quot;&gt;</span><br><span class="line">+              &lt;span itemprop=&quot;name&quot;&gt;&#123;&#123; post.author &#125;&#125;&lt;/span&gt;</span><br><span class="line">+            &lt;/a&gt;</span><br><span class="line">+          &lt;/span&gt;</span><br><span class="line">           &lt;span class=&quot;post-time&quot;&gt;</span><br><span class="line">             &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">               &lt;i class=&quot;fa fa-calendar-o&quot;&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure>

<p>在/layout下新创建author.swig文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% extends &apos;_layout.swig&apos; %&#125;</span><br><span class="line">&#123;% import &apos;_macro/post-collapse.swig&apos; as post_template %&#125;</span><br><span class="line">&#123;% import &apos;_macro/sidebar.swig&apos; as sidebar_template %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125; &#123;&#123; __(&apos;title.author&apos;) &#125;&#125;: &#123;&#123; page.author &#125;&#125; | &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;post-block category&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id=&quot;posts&quot; class=&quot;posts-collapse&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;collection-title&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;&#123;% if theme.seo %&#125;h2&#123;% else %&#125;h1&#123;% endif %&#125;&gt;&#123;#</span><br><span class="line">        #&#125;&#123;&#123; page.author &#125;&#125;&#123;#</span><br><span class="line">        #&#125;&lt;small&gt;&#123;&#123;  __(&apos;title.author&apos;)  &#125;&#125;&lt;/small&gt;</span><br><span class="line">        &lt;/&#123;% if theme.seo %&#125;h2&#123;% else %&#125;h1&#123;% endif %&#125;&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">      &#123;% for post in page.posts %&#125;</span><br><span class="line">        &#123;&#123; post_template.render(post) &#125;&#125;</span><br><span class="line">      &#123;% endfor %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &#123;% include &apos;_partials/pagination.swig&apos; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block sidebar %&#125;</span><br><span class="line">  &#123;&#123; sidebar_template.render(false) &#125;&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>修改/layout下page.swig文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">     &#123;&#123; __(&apos;title.category&apos;) + page_title_suffix &#125;&#125;</span><br><span class="line">   &#123;% elif page.type === &quot;tags&quot; %&#125;</span><br><span class="line">     &#123;&#123; __(&apos;title.tag&apos;) + page_title_suffix &#125;&#125;</span><br><span class="line">+  &#123;% elif page.type === &quot;authors&quot; %&#125;</span><br><span class="line">+    &#123;&#123; __(&apos;title.author&apos;) + page_title_suffix &#125;&#125;</span><br><span class="line">   &#123;% else %&#125;</span><br><span class="line">     &#123;&#123; page.title + page_title_suffix &#125;&#125;</span><br><span class="line">   &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">。。。。。。。</span><br><span class="line">           &#123;&#123; list_categories() &#125;&#125;</span><br><span class="line">         &lt;/div&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">+    &#123;% elif page.type === &apos;authors&apos; %&#125;</span><br><span class="line">+      &lt;div class=&quot;author-all-page&quot;&gt;</span><br><span class="line">+        &lt;div class=&quot;author-all-title&quot;&gt;</span><br><span class="line">+            &#123;&#123; _p(&apos;counter.authors&apos;, site.authors.length) &#125;&#125;</span><br><span class="line">+        &lt;/div&gt;</span><br><span class="line">+        &lt;div class=&quot;author-all&quot;&gt;</span><br><span class="line">+          &#123;&#123; list_authors() &#125;&#125;</span><br><span class="line">+        &lt;/div&gt;</span><br><span class="line">+      &lt;/div&gt;</span><br><span class="line">     &#123;% else %&#125;</span><br><span class="line">       &#123;&#123; page.content &#125;&#125;</span><br><span class="line">     &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>修改{项目名称}/themes/next下zh-Hans.yml文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span></span><br><span class="line"><span class="attr">  archive:</span> <span class="string">归档</span></span><br><span class="line"><span class="attr">  category:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">  tag:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">  schedule:</span> <span class="string">日程表</span></span><br><span class="line">  <span class="string">author</span> <span class="string">:</span> <span class="string">作者</span></span><br><span class="line">  </span><br><span class="line"><span class="string">。。。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">counter:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  authors:</span></span><br><span class="line"><span class="attr">    zero:</span> <span class="string">暂无分类</span></span><br><span class="line"><span class="attr">    one:</span> <span class="string">目前共计</span> <span class="number">1</span> <span class="string">个分类</span></span><br><span class="line"><span class="attr">    other:</span> <span class="string">"目前共计 %d 个作者"</span></span><br></pre></td></tr></table></figure>

<p>在{项目名称}/themes/next/source/css/_common/components/pages/添加authors.styl，复制categories.styl内容将categorie改成author</p>
<p>在同级文件pages.styl中添加@import “authors”;</p>
<p>修改之后，运行以下命令就可以再你的主页看到啦</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  hexo clean</span><br><span class="line">$  hexo d -g</span><br></pre></td></tr></table></figure>

<p>###博文压缩</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install gulp -g</span><br><span class="line">$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save</span><br></pre></td></tr></table></figure>

<p>在项目根目录下创建<code>gulpfile.js</code>并填入以下内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line"><span class="comment">// 压缩 public 目录 css</span></span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">        .pipe(minifycss())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩 public 目录 html</span></span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">    .pipe(htmlclean())</span><br><span class="line">    .pipe(htmlmin(&#123;</span><br><span class="line">         removeComments: <span class="literal">true</span>,</span><br><span class="line">         minifyJS: <span class="literal">true</span>,</span><br><span class="line">         minifyCSS: <span class="literal">true</span>,</span><br><span class="line">         minifyURLs: <span class="literal">true</span>,</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩 public/js 目录 js</span></span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.js'</span>)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行 gulp 命令时执行的任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [</span><br><span class="line">    <span class="string">'minify-html'</span>,<span class="string">'minify-css'</span>,<span class="string">'minify-js'</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
