<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="mask-icon" href="/images/favicon.ico?v=5.1.4" color="#222"><meta name="keywords" content="学习笔记,MySql,InnoDB,"><meta name="description" content="概述 InnoDB存储引擎最早由Innobase Oy公司开发，被包括在MySQL数据库所有的二进制发行版本中， 从MySQL 5.5版本开始是默认的表存储引擎（之前的版本InnoDB存储引擎仅在Windows下为默认的存储引擎） 第一个完整支持ACID事务的MySQL存储引擎（BDB是第一个支持事务的MySQL存储引擎，现在已经停止开发） 特点：行锁设计、支持 MVCC、支持外键、提供一致性非锁"><meta name="keywords" content="学习笔记,MySql,InnoDB"><meta property="og:type" content="article"><meta property="og:title" content="《Mysql技术内幕》学习笔记-InnoDB存储引擎"><meta property="og:url" content="https://a19140312.github.io/Mysql/Mysql02/index.html"><meta property="og:site_name" content="qing&#39;s 随笔"><meta property="og:description" content="概述 InnoDB存储引擎最早由Innobase Oy公司开发，被包括在MySQL数据库所有的二进制发行版本中， 从MySQL 5.5版本开始是默认的表存储引擎（之前的版本InnoDB存储引擎仅在Windows下为默认的存储引擎） 第一个完整支持ACID事务的MySQL存储引擎（BDB是第一个支持事务的MySQL存储引擎，现在已经停止开发） 特点：行锁设计、支持 MVCC、支持外键、提供一致性非锁"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://a19140312.github.io/Mysql/Mysql02/innodb-Architecture.png"><meta property="og:image" content="https://a19140312.github.io/Mysql/Mysql02/read.png"><meta property="og:image" content="https://a19140312.github.io/Mysql/Mysql02/write.png"><meta property="og:image" content="https://a19140312.github.io/Mysql/Mysql02/three-list2.png"><meta property="og:image" content="https://a19140312.github.io/Mysql/Mysql02/innodb-buffer-pool-list.jpg"><meta property="og:image" content="https://a19140312.github.io/Mysql/Mysql02/redo-buffer.png"><meta property="og:image" content="https://a19140312.github.io/Mysql/Mysql02/index-update.png"><meta property="og:image" content="https://a19140312.github.io/Mysql/Mysql02/insert-buffer.png"><meta property="og:image" content="https://a19140312.github.io/Mysql/Mysql02/Insert-Buffer.svg"><meta property="og:image" content="https://a19140312.github.io/Mysql/Mysql02/IO.png"><meta property="og:image" content="https://a19140312.github.io/Mysql/Mysql02/doublewrite.png"><meta property="og:updated_time" content="2019-08-31T03:04:00.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="《Mysql技术内幕》学习笔记-InnoDB存储引擎"><meta name="twitter:description" content="概述 InnoDB存储引擎最早由Innobase Oy公司开发，被包括在MySQL数据库所有的二进制发行版本中， 从MySQL 5.5版本开始是默认的表存储引擎（之前的版本InnoDB存储引擎仅在Windows下为默认的存储引擎） 第一个完整支持ACID事务的MySQL存储引擎（BDB是第一个支持事务的MySQL存储引擎，现在已经停止开发） 特点：行锁设计、支持 MVCC、支持外键、提供一致性非锁"><meta name="twitter:image" content="https://a19140312.github.io/Mysql/Mysql02/innodb-Architecture.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!0,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><script></script><link rel="canonical" href="https://a19140312.github.io/Mysql/Mysql02/"><script src="https://neveryu.github.io/js/src/pace.min.js"></script><script data-ad-client="ca-pub-3961457011147580" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><title>《Mysql技术内幕》学习笔记-InnoDB存储引擎 | qing's 随笔</title></head><body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">qing's 随笔</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br> 公益404</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://a19140312.github.io/Mysql/Mysql02/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="guyuqing"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="qing's 随笔"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《Mysql技术内幕》学习笔记-InnoDB存储引擎</h1><div class="post-meta"> <span itemprop="about" itemscope="" itemtype="https://schema.org/Thing"><a href="/authors/Guyuqing" itemprop="url" rel="index"><span itemprop="name">Guyuqing</span></a></span><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-31T11:34:00+08:00">2019-07-31</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a></span></span> <span class="post-meta-divider">|</span><span class="page-pv"><i class="fa fa-file-o"></i> 阅读数<span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>InnoDB存储引擎最早由Innobase Oy公司开发，被包括在MySQL数据库所有的二进制发行版本中，</li><li>从MySQL 5.5版本开始是默认的表存储引擎<font color="gray">（之前的版本InnoDB存储引擎仅在Windows下为默认的存储引擎）</font></li><li>第一个完整支持ACID事务的MySQL存储引擎<font color="gray">（BDB是第一个支持事务的MySQL存储引擎，现在已经停止开发）</font></li><li>特点：行锁设计、支持 MVCC、支持外键、提供一致性非锁定读、有效利用内存和 CPU<a id="more"></a></li></ul><h1 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h1><p><img src="/Mysql/Mysql02/innodb-Architecture.png" alt="innoDB体系结构图"><br>InnoDB存储引擎是由内存池、后台线程、磁盘存储三大部分组成。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>InnoDB 使用的是多线程模型, 其后台有多个不同的线程负责处理不同的任务</p><h3 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h3><p>Master Thread是最核心的一个后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性。包括脏页刷新、合并插入缓冲、UNDO页的回收等。</p><h3 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h3><p>在 InnoDB 存储引擎中大量使用了异步IO(Async IO)来处理写IO请求, IO Thread的工作主要是负责这些 IO 请求的回调。</p><table><tr><th>InnoDB 版本</th><th colspan="4">线程</th></tr><tr><td style="text-align:center"> 1.0之前</td><td colspan="4">4 个 io thread：write，read，insert buffer，log IO Thread.<ul><li>在Linux下，IO Thread的数量不能进行调整</li><li>在Windows下可以通过参数 innodb_file_io_threads 来增大IO Thread</li></ul></td></tr><tr><td style="text-align:center"> 1.0之后</td><td colspan="4">read 和 write IO thread 分别增大到了 4 个<br><ul><li>分别使用 innodb_read_io_threads 和 innodb_write_io_threads 设置线程数</li></ul></td></tr></table><h3 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h3><p>事务提交后，其所使用的undo log可能不再需要，因此需要Purge Thread来回收已经分配并使用的UNDO页。</p><table><tr><th>InnoDB 版本</th><th colspan="4">作用</th></tr><tr><td style="text-align:center"> 1.1之前</td><td colspan="4">purge 操作在 master thread 内完成</td></tr><tr><td style="text-align:center"> 1.1之后</td><td colspan="4">purge 可以独立到单独的线程,减轻 master thread 工作,提高 cpu 利用率和提高性能<br><ul><li>MySQL数据库的配置文件<code>[mysqld]</code>中添加如下命令来启用独立的Purge Thread：</li><li>innodb_purge_threads=1</li><li>1.1版本中，即使将 innodb_purge_threads 设为大于1，InnoDB存储引擎启动时也会将其设为1</li></ul></td></tr><tr><td style="text-align:center"> 1.2之后</td><td colspan="4">支持多个Purge Thread, 这样做可以加快UNDO页的回收，也能更进一步利用磁盘的随机读取性能</td></tr></table><h3 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h3><p>Page Cleaner Thread的作用是取代Master Thread中脏页刷新的操作，<br>减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高性能。</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>innoDB内存主要由<a href="#缓冲池">缓冲池(innodb buffer pool)</a>、<a href="#重做日志缓冲">重做日志缓冲(redo log buffer)</a>、<a href="#额外的内存池">额外内存池组成(innodb additional men pool size)</a>组成</p><h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>缓冲池是主存储器中的一个区域，用于在访问时缓存表和索引数据。缓冲池允许直接从内存处理常用数据，从而加快处理速度。<br>在专用服务器上，通常会将最多80％的物理内存分配给缓冲池。<br>读取流程：<br> <img src="/Mysql/Mysql02/read.png" alt="流程图"><br>更新流程：<br> <img src="/Mysql/Mysql02/write.png" alt="流程图"></p><p>因此缓冲池的大小影响数据库的整体性能。</p><div class="note info"><p>由于32位操作系统的限制，在该系统下最多将该值设置为3G。<br>用户可以打开操作系统的<code>PAE</code>选项来获得32位操作系统下最大64GB内存的支持。<br>为了让数据库使用更多的内存,建议数据库系统都采用 64 位操作系统。</p></div><table><thead><tr><th align="center">参数</th><th align="center">版本</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">innodb_buffer_pool_instances</td><td align="center">从InnoDB 1.0.x开始</td><td align="center">配置多个缓冲池实例，默认为1</td></tr></tbody></table><h4 id="缓冲池中缓存的数据页类型"><a href="#缓冲池中缓存的数据页类型" class="headerlink" title="缓冲池中缓存的数据页类型"></a>缓冲池中缓存的数据页类型</h4><ul><li>索引页(index page)：缓存数据表索引</li><li>数据页(data page)：缓存数据页，占缓冲池的绝大部分</li><li>undo页(undo Log Page)：undo页是保存事务，为回滚做准备的。</li><li><a href="#插入缓冲">插入缓冲</a>（insert buffer）：插入数据时要先插入到缓存池中。</li><li>自适应哈希索引（adaptive hash index）： 除了B+ Tree索引外，在缓冲池还会维护一个哈希索引，以便在缓冲池中快速找到数据页。</li><li>InnoDB存储的锁信息（lock info）</li><li>数据字典信息（data dictionary）<br> 在MySQL中，数据字典信息内容就包括表结构、数据库名或表名、字段的数据类型、视图、索引、表字段信息、存储过程、触发器等内容。<br> InnoDB有自己的表缓存，可以称为表定义缓存或者数据字典。当InnoDB打开一张表，就增加一个对应的对象到数据字典。</li></ul><h4 id="缓冲池管理方式"><a href="#缓冲池管理方式" class="headerlink" title="缓冲池管理方式"></a>缓冲池管理方式</h4><p><img src="/Mysql/Mysql02/three-list2.png" alt="三种list"></p><ol><li><p><strong>Free list</strong><br>当数据库刚启动时，LRU列表是空的，这时页都存放在Free list中。<br>当需要从缓冲池中分页时，从Free list中查找是否有可用的空闲页，若有则将该页从Free列表中删除，放入到LRU列表中,维持页数守恒。</p></li><li><p><strong>LRU list</strong><br> <strong>LRU算法</strong>：最频繁使用页在LRU列表的前端，最少使用的页在尾端。首先释放LRU列表中的尾端的页。缓冲池中页的大小默认为16KB。<br> <strong>InnoDB优化的LRU算法(midpoint insertion strategy)</strong>：将新读取到的页不放在首部，而是中间部位 <code>midpoint</code> 位置。目标是确保频繁访问”热”页面保留在缓冲池中。<br> <img src="/Mysql/Mysql02/innodb-buffer-pool-list.jpg" alt="lru"></p><table><tr><th>参数</th><th colspan="2">作用</th></tr><tr><td style="text-align:center"> innodb_old_blocks_pct</td><td colspan="2">控制LRU列表中 old list 的百分比。<br> 默认值为 37，对应于原始固定比率3/8。<br> 值范围是 5（缓冲池中的新页面很快就会老化）到 95。</td></tr><tr><td style="text-align:center"> innodb_old_blocks_time</td><td colspan="2">指定第一次访问页面之后的时间窗口（ms）<br> 在此期间可以访问该页面而不移动到LRU列表的前端<br> 默认值为 1000 ms</td></tr></table><p> 默认情况下，算法操作如下：</p><ul><li>在默认配置下， <code>midpoint</code>位置在LRU list 的5/8处。</li><li><code>midpoint</code>是new sublist的尾部与old sublist的头部相交的边界。</li><li>当 InnoDB 将页面读入缓冲池时，将页插入<code>midpoint</code>位置(old sublist的头部)。</li><li>访问old sublist中的页 &amp;&amp; 该页在old sublist中的停留时间超过innodb_old_blocks_time设置的时间，使其变<code>young</code>,将其移动到缓冲池的头部(new sublist的头部)。</li><li>当页从LRU列表的old部分加入到new部分时，称此时发生的操作为<code>page made young</code>，而因为innodb_old_blocks_time的设置而导致页没有从old部分移动到new部分的操作称为<code>page not made young</code></li><li>在数据库操作中，被访问的页将移到new sublist的表头，这样一来，在new sublist中的未被访问的节点将逐渐往表尾移动，当移动过中点，将变为old list的节点。当表满时，old list末尾的页将会被移除。</li></ul><div class="note warning"><p>为什么不采用朴素的LRU？<br>因为某些SQL操作会访问很多页，甚至全部页，但仅仅在该次查询操作，并不是活跃的热点数据。可能会使缓冲池中的页被刷新出，从而影响缓冲池的效率。</p></div><ol start="3"><li><strong>Flush list</strong><br>在LRU类表的页被修改后，称为脏页（Dirty Page），即缓存和硬盘的页数据不一致。<br>数据库会通过<code>CHECKPOINT</code>机制将脏页刷新回磁盘，Flush list中的页即为脏页列表。</li></ol></li></ol><h3 id="重做日志缓冲"><a href="#重做日志缓冲" class="headerlink" title="重做日志缓冲"></a>重做日志缓冲</h3><div class="note info"><p><strong>什么是redo log？</strong><br>当数据库对数据做修改的时候，需要把数据页从磁盘读到buffer pool中，然后在buffer pool中进行修改，那么这个时候buffer pool中的数据页就与磁盘上的数据页内容不一致，称buffer pool的数据页为dirty page 脏数据。<br>如果发生非正常的DB服务重启，那么这些数据并没有同步到磁盘文件中（注意，同步到磁盘文件是个随机IO），会发生数据丢失。<br>如果这个时候，能够有一个文件，当缓冲池中的data page变更结束后，把相应修改记录记录到这个文件（注意，记录日志是顺序IO），那么当DB服务发生crash的情况，恢复DB的时候，也可以根据这个文件的记录内容，重新应用到磁盘文件，数据保持一致。<br>这个文件就是redo log ，用于记录 数据修改后的记录，顺序记录。<br><br><strong>什么是undo log？</strong><br>undo日志用于存放数据修改被修改前的值。<br>假设修改表中 id=1 的行数据，把Name=’B’ 修改为Name = ‘B2’ ，那么undo日志就会用来存放Name=’B’的记录，如果这个修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。</p></div><p><img src="/Mysql/Mysql02/redo-buffer.png" alt="lru"></p><p> 重做日志缓冲不需要设置很大，通常情况下8M能满足大部分的应用场景。重做日志支持以下三种情况触发刷新：</p><ul><li>Master Thread每一秒将重做日志缓冲刷新到重做日志文件</li><li>每次事务提交时将重做日志缓冲刷新到重做日志文件</li><li>当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件</li></ul><h3 id="额外的内存池"><a href="#额外的内存池" class="headerlink" title="额外的内存池"></a>额外的内存池</h3><p> 在InnoDB存储引擎中，对内存的管理是通过一种称为内存堆的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。</p><h1 id="Checkpoint技术"><a href="#Checkpoint技术" class="headerlink" title="Checkpoint技术"></a>Checkpoint技术</h1><div class="note info"><p><strong>什么是Checkpoint？</strong><br>是一个数据库事件(event)，这个事件激活以后会触发数据库写进程(DBWR)将脏数据块写到磁盘中。</p><p><strong>为什么需要Checkpoint技术？</strong><br>innoDB在事务提交时，先写重做日志，再修改内存数据这样，就产生了脏页。既然有重做日志保证数据持久性，查询时也可以从缓冲池页中取数据，那为什么还要刷新脏页到磁盘呢？如果重做日志可以无限增大，同时缓冲池足够大，能够缓存所有数据，那么是不需要将缓冲池中的脏页刷新到磁盘。但是，会有以下几个问题：<br>1) 服务器内存有限，缓冲池不够用，无法缓存全部数据<br>2) 重做日志无限增大成本要求太高<br>3) 宕机时如果重做全部日志恢复时间过长</p><p><strong>Checkpoint 解决了什么问题？</strong><br>1) 缩短短数据库的恢复时间<br>2) 缓冲池不够时，将脏页刷新到磁盘<br>3) 重做日志不可用时，刷新脏页</p></div><p>对于InnoDB存储引擎而言，其是通过LSN（Log Sequence Number）来标记版本的。每个页有LSN，重做日志中也有LSN，Checkpoint也有LSN。</p><p>innodb 内部有两种 checkpoint：</p><ol><li><p><strong>sharp checkpoint</strong>：数据库关闭的时候将<code>所有的脏页</code>刷回到磁盘，默认方式，参数 innodb_fast_shudown=1</p></li><li><p><strong>fuzzy checkpoint</strong>：只刷新<code>部分脏页</code></p><ul><li><p>master thread checkpoint：master thread 异步的以每秒或者每 10 秒的速度从缓冲池的脏页列表中刷新一定比列的也回磁盘</p><ul><li>周期性，异步，读取flush list，找到脏页，写入磁盘</li></ul></li><li><p>flush_lru_list checkpoint：InnoDB要保证LRU列表中需要有差不多100个空闲页可供使用。如果没有这么多，就会将 lru list 尾部的页移除。如果这些页有脏页，就需要进行 checkpoint。</p><ul><li>innodb 1.1.x版本之前，检查在用户查询线程中,会阻塞用户查询操作。</li><li>innodb 1.2.x版本之后，检查放到了单独的 page cleaner 线程中,可通过 <strong>innodb_lru_scan_depth</strong> 控制lru列表中可用页的数量，默认是1024。</li></ul></li><li><p>async/sync flush checkpoint：重做日志文件不可用时，强制将一些页刷新到磁盘。达到重做日志文件的大小阈值。</p><ul><li>checkpoint age = redo_log_lsn - cp_lsn<br> 低水位=75% * total_redo_log_file_size<br> 高水位=90% * total_redo_log_file_size</li><li>checkpoint age &lt; 低水位<br> 不需要刷新</li><li>低水位 &lt;= checkpoint age &lt;= 高水位<br> 会强制进行 checkpoint ，触发async flush， 根据flush_list的顺序，刷新足够多的脏页，直到 checkpoint age &lt; 低水位</li><li>checkpoint age &gt; 高水位<br> 会强制进行 checkpoint ，触发sync flush 根据flush_list的顺序，刷新脏页, 直到 checkpoint age &lt; 低水位</li></ul></li><li><p>dirty page too much checkpoint：当缓冲池中脏页的数量占据一定百分比时，强制进行Checkpoint，用来保证缓冲池中有足够的页，通过 <a href="#innodb_max_dirty_pages_pct">innodb_max_dirty_pages_pct</a> 参数控制。</p></li></ul></li></ol><div style="text-align:center;color:#bfbfbf;font-size:16px"> <span>-------- 第二部分 --------</span></div><h1 id="Master-thread-工作方式"><a href="#Master-thread-工作方式" class="headerlink" title="Master thread 工作方式"></a>Master thread 工作方式</h1><h2 id="InnoDB-1-0-x-版本之前的-Master-thread"><a href="#InnoDB-1-0-x-版本之前的-Master-thread" class="headerlink" title="InnoDB 1.0.x 版本之前的 Master thread"></a>InnoDB 1.0.x 版本之前的 Master thread</h2><p>Master thread 内部有多个循环 loop 组成：</p><ul><li>主循环 loop</li><li>后台循环 backgroup loop</li><li>刷新循环 flush loop</li><li>暂停循环 suspend loop</li></ul><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">master_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goto loop;</span><br><span class="line">	<span class="comment">//主循环</span></span><br><span class="line">	loop ：</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">		thread_sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//1. 日志缓冲刷新到磁盘，即使事务还没有提交</span></span><br><span class="line">		<span class="keyword">do</span> log buffer flush to disk;</span><br><span class="line">		<span class="comment">//2. 根据前一秒IO操作小于5，合并插入缓冲</span></span><br><span class="line">		<span class="keyword">if</span>(last_one_second_ios &lt; <span class="number">5</span>)</span><br><span class="line">			<span class="keyword">do</span> merge at most <span class="number">5</span> insert buffer;</span><br><span class="line">		<span class="comment">//3. 脏页的比例超过了阈值，刷新 100 个脏页到磁盘</span></span><br><span class="line">		<span class="keyword">if</span>(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct)</span><br><span class="line">			<span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;</span><br><span class="line">		<span class="comment">//4. 没有用户活动（数据库空闲时）或者数据库关闭（shutdown），切换到 backgroup loop</span></span><br><span class="line">		<span class="keyword">if</span>(no user activity)</span><br><span class="line">			goto backgroud loop;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1. 前10秒IO操作小于200，刷新 100 个脏页到磁盘</span></span><br><span class="line">	<span class="keyword">if</span>(last_ten_second_ios &lt; <span class="number">200</span>)</span><br><span class="line">		<span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;</span><br><span class="line">	<span class="comment">//2. 合并至多 5 个插入缓冲</span></span><br><span class="line">	<span class="keyword">do</span> merge at most <span class="number">5</span> insert buffer;</span><br><span class="line">	<span class="comment">//3. 将重做日志刷新到磁盘</span></span><br><span class="line">	<span class="keyword">do</span> log buffer flush to disk;</span><br><span class="line">	<span class="comment">//4. 删除无用的 undo 页（每次最多尝试回收 20 个 undo 页）</span></span><br><span class="line">	<span class="keyword">do</span> full purge;</span><br><span class="line">	<span class="comment">//5. 脏页比例超过 70% 刷新100 个脏页到磁盘，否则刷新 10 个脏页</span></span><br><span class="line">	<span class="keyword">if</span> ( buf_get_modified_ratio_pct ＞ <span class="number">70</span> % )</span><br><span class="line">		<span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		buffer pool flush <span class="number">10</span> dirty page</span><br><span class="line">																</span><br><span class="line">	goto loop</span><br><span class="line">	<span class="comment">//后台循环																</span></span><br><span class="line">	background loop :</span><br><span class="line">	<span class="comment">//1. 删除无用的 undo 页</span></span><br><span class="line">	<span class="keyword">do</span> full purge</span><br><span class="line">	<span class="comment">//2. 合并 20 个插入缓冲</span></span><br><span class="line">	<span class="keyword">do</span> merge <span class="number">20</span> insert buffer</span><br><span class="line">	<span class="comment">//3.如果有任务，跳转到主循环，否则跳转到刷新循环</span></span><br><span class="line">	<span class="keyword">if</span> not idle	</span><br><span class="line">		goto loop</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		goto flush loop</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//刷新循环</span></span><br><span class="line">	flush loop :</span><br><span class="line">	<span class="comment">//不断刷新100个脏页，直到脏页比例没有超过阈值</span></span><br><span class="line">	<span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page</span><br><span class="line">	<span class="keyword">if</span> ( buf_get_modified_ratio_pct ＞ innodb_max_dirty_pages_pct )</span><br><span class="line">		goto flush loop</span><br><span class="line">	<span class="comment">//没有任务，跳转到暂停循环</span></span><br><span class="line">	goto suspend loop</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//暂停循环</span></span><br><span class="line">	suspend loop :</span><br><span class="line">	<span class="comment">//将主线程挂起，等待事件发生</span></span><br><span class="line">	suspend_thread()</span><br><span class="line">	waiting event</span><br><span class="line">	goto loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="InnoDB-1-2-x-版本之前的-Master-thread"><a href="#InnoDB-1-2-x-版本之前的-Master-thread" class="headerlink" title="InnoDB 1.2.x 版本之前的 Master thread"></a>InnoDB 1.2.x 版本之前的 Master thread</h2><ol><li>提高刷新脏页数量和合并插入数量，改善磁盘 IO 处理能力,刷新数量不再硬编码，而是使用百分比控制。<ul><li>在合并插入缓冲的时候，合并插入缓冲的数量为 <a href="#innodb_io_capacity">innodb_io_capacity</a> 的 5%</li><li>在从缓冲区刷新脏页的时候，刷新脏页的数量为 <a href="#innodb_io_capacity">innodb_io_capacity</a></li></ul></li><li>增加了自适应刷新脏页功能。<ul><li>1.0.x之前版本：脏页在缓冲池占比小于<a href="#innodb_max_dirty_pages_pct">innodb_max_dirty_pages_pct</a>，不刷新脏页，大于则刷新100个脏页</li><li>1.0.x版本开始：引入<a href="#innodb_adaptive_flushing">innodb_adaptive_flushing</a>参数，通过函数buf_flush_get_desired_flush_rate判断产生重做日志的速度来决定最适合的刷新脏页数量。</li></ul></li><li>full purge回收的Undo页的数量也不再硬编码，使用参数<a href="#innodb_purge_batch_size">innodb_purge_batch_size</a>控制。</li></ol><table><tr><th colspan="2">参数</th><th>InnoDB 版本</th><th colspan="3">作用</th></tr><tr><td colspan="2" style="text-align:center"><span id="innodb_io_capacity">innodb_io_capacity</span></td><td style="text-align:center"> 1.0.x开始</td><td colspan="3">表示磁盘IO的吞吐量,默认值是200</td></tr><tr><td colspan="2" rowspan="2" style="text-align:center"><span id="innodb_max_dirty_pages_pct">innodb_max_dirty_pages_pct</span></td><td style="text-align:center"> 1.0.x之前</td><td colspan="3">脏页在缓冲池中所占比率，默认值是90</td></tr><tr><td style="text-align:center"> 1.0.x开始</td><td colspan="3">默认值是75<br>加快刷新脏页的频率，保证了磁盘IO的负载。</td></tr><tr><td colspan="2" style="text-align:center"><span id="innodb_adaptive_flushing">innodb_adaptive_flushing</span></td><td style="text-align:center"> 1.0.x开始</td><td colspan="3">是否自适应刷新脏页，默认为 ON</td></tr><tr><td colspan="2" style="text-align:center"><span id="innodb_purge_batch_size">innodb_purge_batch_size</span></td><td style="text-align:center"> 1.0.x开始</td><td colspan="3">清除 undo 页时,表示一次删除多少页,默认是 20</td></tr></table><p>Master Thread的伪代码变为了下面的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">master_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goto loop;</span><br><span class="line">	<span class="comment">//主循环</span></span><br><span class="line">	loop ：</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">		thread_sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//1. 日志缓冲刷新到磁盘，即使事务还没有提交</span></span><br><span class="line">		<span class="keyword">do</span> log buffer flush to disk;</span><br><span class="line">		<span class="comment">//2. 根据前一秒IO操作小于5%innodb_io_capacity，合并插入缓冲</span></span><br><span class="line">		<span class="keyword">if</span>(last_one_second_ios &lt; <span class="number">5</span>%innodb_io_capacity)</span><br><span class="line">			<span class="keyword">do</span> merge <span class="number">5</span>%innodb_io_capacity insert buffer;</span><br><span class="line">		<span class="comment">//3. 脏页的比例超过了阈值，刷新 100%innodb_io_capacity 个脏页到磁盘</span></span><br><span class="line">		<span class="keyword">if</span>(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct)</span><br><span class="line">			<span class="keyword">do</span> buffer pool flush <span class="number">100</span>%innodb_io_capacity dirty page;</span><br><span class="line">		<span class="comment">//4. 没有用户活动（数据库空闲时）或者数据库关闭（shutdown），切换到 backgroup loop</span></span><br><span class="line">		<span class="keyword">if</span>(no user activity)</span><br><span class="line">			goto backgroud loop;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1. 前10秒IO操作小于innodb_io_capacity，刷新 innodb_io_capacity 个脏页到磁盘</span></span><br><span class="line">	<span class="keyword">if</span>(last_ten_second_ios &lt; innodb_io_capacity)</span><br><span class="line">		<span class="keyword">do</span> buffer pool flush <span class="number">100</span>%innodb_io_capacity dirty page;</span><br><span class="line">	<span class="comment">//2. 合并至多 5%innodb_io_capacity 个插入缓冲</span></span><br><span class="line">	<span class="keyword">do</span> merge at most <span class="number">5</span>%innodb_io_capacity insert buffer;</span><br><span class="line">	<span class="comment">//3. 将重做日志刷新到磁盘</span></span><br><span class="line">	<span class="keyword">do</span> log buffer flush to disk;</span><br><span class="line">	<span class="comment">//4. 删除无用的 undo 页（每次最多尝试回收 5%innodb_io_capacity 个 undo 页）</span></span><br><span class="line">	<span class="keyword">do</span> full purge;</span><br><span class="line">	<span class="comment">//5. 脏页比例超过 70% 刷新 100%innodb_io_capacity 个脏页到磁盘，</span></span><br><span class="line">	<span class="comment">// 否则刷新 10%innodb_io_capacity 个脏页</span></span><br><span class="line">	<span class="keyword">if</span> ( buf_get_modified_ratio_pct ＞ <span class="number">70</span> % )</span><br><span class="line">		<span class="keyword">do</span> buffer pool flush <span class="number">100</span>%innodb_io_capacity dirty page</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		buffer pool flush <span class="number">10</span>%innodb_io_capacity dirty page</span><br><span class="line">																</span><br><span class="line">	goto loop</span><br><span class="line">	<span class="comment">//后台循环																</span></span><br><span class="line">	background loop :</span><br><span class="line">	<span class="comment">//1. 删除无用的 undo 页</span></span><br><span class="line">	<span class="keyword">do</span> full purge</span><br><span class="line">	<span class="comment">//2. 合并 100%innodb_io_capacity 个插入缓冲</span></span><br><span class="line">	<span class="keyword">do</span> merge <span class="number">100</span>%innodb_io_capacity insert buffer</span><br><span class="line">	<span class="comment">//3.如果有任务，跳转到主循环，否则跳转到刷新循环</span></span><br><span class="line">	<span class="keyword">if</span> not idle	</span><br><span class="line">		goto loop</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		goto flush loop</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//刷新循环</span></span><br><span class="line">	flush loop :</span><br><span class="line">	<span class="comment">//不断刷新 100%innodb_io_capacity 个脏页，直到脏页比例没有超过阈值</span></span><br><span class="line">	<span class="keyword">do</span> buffer pool flush <span class="number">100</span>%innodb_io_capacity dirty page</span><br><span class="line">	<span class="keyword">if</span> ( buf_get_modified_ratio_pct ＞ innodb_max_dirty_pages_pct )</span><br><span class="line">		goto flush loop</span><br><span class="line">	<span class="comment">//没有任务，跳转到暂停循环</span></span><br><span class="line">	goto suspend loop</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//暂停循环</span></span><br><span class="line">	suspend loop :</span><br><span class="line">	<span class="comment">//将主线程挂起，等待事件发生</span></span><br><span class="line">	suspend_thread()</span><br><span class="line">	waiting event</span><br><span class="line">	goto loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="InnoDB-1-2-x-版本的-Master-thread"><a href="#InnoDB-1-2-x-版本的-Master-thread" class="headerlink" title="InnoDB 1.2.x 版本的 Master thread"></a>InnoDB 1.2.x 版本的 Master thread</h2><p>InnoDB 1.2.x 版本中再次对 Master Thread 进行了优化，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> InnoDB is idle</span><br><span class="line"><span class="comment">//之前版本中每10秒的操作</span></span><br><span class="line">srv_master_do_idle_tasks();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//之前版本中每秒的操作</span></span><br><span class="line">srv_master_do_active_tasks();</span><br></pre></td></tr></table></figure><p>对于刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。</p><h1 id="InnoDB-关键特性"><a href="#InnoDB-关键特性" class="headerlink" title="InnoDB 关键特性"></a>InnoDB 关键特性</h1><p>关键特性包括：</p><ul><li>插入缓冲 insert buffer</li><li>两次写 double write</li><li>自适应哈希索引 adaptive hash index</li><li>异步 io async io</li><li>刷新邻接页 flush neighbor page</li></ul><h2 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h2><h3 id="聚集索引（一级索引）"><a href="#聚集索引（一级索引）" class="headerlink" title="聚集索引（一级索引）"></a>聚集索引（一级索引）</h3><p>表在存储的时候按照主键排序进行存储，不需要磁盘的随机读取，插入效率高。<br>非叶子节点存放的是键值，叶子节点存放的是行数据，称之为数据页。</p><h3 id="辅助索引（二级索引）"><a href="#辅助索引（二级索引）" class="headerlink" title="辅助索引（二级索引）"></a>辅助索引（二级索引）</h3><p>除了聚集索引之外的索引都可以称之为辅助索引，叶子节点中存放的是主键的键值。叶子节点的插入不再有序，这时就需要离散访问非聚集索引页，插入性能变低。<br>一张表可以存在多个辅助索引，但是只能有一个聚集索引，通过辅助索引来查找对应的航记录的话，需要进行两步，第一步通过辅助索引来确定对应的主键，第二步通过相应的主键值在聚集索引中查询到对应的行记录，也就是进行两次B+树搜索。</p><h3 id="索引数据页的更新（针对二级索引）"><a href="#索引数据页的更新（针对二级索引）" class="headerlink" title="索引数据页的更新（针对二级索引）"></a>索引数据页的更新（针对二级索引）</h3><p><img src="/Mysql/Mysql02/index-update.png" alt="index更新流程"><br>表数据更新的同时也会更新对应的表的索引数据，所以：对表进行insert delete update时，很可能会产生大量的物理读(物理读索引数据页)</p><p><img src="/Mysql/Mysql02/insert-buffer.png" alt="引入insertbuffer后index更新流程"></p><h3 id="1-insert-buffer"><a href="#1-insert-buffer" class="headerlink" title="1. insert buffer"></a>1. insert buffer</h3><p>Insert Buffer的使用流程：<br><img src="/Mysql/Mysql02/Insert-Buffer.svg" alt="Insert Buffer的使用流程"></p><h4 id="插入缓冲的启用需要满足以下两个条件："><a href="#插入缓冲的启用需要满足以下两个条件：" class="headerlink" title="插入缓冲的启用需要满足以下两个条件："></a>插入缓冲的启用需要满足以下两个条件：</h4><p>1）索引是辅助索引（secondary index）<br>2）索引不是唯一的：整个索引数据被切分为2部分，无法保证唯一性。</p><h4 id="insert-buffer结构"><a href="#insert-buffer结构" class="headerlink" title="insert buffer结构"></a>insert buffer结构</h4><p>insert buffer的数据结构是B+树，全局只有一颗B+树。<br>B+树的非叶子节点是Search key，构造结构为(space,marker,offset)。</p><ul><li>space：待插入记录所在表的表空间id。每个表都有唯一的表空间id，通过表空间id可以查出是哪张表。</li><li>marker：兼容之前的版本。</li><li>offset：在表空间中页的偏移量。</li></ul><p>当一个辅助索引要插入到(space,offset)中时，如果该页不在缓冲池中，则按上述规则构造一个search key，将该记录插入到insert buffer中。<br>但是如果该页一直在insert buffer中，不断有记录插入到同一个索引页中，那么该索引页的空间就会逐渐缩小，要出现B+树节点的分裂情况，这时就不能进行insert buffer了。<br>所以，我们需要一个机制来管理每个页面的剩余空闲空间，这就是<code>Insert buffer bitmap</code>。<br>每隔page_size个页面，就是一个Insert buffer bitmap page。<br>例如：若page_size = 16384(16k)，那么page_no为0，16384，32768，…的page，就是Insert buffer bitmap page，Bitmap page的功能，就是管理其后连续的page_size – 1个page的空间使用率。<br>每个辅助索引页在Insert buffer bitmap中占用4bit。</p><h4 id="merge-insert-buffer-发生条件"><a href="#merge-insert-buffer-发生条件" class="headerlink" title="merge insert buffer 发生条件"></a>merge insert buffer 发生条件</h4><ul><li>辅助索引页被读取到buffer pool中：正常的select查询操作，索引页被调入内存，该索引页对应在insert buffer中的索引更改记录就会发生merge操作。</li><li>Insert buffer bitmap page追踪到该索引页无可用空间时。</li><li>Master Thread。</li></ul><h4 id="insert-buffer-刷新到磁盘条件"><a href="#insert-buffer-刷新到磁盘条件" class="headerlink" title="insert buffer 刷新到磁盘条件"></a>insert buffer 刷新到磁盘条件</h4><ul><li>有一个后台线程，会认为数据库空闲时；</li><li>数据库缓冲池不够用时；</li><li>数据库正常关闭时；</li><li>redo log写满时：<em>几乎不会出现redo log写满，此时整个数据库处于无法写入的不可用状态</em></li></ul><h4 id="插入缓冲主要带来如下两个坏处"><a href="#插入缓冲主要带来如下两个坏处" class="headerlink" title="插入缓冲主要带来如下两个坏处"></a>插入缓冲主要带来如下两个坏处</h4><p>1）可能导致数据库宕机后实例恢复时间变长。如果应用程序执行大量的插入和更新操作，且涉及非唯一的聚集索引，一旦出现宕机，这时就有大量内存中的插入缓冲区数据没有合并至索引页中，导致实例恢复时间会很长。<br>2）在写密集的情况下，插入缓冲会占用过多的缓冲池内存，默认情况下最大可以占用1/2，这在实际应用中会带来一定的问题。</p><h3 id="2-change-buffer"><a href="#2-change-buffer" class="headerlink" title="2. change buffer"></a>2. change buffer</h3><p>InnoDB从1.0.x版本开始引入了Change Buffer，可以将其视为Insert Buffer的升级。<br>从这个版本开始，InnoDB可以对DML操作——Insert、Delete、Update<code>(delete+insert)</code>都进行缓冲，<br>它们分别是：Insert Buffer, Delete Buffer,Purge Buffer。<br>对一个记录进行 update 操作有两个过程</p><ul><li>将记录标记为删除：delete buffer</li><li>将记录真正删除：pruge buffer</li></ul><table><tr><th colspan="2">参数</th><th>InnoDB 版本</th><th colspan="3">作用</th></tr><tr><td colspan="2" style="text-align:center"><span id="innodb_change_buffering">innodb_change_buffering</span></td><td style="text-align:center"> 1.0.x开始</td><td colspan="3">用来开启各种Buffer选项，默认值是all<br><ul><li>inserts</li><li>deletes</li><li>purges</li><li>changes：开启 inserts 和 deletes</li><li>all：都开启</li><li>none：都不开启</li></ul></td></tr><tr><td colspan="2" rowspan="2" style="text-align:center"><span id="innodb_change_buffer_max_size">innodb_change_buffer_max_size</span></td><td style="text-align:center"> 1.2.x开始</td><td colspan="3">用来控制change buffer最大使用内存数量<br>默认值为25,表示最多使用1/4的缓存池空间<br>该参数最大有效值是50</td></tr></table><h2 id="两次写"><a href="#两次写" class="headerlink" title="两次写"></a>两次写</h2><p>提高innodb的可靠性，用来解决部分写失败(partial page write页断裂)。</p><h3 id="脏页刷新到磁盘风险"><a href="#脏页刷新到磁盘风险" class="headerlink" title="脏页刷新到磁盘风险"></a>脏页刷新到磁盘风险</h3><p>IO的最小单位：</p><ul><li>数据库IO的最小单位是16K（MySQL默认，oracle是8K）</li><li>文件系统IO的最小单位是4K（也有1K的）</li><li>磁盘IO的最小单位是512字节</li></ul><p>因此，存在IO写入导致page损坏的风险：<br><img src="/Mysql/Mysql02/IO.png" alt="IO风险"></p><p>提高innodb的可靠性，用来解决部分写失败(partial page write页断裂)。</p><h3 id="Double-write解决了什么问题"><a href="#Double-write解决了什么问题" class="headerlink" title="Double write解决了什么问题"></a>Double write解决了什么问题</h3><p>一个数据页的大小是16K，假设在把内存中的脏页写到数据库的时候，写了8K突然宕机了，也就是说前8K数据是新的，后8K是旧的，那么磁盘数据库这个数据页就是不完整的，是一个坏掉的数据页，这种情况被称为部分<code>写失效</code></p><p><strong>那么可不可以通过 redo log 来进行恢复呢？</strong><br>redo记录的是对页的修改，只能恢复校验完整（还没写）的页，不能修复坏掉的数据页，所以这个数据就丢失了，可能会造成数据不一致，所以需要double write。</p><div class="note info"><p>为什么 redo log 不需要 doublewrite 的支持？<br>因为 redo log 写入的单位就是 512 字节，也就是磁盘 IO 的最小单位，所以无所谓数据损坏。</p></div><h3 id="两次写工作流程"><a href="#两次写工作流程" class="headerlink" title="两次写工作流程"></a>两次写工作流程</h3><p><img src="/Mysql/Mysql02/doublewrite.png" alt="两次写流程"><br>doublewrite由两部分组成，一部分为内存中的doublewrite buffer，其大小为2MB，另一部分是磁盘上共享表空间(ibdata x)中连续的128个页，即2个区(extent)，大小也是2M。</p><ol><li>当一系列机制触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先拷贝至内存中的doublewrite buffer中；</li><li>接着从两次写缓冲区分两次写入磁盘共享表空间中(连续存储，顺序写，性能很高)，每次写1MB；</li><li>待第二步完成后，再将doublewrite buffer中的脏页数据写入实际的各个表空间文件(离散写)；(脏页数据固化后，即进行标记对应doublewrite数据可覆盖)</li></ol><p>现在我们来分析一下为什么 double write 可以生效。当宕机发生时，有那么几种情况：</p><ol><li>磁盘还未写，此时可以通过 redo log 恢复；</li><li>磁盘正在进行从内存到共享表空间的写，此时数据文件中的页还没开始被写入，因此也同样可以通过 redo log 恢复；</li><li>磁盘正在写数据文件，此时共享表空间已经写完，可以从共享表空间拷贝页的副本到数据文件实现恢复。</li></ol><h2 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h2><p>哈希：一次就可以定位数据</p><p>B+树：取决于树的高度，生产环境一般是 3-4 层，所以需要查询 3-4 次</p><p>自适应哈希索引 AHI（adaptive hash index）建立条件：观察到一个访问模式访问频繁，就会建立哈希索引</p><ul><li>通过该模式访问了 100 次（模式：where x = ?）</li><li>页通过该模式访问了 N 次，其中 N = 页的记录总数⁄16</li></ul><p>InnoDB 存储引擎官方文档显示，启用 AHI 后,读取和写入速度可以提高 2 倍，辅助索引的连接操作性能可以提高 5 倍。</p><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>为了提高磁盘的操作性能，当前的数据库系统都采用异步IO的方式处理磁盘操作。用户可以在发出一个IO请求胡立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作完成，这就是AIO。<br>AIO的另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO, 这样可以提高IOPS(Input/Output Per Second)的性能。</p><p>例如：用户访问页的（space, page_no)为(8,6) (8,7) (8,8)，每个页的大小为16KB，同步IO需要3次IO操作。可以优化为从(8,6)开始读取48KB。</p><h2 id="刷新临接页"><a href="#刷新临接页" class="headerlink" title="刷新临接页"></a>刷新临接页</h2><p>当刷新一个脏页时，InnoDB会检查该页所在extent的所有页，如果是脏页，一起刷新。</p><table><tr><th colspan="2">参数</th><th>版本</th><th colspan="3">作用</th></tr><tr><th colspan="2" style="text-align:center">innodb_flush_neighbors</th><td style="text-align:center">1.2.x开始</td><td colspan="3">控制是否启用该特性</td></tr></table><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="http://oohcode.com/2015/10/14/InnoDB-Key-Features/" target="_blank" rel="noopener">http://oohcode.com/2015/10/14/InnoDB-Key-Features/</a></li><li><a href="https://chyroc.cn/posts/innodb-storage-engine-reading-1/" target="_blank" rel="noopener">https://chyroc.cn/posts/innodb-storage-engine-reading-1/</a></li><li><a href="https://www.cnblogs.com/zhoujinyi/archive/2013/04/11/2988923.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhoujinyi/archive/2013/04/11/2988923.html</a></li><li><a href="http://huzb.me/2019/01/14/%E6%8F%92%E5%85%A5%E7%BC%93%E5%86%B2%E3%80%81%E4%B8%A4%E6%AC%A1%E5%86%99%E5%92%8C%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95/" target="_blank" rel="noopener">http://huzb.me/2019/01/14/%E6%8F%92%E5%85%A5%E7%BC%93%E5%86%B2%E3%80%81%E4%B8%A4%E6%AC%A1%E5%86%99%E5%92%8C%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95/</a></li><li><a href="https://blog.csdn.net/tanliqing2010/article/details/81509539" target="_blank" rel="noopener">https://blog.csdn.net/tanliqing2010/article/details/81509539</a></li><li><a href="https://www.cnblogs.com/geaozhang/p/7341333.html" target="_blank" rel="noopener">https://www.cnblogs.com/geaozhang/p/7341333.html</a></li><li><a href="https://draveness.me/mysql-innodb" target="_blank" rel="noopener">https://draveness.me/mysql-innodb</a></li><li><a href="http://richfisher.me/blog/2017/12/18/innodb-notes/" target="_blank" rel="noopener">http://richfisher.me/blog/2017/12/18/innodb-notes/</a></li><li><a href="https://www.docs4dev.com/docs/zh/mysql/5.7/reference/innodb-architecture.html#innodb%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener">https://www.docs4dev.com/docs/zh/mysql/5.7/reference/innodb-architecture.html#innodb%E6%9E%B6%E6%9E%84</a></li><li>MySQL技术内幕：InnoDB存储引擎(第2版)</li></ul></div><div><div><div style="text-align:center;color:#bfbfbf;font-size:16px"> <span>-------- 本文结束</span><i class="fa fa-angellist"></i> <span>感谢阅读 --------</span></div></div></div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.min.js/1.5.10/clipboard.min.js"></script><script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script><script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><p><span>本文标题:</span><a href="/Mysql/Mysql02/">《Mysql技术内幕》学习笔记-InnoDB存储引擎</a></p><p><span>文章作者:</span>Guyuqing</p><p><span>发布时间:</span>2019年07月31日 - 11:34</p><p><span>最后更新:</span>2019年08月31日 - 11:04</p><p><span>原始链接:</span><a href="/Mysql/Mysql02/" title="《Mysql技术内幕》学习笔记-InnoDB存储引擎">https://a19140312.github.io/Mysql/Mysql02/</a><span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://a19140312.github.io/Mysql/Mysql02/" aria-label="复制成功！"></i></span></p><p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"复制成功",icon:"success",showConfirmButton:!0})})})</script></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>坚持技术分享，您的支持将鼓励我继续创作！</div> <button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'> <span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"> <img id="wechat_qr" src="/images/wechatpay.jpg" alt="guyuqing 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"> <img id="alipay_qr" src="/images/alipay.jpg" alt="guyuqing 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/学习笔记/" rel="tag"><i class="fa fa-tag"></i> 学习笔记</a><a href="/tags/MySql/" rel="tag"><i class="fa fa-tag"></i> MySql</a><a href="/tags/InnoDB/" rel="tag"><i class="fa fa-tag"></i> InnoDB</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/Mysql/Mysql01/" rel="next" title="《Mysql技术内幕》学习笔记-MySql体系结构和存储引擎"><i class="fa fa-chevron-left"></i> 《Mysql技术内幕》学习笔记-MySql体系结构和存储引擎</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/Mysql/Mysql-RedoAndUndo/" rel="prev" title="《Mysql技术内幕》学习笔记-Redo与Undo">《Mysql技术内幕》学习笔记-Redo与Undo<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="guyuqing"><p class="site-author-name" itemprop="name">guyuqing</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">33</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">13</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">26</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/a19140312" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="http://weibo.com/" target="_blank" title="微博"><i class="fa fa-fw fa-weibo"></i> 微博</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#体系架构"><span class="nav-number">2.</span> <span class="nav-text">体系架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程"><span class="nav-number">2.1.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Master-Thread"><span class="nav-number">2.1.1.</span> <span class="nav-text">Master Thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO-Thread"><span class="nav-number">2.1.2.</span> <span class="nav-text">IO Thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Purge-Thread"><span class="nav-number">2.1.3.</span> <span class="nav-text">Purge Thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Page-Cleaner-Thread"><span class="nav-number">2.1.4.</span> <span class="nav-text">Page Cleaner Thread</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存"><span class="nav-number">2.2.</span> <span class="nav-text">内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#缓冲池"><span class="nav-number">2.2.1.</span> <span class="nav-text">缓冲池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#缓冲池中缓存的数据页类型"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">缓冲池中缓存的数据页类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓冲池管理方式"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">缓冲池管理方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重做日志缓冲"><span class="nav-number">2.2.2.</span> <span class="nav-text">重做日志缓冲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#额外的内存池"><span class="nav-number">2.2.3.</span> <span class="nav-text">额外的内存池</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Checkpoint技术"><span class="nav-number">3.</span> <span class="nav-text">Checkpoint技术</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Master-thread-工作方式"><span class="nav-number">4.</span> <span class="nav-text">Master thread 工作方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB-1-0-x-版本之前的-Master-thread"><span class="nav-number">4.1.</span> <span class="nav-text">InnoDB 1.0.x 版本之前的 Master thread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB-1-2-x-版本之前的-Master-thread"><span class="nav-number">4.2.</span> <span class="nav-text">InnoDB 1.2.x 版本之前的 Master thread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB-1-2-x-版本的-Master-thread"><span class="nav-number">4.3.</span> <span class="nav-text">InnoDB 1.2.x 版本的 Master thread</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#InnoDB-关键特性"><span class="nav-number">5.</span> <span class="nav-text">InnoDB 关键特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#插入缓冲"><span class="nav-number">5.1.</span> <span class="nav-text">插入缓冲</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#聚集索引（一级索引）"><span class="nav-number">5.1.1.</span> <span class="nav-text">聚集索引（一级索引）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#辅助索引（二级索引）"><span class="nav-number">5.1.2.</span> <span class="nav-text">辅助索引（二级索引）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引数据页的更新（针对二级索引）"><span class="nav-number">5.1.3.</span> <span class="nav-text">索引数据页的更新（针对二级索引）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-insert-buffer"><span class="nav-number">5.1.4.</span> <span class="nav-text">1. insert buffer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#插入缓冲的启用需要满足以下两个条件："><span class="nav-number">5.1.4.1.</span> <span class="nav-text">插入缓冲的启用需要满足以下两个条件：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#insert-buffer结构"><span class="nav-number">5.1.4.2.</span> <span class="nav-text">insert buffer结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#merge-insert-buffer-发生条件"><span class="nav-number">5.1.4.3.</span> <span class="nav-text">merge insert buffer 发生条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#insert-buffer-刷新到磁盘条件"><span class="nav-number">5.1.4.4.</span> <span class="nav-text">insert buffer 刷新到磁盘条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#插入缓冲主要带来如下两个坏处"><span class="nav-number">5.1.4.5.</span> <span class="nav-text">插入缓冲主要带来如下两个坏处</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-change-buffer"><span class="nav-number">5.1.5.</span> <span class="nav-text">2. change buffer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#两次写"><span class="nav-number">5.2.</span> <span class="nav-text">两次写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#脏页刷新到磁盘风险"><span class="nav-number">5.2.1.</span> <span class="nav-text">脏页刷新到磁盘风险</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Double-write解决了什么问题"><span class="nav-number">5.2.2.</span> <span class="nav-text">Double write解决了什么问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两次写工作流程"><span class="nav-number">5.2.3.</span> <span class="nav-text">两次写工作流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自适应哈希索引"><span class="nav-number">5.3.</span> <span class="nav-text">自适应哈希索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异步IO"><span class="nav-number">5.4.</span> <span class="nav-text">异步IO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#刷新临接页"><span class="nav-number">5.5.</span> <span class="nav-text">刷新临接页</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考："><span class="nav-number">6.</span> <span class="nav-text">参考：</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright" style="text-align:center">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">guyuqing</span><div class="theme-info"><div class="powered-by"></div><i class="fa fa-book"></i> <span class="post-count">全站共64.4k字</span></div></div><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script><div class="busuanzi-count" style="text-align:center"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i> 访问人数<span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人</span><span class="site-pv"><i class="fa fa-eye"></i> 总访问量<span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'aO40hbMXUEahTdJdAEqaHaaa-gzGzoHsz',
        appKey: 'T5zgBwJL4cnGAPVsarQphtMa',
        placeholder: '想对作者说点什么～',
        avatar:'monsterid',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script><script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script type="text/javascript" src="/js/src/clipboard.min.js"></script><script type="text/javascript" src="/js/src/clipboard-use.js"></script></body></html>